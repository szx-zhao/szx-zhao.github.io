<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL运维脚本</title>
      <link href="/2024/10/28/2024-10-17-MySQL%E8%BF%90%E7%BB%B4%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/10/28/2024-10-17-MySQL%E8%BF%90%E7%BB%B4%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-获取基本配置信息"><a href="#1-获取基本配置信息" class="headerlink" title="1. 获取基本配置信息"></a>1. 获取基本配置信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">是否区分表名大小写 SHOW VARIABLES LIKE &#x27;lower_case_table_names&#x27;</span><br><span class="line">MySQL 服务端口 SHOW VARIABLES LIKE &#x27;port&#x27;;</span><br><span class="line">MySQL socket 文件路径 SHOW VARIABLES LIKE &#x27;socket&#x27;;</span><br><span class="line">是否跳过域名解析 SHOW VARIABLES LIKE &#x27;skip_name_resolve&#x27;;</span><br><span class="line">数据库字符集 SHOW VARIABLES LIKE &#x27;character_set_server&#x27;;</span><br><span class="line">服务器默认的校对规则 SHOW VARIABLES LIKE &#x27;collation_server&#x27;;</span><br><span class="line">交互式连接超时时间（秒）：SHOW VARIABLES LIKE &#x27;interactive_timeout&#x27;;</span><br><span class="line">非交互式连接超时时间（秒）：SHOW VARIABLES LIKE &#x27;wait_timeout&#x27;;</span><br><span class="line">事务隔离级别：SHOW VARIABLES LIKE &#x27;tx_isolation&#x27;;</span><br><span class="line">数据文件存放位置：SHOW VARIABLES LIKE &#x27;%datadir%&#x27;;</span><br><span class="line">允许的最大数据包大小：SHOW VARIABLES LIKE &#x27;max_allowed_packet&#x27;;</span><br><span class="line">每个线程堆栈的大小：SHOW VARIABLES LIKE &#x27;thread_stack&#x27;;</span><br><span class="line">线程缓存的大小：SHOW VARIABLES LIKE &#x27;thread_cache_size&#x27;;</span><br><span class="line">可以打开的表的数量：SHOW VARIABLES LIKE &#x27;table_open_cache&#x27;;</span><br><span class="line">内部临时表的最大大小：SHOW VARIABLES LIKE &#x27;tmp_table_size&#x27;;</span><br><span class="line">内存中 HEAP 表的最大大小：SHOW VARIABLES LIKE &#x27;max_heap_table_size&#x27;;</span><br><span class="line">MySQL 主进程文件的位置：SHOW VARIABLES LIKE &#x27;pid_file&#x27;;</span><br><span class="line">错误日志文件的位置：SHOW VARIABLES LIKE &#x27;log_error&#x27;;</span><br><span class="line">慢查询日志文件的位置：SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span><br><span class="line">慢查询时间阈值：SHOW VARIABLES LIKE &#x27;long_query_time&#x27;;</span><br></pre></td></tr></table></figure><h1 id="2-获取连接数配置信息"><a href="#2-获取连接数配置信息" class="headerlink" title="2. 获取连接数配置信息"></a>2. 获取连接数配置信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">最大连接数：SHOW VARIABLES LIKE &#x27;max_connections&#x27;;</span><br><span class="line">服务器启动以来已使用的最大连接数 SHOW status LIKE &#x27;Max_used_connections&#x27;</span><br><span class="line">达到最大连接数的时间点 SHOW STATUS LIKE &#x27;Max_used_connections_time&#x27;;</span><br><span class="line">连接失败次数上限 SHOW VARIABLES LIKE &#x27;max_connect_errors&#x27;;</span><br><span class="line">通过 MySQL X Protocol 已接受的连接数 SHOW STATUS LIKE &#x27;Mysqlx_connections_accepted&#x27;;</span><br><span class="line">通过 MySQL X Protocol 已关闭的连接数 SHOW STATUS LIKE &#x27;Mysqlx_connections_closed&#x27;;</span><br></pre></td></tr></table></figure><h1 id="3-获取-Binlog-配置信息"><a href="#3-获取-Binlog-配置信息" class="headerlink" title="3. 获取 Binlog 配置信息"></a>3. 获取 Binlog 配置信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Binlog 文件列表：SHOW BINARY LOGS;</span><br><span class="line">是否开启 Binlog：SHOW VARIABLES LIKE &#x27;log_bin&#x27;;</span><br><span class="line">Binlog 同步频率：SHOW VARIABLES LIKE &#x27;sync_binlog&#x27;;</span><br><span class="line">Binlog 格式：SHOW VARIABLES LIKE &#x27;binlog_format&#x27;;</span><br><span class="line">文件路径 SHOW VARIABLES LIKE &#x27;log-bin&#x27;;</span><br><span class="line">Binlog 索引文件位置：SHOW VARIABLES LIKE &#x27;log_bin_index&#x27;;</span><br><span class="line">单个 Binlog 最大大小：SHOW VARIABLES LIKE &#x27;max_binlog_size&#x27;;</span><br><span class="line">Binlog 基本名字：SHOW VARIABLES LIKE &#x27;log_bin_basename&#x27;;</span><br><span class="line">Binlog 文件过期时间：SHOW VARIABLES LIKE &#x27;expire_logs_days&#x27;;</span><br><span class="line">MySQL 服务器的唯一 ID：SHOW VARIABLES LIKE &#x27;server_id&#x27;;</span><br></pre></td></tr></table></figure><h1 id="4-获取-GTID-配置信息"><a href="#4-获取-GTID-配置信息" class="headerlink" title="4. 获取 GTID 配置信息"></a>4. 获取 GTID 配置信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是否开启 GTID：SHOW VARIABLES LIKE &#x27;gtid_mode&#x27;;</span><br><span class="line">是否强制 GTID 一致性：SHOW VARIABLES LIKE &#x27;enforce_gtid_consistency&#x27;;</span><br><span class="line">查询 GTID 执行的详细情况 SELECT \* FROM mysql.gtid_executed;</span><br><span class="line">是否开启级联复制：SHOW VARIABLES LIKE &#x27;log_slave_updates&#x27;;</span><br></pre></td></tr></table></figure><h1 id="5-InnoDB-配置信息"><a href="#5-InnoDB-配置信息" class="headerlink" title="5. InnoDB 配置信息"></a>5. InnoDB 配置信息</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 版本：SHOW VARIABLES LIKE &#x27;innodb_version&#x27;;</span><br><span class="line">是否为每个 InnoDB 表创建单独的文件：SHOW VARIABLES LIKE &#x27;innodb_file_per_table&#x27;;</span><br><span class="line">InnoDB 缓存池大小：SHOW VARIABLES LIKE &#x27;innodb_buffer_pool_size&#x27;;</span><br><span class="line">InnoDB 日志文件大小：SHOW VARIABLES LIKE &#x27;innodb_log_file_size&#x27;;</span><br><span class="line">InnoDB 可以有多少线程同时运行：SHOW VARIABLES LIKE &#x27;innodb_thread_concurrency&#x27;;</span><br><span class="line">缓冲池中脏页的最大百分比：SHOW VARIABLES LIKE &#x27;innodb_max_dirty_pages_pct&#x27;;</span><br><span class="line">InnoDB 的最大写入 IO 能力：SHOW VARIABLES LIKE &#x27;innodb_io_capacity_max&#x27;;</span><br><span class="line">日志缓冲区大小：SHOW VARIABLES LIKE &#x27;innodb_log_buffer_size&#x27;;</span><br><span class="line">事务提交时刷新日志的频率：SHOW VARIABLES LIKE &#x27;innodb_flush_log_at_trx_commit&#x27;;</span><br><span class="line">InnoDB IO 容量：SHOW VARIABLES LIKE &#x27;innodb_io_capacity&#x27;;</span><br><span class="line">缓冲池实例数：SHOW VARIABLES LIKE &#x27;innodb_buffer_pool_instances&#x27;;</span><br></pre></td></tr></table></figure><h1 id="6-监控指标"><a href="#6-监控指标" class="headerlink" title="6. 监控指标"></a>6. 监控指标</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">全局状态信息：SHOW GLOBAL STATUS;</span><br><span class="line">当前所有线程的信息：SHOW PROCESSLIST;</span><br><span class="line">当前打开的连接数：SHOW STATUS LIKE &#x27;Threads_connected&#x27;;</span><br><span class="line">当前线程缓存中有多少空闲线程：SHOW STATUS LIKE &#x27;Threads_cached&#x27;;</span><br><span class="line">从最近一次服务启动，已创建线程的数量：SHOW STATUS LIKE &#x27;Threads_created&#x27;;</span><br><span class="line">当前激活的线程数：SHOW STATUS LIKE &#x27;Threads_running&#x27;;</span><br><span class="line">慢查询的次数：SHOW STATUS LIKE &#x27;Slow_queries&#x27;;</span><br><span class="line">InnoDB 读取的行数：SHOW STATUS LIKE &#x27;Innodb_rows_read&#x27;;</span><br><span class="line">InnoDB 写入的行数：SHOW STATUS LIKE &#x27;Innodb_rows_inserted&#x27;;</span><br><span class="line">InnoDB 更新的行数：SHOW STATUS LIKE &#x27;Innodb_rows_updated&#x27;;</span><br><span class="line">InnoDB 删除的行数：SHOW STATUS LIKE &#x27;Innodb_rows_deleted&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-06-Mobx%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2024-09-06-Mobx%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用MobX"><a href="#1-使用MobX" class="headerlink" title="1. 使用MobX"></a>1. 使用MobX</h1><p>Mobx 6 是目前最新版本，为了与标准 javaScript 的最大兼容，默认情况下放弃了装饰器语法。（本文主要介绍 Mobx6）</p><h2 id="1-1-MobX的例子"><a href="#1-1-MobX的例子" class="headerlink" title="1.1. MobX的例子"></a>1.1. MobX的例子</h2><p>实现一个计时器的功能</p><p><strong>使用MobX</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &#123; makeAutoObservable &#125; from &quot;mobx&quot;;</span><br><span class="line">import &#123; observer &#125; from &quot;mobx-react-lite&quot;;</span><br><span class="line"></span><br><span class="line">// Model the application state.</span><br><span class="line">const createTimer = () =&gt; &#123;</span><br><span class="line">    return makeAutoObservable(&#123;</span><br><span class="line">        secondsPassed: 0,</span><br><span class="line">        increase() &#123;</span><br><span class="line">            this.secondsPassed += 1;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset() &#123;</span><br><span class="line">            this.secondsPassed = 0;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const myTimer = createTimer();</span><br><span class="line"></span><br><span class="line">// Build a &quot;user interface&quot; that uses the observable state.</span><br><span class="line">const TimerView = observer((&#123; timer &#125;) =&gt; (</span><br><span class="line">    &lt;button onClick=&#123;() =&gt; timer.reset()&#125;&gt;</span><br><span class="line">        Seconds passed: &#123;timer.secondsPassed&#125;</span><br><span class="line">    &lt;/button&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;TimerView timer=&#123;myTimer&#125; /&gt;, document.body);</span><br><span class="line"></span><br><span class="line">// Update the &#x27;Seconds passed: X&#x27; text every second.</span><br><span class="line">setInterval(() =&gt; &#123;</span><br><span class="line">    myTimer.increase();</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>makeAutoObservable</code> 是MobX库中的一个函数，用于自动将对象属性转换为可观察的</p><p><code>observer</code> 是MobX-react-lite库中的一个高阶组件，用于将React组件与MobX的可观察状态连接起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    D[&quot;event&quot;] --&gt; n1[&quot;actions&quot;]</span><br><span class="line">    n1 --&gt;|update| n2[&quot;observable state&quot;]</span><br><span class="line">    n2 --&gt;|notify| n3[&quot;computed values&quot;]</span><br><span class="line">    n3 --&gt;|trigger| n4[&quot;side-effects&quot;]</span><br><span class="line">    n4 --&gt;|event| n1</span><br></pre></td></tr></table></figure><p><strong>使用React hook</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; useState, useEffect &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">// Build a &quot;user interface&quot; that uses the observable state.</span><br><span class="line">const Timer = () =&gt; &#123;</span><br><span class="line">    const initSecondsPassed = 0;</span><br><span class="line">    const [secondsPassed, setSecondsPassed] = useState(initSecondsPassed);</span><br><span class="line"></span><br><span class="line">    const reset = () =&gt; setSecondsPassed(initSecondsPassed);</span><br><span class="line"></span><br><span class="line">    useEffect(() =&gt; &#123;</span><br><span class="line">        const increase = () =&gt; setSecondsPassed(secondsPassed + 1);</span><br><span class="line">        const intervalId = setInterval(increase, 1000);</span><br><span class="line">        return () =&gt; clearInterval(intervalId); // 清理函数，在组件卸载时清除定时器</span><br><span class="line">    &#125;, [secondsPassed]); // 将secondsPassed添加到依赖数组中</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; reset()&#125;&gt;Seconds passed: &#123;secondsPassed&#125;&lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default Timer;</span><br></pre></td></tr></table></figure><h2 id="1-2-有了hooks-为什么还需要mobx"><a href="#1-2-有了hooks-为什么还需要mobx" class="headerlink" title="1.2. 有了hooks 为什么还需要mobx"></a>1.2. 有了hooks 为什么还需要mobx</h2><p>通过上面的例子可以看出，mobx能实现的，使用react的hook也能达到同样的效果，那为什么还要使用mobx呢</p><ol><li>自动依赖追踪<br>MobX 使用响应式编程模型，能够自动追踪状态的依赖关系。当状态变化时，相关的组件会自动重新渲染，而不需要手动管理依赖关系。</li><li>更少的样板代码<br>相比于使用多个 useState 和 useEffect 钩子，MobX 可以通过简单的状态树和观察者模式来减少样板代码，使得代码更加简洁。</li><li>性能优化<br>MobX 的细粒度更新机制可以提高性能，避免不必要的重新渲染。只有依赖于变化状态的组件才会更新。</li><li>更好的组织结构<br>使用 MobX 可以将状态和行为逻辑集中在一起，便于管理和维护，尤其是在大型项目中。</li><li>与类组件的兼容性<br>在某些情况下，仍然需要使用类组件。MobX 可以与类组件很好地集成，而 Hooks 主要适用于函数组件。</li><li>跨组件的状态共享<br>MobX 提供了一种简单的方式来在不同的组件之间共享状态，特别适合于需要在多个地方访问同一状态的场景。<h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2. 概念"></a>2. 概念</h1></li></ol><p><a href="https://mobx.js.org/README.html">官网</a></p><p>MobX在应用程序中区分了以下三个概念</p><ol><li>State</li><li>Actions</li><li>Derivations</li></ol><p>MobX是一个基于信号的状态管理库</p><h2 id="2-1-定义可observable的state"><a href="#2-1-定义可observable的state" class="headerlink" title="2.1. 定义可observable的state"></a>2.1. 定义可observable的state</h2><p>state通常用来保存视图的状态、待办的事项等</p><p>MobX并不关心存储state所使用的数据结构（对象、数组、引用等），只要确保你想随时间改变的所有属性都被标记为可观察的<code>observable</code>，这样MobX就可以跟踪它们</p><p>state就像保存值的电子表格，使用observable就像把一个对象的属性变成一个电子表格的单元格</p><p>方法一（推荐）：通过<code>makeAutoObservale</code>自动地给方法中的每个属性和方法标记上<code>observale</code>和<code>action</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import &#123; makeAutoObservable &#125; from &quot;mobx&quot;;</span><br><span class="line">const createTimer = () =&gt; &#123;</span><br><span class="line">    return makeAutoObservable(&#123;</span><br><span class="line">        secondsPassed: 0,</span><br><span class="line">        increase() &#123;</span><br><span class="line">            this.secondsPassed += 1;</span><br><span class="line">        &#125;,</span><br><span class="line">        reset() &#123;</span><br><span class="line">            this.secondsPassed = 0;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>方法二：显式地标记observable和action</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import &#123; makeObservable, observable, action &#125; from &quot;mobx&quot;</span><br><span class="line"></span><br><span class="line">class Todo &#123;</span><br><span class="line">    id = Math.random()</span><br><span class="line">    title = &quot;&quot;</span><br><span class="line">    finished = false</span><br><span class="line"></span><br><span class="line">    constructor(title) &#123;</span><br><span class="line">        makeObservable(this, &#123;</span><br><span class="line">            title: observable,</span><br><span class="line">            finished: observable,</span><br><span class="line">            toggle: action</span><br><span class="line">        &#125;)</span><br><span class="line">        this.title = title</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    toggle() &#123;</span><br><span class="line">        this.finished = !this.finished</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过类的方式去定义state，也可以通过方法去定义，更推荐使用方法的方式</p><h2 id="2-2-使用Actions更新状态"><a href="#2-2-使用Actions更新状态" class="headerlink" title="2.2. 使用Actions更新状态"></a>2.2. 使用Actions更新状态</h2><p>Actions是任何一段改变状态的代码，Actions就像用户在电子表格的单元格中输入一个新值。</p><p>在MobX中任何改变可观察对象的代码都可标记为动作</p><h2 id="2-3-创建自动响应状态变化的Derivations"><a href="#2-3-创建自动响应状态变化的Derivations" class="headerlink" title="2.3. 创建自动响应状态变化的Derivations"></a>2.3. 创建自动响应状态变化的Derivations</h2><p>任何来源是State且不需要进一步交互的东西都是Derivations</p><p>Derivations 存在的多种形式</p><ul><li>用户界面</li></ul><p>MobX区分了两种Derivations</p><ul><li>Computed，它总是可以使用纯函数从当前可观察状态派生出来</li><li>Reactions，当状态改变时需要自动发生的副作用(介于命令式编程和响应式编程之间的桥梁)</li></ul><p>黄金法则是，如果你希望基于当前状态创建值，则始终使用computed</p><h3 id="2-3-1-组件的响应式Derivations"><a href="#2-3-1-组件的响应式Derivations" class="headerlink" title="2.3.1. 组件的响应式Derivations"></a>2.3.1. 组件的响应式Derivations</h3><p>To create a <em>computed</em> value, define a property using a JS getter function <code>get</code> and mark it as <code>computed</code> with <code>makeObservable</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import &#123; makeObservable, observable, computed &#125; from &quot;mobx&quot;</span><br><span class="line"></span><br><span class="line">class TodoList &#123;</span><br><span class="line">    todos = []</span><br><span class="line">    get unfinishedTodoCount() &#123;</span><br><span class="line">        return this.todos.filter(todo =&gt; !todo.finished).length</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(todos) &#123;</span><br><span class="line">        makeObservable(this, &#123;</span><br><span class="line">            todos: observable,</span><br><span class="line">            unfinishedTodoCount: computed</span><br><span class="line">        &#125;)</span><br><span class="line">        this.todos = todos</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MobX will ensure that <code>unfinishedTodoCount</code> is updated automatically when a todo is added or when one of the <code>finished</code> properties is modified.</p><h1 id="3-准则"><a href="#3-准则" class="headerlink" title="3. 准则"></a>3. 准则</h1><p>MobX 使用单向数据流，通过Actions改变状态，进而更新所有受影响的视图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">    A[&quot;Actions&quot;] --&gt; B[&quot;Observable state&quot;]</span><br><span class="line">B --&gt; n1[&quot;Derived values&quot;]</span><br><span class="line">n1 --&gt; n2[&quot;Reactions&quot;]</span><br></pre></td></tr></table></figure><ul><li>当state改变时，所有的Derivations都会自动更新</li><li>默认情况下，所有Derivations都同步更新</li><li>Computed values 的更新是懒加载的，当没有被使用时，它不会更新</li><li>所有Computed values 都应该是纯值。它们不应该改变state</li></ul><h1 id="4-核心概念"><a href="#4-核心概念" class="headerlink" title="4. 核心概念"></a>4. 核心概念</h1><ol><li>observable 定义一个存储 state 的可追踪字段（Proxy）</li><li>action 将一个方法标记为可以修改 state 的 action</li><li>computed 标记一个可以由 state 派生出新值并且缓存其输出的计算属性</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-10-Taro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-09-10-Taro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>Taro 在组件、API、路由等规范上，遵循微信小程序规范，所以在 Taro 中使用 React 和开发者熟悉的 Web 端有一些差异</p><p>因为在 Taro 3 中开发者使用的是真实的 React，React 的 API 如 <code>Component</code>、<code>useState</code>、<code>useEffect</code> 等都需要从 React 包中获取。</p><p>从 Taro v3.5 开始，Taro 将默认使用 React 18 版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 从 &#x27;react&#x27; 包中获取 React API</span><br><span class="line">import React, &#123; Component, useState, useEffect &#125; from &#x27;react&#x27;</span><br></pre></td></tr></table></figure><p>UI组件使用Taro UI</p><p>安装 <code>npm i -g @tarojs/cli@3.6.35</code></p><h1 id="2-项目结构"><a href="#2-项目结构" class="headerlink" title="2. 项目结构"></a>2. 项目结构</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">├── babel.config.js             # Babel 配置</span><br><span class="line">├── .eslintrc.js                # ESLint 配置</span><br><span class="line">├── config                      # 编译配置目录</span><br><span class="line">│   ├── dev.js                  # 开发模式配置</span><br><span class="line">│   ├── index.js                # 默认配置</span><br><span class="line">│   └── prod.js                 # 生产模式配置</span><br><span class="line">├── package.json                # Node.js manifest</span><br><span class="line">├── dist                        # 打包目录</span><br><span class="line">├── project.config.json         # 小程序项目配置</span><br><span class="line">├── src # 源码目录</span><br><span class="line">│   ├── app.config.js           # 全局配置</span><br><span class="line">│   ├── app.css                 # 全局 CSS</span><br><span class="line">│   ├── app.js                  # 入口组件</span><br><span class="line">│   ├── index.html              # H5 入口 HTML</span><br><span class="line">│   └── pages                   # 页面组件</span><br><span class="line">│       └── index</span><br><span class="line">│           ├── index.config.js # 页面配置</span><br><span class="line">│           ├── index.css       # 页面 CSS</span><br><span class="line">│           └── index.jsx       # 页面组件，如果是 Vue 项目，此文件为 index.vue</span><br></pre></td></tr></table></figure><h1 id="3-入口组件和页面组件"><a href="#3-入口组件和页面组件" class="headerlink" title="3. 入口组件和页面组件"></a>3. 入口组件和页面组件</h1><p>因为 Taro 遵循小程序的路由规范，所以引入了入口组件和页面组件的概念，分别对应小程序规范的入口组件 <code>app</code> 和页面组件 <code>page</code>。</p><p>一个 Taro 应用由一个入口组件和至少一个页面组件所组成。</p><h2 id="3-1-入口组件"><a href="#3-1-入口组件" class="headerlink" title="3.1. 入口组件"></a>3.1. 入口组件</h2><h2 id="3-2-页面组件"><a href="#3-2-页面组件" class="headerlink" title="3.2. 页面组件"></a>3.2. 页面组件</h2><h1 id="4-Taro插件"><a href="#4-Taro插件" class="headerlink" title="4. Taro插件"></a>4. Taro插件</h1><h2 id="4-1-使用-HTML-标签"><a href="#4-1-使用-HTML-标签" class="headerlink" title="4.1. 使用 HTML 标签"></a>4.1. 使用 HTML 标签</h2><h2 id="4-2-跨端请求库"><a href="#4-2-跨端请求库" class="headerlink" title="4.2. 跨端请求库"></a>4.2. 跨端请求库</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Taro </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
      <url>/2024/10/28/2024-09-09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是状态"><a href="#1-什么是状态" class="headerlink" title="1. 什么是状态"></a>1. 什么是状态</h1><p>创建一个react项目，src下只需有一个index.js文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/index.js</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  let data = 1;</span><br><span class="line"></span><br><span class="line">  const setDataAdd = () =&gt; &#123;</span><br><span class="line">    data = data + 1;</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;测试数据：&#123;data&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;setDataAdd&#125;&gt;让数据+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure><p>这个 React 组件里面有一个数据 <code>data</code> ，我们让组件中的 H1 标签引用了它。并且希望这个数据在每一次按钮单击的时候，这个 H1 标签里面的数字可以自动的变化。但是我们无论怎么点击，这个标签里面的数据也都没有任何的变化。打开这个沙盒的 Console 却发现每一次点击时，这些数据的确是在发生变化的。</p><p>现在，我们将这个组件稍微进行一下改写，用一个 React Hooks 将它变为 State（状态） 看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// src/index.js</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &#123; useState &#125; from &quot;react&quot;;</span><br><span class="line">const App = () =&gt; &#123;</span><br><span class="line">  const [data, setData] = useState(1);</span><br><span class="line"></span><br><span class="line">  const setDataAdd = () =&gt; &#123;</span><br><span class="line">    setData((oldData) =&gt; oldData + 1);</span><br><span class="line">    console.log(data);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;h1&gt;测试数据：&#123;data&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;button onClick=&#123;setDataAdd&#125;&gt;让数据+1&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure><p>现在H1 标签已经可以按照数据的变化自动变化了！这个将数据反应在用户界面上的过程，就叫 <strong>渲染</strong> ，当数据发生变动时，网页的显示也会跟着一起变化，这就叫 <strong>重渲染</strong></p><p>为什么相同的 <code>data</code> 变量，使用不同的写法，产生的效果会截然不同呢？</p><p>你可以这么理解：React这种视图层前端框架只关注那些已经被声明成需要特别监视的变量，只有这些变量发生变动时，才会触发组件的重渲染。这些通过特殊方法声明的变量，就叫做  <strong>State（状态）</strong>  。比如说上面例子中的 <code>data</code> 就是使用了 React 中的一个 Hook 函数 <code>useState()</code> 声明了这个变量需要进行监视，那么 <code>data</code> 就是一个 State 。在检测到 <code>data</code> State 变化时，React 就会重新渲染这个组件。而在 Vue 中，这些 State 则是放到了 <code>data()</code> 函数里。</p><h1 id="2-何时需要状态管理"><a href="#2-何时需要状态管理" class="headerlink" title="2. 何时需要状态管理"></a>2. 何时需要状态管理</h1><p>使用前端框架构建的网站由许多的组件组成，这些组件可能会在自己内部保留有许多的 State。但是这些内部的 State 其它组件是无法访问的。当一个组件需要访问其它组件的少量 State 时，你可以使用 Vue 中的 <code>Provide/Inject</code> 和 React 中的 <code>Context</code>。随着组件数量的增多，各个组件内部维护的 State 也将变多。这个时候如果继续使用上述方法来访问 State，代码将变得难以维护。最好的解决办法就是将这些 State 全部抽离到一个 <strong>统一的状态存储（Store）</strong> 中统一管理，组件本身不持有任何的状态，获取数据的唯一方式就是从 Store 中获取。如果组件想要修改状态，必须通过 Store 内置的方法（mutation/reducer）执行。这样，网站里的大部分组件就符合了单一数据流原则。</p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>状态管理的本质——像数据库一样集中管理从 API 中获取到的数据，让组件更加方便地进行维护。但是别急着为你的网站添加状态管理，如果你的网站组件内部的状态没有严重到需要相互依赖的“蜘蛛网”形状，那么还是先维持现状吧。正如 Redux 的开发者所说：</p><blockquote><p><em>Don’t use Redux just because someone said you should - take some time to understand the potential benefits and tradeoffs of using it.</em></p><p>不要仅仅只是因为别人告诉你应该用 Redux 就强上 Redux —— 花点时间了解一下利弊再做定夺。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-13-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
      <url>/2024/10/28/2024-09-13-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-加解密技术"><a href="#1-加解密技术" class="headerlink" title="1. 加解密技术"></a>1. 加解密技术</h1><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131549383.jpg" alt="加解密.jpg"></p><h2 id="1-1-对称加密"><a href="#1-1-对称加密" class="headerlink" title="1.1. 对称加密"></a>1.1. 对称加密</h2><p>对称加密是指加密和解密都使用相同的密钥。这意味着发送方和接收方都必须拥有这个密钥才能进行加密和解密操作。</p><p><strong>常见的对称加密算法：</strong></p><ul><li>AES（高级加密标准）</li><li>DES（数据加密标准）</li><li>3DES（三重数据加密算法）</li></ul><p><strong>对称加密特点</strong></p><p>一般来说，对称加密具有如下特点：</p><ol><li>速度较快：由于加密和解密使用相同的密钥，对称加密通常比非对称加密要快。</li><li>密钥管理：对称加密的主要挑战在于密钥的分发和管理。如果密钥泄露，加密的安全性就会受到威胁。</li><li>适用于大量数据：由于速度快，对称加密适合加密大量数据。</li></ol><p>从这里可以看到，对称加密主要有两大优势：第一就是运算速度快；第二就是适用于大量数据。</p><p>但是，对称加密有一个致命的问题，就是密钥管理。如何从服务端将密钥安全的传输到客户端是个问题！另外就是当一对多通信的时候，如何管理好密钥不被泄露也是一个考验。这是对称加密的不足之处。</p><p><strong>用途</strong></p><p>对消息明文进行加密传送</p><h2 id="1-2-非对称加密"><a href="#1-2-非对称加密" class="headerlink" title="1.2. 非对称加密"></a>1.2. 非对称加密</h2><p>非对称加密，是一种使用两个不同密钥（公钥和私钥）的加密方式</p><p><strong>加密体制，用接收方的公钥加密，用接收方的私钥解密</strong></p><p><strong>常见的非对称加密算法：</strong></p><ul><li>RSA</li><li>ECC</li></ul><p><strong>非对称加密特点</strong></p><p>任何人的私钥只能自己拥有，任何人的公钥可以明文公开发送</p><ol><li>公开密钥分发方便</li></ol><ul><li>公钥的公开性：公钥可以公开给任何人，因此分发起来非常方便。任何人都可以使用公钥来加密数据，但只有私钥持有者才能解密。</li></ul><ol><li>身份验证与数字签名</li></ol><ul><li>身份验证：公钥可以用作用户的身份标识，其他人可以验证用户的身份而无需了解其私钥。这有助于在区块链等去中心化网络中建立可信身份。</li><li>数字签名：私钥持有者可以使用私钥对消息进行签名，其他人则可以使用公钥来验证签名的真实性。这确保了消息的完整性和来源的可靠性。</li></ul><ol><li>安全通信</li></ol><ul><li>加密通信：公钥可以用于加密消息，只有持有相应私钥的人才能解密。这确保了通信过程中的数据安全，防止了信息被未经授权的人员访问。</li></ul><ol><li>数字资产控制</li></ol><ul><li>区块链地址与私钥：区块链地址通常由公钥派生而来，用户通过私钥来控制与该地址相关联的数字资产。私钥的安全性对数字资产的安全至关重要。</li></ul><ol><li>加密解密速度</li></ol><ul><li>相对较慢：非对称加密的加密和解密速度相对于对称加密要慢得多，因为它需要进行更加复杂的数学计算。然而，这并不影响其在安全通信、身份验证等领域的应用。</li></ul><p><strong>用途</strong></p><p>对密钥加密（通常给对称加密中的密钥进行加密处理），做数字签名</p><h1 id="2-数字签名技术"><a href="#2-数字签名技术" class="headerlink" title="2. 数字签名技术"></a>2. 数字签名技术</h1><h2 id="2-1-信息摘要"><a href="#2-1-信息摘要" class="headerlink" title="2.1. 信息摘要"></a>2.1. 信息摘要</h2><p>单向散列函数 hash（不可逆）</p><p>固定长度的散列值</p><p>摘要用途：确保信息的完整性，防篡改</p><p>常用的信息摘要算法：md5、sha</p><h2 id="2-2-什么是签名"><a href="#2-2-什么是签名" class="headerlink" title="2.2. 什么是签名"></a>2.2. 什么是签名</h2><p><strong>签名体制，用发送方的私钥签名，用发送方的公钥验证</strong></p><p>因为公钥是公开的，所以任何持有公钥的人都能解密私钥加密过的密文，所以这个过程并不能保证消息的安全性，但是它却能保证消息来源的准确性和不可否认性，也就是说，如果使用公钥能正常解密某一个密文，那么就能证明这段密文一定是由私钥持有者发布的，而不是其他第三方发布的，并且私钥持有者不能否认他曾经发布过该消息（不可抵赖性）。故此将该过程称为「签名」</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131537597.jpg" alt="数字签名的过程.jpg"></p><h1 id="3-加密和签名的综合案例"><a href="#3-加密和签名的综合案例" class="headerlink" title="3. 加密和签名的综合案例"></a>3. 加密和签名的综合案例</h1><p>设计一个系统，要求以加密的形式进行传输，传输文件最大2GB，发送者不可抵赖，若文件被第三方截获，第三方无法篡改</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131636640.jpg" alt="加密的案例.jpg"></p><h1 id="4-访问控制"><a href="#4-访问控制" class="headerlink" title="4. 访问控制"></a>4. 访问控制</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-11-ping%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%86%E7%A8%8B/"/>
      <url>/2024/10/28/2024-09-11-ping%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>进行网络通信时，我们经常需要判断一台主机是否活跃。</p><p>A主机跟 B主机 进行通信之前，可以先 <em>ping</em> 一下他的 <em>IP</em> 地址，看主机是否有应答</p><p>那么，<em>ping</em> 命令是如何工作的呢？掌握 <em>ICMP</em> 协议后，我们可以着手研究 <em>ping</em> 的通信过程了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-16-Vue%E8%BD%ACElectron/"/>
      <url>/2024/10/28/2024-09-16-Vue%E8%BD%ACElectron/</url>
      
        <content type="html"><![CDATA[<p>如何将一个Vue项目转为Electron应用</p><p><strong>vue add electron-builder</strong></p><p><code>vue add electron-builder</code> 是一个 Vue CLI 插件命令，用于将 Electron 构建工具集成到你的 Vue 项目中。具体来说，这个命令会：</p><ol><li><strong>安装依赖</strong>：安装 <code>electron-builder</code> 和其他必要的依赖项。</li><li><strong>配置项目</strong>：在项目根目录下生成或更新 <code>vue.config.js</code> 和 <code>package.json</code> 文件，以配置 Electron 构建相关的设置。</li><li><strong>添加脚本</strong>：在 <code>package.json</code> 中添加构建和打包 Electron 应用的脚本。</li></ol><p><strong>npm run electron:build</strong></p><p><code>npm run electron:build</code> 是一个 npm 脚本命令，用于执行 Electron 应用的构建和打包过程。具体来说，这个命令会：</p><ol><li><strong>读取配置</strong>：读取 <code>vue.config.js</code> 和 <code>package.json</code> 中的 Electron 构建配置。</li><li><strong>打包应用</strong>：使用 <code>electron-builder</code> 工具将 Vue.js 应用打包成可执行文件（例如 <code>.exe</code>、<code>.dmg</code>、<code>.appimage</code> 等）。</li><li><strong>生成安装包</strong>：根据配置生成不同平台的安装包，如 Windows 的 <code>.exe</code> 文件、macOS 的 <code>.dmg</code> 文件、Linux 的 <code>.AppImage</code> 文件等。</li></ol><p>这个命令通常在开发完成后，用于生成最终的可分发版本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Electron </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-14-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/10/28/2024-09-14-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h1><h2 id="1-1-通讯模型"><a href="#1-1-通讯模型" class="headerlink" title="1.1. 通讯模型"></a>1.1. 通讯模型</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409141636474.png" alt="697a2f1f97f5f09cff4390c5b5458241.png"><br>想在两台主机间传输数据，该怎么办呢？用一根电缆将两台主机连接起来</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409141637982.png" alt="90c371e185fc7cdde7718d2059e7789e.png"></p><h2 id="1-2-冲突仲裁"><a href="#1-2-冲突仲裁" class="headerlink" title="1.2. 冲突仲裁"></a>1.2. 冲突仲裁</h2><p>如果两台服务器同时向信道发送数据，会发生什么事情呢，肯定冲突了嘛！有什么办法可以解决冲突吗？</p><p><strong>方法一</strong></p><p>引入一根新电缆，组成双电缆结构，每根电缆只负责一个方向的传输。这样一来，两个方向的传输保持独立，互不干扰，可以同时进行。这样的传输模式在通讯领域称为 <strong>全双工模式</strong></p><p><strong>方法二</strong></p><p>在硬件层面实现一种仲裁机制：当检测到多台主机同时传输数据时，及时叫停，并协商哪一方先发。这样一来，信道同样支持双向通讯，但不可同时进行。这种传输模式则称为 <strong>半双工模式</strong></p><h2 id="1-3-常见物理介质"><a href="#1-3-常见物理介质" class="headerlink" title="1.3. 常见物理介质"></a>1.3. 常见物理介质</h2><ul><li>电信号，例如电缆，网线就是电缆中的一种；</li><li>光信号，例如光纤；</li><li>电磁波，例如 <em>WiFi</em> ，无线网卡，蓝牙等；</li></ul><h1 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h1><p>第一节我们以两台主机为例，讨论了一个理想化的物理层模型。 现在，我们将问题进一步延伸：多台主机如何实现两两通讯呢？我们以三台主机为例进行讨论<br><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409141652678.png" alt="b5b564016c666f6ccfe37ca00839df33 (1).png"></p><h2 id="2-1-主机寻址"><a href="#2-1-主机寻址" class="headerlink" title="2.1. 主机寻址"></a>2.1. 主机寻址</h2><h2 id="2-2-信道复用"><a href="#2-2-信道复用" class="headerlink" title="2.2. 信道复用"></a>2.2. 信道复用</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-17-nvm%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/28/2024-09-17-nvm%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><code>nvm</code> 全称为 <code>node.js version management</code>，顾名思义是用于管理多个 nodejs 的版本控制工具。通过 nvm 可以安装和切换不同版本的 nodejs。nvm 主要是为了解决 node.js 各种版本存在不兼容现象。</p><h1 id="2-nvm的安装与配置"><a href="#2-nvm的安装与配置" class="headerlink" title="2. nvm的安装与配置"></a>2. nvm的安装与配置</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1. 安装"></a>2.1. 安装</h2><p><a href="https://github.com/coreybutler/nvm-windows">https://github.com/coreybutler/nvm-windows</a></p><p>验证是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 nvm 版本，version 可简写成 小v</span><br><span class="line">nvm version</span><br><span class="line"># 显示 node 是运行在 32 位还是 64 位</span><br><span class="line">nvm arch</span><br></pre></td></tr></table></figure><p>常用的管理命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 显示已经安装的列表，list 可简化为 ls</span><br><span class="line">nvm list</span><br><span class="line"># 显示远程可安装的列表，list 也可简化为 ls</span><br><span class="line">nvm list available</span><br><span class="line"># 卸载指定版本 node</span><br><span class="line">nvm uninstall [version]</span><br><span class="line"># 使用指定版本 node</span><br><span class="line">nvm use [version]</span><br></pre></td></tr></table></figure><h2 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2. 配置"></a>2.2. 配置</h2><p>在 <code>nvm</code> 的安装路径下，找到 <code>settings.txt</code>，在后面加上这两行，设置国内淘宝镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node_mirror: https://npmmirror.com/mirrors/node/</span><br><span class="line">npm_mirror: https://npmmirror.com/mirrors/npm/</span><br></pre></td></tr></table></figure><h1 id="3-node-的安装与配置"><a href="#3-node-的安装与配置" class="headerlink" title="3. node 的安装与配置"></a>3. node 的安装与配置</h1><h2 id="3-1-安装"><a href="#3-1-安装" class="headerlink" title="3.1. 安装"></a>3.1. 安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nvm list available</span><br><span class="line">nvm install 16</span><br><span class="line">nvm list</span><br><span class="line">nvm use 16</span><br></pre></td></tr></table></figure><blockquote><p>不要安装 node 的奇数版本！LTS 一般就是偶数版本</p></blockquote><h2 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2. 配置"></a>3.2. 配置</h2><p>修改 <code>npm</code> 镜像源为淘宝镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>检查是否成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure><p>设置全局模板（prefix）和缓存文件（cache）的存放路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set cache &quot;%NVM_SYMLINK%\node_cache&quot;</span><br><span class="line">npm config set prefix &quot;%NVM_SYMLINK%\node_global&quot;</span><br></pre></td></tr></table></figure><blockquote><p>每次使用 nvm 安装 node 都需要配置 prefix 和 cache 吗？<br>答：并不需要每次都设置。配置的 prefix 和 cache 的信息都在 <code>C:\Users\username\.npmrc</code> 文件里</p></blockquote><p>配置 node 环境变量（path下添加）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%NVM_SYMLINK%\node_global</span><br></pre></td></tr></table></figure><p>配置完成后，输入以下命令进行验证</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看 node 版本，若返回版本号，node 可用</span><br><span class="line">node -v</span><br><span class="line"># 查看 npm 版本，若返回版本号，npm 可用</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h1 id="4-nvm的原理"><a href="#4-nvm的原理" class="headerlink" title="4. nvm的原理"></a>4. nvm的原理</h1><p>执行<code>nvm use 版本号</code>命令时会将对应版本的 node链接到<code>%NVM_SYMLINK%</code>，以此来实现多版本node自由切换</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-25-Javadoc%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-09-25-Javadoc%20%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>官网：Javadoc is a tool for generating API documentation in HTML format from doc comments in source code. </p><p>译：Javadoc是一款能根据源代码中的<strong>文档注释</strong>来产生HTML格式的API文档的工具。 </p><p>解释：只要你在java源码中按一定的格式写注释，就可以利用 Javadoc 这款工具自动生成配套的API文档。  </p><p>文档注释只负责描述类(class)、接口(interface)、方法(method)、构造器(constructor)、成员字段(field)。相应地，文档注释必须写在类、接口、方法、构造器、成员字段前面，而写在其他位置，比如函数内部，是无效的文档注释。</p><p>文档注释采用HTML语法规则书写，支持HTML标记(tag)，同时也有一些额外的辅助标记。需要注意的是，这些标记不是给人看的（通常他们的可读性也不好），他们的作用是为了javadoc工具更好地生成最终文档。所以，虽然有些标记写起来麻烦且看着不直观，还是要老老实实按规矩写滴。</p><h1 id="2-Javadoc-的组成"><a href="#2-Javadoc-的组成" class="headerlink" title="2. Javadoc 的组成"></a>2. Javadoc 的组成</h1><p>一个文档注释由两部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 描述部分(description) </span><br><span class="line">*</span><br><span class="line">* 标记部分(block tags)</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>描述部分自然不用多说，所谓的标记符号指的是@param，@return，@see之类的。需要注意的是描述部分和文档标记之间必须空一行，描述段落必须在标记段落之前</p><h1 id="3-Javadoc-的使用规范"><a href="#3-Javadoc-的使用规范" class="headerlink" title="3. Javadoc 的使用规范"></a>3. Javadoc 的使用规范</h1><p>所有 Public 和 Protected 方法都应当有相应的 Javadoc。Package 和 Private 方法不强求，但是如果有帮助的话加上也很好</p><p>Javadoc 以 <code>/**</code> 开头、以 <code>*/</code> 结尾，并且每行要以星号开头：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Standard comment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ...</span><br></pre></td></tr></table></figure><p>Javadoc要和其后对应的类/方法/字段/包保持同样的缩进，以下例子就是错误的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 没有和下面的方法保持同样的缩进，是错误的.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getName</span><span class="params">(<span class="type">int</span> ID)</span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-描述部分-Description"><a href="#3-1-描述部分-Description" class="headerlink" title="3.1. 描述部分(Description)"></a>3.1. 描述部分(Description)</h2><p><strong>首句很重要</strong></p><p>Javadoc 的首句（用英文句号结束）也被作为这个 Javadoc 的摘要，在折叠的时候只会显示这一句。因此首句必须是个总结性的描述，它最好简洁有力，不能太长</p><p><strong>用单个 <code>&lt;p&gt;</code> 来分割段落</strong></p><p>Javadoc 经常会需要分成好几段。所以问题来了：怎样优雅地加上段落标记？答案是，在两段之间写上一行 <code>&lt;p&gt;</code> 就可以了，不用加 <code>&lt;/p&gt;</code> 闭合它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * First paragraph.  </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;  </span></span><br><span class="line"><span class="comment"> * Second paragraph.  </span></span><br><span class="line"><span class="comment"> * May be on multiple lines.  </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;  </span></span><br><span class="line"><span class="comment"> * Third paragraph.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> ...</span><br></pre></td></tr></table></figure><p><strong>用单个 <code>&lt;li&gt;</code> 来标记列表项</strong></p><p>列表在 Javadoc 中也很常用，比如用来表示一组选项、一些问题等等。推荐的做法是用一个 <code>&lt;li&gt;</code> 作为每项的开头，同样不需要闭合。此外，别忘了加段落 tag</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * First paragraph.  </span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;ul&gt;  </span></span><br><span class="line"><span class="comment"> * &lt;li&gt;the first item  </span></span><br><span class="line"><span class="comment"> * &lt;li&gt;the second item  </span></span><br><span class="line"><span class="comment"> * &lt;li&gt;the third item  </span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;&lt;p&gt;  </span></span><br><span class="line"><span class="comment"> * Second paragraph.  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> ...</span><br></pre></td></tr></table></figure><h2 id="3-2-标记部分-Tag"><a href="#3-2-标记部分-Tag" class="headerlink" title="3.2. 标记部分(Tag)"></a>3.2. 标记部分(Tag)</h2><p>下面是常见的文档标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@author</span> 作者名（只出现在类和接口的文档中）</span><br><span class="line"><span class="meta">@version</span> 版本号（只出现在类和接口的文档中）</span><br><span class="line"><span class="meta">@param</span> 参数名（只出现在方法或构造器的文档中）</span><br><span class="line"><span class="meta">@return</span> 返回值情况（只出现在方法中）</span><br><span class="line"><span class="meta">@throws</span> 异常抛出情况</span><br><span class="line"><span class="meta">@exception</span> <span class="meta">@throws</span> 和 <span class="meta">@exception</span>是一模一样的  </span><br><span class="line"><span class="meta">@see</span></span><br><span class="line"><span class="meta">@since</span> 指明需要最早使用的jdk版本</span><br><span class="line"><span class="meta">@serial</span>（也可以使用<span class="meta">@serialField</span>或<span class="meta">@serialData</span>替代）</span><br><span class="line"><span class="meta">@deprecated</span> 给出代码被弃用的原因、何时可能被弃用以及替代方案的解释</span><br><span class="line"><span class="meta">@value</span> 常用于写在字段上的Javadoc注释</span><br></pre></td></tr></table></figure></p><p>如果方法有参数，@param标记必须包含，而且每个对应一个参数<br>如果方法有返回值，@return标记必须包含</p><p>在IDEA中，可以安装Easy JavaDoc 插件快速生成</p><h1 id="4-用IDE生成"><a href="#4-用IDE生成" class="headerlink" title="4. 用IDE生成"></a>4. 用IDE生成</h1><p>IDEA工具栏中选择<code>Tools——&gt;Generate JavaDoc</code></p><ul><li>第一步：选择生成JavaDoc文档的范围，我只对一个源文件生成Doc，所以选择文件。</li><li>第二步：输出目录最好新建一个文件夹，比较有条理和整洁</li><li>第三步：区域设置，决定文档的语言，简体中文就是zh_CN、繁体(台湾)zh_tw、繁体(香港)zh-hk、英语(香港)en-hk、英语(美国)en-us、英语(英国)en-gb、英语(全球)en-ww</li><li>第四步：其他命令行参数：如果区域设置为中国，参数一般为<code>-encoding UTF-8 -charset UTF-8</code></li><li>第五步：设置完成后点击确定即可生成Doc文档</li></ul><p>打开输出目录，就可看到成功生成，打开 index.html 便能看生成的文档。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-28-CSS%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2024-08-28-CSS%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<ul><li><p>选择器</p></li><li><p>文档流</p></li><li><p>浮动 float</p></li><li><p>定位 position (z-index)</p></li><li><p>盒子模型</p></li><li><p>display</p></li><li><p>变形 transform</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三大件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-29-VSCode%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/28/2024-08-29-VSCode%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-初始化设置"><a href="#1-初始化设置" class="headerlink" title="1. 初始化设置"></a>1. 初始化设置</h1><p><strong>编辑后自动保存</strong></p><p><code>settings-&gt;auto save-&gt;Files:Auto Save</code>  设置为afterDelay（这个是在多少毫秒后自动保存）</p><p><code>settings-&gt;auto save-&gt;Files:Auto Save Delay</code> 设置为默认即可，单位是毫秒</p><p><strong>设置启动时不打开上一次的项目</strong></p><p><code>settings-&gt;window.restoreWindows</code>  设置为none</p><p><strong>设置打开的文件自动猜测合适的编码格式并选择该格式打开文件</strong></p><p>打开settings 搜索 Auto Guess Encoding</p><h1 id="2-插件"><a href="#2-插件" class="headerlink" title="2. 插件"></a>2. 插件</h1><p><strong>prettier Code formatter（格式化代码）</strong></p><ol><li>下载插件 Prettier</li><li>Default Formatter选择Prettier</li><li>勾选 format on save</li><li>打开配置文件setting.json，添加下面内容</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置JavaScript的格式化工具</span></span><br><span class="line"><span class="attr">&quot;[javascript]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="comment">// 配置JSX的格式化工具</span></span><br><span class="line"><span class="attr">&quot;[javascriptreact]&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">&quot;editor.defaultFormatter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esbenp.prettier-vscode&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>Vue - Official（Vue3）</strong></p><p><strong>Vuter（Vue2）</strong></p><p><strong>editorconfig</strong></p><p>它可以定义一些基本的编辑器设置，如缩进风格、换行符类型、字符编码等，以确保团队成员在不同的编辑器中编写的代码具有一致的风格。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># EditorConfig 文件示例</span><br><span class="line"></span><br><span class="line"># 表示这是项目根目录下的顶级 .editorconfig 文件，编辑器在查找配置时会停止向上查找</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line"># 匹配所有文件</span><br><span class="line">[*]</span><br><span class="line"># 使用 Unix 风格的换行符</span><br><span class="line">end_of_line = lf</span><br><span class="line"># 文件末尾会插入一个空行</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line"># 匹配 JavaScript 文件</span><br><span class="line">[*.js]</span><br><span class="line"># 使用空格缩进</span><br><span class="line">indent_style = space</span><br><span class="line"># 缩进大小为 4</span><br><span class="line">indent_size = 4</span><br><span class="line"></span><br><span class="line"># 匹配 Markdown 文件</span><br><span class="line">[*.md]</span><br><span class="line"># 使用制表符缩进</span><br><span class="line">indent_style = tab</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-30-React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-08-30-React%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-技术搭配"><a href="#1-技术搭配" class="headerlink" title="1. 技术搭配"></a>1. 技术搭配</h1><p>React版本选择React18</p><p>CSS preprocessor（CSS预处理器）选择：SCSS</p><p>代码格式化选择：Prettier规则，使用vscode中的插件进行自动格式化</p><p>构建工具选择：Vite</p><p>路由管理选择：React Router</p><p>国际化插件选择：react-i18next</p><p>API通信选择：Axios</p><p>状态管理选择：Mobx 或 原生 React Hooks（中小项目）、Redux（大项目）</p><p>第三方UI组件：Ant Design</p><p>脚本语言：JSX</p><p>脚手架：create-react-app</p><p>骨架屏：React Content Loader</p><p>一站式跨平台开发框架：taro</p><p>身份验证：</p><ul><li>Firebase Auth</li><li>Supabase Auth</li><li>Auth0</li><li>AWS Cognito</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-28-HTML%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2024-08-28-HTML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;shortcut icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"><span class="selector-tag">html</span>,<span class="selector-tag">body</span>,<span class="selector-id">#container</span>&#123; <span class="attribute">height</span>: <span class="number">100%</span>;<span class="attribute">overflow</span>: hidden&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>DOCTYPE</code> 文档类型 (jsp php 动态页面需要格外注意，不同文档类型声明会造成样式等解析规则不同)</li><li><code>&lt;meta&gt;</code> 元信息 （文档编码、特殊浏览器标识、viewport 设置等等）</li><li><code>&lt;viewport&gt;</code> 视窗 (devicePixelRatio)</li><li><code>&lt;title&gt;</code> 文档标题 (document.title)</li><li><code>&lt;link&gt;</code> 链接 (rel 当前文档与被链接文档之间的关系、href 链接地址 <code>&lt;a&gt;</code>)</li><li><code>&lt;script&gt;</code> 脚本 (src 资源地址 <code>&lt;video&gt;</code> <code>&lt;img&gt;</code>)</li><li><code>&lt;style&gt;</code> 引入 css 样式的几种形式、优先级、优缺点</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三大件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-30-Vue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-08-30-Vue%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-技术搭配"><a href="#1-技术搭配" class="headerlink" title="1. 技术搭配"></a>1. 技术搭配</h1><p>Vue版本选择Vue3</p><p>Vue组件风格选择：composition API（组合式API）</p><p>CSS preprocessor（CSS预处理器）选择：SCSS</p><p>代码格式化选择：Prettier规则，使用vscode中的插件进行自动格式化</p><p>构建工具选择：Vite</p><p>路由管理选择：Vue-router</p><p>国际化插件选择：Vue-i18n</p><p>API通信选择：Axios</p><p>状态管理选择：Pinia</p><p>第三方UI组件：<a href="https://element.eleme.cn/">ElementUI</a></p><p>脚本语言：JavaScript</p><p>脚手架：Vue CLI</p><p>一站式跨平台开发框架：Quasar</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-31-SpringBoot%E6%95%B4%E5%90%88Druid/"/>
      <url>/2024/10/28/2024-08-31-SpringBoot%E6%95%B4%E5%90%88Druid/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是数据库连接池"><a href="#1-什么是数据库连接池" class="headerlink" title="1. 什么是数据库连接池"></a>1. 什么是数据库连接池</h1><p>数据库连接池就是在程序启动时就创建一定数量的数据库连接，将这些连接放入一个池子进行管理。由程序动态的进行连接的申请、使用和释放。注意，数据库不单单指Mysql，同样也可以为Redis设计连接池。</p><h1 id="2-连接池的运行原理"><a href="#2-连接池的运行原理" class="headerlink" title="2. 连接池的运行原理"></a>2. 连接池的运行原理</h1><ol><li>从连接池获取连接或者创建连接；</li><li>使用连接，用完归还到连接池；</li><li>在系统关闭前，关闭所有连接并释放资源<h1 id="3-为什么要使用数据库连接池"><a href="#3-为什么要使用数据库连接池" class="headerlink" title="3. 为什么要使用数据库连接池"></a>3. 为什么要使用数据库连接池</h1></li></ol><ul><li><strong>资源复用</strong>。避免了频繁的创建、销毁带来的性能开销，<strong>减少系统资源消耗</strong>的基础上，<strong>增加了系统运行的稳定性</strong>，主要<strong>体现在减少内存碎片和线程或进程的临时创建</strong>。</li><li><strong>更快的响应速度</strong>。由于程序启动时就准备好了若干连接备用，业务请求直接使用即可，不需要实时进行连接的创建、权限验证及销毁等操作，从而减少了系统的响应时间。</li><li><strong>统一的连接管理，避免数据库连接泄漏</strong>。可预先设定连接占用的超时时间，假如某条连接被占用超过设定值，可以强制回收该连接。</li></ul><h1 id="4-Mysql数据库连接的建立过程"><a href="#4-Mysql数据库连接的建立过程" class="headerlink" title="4. Mysql数据库连接的建立过程"></a>4. Mysql数据库连接的建立过程</h1><ol><li>客户端发起连接请求，TCP三次握手</li><li>Mysql内部权限验证</li><li>SQL执行语句</li><li>Mysql关闭</li><li>断开连接，TCP四次挥手</li></ol><h1 id="5-整合Druid"><a href="#5-整合Druid" class="headerlink" title="5. 整合Druid"></a>5. 整合Druid</h1><p>Druid是高性能的关系型数据库连接池，它是阿里巴巴的一个开源项目。支持所有JDBC兼容的数据库，包括Oracle、MySQL、Derby、PostgreSQL、SQL Server、H2等。提供了丰富的监控和统计功能，可以帮助开发者更好地管理数据库连接</p><p>在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml 文件中添加以下配置项，<code>com.alibaba.druid.pool.DruidDataSource</code> 基本配置参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # 指定使用 Druid 数据源</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">    # 配置 Druid 数据源相关属性</span><br><span class="line">    druid:</span><br><span class="line">      # 初始化时连接池的大小</span><br><span class="line">      initial-size: 5</span><br><span class="line">      # 连接池的最小空闲连接数</span><br><span class="line">      min-idle: 5</span><br><span class="line">      # 连接池的最大活跃连接数</span><br><span class="line">      max-active: 20</span><br><span class="line">      # 获取连接时最大等待时间</span><br><span class="line">      max-wait: 60000</span><br><span class="line">      # 用于检测空闲连接的 SQL 查询语句</span><br><span class="line">      validation-query: SELECT 1</span><br><span class="line">      # 是否在获取连接时验证连接</span><br><span class="line">      test-on-borrow: true</span><br><span class="line">      # 是否在归还连接时验证连接</span><br><span class="line">      test-on-return: false</span><br><span class="line">      # 是否在连接空闲时验证连接</span><br><span class="line">      test-while-idle: true</span><br><span class="line">      # 配置间隔多久进行一次检测，检测需要关闭的空闲连接，单位是毫秒</span><br><span class="line">      time-between-eviction-runs-millis: 60000</span><br><span class="line">      # 配置连接在池中最小生存的时间，单位是毫秒</span><br><span class="line">      min-evictable-idle-time-millis: 300000</span><br><span class="line">      # 配置连接在池中最大生存的时间，单位是毫秒</span><br><span class="line">      max-evictable-idle-time-millis: 900000</span><br><span class="line">      # 打开PSCache，并且指定每个连接上PSCache的大小</span><br><span class="line">      pool-prepared-statements: true</span><br><span class="line">      max-pool-prepared-statement-per-connection-size: 20</span><br><span class="line">      # 配置监控统计拦截的filters，stat表示统计功能，wall表示防火墙</span><br><span class="line">      filters: stat,wall,log4j</span><br><span class="line">      # 合并多个DruidDataSource的监控数据</span><br><span class="line">      use-global-data-source-stat: true</span><br><span class="line">      # SQL执行时是否打印日志</span><br><span class="line">      log-slow-sql: true</span><br><span class="line">      # SQL执行超过多长时间就认为是慢SQL，单位毫秒</span><br><span class="line">      slow-sql-millis: 2000</span><br><span class="line">      # SQL日志是否需要格式化</span><br><span class="line">      connection-properties: druid.stat.slowSqlMillis=2000;druid.stat.logSlowSql=true</span><br><span class="line">      # 用于采集web-jdbc关联监控的数据</span><br><span class="line">      webStatFilter:</span><br><span class="line">        enabled: true</span><br><span class="line">      # 提供监控信息展示的html页面</span><br><span class="line">      statViewServlet:</span><br><span class="line">        enabled: true</span><br><span class="line">        # 设置白名单，不填则允许所有访问</span><br><span class="line">        allow:</span><br><span class="line">        url-pattern: /druid/*</span><br><span class="line">        # 控制台管理用户名和密码</span><br><span class="line">        login-username: admin</span><br><span class="line">        login-password: admin</span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8080/druid/datasource.html">http://localhost:8080/druid/datasource.html</a></p><h1 id="6-Druid-密码回调"><a href="#6-Druid-密码回调" class="headerlink" title="6. Druid 密码回调"></a>6. Druid 密码回调</h1><p>很多项目都是把数据库的密码明文放在配置文件中，这样其实是不安全的，应该将密码加密后再放到配置中，这样可以一定程度的保护数据库密码的安全。</p><p>Druid 可以通过配置参数 passwordCallBack 来指定一个密码接口回调类进行密文密码解密操作。</p><p><strong>首先自定义一个密码接口回调类</strong></p><p>需要实现 DruidPasswordCallback 接口并重写接口方法 <code>setProperties()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.util.DruidPasswordCallback;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DruidCustomPasswordCallback</span> <span class="keyword">extends</span> <span class="title class_">DruidPasswordCallback</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setProperties(properties);</span><br><span class="line">        <span class="comment">// 获取配置文件中的已经加密的密码（spring.datasource.druid.connect-properties.password）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> (String)properties.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(pwd)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这里的代码是将密码进行解密，并设置</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;解密后的明文密码&quot;</span>;</span><br><span class="line">                setPassword(password.toCharArray());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后在yml 配置文件中配置密码接口回调类</strong></p><p>使用 <code>spring.datasource.druid.password-callback-class-name</code> 属性来配置密码接口回调类</p><p>根据密码接口回调类中的密文密码解密的逻辑，必须配置 <code>spring.datasource.druid.connect-properties.password</code> 属性才会进行密文密码解密操作并重置密码为解密后的明文密码</p><h1 id="7-Druid-数据源监控"><a href="#7-Druid-数据源监控" class="headerlink" title="7. Druid 数据源监控"></a>7. Druid 数据源监控</h1><p>Druid 数据源具有监控的功能，并提供了一个 web 界面方便用户查看</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-02-React%20Router%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2024-09-02-React%20Router%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://reactrouter.com/en/main/start/tutorial">官方文档</a></p><h1 id="1-创建路由"><a href="#1-创建路由" class="headerlink" title="1. 创建路由"></a>1. 创建路由</h1><p>使用对象，创建一个路由，将路径和组件做匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h1 id="2-路由挂载到根DOM"><a href="#2-路由挂载到根DOM" class="headerlink" title="2. 路由挂载到根DOM"></a>2. 路由挂载到根DOM</h1><p>不使用ReactRouter时，是这样挂载的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用ReactRouter时，是这样挂载的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./Router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouterProvider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">RouterProvider</span> <span class="attr">router</span>=<span class="string">&#123;router&#125;</span> /&gt;</span></span>,</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><h1 id="3-创建全局布局"><a href="#3-创建全局布局" class="headerlink" title="3. 创建全局布局"></a>3. 创建全局布局</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">// src/layouts/MainLayout.js</span><br><span class="line">const MainLayout = ()=&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;div id=&quot;sidebar&quot;&gt;</span><br><span class="line">          &lt;h1&gt;React Router&lt;/h1&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;form id=&quot;search-form&quot; role=&quot;search&quot;&gt;</span><br><span class="line">              &lt;input</span><br><span class="line">                id=&quot;q&quot;</span><br><span class="line">                aria-label=&quot;Search contacts&quot;</span><br><span class="line">                placeholder=&quot;Search&quot;</span><br><span class="line">                type=&quot;search&quot;</span><br><span class="line">                name=&quot;q&quot;</span><br><span class="line">              /&gt;</span><br><span class="line">              &lt;div</span><br><span class="line">                id=&quot;search-spinner&quot;</span><br><span class="line">                aria-hidden</span><br><span class="line">                hidden=&#123;true&#125;</span><br><span class="line">              /&gt;</span><br><span class="line">              &lt;div</span><br><span class="line">                className=&quot;sr-only&quot;</span><br><span class="line">                aria-live=&quot;polite&quot;</span><br><span class="line">              &gt;&lt;/div&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">            &lt;form method=&quot;post&quot;&gt;</span><br><span class="line">              &lt;button type=&quot;submit&quot;&gt;New&lt;/button&gt;</span><br><span class="line">            &lt;/form&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;nav&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">              &lt;li&gt;</span><br><span class="line">                &lt;a href=&#123;`/contacts/1`&#125;&gt;Your Name&lt;/a&gt;</span><br><span class="line">              &lt;/li&gt;</span><br><span class="line">              &lt;li&gt;</span><br><span class="line">                &lt;a href=&#123;`/contacts/2`&#125;&gt;Your Friend&lt;/a&gt;</span><br><span class="line">              &lt;/li&gt;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">          &lt;/nav&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;detail&quot;&gt;具体页面组件&lt;/div&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  export default MainLayout;</span><br></pre></td></tr></table></figure><p>把全局布局与根路径匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MainLayout</span> <span class="keyword">from</span> <span class="string">&#x27;./layouts/MainLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>, <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">MainLayout</span> /&gt;</span></span> &#125;,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure><h1 id="4-处理路由不存在异常"><a href="#4-处理路由不存在异常" class="headerlink" title="4. 处理路由不存在异常"></a>4. 处理路由不存在异常</h1><p>定义异常页<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// src/pages/ErrorPage.js</span><br><span class="line">import &#123; useRouteError &#125; from &quot;react-router-dom&quot;;</span><br><span class="line"></span><br><span class="line">const ErrorPage = () =&gt; &#123;</span><br><span class="line">    const error = useRouteError();</span><br><span class="line">    console.error(error);</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">        &lt;div id=&quot;error-page&quot;&gt;</span><br><span class="line">            &lt;h1&gt;Oops!&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;Sorry, an unexpected error has occurred.&lt;/p&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                &lt;i&gt;&#123;error.statusText || error.message&#125;&lt;/i&gt;</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br><span class="line">export default ErrorPage;</span><br></pre></td></tr></table></figure></p><p>放置异常页，当访问的路径下没有匹配的组件就返回异常页</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorPage</span> <span class="keyword">from</span> <span class="string">&quot;./pages/ErrorPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MainLayout</span> <span class="keyword">from</span> <span class="string">&quot;./layouts/MainLayout&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">MainLayout</span> /&gt;</span></span>,</span><br><span class="line">        <span class="attr">errorElement</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorPage</span> /&gt;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><h1 id="5-嵌套路由"><a href="#5-嵌套路由" class="headerlink" title="5. 嵌套路由"></a>5. 嵌套路由</h1><p>在全局布局中，加载其他组件</p><p>先把这些组件放在children数组中，和对应的路径匹配好</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/Router.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createBrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ErrorPage</span> <span class="keyword">from</span> <span class="string">&quot;./pages/ErrorPage&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MainLayout</span> <span class="keyword">from</span> <span class="string">&quot;./layouts/MainLayout&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Query</span> <span class="keyword">from</span> <span class="string">&quot;./pages/Query&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Hello</span> <span class="keyword">from</span> <span class="string">&quot;./pages/Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createBrowserRouter</span>([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">        <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">MainLayout</span> /&gt;</span></span>,</span><br><span class="line">        <span class="attr">errorElement</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">ErrorPage</span> /&gt;</span></span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;query&quot;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Query</span> /&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">                <span class="attr">element</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">Hello</span> /&gt;</span></span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>然后在全局布局的代码中，引入Outlet，把<code>&lt;Outlet /&gt;</code>放在全局布局代码中相应的位置<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/layouts/MainLayout.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Outlet</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line">&#123;<span class="comment">/* other code */</span>&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  &#123;<span class="comment">/* other code */</span>&#125;</span><br><span class="line">      &lt;div id=<span class="string">&quot;detail&quot;</span>&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">Outlet</span> /&gt;</span></span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &#123;<span class="comment">/* other code */</span>&#125;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#123;<span class="comment">/* other code */</span>&#125;</span><br></pre></td></tr></table></figure></p><h1 id="6-路由切换"><a href="#6-路由切换" class="headerlink" title="6. 路由切换"></a>6. 路由切换</h1><p>使用<code>&lt;Link to&gt;</code>实现路由的跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// src/layouts/MainLayout.js</span><br><span class="line">&#123;/* other code */&#125;</span><br><span class="line">&lt;nav&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;Link to=&#123;`query`&#125;&gt;Your query&lt;/Link&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;Link to=&#123;`hello`&#125;&gt;Your Hello&lt;/Link&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/nav&gt;</span><br><span class="line">&#123;/* other code */&#125;</span><br></pre></td></tr></table></figure><h1 id="7-路由参数"><a href="#7-路由参数" class="headerlink" title="7. 路由参数"></a>7. 路由参数</h1><p>形如 <code>/users/:userId</code>。<code>/users/123</code>，怎么把路径中的id参数传递到组件中</p><h1 id="8-导航状态"><a href="#8-导航状态" class="headerlink" title="8. 导航状态"></a>8. 导航状态</h1><p>使用<code>useNavigation</code> hook，获取导航的状态，包括 <code>&quot;idle&quot; | &quot;submitting&quot; | &quot;loading&quot;</code></p><p>可以根据该状态，加载进度条等内容，可以配合React Content Loader 骨架屏使用</p><h1 id="9-默认子路由"><a href="#9-默认子路由" class="headerlink" title="9. 默认子路由"></a>9. 默认子路由</h1><p>在配置完路由后，直接访问应用，只会展示全局布局组件，不会展示具体的业务组件</p><p><code>&lt;Outlet&gt;</code> 不会返回任何组件，因为没有任何子路由匹配，也就是说<code>&lt;Outlet&gt;</code>是根据子路由去返回组件的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const router = createBrowserRouter([</span><br><span class="line">    &#123;</span><br><span class="line">        path: &quot;/&quot;,</span><br><span class="line">        element: &lt;MainLayout /&gt;,</span><br><span class="line">        errorElement: &lt;ErrorPage /&gt;,</span><br><span class="line">        children: [</span><br><span class="line">            &#123; index: true, element: &lt;Query /&gt; &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;query&quot;,</span><br><span class="line">                element: &lt;Query /&gt;,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: &quot;hello&quot;,</span><br><span class="line">                element: &lt;Hello /&gt;,</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>在children中配置<code>&#123; index: true, element: &lt;Index /&gt; &#125;</code>，当访问其父路由时，<code>&lt;Outlet&gt;</code> 就会返回<code>&#123; index: true, element: &lt;Index /&gt; &#125;</code>中配置的组件</p><h1 id="10-JSX-Routes"><a href="#10-JSX-Routes" class="headerlink" title="10. JSX Routes"></a>10. JSX Routes</h1><p>使用JSX的方式创建路由和使用对象的方式创建路由效果是一样的，使用习惯不同而已</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-02-React%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/28/2024-09-02-React%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-React-Content-Loader的使用"><a href="#1-React-Content-Loader的使用" class="headerlink" title="1. React Content Loader的使用"></a>1. <a href="https://skeletonreact.com/">React Content Loader</a>的使用</h1><p>创建骨架屏，在组件加载完成前显示大体边框，避免让用户看到白色屏幕，有个过渡的动效</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-09-04-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B0%81%E8%A3%85/"/>
      <url>/2024/10/28/2024-09-04-%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计"><a href="#1-设计" class="headerlink" title="1. 设计"></a>1. 设计</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">5emcmlug3i37dupviovh9067oj[&quot;组件设计&quot;] --&gt; 2e3gldb8pr4l8v465kmnd2ku3v[&quot;组件层级设计&quot;]</span><br><span class="line">2e3gldb8pr4l8v465kmnd2ku3v --&gt; 3sljttlr3hhoks9je2kv1e9gel[&quot;职责的确定&quot;]</span><br><span class="line">3sljttlr3hhoks9je2kv1e9gel --&gt; 3801ved9ggt90361v2b8gu6g0q[&quot;基础组件 or 业务组件&quot;]</span><br><span class="line">3sljttlr3hhoks9je2kv1e9gel --&gt; 2flfn88iidjphp3vkkcqcvcmhc[&quot;通用 or 定制&quot;]</span><br><span class="line">5emcmlug3i37dupviovh9067oj --&gt; 2uk7vvod7kbgtp8q9gpb2va4t9[&quot;状态设计&quot;]</span><br><span class="line">2uk7vvod7kbgtp8q9gpb2va4t9 --&gt; 48066v5mj7js61svgja7knbd7o[&quot;定义（数据结构）&quot;]</span><br><span class="line">2uk7vvod7kbgtp8q9gpb2va4t9 --&gt; 7c17eie2culpnqnkf4o44ngcbg[&quot;存储（local storage or 全局状态 or 组件状态）&quot;]</span><br></pre></td></tr></table></figure><h1 id="2-基础组件-业务组件"><a href="#2-基础组件-业务组件" class="headerlink" title="2. 基础组件 / 业务组件"></a>2. 基础组件 / 业务组件</h1><p>如何区分基础组件和业务组件的差别，通用性是我们区分基础组件和业务组件的边界。</p><h1 id="3-通用特性-定制特性"><a href="#3-通用特性-定制特性" class="headerlink" title="3. 通用特性 / 定制特性"></a>3. 通用特性 / 定制特性</h1><p>通用特性归于基础组件中，定制特性在业务组件中封装</p><p>看一个复杂些的例子，各大厂都在推的工作流类应用，我们来思考如果是我们来做这些节点，我们应该如何来做？我们可以从以下几点来思考：</p><ol><li><p><strong>节点的通用特性是什么？</strong></p></li><li><p><strong>节点的定制特性是什么？</strong></p></li><li><p><strong>如何封装？</strong></p></li></ol><h1 id="4-状态定义"><a href="#4-状态定义" class="headerlink" title="4. 状态定义"></a>4. 状态定义</h1><p><a href="https://react.dev/learn/thinking-in-react">React 官方的这篇文章值得反复阅读</a></p><h1 id="5-状态的存储"><a href="#5-状态的存储" class="headerlink" title="5. 状态的存储"></a>5. 状态的存储</h1><p>状态的存储方式是一个跟实际业务挂钩的东西</p><p><strong>唯一要注意的就是区分好「 全局状态 」和 「 组件状态 」</strong></p><p><strong>应该始终以一个消费者的视角来开发组件。</strong></p><p>综上所述，组件的设计应该包含以下的路径：</p><ol><li><p>根据「 通用特性/定制特性 」确定组件的通用级别。</p></li><li><p>将特性区分为 「 UI 特性 / 业务特性 」来确定组件层级和封装。</p></li><li><p>结合一些技巧来优化组件层级和状态存储的位置，优化性能表现。</p></li><li><p>还有许多的细节需要处理（Typescript 定义、props 定义、样式等）…</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-22-MySQL%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/10/28/2024-07-22-MySQL%E4%B8%BB%E9%94%AE%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主键的选择"><a href="#1-主键的选择" class="headerlink" title="1. 主键的选择"></a>1. 主键的选择</h1><p>可以使用 BIGINT 的自增类型作为主键，同时由于整型的自增性，数据库插入也是顺序的，性能较好</p><p>但是要注意，使用 BIGINT 的自增类型作为主键的设计仅仅适合<strong>非核心业务表</strong>，比如告警表、日志表等。<strong>真正的核心业务表，一定不要用自增键做主键</strong>，主要有 6 个原因：</p><ul><li>自增存在回溯问题；</li><li>自增值在服务器端产生，存在并发性能问题；</li><li>自增值做主键，只能在当前实例中保证唯一，<strong>不能保证全局唯一</strong>；</li><li>公开数据值，容易引发安全问题，例如知道地址<code>http://www.example.com/User/10/</code>，很容猜出 User 有 11、12 依次类推的值，容易引发数据泄露；</li><li>MGR（MySQL Group Replication） 可能引起的性能问题；</li><li>分布式架构设计问题。</li></ul><p><strong>更推荐 UUID 做主键或业务自定义生成主键</strong></p><h1 id="2-UUID主键设计"><a href="#2-UUID主键设计" class="headerlink" title="2. UUID主键设计"></a>2. UUID主键设计</h1><p>UUID（Universally Unique Identifier）代表全局唯一标识 ID。</p><p>MySQL 数据库遵循 <code>DRFC 4122</code> 命名空间版本定义的 Version 1规范，可以通过函数 UUID自动生成36字节字符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> UUID();</span><br></pre></td></tr></table></figure><p>根据 Version 1的规范，MySQL中的 UUID 由以下几个部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID = 时间低（4字节）- 时间中高+版本（4字节）- 时钟序列 - MAC地址</span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是，在存储时间时，UUID 是根据时间位逆序存储，</strong> 也就是低时间低位存放在最前面，高时间位在最后，即 UUID 的前 4 个字节会随着时间的变化而不断“随机”变化，并非单调递增。而非随机值在插入时会产生离散 IO，从而产生性能瓶颈。这也是 UUID 对比自增值最大的弊端。</p><p>为了解决这个问题，MySQL 8.0 推出了函数 UUID_TO_BIN，它可以把 UUID 字符串：</p><ul><li>通过参数将时间高位放在最前，解决了 UUID 插入时乱序问题；</li><li>去掉了无用的字符串”-“，精简存储空间；</li><li>将字符串其转换为二进制值存储，空间最终从之前的 36 个字节缩短为了 16 字节。</li></ul><p>除此之外，MySQL 8.0 也提供了函数 BIN_TO_UUID，支持将二进制值反转为 UUID 字符串。</p><p>因此，创建表时可以将其主键修改为 BINARY(16)，用于存储排序后的 16 字节的 UUID 值。其表结构修如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">User</span> (</span><br><span class="line"></span><br><span class="line">    id  <span class="type">BINARY</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">    sex <span class="type">CHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"></span><br><span class="line">    money <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    register_date DATETIME(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line">    last_modify_date DATETIME(<span class="number">6</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line"></span><br><span class="line">    uuid <span class="type">CHAR</span>(<span class="number">36</span>) <span class="keyword">AS</span> (BIN_TO_UUID(id)),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CONSTRAINT</span> chk_sex <span class="keyword">CHECK</span> (sex <span class="operator">=</span> <span class="string">&#x27;M&#x27;</span> <span class="keyword">OR</span> sex <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>现在，你可以在客户端通过以下 SQL 命令插入数据，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span> <span class="keyword">VALUES</span> (UUID_TO_BIN(UUID(),<span class="literal">TRUE</span>),......);</span><br></pre></td></tr></table></figure><p>MySQL 8.0 提供的排序 UUID 性能最好，甚至比自增ID还要好</p><p>MySQL 8.0版本之前没有函数 UUID_TO_BIN/BIN_TO_UUID，但是可以通过用户定义函数（UDF）的方式解决，如创建下面的函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> my_uuid() <span class="keyword">RETURNS</span> <span class="type">CHAR</span>(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">NO</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> original_uuid <span class="type">CHAR</span>(<span class="number">36</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> rearranged_uuid <span class="type">CHAR</span>(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 生成原始 UUID</span></span><br><span class="line">    <span class="keyword">SET</span> original_uuid <span class="operator">=</span> UUID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">-- 将时间高位放在最前，并去掉无用的字符串 -</span></span><br><span class="line">    <span class="keyword">SET</span> rearranged_uuid <span class="operator">=</span> CONCAT(</span><br><span class="line">        <span class="built_in">SUBSTRING</span>(original_uuid, <span class="number">15</span>, <span class="number">4</span>), </span><br><span class="line">        <span class="built_in">SUBSTRING</span>(original_uuid, <span class="number">10</span>, <span class="number">4</span>), </span><br><span class="line">        <span class="built_in">SUBSTRING</span>(original_uuid, <span class="number">1</span>, <span class="number">8</span>), </span><br><span class="line">        <span class="built_in">SUBSTRING</span>(original_uuid, <span class="number">20</span>, <span class="number">4</span>), </span><br><span class="line">        <span class="built_in">SUBSTRING</span>(original_uuid, <span class="number">25</span>, <span class="number">12</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">RETURN</span> rearranged_uuid;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1 id="3-业务自定义生成主键"><a href="#3-业务自定义生成主键" class="headerlink" title="3. 业务自定义生成主键"></a>3. 业务自定义生成主键</h1><p>UUID 虽好，但是在分布式数据库场景下，主键还需要加入一些额外的信息，这样才能保证后续二级索引的查询效率。<strong>现在你只需要牢记：分布式数据库架构，仅用 UUID 做主键依然是不够的。</strong> 所以，对于分布式架构的核心业务表，我推荐类似如下的设计，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PK = 时间字段 + 随机码（可选） + 业务信息1 + 业务信息2 ......</span><br></pre></td></tr></table></figure><p>一个最基本的分布式 ID 需要满足下面这些要求：</p><ul><li><p><strong>全局唯一</strong>：ID 的全局唯一性肯定是首先要满足的！</p></li><li><p><strong>高性能</strong>：分布式 ID 的生成速度要快，对本地资源消耗要小。</p></li><li><p><strong>高可用</strong>：生成分布式 ID 的服务要保证可用性无限接近于 100%。</p></li><li><p><strong>方便易用</strong>：拿来即用，使用方便，快速接入！</p></li></ul><p>除了这些之外，一个比较好的分布式 ID 还应保证：</p><ul><li><p><strong>安全</strong>：ID 中不包含敏感信息。</p></li><li><p><strong>有序递增</strong>：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</p></li><li><p><strong>有具体的业务含义</strong>：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</p></li><li><p><strong>独立部署</strong>：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</p></li></ul><h1 id="4-IdGenerator"><a href="#4-IdGenerator" class="headerlink" title="4. IdGenerator"></a>4. IdGenerator</h1><p><a href="https://github.com/yitter/IdGenerator">https://github.com/yitter/IdGenerator</a></p><p><a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/MySQL%e5%ae%9e%e6%88%98%e5%ae%9d%e5%85%b8/05%20%20%e8%a1%a8%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%ef%bc%9a%e5%bf%98%e8%ae%b0%e8%8c%83%e5%bc%8f%e5%87%86%e5%88%99.md">参考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-12-Linux%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E6%8C%87%E5%8D%97/"/>
      <url>/2024/10/28/2024-08-12-Linux%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-分区和目录"><a href="#1-分区和目录" class="headerlink" title="1. 分区和目录"></a>1. 分区和目录</h1><p>和 Windows 使用盘符定义分区的方式不同，Linux 系统使用树状目录的方式来定义分区，这也被称为<strong>挂载点</strong>。一些常见的分区目录如下：</p><div class="table-container"><table><thead><tr><th>分区名称</th><th>作用</th></tr></thead><tbody><tr><td><code>/</code></td><td>根分区目录，其他所有分区目录都位于其下。</td></tr><tr><td><code>/boot/</code></td><td>存放系统启动时所需的各种文件。如果采用传统的 BIOS 引导方式，那么需要创建一个 <code>/boot</code> 分区。在使用 UEFI 引导的系统中，<code>/boot</code> 目录通常可以与根分区合并</td></tr><tr><td><code>/root/</code></td><td>系统管理员 <strong>root</strong> 用户的主目录。</td></tr><tr><td><code>/home/</code></td><td>普通用户的主目录。</td></tr><tr><td><code>/etc/</code></td><td>配置文件的目录。平常通过系统包管理命令安装的各种软件，它们的配置文件默认都在此目录下。</td></tr><tr><td><code>/bin/</code></td><td>系统核心命令的存放目录。</td></tr><tr><td><code>/usr/</code></td><td>系统默认软件的安装目录和共享资源目录。通过系统包管理命令安装的软件，大多都位于这里。</td></tr><tr><td><code>/opt/</code></td><td>用户软件的安装目录。</td></tr><tr><td><code>/var/</code></td><td>存放软件运行时生成的一些文件，比如日志，运行中的进程 ID 文件等。</td></tr><tr><td><code>/tmp/</code></td><td>系统临时文件的目录。每次系统关机时，此目录中的所有文件都会清除。</td></tr><tr><td>Swap</td><td>这不是目录，是一个特殊的 Linux 分区，通过文件系统的方式模拟物理内存，以应对物理内存使用时的不足。建议大小是物理内存的1~2倍</td></tr></tbody></table></div><p>对于 Linux 的分区和目录来说，需要理解两个概念：</p><p>1 . 目录是树状层级结构的。<br>2 . 分区可以通过挂载的方式指定为任何层级下的目录</p><p>举个例子来说明一下这两个概念。假设现在系统就一个硬盘，并且快满了。经过了解分析，发现是用户目录 <code>/home/zzxworld/Movies</code> 下存放了太多电影导致的。那我现在可以选择添加一个新的硬盘，格式化后并挂载到 <code>/home/zzxworld/Movies</code> 目录，专门用来存放电影。</p><p>理论上来说，安装 Linux 系统，只需要给硬盘分一个区，然后挂载 <code>/</code> 根分区目录即可正常安装和使用</p><p>在此基础上，再根据自己的需求规划更加细致的分区方案。</p><ul><li>感觉物理内存不够用？那就尝试在方案中添加一个 Swap 交换分区。它通常设置为物理内存大小的 50% 和 100% 左右。</li><li>在意个人数据的安全性？可以单独新建一个分区，并挂载到 <code>/home</code> 目录。如果可以的话，添加一个新的硬盘专门挂载到 <code>/home</code> 也没问题。</li></ul><p>总之，这一切都需要自己来实践并优化。适合自己的分区方案才是好方案。</p><h1 id="2-文件系统"><a href="#2-文件系统" class="headerlink" title="2. 文件系统"></a>2. 文件系统</h1><p>给硬盘分好区，接下来要面对的就是把分区格式化的问题。Linux 有专属的各种分区格式，也就是俗称的文件系统。常用的文件系统如下：</p><ul><li>ext4：目前 Linux 主流的文件系统，如无意外的话，默认都应该选择它。</li><li>swap：Swap 交换分区专属的文件系统，如果有划分 Swap 分区，需要格式化为这种格式。</li></ul><h1 id="3-分区"><a href="#3-分区" class="headerlink" title="3. 分区"></a>3. 分区</h1><p><code>fdisk -l</code> 命令会列出系统中所有的硬盘及其分区情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 100 GiB, 107374182400 bytes, 209715200 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0xabcd1234</span><br><span class="line"></span><br><span class="line">Device     Boot   Start       End   Sectors  Size Id Type</span><br><span class="line">/dev/sda1  *       2048    1026047   1024000  500M 83 Linux</span><br><span class="line">/dev/sda2       1026048  209715166 208689119 99.5G 8e Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 50 GiB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 95 GiB, 102187624192 bytes, 199667216 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 4096 bytes</span><br><span class="line">I/O size (minimum/optimal): 4096 bytes / 4096 bytes</span><br></pre></td></tr></table></figure><p>解读<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.  **硬盘信息**：输出以每个硬盘开始，每个硬盘的信息包括其大小、标识符、扇区大小等。</span><br><span class="line">    </span><br><span class="line">    -   `Disk /dev/sda` 表示第一个硬盘，其大小为 100 GiB。</span><br><span class="line">    -   `Disk /dev/sdb` 表示第二个硬盘，其大小为 50 GiB。</span><br><span class="line">2.  **分区信息**：每个硬盘下面列出了分区信息，包括每个分区的起始扇区、结束扇区、大小、类型等。</span><br><span class="line">    </span><br><span class="line">    -   对于 `/dev/sda`，有两个分区：`/dev/sda1` 和 `/dev/sda2`。</span><br><span class="line">    -   `/dev/sda1` 是引导分区，大小为 500M。</span><br><span class="line">    -   `/dev/sda2` 是 LVM 分区，占据了硬盘大部分空间。</span><br><span class="line">3.  **LVM 逻辑卷信息**：如果有 LVM 逻辑卷，它们会以 `/dev/mapper/` 开头列出。</span><br><span class="line"></span><br><span class="line">    -   `/dev/mapper/centos-root` 是一个逻辑卷，它的大小为 95 GiB。</span><br></pre></td></tr></table></figure></p><h1 id="4-挂载"><a href="#4-挂载" class="headerlink" title="4. 挂载"></a>4. 挂载</h1><p>硬盘完成分区和格式化后，离真正可用还差最后一步：挂载。使用 <code>mount</code> 命令来完成。上面分区环节前规划好的分区和目录的对应方案，也是通过这步落到实处。</p><p>挂载在操作形式上可以分为手动挂载和自动挂载。手动挂载通过输入 <code>mount</code> 命令的方式来实现。自动挂载则是通过修改 <strong>/etc/fstab</strong> 文件配置来达成。完成挂载后的硬盘分区，就真正意义上可以使用了</p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>总的来看，把一块硬盘用作 Linux 分区需要经历四个流程：</p><p>1 . 分区方案的制定<br>2 . 分区操作<br>3 . 格式化操作<br>4 . 挂载</p><h1 id="6-硬盘分区"><a href="#6-硬盘分区" class="headerlink" title="6. 硬盘分区"></a>6. 硬盘分区</h1><p><img src="F:\笔记\博客\文章图片\QQ图片20240509085842.png" alt="QQ图片20240509085842"></p><p><strong>LVM 逻辑卷 和lvm分区的关系</strong></p><p><strong>卷组（Volume Group，VG）</strong>：卷组是由一个或多个物理卷组成的逻辑单元。在卷组上创建逻辑卷，并对其进行管理。</p><p><strong>逻辑卷（Logical Volumes，LVs）</strong>：逻辑卷是从卷组中划分出来的逻辑分区。它们类似于传统的硬盘分区，但是具有更灵活的管理能力。逻辑卷可以动态调整大小，并且支持其他高级功能，如快照和镜像。</p><p><strong>LVM 分区</strong>：LVM 分区是指通过 LVM 技术创建的逻辑卷。与传统的硬盘分区不同，LVM 分区是在逻辑卷上创建的，而不是在物理硬盘上直接分区。</p><p>因此，LVM 逻辑卷和 LVM 分区的关系是：LVM 分区是从 LVM 逻辑卷中划分出来的逻辑分区，它们具有灵活的管理能力，并且可以根据需要调整大小。通过 LVM，你可以更好地管理和利用系统的存储资源。</p><p><strong>先分区，后挂载，给分区分配挂载点，挂载后就可以使用分区了</strong></p><p><strong>需要注意：硬盘最后有剩余的空间都会给根分区 /，需要计算剩余多少空间分给 /，将系统分区和管理员分区剥离开，可便于维护，提升安全性，方便备份等</strong></p><p><strong>挂载点（Mount Point）：</strong> 挂载点通常是一个目录（如<code>/mnt</code>、<code>/media</code>等），文件系统中的文件和目录会被挂载到这些目录下以供访问。在CentOS 7中，可以使用 <code>mount</code> 命令来挂载文件系统。如 Linux系统中，根文件系统通常挂载在<code>/</code>目录下，而在Windows系统中，根文件系统则是挂载在特定的驱动器上（如<code>C:\</code>）。<strong>挂载点，必须是目录且是 空目录</strong></p><p><strong>管理磁盘存储空间：</strong> 标准分区、btrfs、lvm</p><p>标准分区是将硬盘划分为独立的部分，并在每个部分上安装一个文件系统的传统方法。每个分区的大小是固定的，无法动态调整。通常用于单个操作系统的安装，或者在多引导系统中分配给不同的操作系统。</p><p>Btrfs（B-tree文件系统）是一种先进的文件系统，它采用B树数据结构来管理数据，提供了许多高级特性，如快照、压缩、RAID等。它支持动态分配存储空间，可以在运行时动态调整文件系统的大小。Btrfs还支持快照功能，可以快速创建文件系统的副本，并在需要时恢复数据。</p><p>LVM（Logical Volume Manager）是一种逻辑卷管理系统，允许管理员动态地创建、调整和删除逻辑卷。它可以在多个物理磁盘上创建逻辑卷，并允许对逻辑卷进行扩展和缩小而无需重新分区。LVM还支持数据快照和数据迁移等高级功能</p><p><strong>分区</strong>：分区是将物理磁盘的空间划分成逻辑上独立的部分。每个分区被视为一个独立的存储空间单元，它们具有自己的文件系统和数据。分区的目的是允许操作系统将磁盘空间进行有效管理和利用，以便在其上存储数据和执行操作</p><p><strong>主分区、扩展分区、逻辑分区</strong></p><p>主分区是一种分区类型。主分区中不能再划分其他类型的分区，因此每个主分区都相当于一个逻辑磁盘</p><p>一个硬盘最多只能有4个主分区。这是因为主分区的分区表（MBR，Master Boot Record）只能记录4个分区的信息，其中最多只能有一个扩展分区，剩下的三个都可以是主分区。如果需要更多的分区，可以使用扩展分区来扩展</p><p>主分区才能存数据，扩展分区不能直接存数据，需要将扩展分区再细分为逻辑分区才可以。所有的逻辑分区都是扩展分区的一部分</p><p>硬盘的容量=主分区的容量+扩展分区的容量</p><p>扩展分区的容量=各个逻辑分区的容量之和</p><p><strong>格式化（逻辑格式化）：</strong> 目的是在硬盘中写入文件系统（在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间），写入文件系统就将分区变成一个一个小的数据块Block，大小是1-4KB。同时建立一个inode列表</p><p><strong>Linux中硬盘以及分区等设备均表示为文件，其命名规则如下</strong></p><p>IDE磁盘的文件名为：<code>/dev/hdxx</code></p><p>SCSI/SATA/USB磁盘文件名为：<code>/dev/sdxx</code></p><p>鼠标：<code>/dev/mouse</code></p><p>USB：<code>/dev/usb/lpxx</code></p><p><code>/dev/mapper/</code> 目录通常是 LVM（Logical Volume Manager，逻辑卷管理器）创建的设备映射的路径，如果你有一个名为 <code>vg01</code> 的卷组，并在其中创建了一个名为 <code>lv01</code> 的逻辑卷，那么你可能会在 <code>/dev/mapper/</code> 目录下看到 <code>/dev/mapper/vg01-lv01</code> 这样的设备文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-04-SpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>/2024/10/28/2024-08-04-SpringBoot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h1><p>软件测试分为多种类型，但开发人员一般只涉及单元测试和集成测试</p><p>单元测试用于验证相关的一小段代码是否正常工作。传统的单元测试，即是测试一个函数是否正确运行。单元测试可以<strong>为这个函数预先伪造一个测试环境</strong>，例如用户登录了，且已经有超管权限了，那么运行这个函数是否能够得到我们期望得到的结果</p><p>单元测试就是一部分代码，但是它</p><ul><li>不会在正常的业务流程中被执行</li><li>不被打包进入最终的编译程序</li><li>不会被任何其他业务代码以任何方式导入</li><li>不会影响正常的代码</li></ul><p>当然，它通常还要满足下面这些条件</p><ul><li>自动化的，不需要人工输入任何数据即可完成</li><li>独立的，任何两个单元测试之间都不应该发生调用关系</li><li>可重复的，单元测试可以无限重复执行且结果应该一致</li></ul><h1 id="2-spring-boot-starter-test"><a href="#2-spring-boot-starter-test" class="headerlink" title="2. spring-boot-starter-test"></a>2. spring-boot-starter-test</h1><p>SpringBoot中有关测试的框架，主要来源于 spring-boot-starter-test。一旦依赖了spring-boot-starter-test，下面这些类库将被一同依赖进去：</p><ul><li><strong>JUnit</strong>：java测试事实上的标准。</li><li><strong>Spring Test &amp; Spring Boot Test</strong>：Spring的测试支持。</li><li><strong>AssertJ</strong>：提供了流式的断言方式。</li><li><strong>Hamcrest</strong>：提供了丰富的matcher。</li><li><strong>Mockito</strong>：mock框架，可以按类型创建mock对象，可以根据方法参数指定特定的响应，也支持对于mock调用过程的断言。</li><li><strong>JSONassert</strong>：为JSON提供了断言功能。</li><li><strong>JsonPath</strong>：为JSON提供了XPATH功能。</li></ul><h1 id="3-插件-Squaretest"><a href="#3-插件-Squaretest" class="headerlink" title="3. 插件 Squaretest"></a>3. 插件 Squaretest</h1><p>强烈推荐这个自动生成单元测试代码的插件</p><p>在选中类右键<code>Generate -&gt; Generate Test</code> 后，不光能生成测试类和方法，甚至连Mockito 数据、方法和 Assertions 等都写好了，只需要自己改一改即可。</p><p>要测试哪个类，<strong>点进当前类，<code>右键-&gt;Go To-&gt;Test-&gt;Create New Test</code>，在 Testing library 中选择 Junit5，则在对应目录生成测试类和方法。</strong></p><h1 id="4-实践"><a href="#4-实践" class="headerlink" title="4. 实践"></a>4. 实践</h1><p>单元测试不需要启动项目，也不会连接数据库、RPC注 册中心等，但是相应的所有数据都需要打桩 Mock</p><p>Squaretest生成的单元测试方法都是只能生成public的</p><p>生成的代码说明，以查询方法SelectGiftLis为例：如果是测试service接口，一般使用serviceImpl来写测试用例，serviceImpl中一般会引入mapper接口。</p><p>测试代码中一般都是先生成一个对象，传入mapper接口方法的参数中，并且会创建一个mapper接口的返回对象。然后在使用serviceImpl来测试查</p><p>询方法，mock一个同样的查询参数，serviceImpl查询时就会有返回值。最后比对mapper接口返回的结果和serviceImpl查询返回的结果是否一致。</p><p>一致则通过测试，不一致则测试不通过。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-29-%E7%BD%91%E9%A1%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%8E%86%E7%A8%8B/"/>
      <url>/2024/10/28/2024-07-29-%E7%BD%91%E9%A1%B5%E8%AE%BF%E9%97%AE%E7%9A%84%E5%8E%86%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-目的"><a href="#1-目的" class="headerlink" title="1. 目的"></a>1. 目的</h1><p>把「<strong>键入网址，到网页显示，期间发生了什么？</strong>」这个问题所涉及到的协议、网络设备都要掌握，比如 HTTP、DNS、TCP、UDP、IP、ARP、MAC 等等</p><h1 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h1><p>当一台位于局域网（LAN）中的计算机想要访问互联网上的资源时，会涉及到不同的网络协议和网络设备</p><p>此处尚缺一个网络拓扑图</p><p><a href="https://zhuanlanjia.com/post/225">https://zhuanlanjia.com/post/225</a></p><h1 id="3-DNS解析"><a href="#3-DNS解析" class="headerlink" title="3. DNS解析"></a>3. DNS解析</h1><p>在真实网络传输过程中，其实压根就不会用到域名这个东西。点对点传输是基于IP地址进行交互的。所以，网络传输的第一步就是做域名解析，通过域名将IP地址换回来，然后再进行后续操作。</p><p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html">https://www.cnblogs.com/qingdaofu/p/7399670.html</a></p><h2 id="3-1-域名系统"><a href="#3-1-域名系统" class="headerlink" title="3.1. 域名系统"></a>3.1. 域名系统</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904437.png" alt="QQ截图20240729095147"></p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130916078.png" alt="img"></p><h2 id="3-2-域名解析过程"><a href="#3-2-域名解析过程" class="headerlink" title="3.2. 域名解析过程"></a>3.2. 域名解析过程</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904010.png" alt="DNS解析"></p><p>获得IP地址后，用户主机中的浏览器可以通过Web服务器的IP地址对其进行访问了</p><p><strong>递归查询和迭代查询</strong></p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130927302.png" alt="img"></p><p><strong>DNS请求为什么用UDP？能不能使用TCP</strong></p><p>使用UDP 优势是不需要经过 TCP 三次握手的过程，从而大大提高了响应速度。但也有缺点，容易被地方运营商劫持， 给你推送垃圾广告。为了避免被劫持，很多大厂都用了HttpDNS</p><h1 id="4-数据包转发"><a href="#4-数据包转发" class="headerlink" title="4. 数据包转发"></a>4. 数据包转发</h1><p><strong>相关工具nexttrace或者Tracert命令，可以帮助理解数据包的转发过程</strong></p><p>怎么理解数据包转发呢？这里简单举个例子，比如说你给远方的朋友写信，信写好后，先放到信封里。然后找到邮局，把信封投递出去。邮局收到你的信封后，根据信封上的地址，帮你送到朋友那里。朋友收到你的信封以后，拆开信封，看到了你写的祝福，然后进行回信，回信的过程跟你寄信过程一样。这样一来一回，就是一个完整的请求-响应。整个过程中：</p><p>信的内容就是原始的消息体</p><p>信封就好比是消息体的组装，组装的结果就是数据报文</p><p>邮局就是网关，他接收我们的信件，并统一进行分发</p><p>信封上写的地址就是DNS请求出来的IP地址</p><p>邮局送信过程就是IP数据包寻路过程，也就是所说的路由</p><p>在讲数据包转发之前我们先聊聊IP地址，因为数据包转发是基于IP地址的，IP地址分为<code>私有地址</code>和<code>公有地址</code>两种。 私有地址主要用于在局域网中进行分配，在 Internet上是无效的。这样可以很好地隔离局域网和 Internet，也能节省IP资源，而<code>公有地址</code>是全球唯一的</p><p><strong>私有地址</strong></p><p>A类、B类、C类</p><p><strong>IP以及子网掩码</strong></p><p>子网掩码该如何理解呢？简单来说就是为了隔离广播域，掩码越长广播域越小</p><p>假如说某个学校一年级总人数是100人，如果不分班，老师讲话，所有的学生都能听到，如果分了10个班，每个班只有10人，那老师讲话只有10个人可以听到。通过分班(子网掩码)，可以很好隔离广播域。另外要注意的一点是，广播域越大，交换机设备的压力也会越大，因为同一个数据包需要复制多份发出去，所以有了子网掩码就能很好的规避这个问题</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904561.png" alt="image.png"></p><p>当一台机器有了IP以及子网掩码以后，是不是就能直接发送数据报文了呢？No,No,No这里还有一个关键点没讲，那就是MAC地址，数据包在从网卡发送出去之前一定要知道下一跳的MAC地址，这里的下一跳包含2种场景：</p><p>1 . 下一跳是网关</p><p>2 . 下一跳是相同子网下的IP</p><p>如果你访问的是一个公网地址，那么数据包的下一跳会丢给网关，让网关接着转发。 如果说下一跳是同子网下的IP，那么它不需要经过网关，这时它会通过ARP广播查找同子网下的MAC，拿到目标IP+MAC后，数据包就可以正常转发了</p><p>对于第一个场景，当网关拿到去公网的数据包该如何处理呢？它的处理方式，查找本地路由表，找到下一跳出口，然后将数据包转发出去</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904507.png" alt="image.png"></p><h1 id="5-数据包封装之网络协议"><a href="#5-数据包封装之网络协议" class="headerlink" title="5. 数据包封装之网络协议"></a>5. 数据包封装之网络协议</h1><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904912.png" alt="image.png"></p><p>右边是客户端，可以理解成我们浏览器，左边是服务器。中间涉及到TCP、IP、ARP网络协议。协议栈分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904384.png" alt="image.png"></p><p>应用程序（浏览器）HTTP请求通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们俩会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 ICMP 协议和 ARP 协议。</p><ul><li>ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li>ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904614.png" alt="image.png"></p><p>如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p><ul><li>MTU ：一个网络包的最大长度，以太网中一般为 1500 字节。</li><li>MSS ：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。</li></ul><p>数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904441.png" alt="image.png"></p><p>简单看看TCP报文格式</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904368.png" alt="image.png"></p><p>源端口号和目标端口号是必不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。接下来是包的序号，这个是为了解决包乱序的问题。在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为三次握手</p><p>下面简单讲讲IP协议：TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。我们先看看 IP 报文头部的格式</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904668.png" alt="image.png"></p><p>在 IP 协议里面最重要的是源地址 IP 和目标地址 IP ：</p><ul><li>源地址 IP ，即是客户端输出的 IP 地址；</li><li>目标地址 IP ，即通过 DNS 域名解析得到的 Web 服务器 IP </li></ul><p>日常所说的<code>五元组</code>数据就是：源IP、源端口、目的IP、目的端口、协议  所组成</p><h1 id="6-流量接入层"><a href="#6-流量接入层" class="headerlink" title="6. 流量接入层"></a>6. 流量接入层</h1><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904393.png" alt="image.png"></p><p>客户端请求流量送到VIP以后，首先要经过的是4层负载均衡，4层负载均衡它的特点是性能好，但缺点是它只处理TCP、UDP、ICMP4层相关的协议，如果要处理HTTP 7层协议，那就需要用到Nginx7层代理，最终将数据包转发到服务器上。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130904332.png" alt="image.png"></p><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK ，如果不是就丢弃。TCP 头部里面还有端口号，HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP 、IP 、MAC 头部，不过这次源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-22-Google%20Chrome/"/>
      <url>/2024/10/28/2024-08-22-Google%20Chrome/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Tab-and-window"><a href="#1-Tab-and-window" class="headerlink" title="1. Tab and window"></a>1. Tab and window</h1><div class="table-container"><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td><code>Ctrl</code> <code>N</code></td><td>Open a new window</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>N</code></td><td>Open a new window in Incognito mode</td></tr><tr><td><code>Ctrl</code> <code>T</code></td><td>Open a new tab, and jump to it</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>T</code></td><td>Reopen the last closed tab, and jump to it</td></tr><tr><td><code>Ctrl</code> <code>Tab</code></td><td>Jump to the next open tab</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>Tab</code></td><td>Jump to the previous open tab</td></tr><tr><td><code>Ctrl</code> <code>1-8</code></td><td>Jump to a specific tab</td></tr><tr><td><code>Ctrl</code> <code>9</code></td><td>Jump to the last tab</td></tr><tr><td><code>Alt</code> <code>Home</code></td><td>Open your home page in the current tab</td></tr><tr><td><code>Alt</code> <code>Left</code></td><td>Open the previous page from your history in the current tab</td></tr><tr><td><code>Alt</code> <code>Right</code></td><td>Open the next page from your history in the current tab</td></tr><tr><td><code>Ctrl</code> <code>W</code></td><td>Close the current tab</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>W</code></td><td>Close the current window</td></tr><tr><td><code>Alt</code> <code>Space</code> <code>N</code></td><td>Minimize the current window</td></tr><tr><td><code>Alt</code> <code>Space</code> <code>X</code></td><td>Maximize the current window</td></tr><tr><td><code>Alt</code> <code>F4</code></td><td>Close the current window</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>Q</code></td><td>Quite Google Chrome</td></tr></tbody></table></div><h1 id="2-Google-Chrome-features"><a href="#2-Google-Chrome-features" class="headerlink" title="2. Google Chrome features"></a>2. Google Chrome features</h1><div class="table-container"><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td><code>Alt</code> <code>F</code></td><td>Open the Chrome menu</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>B</code></td><td>Show or hide the Bookmarks bar</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>O</code></td><td>Open the Bookmarks manager</td></tr><tr><td><code>Ctrl</code> <code>H</code></td><td>Open the History page in a new tab</td></tr><tr><td><code>Ctrl</code> <code>J</code></td><td>Open the Downloads page in a new tab</td></tr><tr><td><code>Shift</code> <code>Esc</code></td><td>Open the Chrome Task Manager</td></tr><tr><td><code>Shift</code> <code>Alt</code> <code>T</code></td><td>Set focus on the first item in the Chrome toolbar</td></tr><tr><td><code>F10</code></td><td>Set focus on the last item in the Chrome toolbar</td></tr><tr><td><code>F6</code></td><td>Switch focus to unfocused dialog (if showing)</td></tr><tr><td><code>Ctrl</code> <code>F</code></td><td>Open the Find Bar to search the current page</td></tr><tr><td><code>Ctrl</code> <code>G</code></td><td>Jump to the next match to your Find Bar search</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>G</code></td><td>Jump to the previous match to your Find Bar search</td></tr><tr><td><code>F12</code></td><td>Open Developer Tools</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>Delete</code></td><td>Open the Clear Browsing Data options</td></tr><tr><td><code>F1</code></td><td>Open the Chrome Help Center in a new tab</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>M</code></td><td>Log in a different user or browse as a Guest</td></tr><tr><td><code>Alt</code> <code>Shift</code> <code>I</code></td><td>Open a feedback form</td></tr></tbody></table></div><h1 id="3-Address-bar"><a href="#3-Address-bar" class="headerlink" title="3. Address bar"></a>3. Address bar</h1><div class="table-container"><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td><code>(type)</code> <code>Enter</code></td><td>Search with your default search engine</td></tr><tr><td><code>(type)</code> <code>Tab</code></td><td>Search using a different search engine</td></tr><tr><td><code>Ctrl</code> <code>Enter</code></td><td>Add www. and .com to a site name, and open in the current tab</td></tr><tr><td><code>Alt</code> <code>Enter</code></td><td>Open a new tab and perform a Google search</td></tr><tr><td><code>Ctrl</code> <code>L</code></td><td>Jump to the address bar</td></tr><tr><td><code>Ctrl</code> <code>K</code></td><td>Search from anywhere on the page</td></tr><tr><td><code>Shift</code> <code>Delete</code></td><td>Remove predictions from your address bar</td></tr></tbody></table></div><h1 id="4-Webpage-shortcuts"><a href="#4-Webpage-shortcuts" class="headerlink" title="4. Webpage shortcuts"></a>4. Webpage shortcuts</h1><div class="table-container"><table><thead><tr><th>Shortcut</th><th>Action</th></tr></thead><tbody><tr><td><code>Ctrl</code> <code>P</code></td><td>Open options to print the current page</td></tr><tr><td><code>Ctrl</code> <code>S</code></td><td>Open options to save the current page</td></tr><tr><td><code>Ctrl</code> <code>R</code></td><td>Reload the current page</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>R</code></td><td>Reload the current page, ignoring cached content</td></tr><tr><td><code>Esc</code></td><td>Stop the page loading</td></tr><tr><td><code>Tab</code></td><td>Browse clickable items moving forward</td></tr><tr><td><code>Shift</code> <code>Tab</code></td><td>Browse clickable items moving backward</td></tr><tr><td><code>Ctrl</code> <code>O</code></td><td>Open a file from your computer in Chrome</td></tr><tr><td><code>Ctrl</code> <code>U</code></td><td>Display non-editable HTML source code for the current page</td></tr><tr><td><code>Ctrl</code> <code>D</code></td><td>Save your current webpage as a bookmark</td></tr><tr><td><code>Ctrl</code> <code>Shift</code> <code>D</code></td><td>Save all open tabs as bookmarks in a new folder</td></tr><tr><td><code>F11</code></td><td>Turn full-screen mode on or off</td></tr><tr><td><code>Ctrl</code> <code>+</code></td><td>Make everything on the page bigger</td></tr><tr><td><code>Ctrl</code> <code>-</code></td><td>Make everything on the page smaller</td></tr><tr><td><code>Ctrl</code> <code>0</code></td><td>Return everything on the page to default size</td></tr><tr><td><code>Space</code></td><td>Scroll down a webpage, a screen at a time</td></tr><tr><td><code>Shift</code> <code>Space</code></td><td>Scroll up a webpage, a screen at a time</td></tr><tr><td><code>Home</code></td><td>Go to the top of the page</td></tr><tr><td><code>End</code></td><td>Go to the bottom of the page</td></tr><tr><td><code>Shift</code> <code>(scroll mouse)</code></td><td>Scroll horizontally on the page</td></tr><tr><td><code>Ctrl</code> <code>Left</code></td><td>Move your cursor to the front of the previous word in a text field</td></tr><tr><td><code>Ctrl</code> <code>Right</code></td><td>Move your cursor to the back of the next word in a text field</td></tr><tr><td><code>Ctrl</code> <code>Backspace</code></td><td>Delete the previous word in a text field</td></tr><tr><td><code>Alt</code> <code>Home</code></td><td>Open the Home page in the current tab</td></tr></tbody></table></div><h1 id="5-允许在控制台粘贴内容"><a href="#5-允许在控制台粘贴内容" class="headerlink" title="5. 允许在控制台粘贴内容"></a>5. 允许在控制台粘贴内容</h1><p>默认是不允许在控制台进行粘贴内容的</p><p>Warning: Don’t paste code into the DevTools Console that you don’t understand or haven’t reviewed yourself. This could allow attackers to steal your identity or take control of your computer. Please <a href="https://so.csdn.net/so/search?q=type&amp;spm=1001.2101.3001.7020">type</a> ‘allow pasting’ below to allow pasting.</p><p>在控制台输入：allow pasting 回车即可</p><h1 id="6-修改User-Agent的方法"><a href="#6-修改User-Agent的方法" class="headerlink" title="6. 修改User-Agent的方法"></a>6. 修改User-Agent的方法</h1><p>添加启动参数 <code>--user-agent=&quot;自定义的User-Agent值&quot;</code>，可在命令行或快捷方式的“目标”框中使用</p><h1 id="7-请求的重放"><a href="#7-请求的重放" class="headerlink" title="7. 请求的重放"></a>7. 请求的重放</h1><p>通过鼠标在请求的列表中找到我们需要复制的请求，右键——Copy——Copy as fetch</p><p>到这里我们的请求已经被复制下来了，那怎么实现重新请求呢？很简单，还是刚才的页面，我们切换到Console页面，直接粘贴回车即可，需要多次请求则粘贴多次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-15-Python%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-08-15-Python%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-python环境"><a href="#1-python环境" class="headerlink" title="1. python环境"></a>1. python环境</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">6enbg3r6rt0herjfqsulcq8ar1[&quot;python环境&quot;] --&gt; 1l8ec5hmd4nl34b6km9tblk5u9[&quot;Lib&quot;]</span><br><span class="line">1l8ec5hmd4nl34b6km9tblk5u9 --&gt; 76qn6d2uiffuuj0n5fou5nl92p[&quot;site-packages&quot;]</span><br><span class="line">76qn6d2uiffuuj0n5fou5nl92p --&gt; 7sq6bva7ms8jfremq5uf1a8ja8[&quot;该目录下是python第三方包（也就是pip install 安装的包都在该目录下）&quot;]</span><br><span class="line">1l8ec5hmd4nl34b6km9tblk5u9 --&gt; 490ei18hcfqvii60dc38csu20n[&quot;python标准库&quot;]</span><br><span class="line">490ei18hcfqvii60dc38csu20n --&gt; 06cfvcesaootvsaq3mp37bg34f[&quot;原生库（os,sys, math 等等）&quot;]</span><br><span class="line">6enbg3r6rt0herjfqsulcq8ar1 --&gt; 2k6uog1geih6e97su5ujs8m0tj[&quot;Scripts&quot;]</span><br><span class="line">2k6uog1geih6e97su5ujs8m0tj --&gt; 1s9qmm47svn1aj64jtng2ghvk0[&quot;pip.exe&quot;]</span><br><span class="line">1s9qmm47svn1aj64jtng2ghvk0 --&gt; 45kp596s35r16j7qhncfod4c4d[&quot;pip install 时就会使用pip.exe这个可执行文件&quot;]</span><br><span class="line">6enbg3r6rt0herjfqsulcq8ar1 --&gt; 5ildhlff6bid0rbfvnrt649bio[&quot;python.exe&quot;]</span><br><span class="line">5ildhlff6bid0rbfvnrt649bio --&gt; 0econebqf24563hvnk0t61ma06[&quot;python解释器&quot;]</span><br></pre></td></tr></table></figure><h1 id="2-python虚拟环境"><a href="#2-python虚拟环境" class="headerlink" title="2. python虚拟环境"></a>2. python虚拟环境</h1><p>虚拟环境可以看作是原生Python的副本，但是标准库都是一样的。所以每次就不复制标准库，而是直接调用原来的标准库就行。同时解释器也存到Scripts这个目录下，path环境变量只需要增加一个即可</p><h2 id="2-1-venv创建虚拟环境"><a href="#2-1-venv创建虚拟环境" class="headerlink" title="2.1. venv创建虚拟环境"></a>2.1. venv创建虚拟环境</h2><p><strong>python3.3</strong> 之后<strong>venv</strong>已经作为标准库嵌入到了python中，而之前的版本需要借助<strong>virtualenv</strong>这个第三方库来实现。</p><p>在终端中使用<code>python -m venv -h</code>可以显示<code>venv</code>工具的用法。</p><p><code>--system-site-packages</code>代表使用全局环境中的第三方库（否则虚拟环境是纯净的）</p><p><code>--without-pip</code>代表不安装pip（一般都是要装的，所以默认就行）</p><p><strong>创建虚拟环境</strong></p><p><code>python -m venv 安装路径</code>创建虚拟环境的指令</p><h2 id="2-2-激活虚拟环境"><a href="#2-2-激活虚拟环境" class="headerlink" title="2.2. 激活虚拟环境"></a>2.2. 激活虚拟环境</h2><p>直接激活虚拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source activate 虚拟环境名字</span><br></pre></td></tr></table></figure><p>或者在Scripts目录下调用activate文件激活虚拟环境</p><h2 id="2-3-关闭虚拟环境"><a href="#2-3-关闭虚拟环境" class="headerlink" title="2.3. 关闭虚拟环境"></a>2.3. 关闭虚拟环境</h2><p>在Scripts目录下调用deactivate文件关闭虚拟环境</p><h2 id="2-4-虚拟环境做了什么"><a href="#2-4-虚拟环境做了什么" class="headerlink" title="2.4. 虚拟环境做了什么"></a>2.4. 虚拟环境做了什么</h2><p>其实激活虚拟环境就是在环境变量PATH中插入激活的虚拟环境的路径</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-24-Python%E7%88%AC%E8%99%AB/"/>
      <url>/2024/10/28/2024-08-24-Python%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-工具"><a href="#1-工具" class="headerlink" title="1. 工具"></a>1. 工具</h1><p><strong>DrissionPage</strong></p><p><a href="https://www.drissionpage.cn/">DrissionPage官网</a>，比selenium功能更丰富，相同功能使用更简单</p><h1 id="2-运行环境"><a href="#2-运行环境" class="headerlink" title="2. 运行环境"></a>2. 运行环境</h1><h2 id="2-1-纯命令行"><a href="#2-1-纯命令行" class="headerlink" title="2.1. 纯命令行"></a>2.1. 纯命令行</h2><p>在Linux服务器上运行时，是纯命令行的，没有GUI界面，如果想使用该功能，需要打开<code>headless</code>模式</p><h2 id="2-2-GUI图形化"><a href="#2-2-GUI图形化" class="headerlink" title="2.2. GUI图形化"></a>2.2. GUI图形化</h2><p>正常使用即可</p><h1 id="3-抓包"><a href="#3-抓包" class="headerlink" title="3. 抓包"></a>3. 抓包</h1><p><strong>DrissionPage</strong> 支持监听数据包</p><h1 id="4-使用建议"><a href="#4-使用建议" class="headerlink" title="4. 使用建议"></a>4. 使用建议</h1><p>模拟登录，拿到登录凭证后，尝试分析网站的api，直接调用api去获取数据</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/10/28/2024-08-22-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文主要罗列GOF的面向对象的23种设计模式</p><h1 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h1><p>设计模式按照其要解决的问题被分为3类：</p><p><strong>创建型（creational）</strong></p><p>主要解决如何灵活创建对象或者类的问题，共<strong>5</strong>个</p><p><strong>结构型（structural）</strong></p><p>主要用于将类或对象进行组合从而构建灵活而高效的结构，共<strong>7</strong>个</p><p><strong>行为型（behavioral）</strong></p><p>行为型设计模式主要解决类或者对象之间互相通信的问题，共<strong>11</strong>个</p><h1 id="2-创建型（creational）"><a href="#2-创建型（creational）" class="headerlink" title="2. 创建型（creational）"></a>2. 创建型（creational）</h1><h2 id="2-1-工厂方法模式（Factory-Method）"><a href="#2-1-工厂方法模式（Factory-Method）" class="headerlink" title="2.1. 工厂方法模式（Factory Method）"></a>2.1. 工厂方法模式（Factory Method）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart TD</span><br><span class="line">1af1vu7qdupshrmud6q9pok8f3[&quot;工厂方法模式&quot;] --&gt; 5n150lh93j91nqs6p3nbcg8seg[&quot;第一步：定义一个某类产品（如：电脑）的抽象基类和抽象方法（该方法就是该类产品要实现的共同接口）&quot;]</span><br><span class="line">5n150lh93j91nqs6p3nbcg8seg --&gt; 556jv97jd1e348ri4ni1cso88s[&quot;第二步：实现该类产品下的某个具体类（如：苹果电脑、惠普电脑）&quot;]</span><br><span class="line">1af1vu7qdupshrmud6q9pok8f3 --&gt; 1pd50kb8gv54q520cldphl1k1g[&quot;第三步：定义一个抽象工厂接口，里面定义了生产方法，通过这个方法就可以生产出某类产品（如：电脑）。但是生产不同品牌电脑的具体方式是不同的，所以这个接口方法由具体产品工厂（苹果工厂、惠普工厂）去实现&quot;]</span><br><span class="line">1pd50kb8gv54q520cldphl1k1g --&gt; 6tp40eqni2f70scrhmv7idgapv[&quot;第四步：实现生成苹果电脑的MacComputerFactory 工厂和生产惠普电脑的HpComputerFactory 工厂&quot;]</span><br><span class="line">1af1vu7qdupshrmud6q9pok8f3 --&gt; 0tvaae085v18ikiqi7gostsdie[&quot;第五步：使用具体的工厂来生产相应品牌的电脑，例如要生产苹果电脑，就先构建Mac的生产工厂，然后去生产mac电脑&quot;]</span><br></pre></td></tr></table></figure><p>工厂方法模式讨论的是如何构建<strong>同一类</strong>型产品（都实现同一个接口）的问题，只不过是通过为每一种要生产的产品配备一个工厂，就是说每个工厂只生产一种特定的产品。这样做的好处就是当以后需要增加新的产品时，直接新增加一个对应的工厂就可以了，而不是去修改原有的工厂，符合编程原则的<strong>开闭原则</strong></p><h3 id="2-1-1-解决的问题"><a href="#2-1-1-解决的问题" class="headerlink" title="2.1.1. 解决的问题"></a>2.1.1. 解决的问题</h3><p>首先当然是在你需要<strong>new</strong>一个类的对象的时候，此时各种状况出现啦：</p><ol><li>你不想直接<strong>new</strong>这个类的对象，怕以后这个类改变的时候你需要回来改代码，而此时依赖这个类的地方已经到处都是了。</li><li>这个类的对象构建过程非常复杂，你不愿意将这么复杂的构建过程一遍又一遍的写在需要用到此对象的地方。</li><li>这个类的对象在构建过程中依赖了很多其他的类，而你无法在调用的地方提供。</li></ol><p>工厂方法模式是简单工厂方法模式的升级版本，为了克服简单工厂方法模式的缺点而生，作用和简单工厂方法完全一样</p><h3 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2. 优缺点"></a>2.1.2. 优缺点</h3><p><strong>优点</strong></p><p>不直接在客户端创建具体产品的实例，降低了耦合性。</p><p><strong>缺点</strong></p><p>每增加一种产品就要相应的增加一个工厂类，类增多了。</p><h3 id="2-1-3-总结"><a href="#2-1-3-总结" class="headerlink" title="2.1.3. 总结"></a>2.1.3. 总结</h3><ul><li>构建的都是同一类型的对象，即实现相同的接口</li><li>每一类对象对应一个工厂</li></ul><h2 id="2-2-抽象工厂模式（Abstract-Factory-Pattern）"><a href="#2-2-抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="2.2. *抽象工厂模式（Abstract Factory Pattern）"></a>2.2. <code>*</code>抽象工厂模式（Abstract Factory Pattern）</h2><p>抽象工厂模式其关键在于<strong>品牌家族</strong>的概念，这里的一个工厂要生产某一个品牌家族里面的系列产品。</p><h3 id="2-2-1-解决的问题"><a href="#2-2-1-解决的问题" class="headerlink" title="2.2.1. 解决的问题"></a>2.2.1. 解决的问题</h3><p>如果你的业务中出现了要依据不同的<strong>产品家族</strong>来生产其旗下的一系列产品的时候，抽象工厂模式就配上用场了。</p><p>例如小米公司和苹果公司就是两个不同产品家族，而他们两家都生产笔记本电脑和手机，那么小米的笔记本电脑和苹果的笔记本电脑肯定不一样，手机情况也是如此。这就构成了两个产品家族的系列产品之间比较的关系。</p><p>再比如麦当劳和肯德基是两个不同的产品家族，他们都生产汉堡和果汁</p><h2 id="2-3-构造者模式（Builder-pattern）"><a href="#2-3-构造者模式（Builder-pattern）" class="headerlink" title="2.3. 构造者模式（Builder pattern）"></a>2.3. 构造者模式（Builder pattern）</h2><h3 id="2-3-1-解决的问题"><a href="#2-3-1-解决的问题" class="headerlink" title="2.3.1. 解决的问题"></a>2.3.1. 解决的问题</h3><p><strong>当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java开发中，Lombok的<code>@Builder</code>注解可以轻松实现构造者模式创建对象</p><h3 id="2-3-2-如何实现"><a href="#2-3-2-如何实现" class="headerlink" title="2.3.2. 如何实现"></a>2.3.2. 如何实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String ram;<span class="comment">//必须</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Computer</span><span class="params">(Builder builder)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.cpu=builder.cpu;</span><br><span class="line">        <span class="built_in">this</span>.ram=builder.ram;</span><br><span class="line">        <span class="built_in">this</span>.usbCount=builder.usbCount;</span><br><span class="line">        <span class="built_in">this</span>.keyboard=builder.keyboard;</span><br><span class="line">        <span class="built_in">this</span>.display=builder.display;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略getter</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Builder</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> String ram;<span class="comment">//必须</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> usbCount;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String keyboard;<span class="comment">//可选</span></span><br><span class="line">        <span class="keyword">private</span> String display;<span class="comment">//可选</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">(String cup,String ram)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.cpu=cup;</span><br><span class="line">            <span class="built_in">this</span>.ram=ram;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setUsbCount</span><span class="params">(<span class="type">int</span> usbCount)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.usbCount = usbCount;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setKeyboard</span><span class="params">(String keyboard)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.keyboard = keyboard;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">setDisplay</span><span class="params">(String display)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.display = display;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">public</span> Computer <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Computer</span>(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-如何使用"><a href="#2-3-3-如何使用" class="headerlink" title="2.3.3. 如何使用"></a>2.3.3. 如何使用</h3><p>使用链式调用，一步一步的把对象构建出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Computer computer=<span class="keyword">new</span> <span class="title class_">Computer</span>.Builder(<span class="string">&quot;因特尔&quot;</span>,<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">        .setDisplay(<span class="string">&quot;三星24寸&quot;</span>)</span><br><span class="line">        .setKeyboard(<span class="string">&quot;罗技&quot;</span>)</span><br><span class="line">        .setUsbCount(<span class="number">2</span>)</span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><h2 id="2-4-单例模式（Singleton-Pattern）"><a href="#2-4-单例模式（Singleton-Pattern）" class="headerlink" title="2.4. 单例模式（Singleton Pattern）"></a>2.4. 单例模式（Singleton Pattern）</h2><h3 id="2-4-1-解决的问题"><a href="#2-4-1-解决的问题" class="headerlink" title="2.4.1. 解决的问题"></a>2.4.1. 解决的问题</h3><p>当你希望整个系统运行期间某个类只有一个实例时候就使用单例模式</p><h3 id="2-4-2-单例模式两个核心"><a href="#2-4-2-单例模式两个核心" class="headerlink" title="2.4.2. 单例模式两个核心"></a>2.4.2. 单例模式两个核心</h3><p><strong>如何保证单例</strong></p><p>多线程环境下如何保证系统中只有一个实例？类实现序列化时如何保证？如何保证不能通过反射创建新的实例？</p><p><strong>如何创建单例</strong></p><p>这块又分为<strong>懒汉模式</strong>与<strong>饿汉模式</strong>。</p><p>其实也很好理解，懒汉的意思就是这个类很懒，只要别人不找它要实例，它都懒得创建。饿汉模式正好相反，这个类很着急，非常饥渴的要得到自己的实例，所以一有机会他就创建了自己的实例，不管别人要不要</p><h3 id="2-4-3-单例模式的5种写法"><a href="#2-4-3-单例模式的5种写法" class="headerlink" title="2.4.3. 单例模式的5种写法"></a>2.4.3. 单例模式的5种写法</h3><p><strong>静态常量</strong></p><p><strong>单null检查</strong></p><p><strong>双重null检查</strong></p><p><strong>静态内部类</strong></p><p>这种方式其实很棒，既是线程安全的，也是懒汉式的，那个实例只有在你首次访问时候才会生成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton5</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton5</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton5</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton5</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举</strong></p><h2 id="2-5-原型模式（Prototype-Pattern）"><a href="#2-5-原型模式（Prototype-Pattern）" class="headerlink" title="2.5. 原型模式（Prototype Pattern）"></a>2.5. 原型模式（Prototype Pattern）</h2><h3 id="2-5-1-解决的问题"><a href="#2-5-1-解决的问题" class="headerlink" title="2.5.1. 解决的问题"></a>2.5.1. 解决的问题</h3><ul><li>当一个对象的构建代价过高时。例如某个对象里面的数据需要访问数据库才能拿到，而我们却要多次构建这样的对象。</li><li>当构建的多个对象，均需要处于某种原始状态时，就可以先构建一个拥有此状态的原型对象，其他对象基于原型对象来修改。</li></ul><h1 id="3-结构型（structural）"><a href="#3-结构型（structural）" class="headerlink" title="3. 结构型（structural）"></a>3. 结构型（structural）</h1><h2 id="3-1-适配器模式（Adapter-Pattern）"><a href="#3-1-适配器模式（Adapter-Pattern）" class="headerlink" title="3.1. 适配器模式（Adapter Pattern）"></a>3.1. 适配器模式（Adapter Pattern）</h2><p>适配器模式还有个别名叫：Wrapper（包装器），顾名思义就是将目标类用一个新类包装一下，相当于在客户端与目标类之间加了一层。IT世界有句俗语：没有什么问题是加一层不能解决的</p><h3 id="3-1-1-解决的问题"><a href="#3-1-1-解决的问题" class="headerlink" title="3.1.1. 解决的问题"></a>3.1.1. 解决的问题</h3><ul><li>当需要使用一个现存的类，但它提供的接口与我们系统的接口不兼容，而我们还不能修改它时</li><li>当多个团队独立开发一个系统中的各个功能模块，最后组合在一起，但由于某些原因事先不能确定接口时。（别和我说这不可能，这太tm可能了）<h3 id="3-1-2-优缺点"><a href="#3-1-2-优缺点" class="headerlink" title="3.1.2. 优缺点"></a>3.1.2. 优缺点</h3></li></ul><p><strong>优点</strong></p><p>极大的增强了程序的可扩展性，通过此模式，你可以随意扩展程序的功能，但却不需要修改接口</p><p><strong>缺点</strong></p><p>其实在我看来这个模式真没啥缺点，唯一可以称的上的缺点是多了一层，但是这也是没有办法的事情。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-08-26-React%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2024-08-26-React%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文章内容"><a href="#1-文章内容" class="headerlink" title="1. 文章内容"></a>1. 文章内容</h1><p>学习 React 的重要概念和相关术语，例如 <strong>Babel, Webpack, JSX, components, props, state, lifecycle</strong></p><p>最终执行的主要是三大件 <strong><em>html (超文本) + js (脚本) + css (层叠样式表) -&gt; 结构 + 功能 + 样式</em></strong></p><p><strong>入门必读</strong>(<a href="http://www.snofly.cn/posts/react-to/">React 入门引导：理论概述与示例演练 - Snofly</a>)</p><h1 id="2-什么是-React"><a href="#2-什么是-React" class="headerlink" title="2. 什么是 React"></a>2. 什么是 React</h1><ul><li>React 是一个 JavaScript 库</li><li>React 不是一个框架</li><li>React 是 Facebook 创建的一个开源项目</li><li>React 被用于在前端构建用户界面(UI)</li><li>React 是 MVC 应用程序中的视图层(MVC: Model View Controller)</li></ul><p>事实上，React 最重要的一点就是，你可以创建组件(components) —— 类似于自定义的、可复用的 HTML 元素，然后借此高效地实现 UI。另一方面，React 通过 state 和 props 大大地简化了数据的存储和处理过程。</p><h1 id="3-使用-React-的方法"><a href="#3-使用-React-的方法" class="headerlink" title="3. 使用 React 的方法"></a>3. 使用 React 的方法</h1><p>这里我将展示其中的两种，以便于你理解到 React 的工作原理</p><h2 id="3-1-静态-HTML-文件"><a href="#3-1-静态-HTML-文件" class="headerlink" title="3.1. 静态 HTML 文件"></a>3.1. 静态 HTML 文件</h2><p>将 JavaScript 库加载到静态 HTML 页面并动态渲染 React 和 Babel</p><p>先要创建一个 index.html 文件，然后在 head 元素中加载三个CDN ：React、React DOM、Babel。之后要写个 div 元素，设置其 id 为 root，最后创建一个 script 标签用来写你自己的代码。</p><p>React 顶层 API React DOM - 提供了一些 DOM 方法 </p><p>Babel - 一种 JavaScript 编译器，它能让 ES6+ 代码在旧浏览器上运行。</p><p>我们的程序入口是 id 为 root 的 div 元素，这是按照规范约定的命名。同时，你也要注意到 test/babel 这种类型，这是使用 Babel 必须的写法。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello React!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@^16/umd/react.production.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16.13.0/umd/react-dom.production.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6.26.0/babel.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="comment">// React code will go here</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-Create-React-APP"><a href="#3-2-Create-React-APP" class="headerlink" title="3.2. Create React APP"></a>3.2. Create React APP</h2><p>可以看到 /public 目录和 /src 目录，还有常规的 node_modules、.gitignore、README.md、package.json。</p><p>在 /public 中，最重要的文件是 index.html，它和前文中提到的静态 index.html 文件很像，都是一个 root div。不过这次，没有在文件中加载任何的依赖库和 script 标签。</p><p>在 /src 中，将会包含全部的 React 代码。</p><p>现在，让我们删除 /src 目录下的全部文件，因为我们将要创建自定义的模板——非常简洁，只有 index.css 和 index.js 文件。</p><p>对于 index.css 文件，我就直接复制粘贴来自 <a href="https://taniarascia.github.io/primitive/css/main.css">Primitive CSS</a> 的内容。当然，如果你想，也可以使用 Bootstrap 或者别的什么 CSS 框架，或者干脆什么都不写。我只是觉得这个更容易使用。</p><p>对于 index.js 文件，我们导入 React、ReactDOM，以及 CSS 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import &quot;./index.css&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;h1&gt;My First React App&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;Hello World!&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(&lt;App /&gt;, document.getElementById(&quot;root&quot;));</span><br></pre></td></tr></table></figure><h1 id="4-React-Developer-Tools"><a href="#4-React-Developer-Tools" class="headerlink" title="4. React Developer Tools"></a>4. React Developer Tools</h1><p>有一个浏览器扩展，叫做 React Developer Tools，它能让你更轻松地使用 React</p><p>安装之后，打开浏览器开发工具 F12，你能在 tab 列中看到 React。点击一下，你就能够在编写组件时进行检查。你也可以在 Elements 中查看实际的 DOM 输出。现在看起来用处不大，但是当 app 变得越来越复杂的时候，它就越来越有必要去使用了。</p><h1 id="5-JSX"><a href="#5-JSX" class="headerlink" title="5. JSX"></a>5. JSX</h1><p>我们在 React 代码中编写的好像是 HTML，但它并不是正经的 HTML，而是 JSX，即 JavaScript XML。React 使用 JSX 来替代常规的 JavaScript。你也可以认为 JSX 其实就是 JavaScript。当遇到 <code>&lt;</code>，JSX就当HTML解析，遇到 <code>&#123;</code> 就当 JavaScript 解析</p><p>使用 JSX，我们可以直接编写类似 HTML 的内容（看起来像是HTML和JavaScript的混写），还可以创建和使用自定义的类 XML 便签。下面是 JSX 变量赋值语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heading = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">&quot;site-heading&quot;</span>&gt;</span>Hello, React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><p>编写 React 代码并不一定要使用 JSX。引擎底层的实现，是通过 createElement 方法来创建标签、属性、子组件的，之后渲染它们。下面的代码具有相同的输出结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> heading = <span class="title class_">React</span>.<span class="title function_">createElement</span>(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">&quot;site-heading&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;Hello, React!&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>这里有一些编写代码时候需要注意的关键性差异</strong>：</p><ul><li>在 CSS 类名指定时，className 被用来替换 class ，因为在 JavaScript 中 class 是关键字。</li><li>在 JSX 中的属性和方法采用小驼峰命名法，比如 onclick 变为 onClick。</li><li>自闭合标签必须使用斜杠结尾，例如 <code>&lt; img /&gt;</code></li><li>JavaScript 代码也能被嵌入 JSX 中，使用花括号<code>&#123;&#125;</code>就能嵌入变量、函数、属性。</li></ul><p>JSX 创建和添加元素（大部分）比原生 JS 更容易理解和使用</p><p><strong>JSX只能返回单个根元素，但是我们需要返回多个根元素怎么办？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 错误写法</span><br><span class="line">return(</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>方法一：在这些元素外面再包裹一层元素，使得其变为单个根元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return(&lt;div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>方法二：在这些元素外面再包裹一层空标签，这样渲染结果不会有外部的父级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return(&lt;&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">   &lt;div&gt;&lt;/div&gt;</span><br><span class="line">  &lt;&gt;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>方法三：<code>&lt;Fragment&gt;</code>标签，和方法二一样，它们都允许你在不添加额外节点的情况下将子元素组合，但是<code>&lt;Fragment&gt;</code> 可以拥有<code>key</code>属性</p><h1 id="6-组件-Components"><a href="#6-组件-Components" class="headerlink" title="6. 组件 (Components)"></a>6. 组件 (Components)</h1><p>几乎所有 React 组件可以分为两种：类组件（class components）和简单组件（simple components）</p><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure><p>APP.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">                &lt;h1&gt;My First React App&lt;/h1&gt;</span><br><span class="line">                &lt;p&gt;Hello World!&lt;/p&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>我们导出 App 组件，然后在 index.js 中加载。将组件分离到其他文件里面</p><h2 id="6-1-类组件（class-components）"><a href="#6-1-类组件（class-components）" class="headerlink" title="6.1. 类组件（class components）"></a>6.1. 类组件（class components）</h2><p>现在创建另一个组件，计划是做个表格组件。新建一个 Table.js 文件，我们创建的自定义类组件，它用大写字母开始，以区别于一般的 html 元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">class Table extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;Name&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;Job&lt;/th&gt;</span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">        &lt;tbody&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Charlie&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;Janitor&lt;/td&gt;</span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;Mac&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;Bouncer&lt;/td&gt;</span><br><span class="line">          &lt;/tr&gt;</span><br><span class="line">        &lt;/tbody&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Table;</span><br></pre></td></tr></table></figure><h2 id="6-2-简单组件（simple-components）"><a href="#6-2-简单组件（simple-components）" class="headerlink" title="6.2. 简单组件（simple components）"></a>6.2. 简单组件（simple components）</h2><p>目前推荐使用简单组件</p><p>React 的简单组件，其本质是一个函数，所以这种组件不需要使用关键字 class</p><p>我们使用 ES6 的箭头函数来创建这些简单组件</p><p>现在让我们改造 Table，在里面做两个简单组件：一个表格标题、一个表格内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const TableHead = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;Product&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;Price&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const TableBody = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Product 1&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;Price 1&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Product 2&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;Price 2&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/tbody&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Table extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;TableHead /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TableBody /&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Table;</span><br></pre></td></tr></table></figure><p>注意，TableHeader 和 TableBody 组件在同一个文件中，都是被 Table 类组件使用的。</p><p>注意观察，组件是可以被嵌套在其他组件中的，并且简单组件和类组件可以混合使用。</p><p>一个类组件必须包含 render() 方法，并且 return 返回的最外层父元素只能有一个</p><h2 id="6-3-类组件和函数组件的区别"><a href="#6-3-类组件和函数组件的区别" class="headerlink" title="6.3. 类组件和函数组件的区别"></a>6.3. 类组件和函数组件的区别</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** Simple Component */ </span><br><span class="line">const SimpleComponent = () =&gt; &#123;   </span><br><span class="line">return &lt;div&gt;Example&lt;/div&gt;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/** Class Component */ </span><br><span class="line">class ClassComponent extends Component &#123;   </span><br><span class="line">render() &#123;     </span><br><span class="line">return &lt;div&gt;Example&lt;/div&gt;;   </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-Props"><a href="#7-Props" class="headerlink" title="7. Props"></a>7. Props</h1><p><strong>props 和 父子组件通信</strong></p><ul><li>子组件通过 props 的属性 获取父组件的数据</li><li>父组件通过 props.function 获取子组件的事件等回调</li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409191157082.jpg" alt="react父子组件通信.jpg"></p><p>React 的一大优化就是数据的处理，通过属性 props 和状态 state 来实现。接下来，我们将重点关注 props 中的数据处理</p><p>将 TableBody 中的数据移除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/** src/Table.js */</span><br><span class="line">const TableBody = () =&gt; &#123;</span><br><span class="line">  return &lt;tbody /&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把数据都放到一个数组对象里面，就像自定义了一个 JSON 格式参数的 API。这个数组对象需要放在 render() 方法里面</p><p>通过 Table 组件的元素特性将数据传到 Table 组件里面，这种传数据的用法类似 HTML5 中的<code>data-*</code>属性</p><p>这个元素特性的命名是任意的，只要不与关键字重复即可，所以这里使用自定义的 tbodyData</p><p>传递的数据是一个变量 tbodyData，所以需要用花括号包裹起来——其本质上是作为一个 JavaScript 表达式存在的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/** src/App.js */</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">import Table from &quot;./Table&quot;;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const tbodyData = [</span><br><span class="line">      &#123;</span><br><span class="line">        Product: &quot;Product 1&quot;,</span><br><span class="line"></span><br><span class="line">        Price: &quot;100&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        Product: &quot;Product 2&quot;,</span><br><span class="line"></span><br><span class="line">        Price: &quot;200&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ];</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;Table&quot;&gt;</span><br><span class="line">        &lt;Table tbodyData=&#123;tbodyData&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>现在数据已经从外面传入 Table组件，那么就需要从里面接收数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">/** src/Table.js */</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">const TableHead = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;Product&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;Price&lt;/th&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    &lt;/thead&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const TableBody = () =&gt; &#123;</span><br><span class="line">  return &lt;tbody /&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Table extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; tbodyData &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;TableHead /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TableBody tbodyData=&#123;tbodyData&#125; /&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Table;</span><br></pre></td></tr></table></figure><p>这时打开 React 开发工具检查 Table 组件，你就能在其 props 中看到数组数据。这些数据是被存储在虚拟 DOM(virtual DOM) 中，这是一种快速同步数据到实体 DOM 方法。</p><p>此时数据还没有放到实际的 DOM 中，在 Table 中，我们可以通过 this.props 访问全部的属性。我们使用 ES6 的结构方式来创建一个变量，用于包含 this.props.tbodyData</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; tbodyData &#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br></pre></td></tr></table></figure><p>因为 Table 组件包含两个更小的简单组件，所以需要再次通过 props 将数据传递到 TableBody 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** src/Table.js */</span><br><span class="line">class Table extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123; tbodyData &#125; = this.props;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;TableHead /&gt;</span><br><span class="line"></span><br><span class="line">        &lt;TableBody tbodyData=&#123;tbodyData&#125; /&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，在 TableBody 中没有参数，并且它也只返回了一个标签。我们将通过函数参数来传递 props，然后通过数组映射来返回构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const TableBody = (props) =&gt; &#123;</span><br><span class="line">  const rows = props.tbodyData.map((row, index) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;tr key=&#123;index&#125;&gt;</span><br><span class="line">        &lt;td&gt;&#123;row.Product&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&#123;row.Price&#125;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return &lt;tbody&gt;&#123;rows&#125;&lt;/tbody&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 React 组件中传递存在的数据，props 是一种高效的方式，然而组件不能修改只可读的 props。在下个章节，我们将学习使用状态(state) 来进一步控制 React 中的数据处理。</p><h1 id="8-State"><a href="#8-State" class="headerlink" title="8. State"></a>8. State</h1><ul><li>不要直接修改 state 的值</li><li>setState 是一个异步方法</li><li>setState是新的内容直接换掉旧的内容</li><li>setState中同名属性，后面的会覆盖前面的</li></ul><p>如果我们想要删除数组中的条目呢？通过 props 我们得到了一个单向数据流，<strong>通过 state 我们可以更新组件内部的私有数据</strong>。</p><p>state 可以简单理解为一种临时变量</p><p>创建一个 state 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">    state = &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个对象中要包含所有你想要存储的变量，这里就是tbodyData</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class App extends React.Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    tbodyData: [</span><br><span class="line">      &#123;</span><br><span class="line">        Product: &quot;Product 1&quot;,</span><br><span class="line"></span><br><span class="line">        Price: &quot;100&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      &#123;</span><br><span class="line">        Product: &quot;Product 2&quot;,</span><br><span class="line"></span><br><span class="line">        Price: &quot;200&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样数据就被包含在 state 中。因为我们想能够移除表格中的数据，所以在 App 中创建一个 removeCharacter 方法。</p><p>为了更新 state，我们使用 this.setState()，它是一种操作 state 的内置方法，不能直接写等号赋值。最后基于传入的索引参数过滤数组，获取并返回一个新的数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/** src/App.js */</span><br><span class="line">removeTbodyData = (index) =&gt; &#123;</span><br><span class="line">  const &#123; tbodyData &#125; = this.state;</span><br><span class="line"></span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    tbodyData: tbodyData.filter((tbodyData, i) =&gt; &#123;</span><br><span class="line">      return i !== index;</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在每行的后面渲染一个按钮，点击它可以调用这个函数。这里将 removeCharacter 作为 prop 传递到 Table 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** src/App.js */</span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;tbodyData&#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Table&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Table</span> <span class="attr">tbodyData</span>=<span class="string">&#123;tbodyData&#125;</span> <span class="attr">removeTbodyData</span>=<span class="string">&#123;this.removeTbodyData&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要将参数从 Table 传递到 TableBody 中，所以再来一次通过 prop 传值</p><p>另外，在我们的项目中，只有 App 和 Form 两个组件拥有自己的 state，所以 Table 类组件最好转为简单组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** src/Table.js */</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TableHead</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Product<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">TableBody</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> rows = props.<span class="property">tbodyData</span>.<span class="title function_">map</span>(<span class="function">(<span class="params">row, index</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;row.Product&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;row.Price&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> props.removeTbodyData(index)&#125;&gt;Remove<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line"></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span>&#123;rows&#125;<span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Table</span> = (<span class="params">props</span>) =&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123;tbodyData, removeTbodyData&#125; = props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line"></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TableHead</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">TableBody</span> <span class="attr">tbodyData</span>=<span class="string">&#123;tbodyData&#125;</span> <span class="attr">removeTbodyData</span>=<span class="string">&#123;removeTbodyData&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Table</span>;</span><br></pre></td></tr></table></figure><p> 观察下面两行代码的区别，onClick 函数必须传入一个函数作为参数，且这个函数是返回的 removeCharacter() 方法，否则，如果直接传入 removeCharacter() 方法给 onClick，则会自动执行一次<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> props.<span class="title function_">removeCharacter</span>(index)&#125;&gt;<span class="title class_">Delete</span>&lt;<span class="regexp">/button&gt; &lt;button onClick=&#123;props.removeCharacter(index)&#125;&gt;Delete&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure></p><h1 id="9-表单数据提交"><a href="#9-表单数据提交" class="headerlink" title="9. 表单数据提交"></a>9. 表单数据提交</h1><p>我们将数据存储在了 state 中，并且可以移除其中的任意条目。然而，如果我们想要添加新的条目呢？在一个实际的项目中，大概率是从一个空的 state 开始，然后往里面添加数据，例如任务手账或者购物车。</p><p>新文件 From.js 中创建一个 Form 组件</p><p>将 Form 的初始值设置为空属性对象 initialState，并将其配给 this.state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Form</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  initState = &#123;</span><br><span class="line">    <span class="title class_">Product</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="title class_">Price</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  state = <span class="variable language_">this</span>.<span class="property">initState</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们这个表单的目标是，每当一个表单中的字段发生变化时，能够更新 Form 的 state，然后在提交时，所有数据都要传到 App state 中并更新 Table</p><p>首先，创建一个函数，一旦发生了输入改变，它就会执行。这个事件被传递，然后通过设置 Form state 来获得输入的 name(key) 和 value。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** src/Form.js */</span></span><br><span class="line">  handleChange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> &#123; name, value &#125; = event.<span class="property">target</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line"></span><br><span class="line">      [name]: value,</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>在 render 中，获取 state 中的两个属性，并将他们作为 value 分配给对应的表单 key。将 handleChange() 作为 input 的 onChange，最后导出 Form 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Price</span>, <span class="title class_">Product</span> &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;Product&quot;</span>&gt;</span>Product<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">name</span>=<span class="string">&quot;Product&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;Product&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">value</span>=<span class="string">&#123;Product&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">label</span> <span class="attr">htmlFor</span>=<span class="string">&quot;Price&quot;</span>&gt;</span>Price<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">name</span>=<span class="string">&quot;Price&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">id</span>=<span class="string">&quot;Price&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">value</span>=<span class="string">&#123;Price&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">  <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml"></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">/&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.submitForm&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Form</span>;</span><br></pre></td></tr></table></figure><p>在 App.js 中，我们可以在 表格的下方渲染表单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (</span><br><span class="line"></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;Table&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Table</span> <span class="attr">tbodyData</span>=<span class="string">&#123;tbodyData&#125;</span> <span class="attr">removeTbodyData</span>=<span class="string">&#123;this.removeTbodyData&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">handleSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>观察前端运行效果。更新表单字段，你会发现本地的 From 也被更新。</p><p>最后一步就是提交表单，然后更新父组件状态。我们在 App 组件中创建一个 handleSubmit() 方法，用来更新 App 的 state，数据来自原有的 this.state.tbodyData 以及新添加 bodyItem 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleSubmit = <span class="function">(<span class="params">bodyItem</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">tbodyData</span>: [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">tbodyData</span>, bodyItem] &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>确保把这个函数参数传递到了 Form 中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Form</span> handleSubmit=&#123;<span class="variable language_">this</span>.<span class="property">handleSubmit</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>在 Form 组件中，创建一个 submitForm() 方法，由它来调用 handleSubmit() 并传参，实参就是 Form 中的 state ，形参就是前面定义的 bodyItem。 之后，它会重置 state 为初始值，相当于表单重置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  submitForm = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">props</span>.<span class="title function_">handleSubmit</span>(<span class="variable language_">this</span>.<span class="property">state</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="variable language_">this</span>.<span class="property">initState</span>);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>最后，我们添加一个表单提交按钮。注意，这里使用 onClick 而不是 onSubmit，因为我们并不使用标准的提交函数。这个点击事件会调用自定义的 submitForm 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">&quot;button&quot;</span> value=<span class="string">&quot;Submit&quot;</span> onClick=&#123;<span class="variable language_">this</span>.<span class="property">submitForm</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>到此，我们可以创建和删除表格中的数据</p><h1 id="10-Pulling-in-API-Data"><a href="#10-Pulling-in-API-Data" class="headerlink" title="10. Pulling in API Data"></a>10. Pulling in API Data</h1><p>从 API 中提取数据。如果你不熟悉 API 的概念或者不知道怎么链接 API，我推荐你阅读这篇文章：<a href="https://www.taniarascia.com/how-to-connect-to-an-api-with-javascript/">How to Connect to an API with JavaScript</a>，它会让你知道什么是 API 以及怎样用原生 JavaScript 调用它。</p><p>使用 JavaScript 内置的 <a href="https://www.taniarascia.com/how-to-use-the-javascript-fetch-api-to-get-json-data/">Fetch</a> 方法从 URL 终端获取数据并展示</p><h1 id="11-构建和部署-React-应用"><a href="#11-构建和部署-React-应用" class="headerlink" title="11. 构建和部署 React 应用"></a>11. 构建和部署 React 应用</h1><p>到目前为止，我们所做的一切都是在开发环境中进行的：编译、热加载、实时更新。 在实际生产中，我们将希望加载的是最后的静态文件，也就是不需要源代码来编译。 这个可以通过构建和部署来实现</p><p>现在，如果你想要编译所有的 React 代码，然后把它放到根目录的某个地方，你需要运行这个命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>这会创建一个 build 文件夹来存放你的 app，其中的内容可以放到任何地方，然后就完成了！</p><p>我们还可以更进一步，用 npm 将它部署到某处。我们计划创建一个 GitHub 网页，然后将你的代码上传到 GitHub 中。</p><p>确保你已经退出本地运行环境，也就是代码没在运行。首先，在 package.json 中添加 homepage 字段，这个 URL 是我们想让这个 app 运行的地址。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** package.json */</span> </span><br><span class="line"><span class="string">&quot;homepage&quot;</span>: <span class="string">&quot;https://taniarascia.github.io/react-tutorial&quot;</span>,</span><br></pre></td></tr></table></figure><p>然后添加这两行到 package.json 的属性 scripts 中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;   </span><br><span class="line"><span class="comment">// ...   </span></span><br><span class="line"><span class="string">&quot;predeploy&quot;</span>: <span class="string">&quot;npm run build&quot;</span>,   </span><br><span class="line"><span class="string">&quot;deploy&quot;</span>: <span class="string">&quot;gh-pages -d build&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中，添加 gh-pages 包来到开发依赖中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev gh-pages</span><br></pre></td></tr></table></figure><p>我们创建 build 静态文件，它能完成全部的编译。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure><p>最后部署到 gh-pages 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run deploy</span><br></pre></td></tr></table></figure><h1 id="12-生命周期的钩子方法"><a href="#12-生命周期的钩子方法" class="headerlink" title="12. 生命周期的钩子方法"></a>12. 生命周期的钩子方法</h1><ul><li><code>render</code></li><li><code>constructor</code> 构造器<ul><li>一般做初始化数据获取操作等</li></ul></li><li><code>componentWillMount</code> 即将做初始化 render 前</li><li><code>componentDidMount</code> 组件初始化渲染完成<ul><li>这里可以操作 dom 节点、获取已渲染 dom 节点宽高等等</li><li>可以做些数据判断确认一些初始化数据更新</li><li>绑定一些事件监听</li></ul></li><li><code>componentWillReceiveProps(nextProps)</code> 组件接收到新的 props<ul><li>公共组件做数据判断、同步 props 到 state 等操作</li></ul></li><li><code>shouldComponentUpdate(nextProps, nextState)</code> 是否要更新渲染<ul><li>可以做性能优化，虽然很鸡肋，搞不好还不如不优化</li></ul></li><li><code>componentDidUpdate(preProps, preState)</code> 组件完成渲染更新<ul><li>这里可以操作 dom 节点、获取已渲染 dom 节点宽高等等</li></ul></li><li><code>componentWillUnmount</code> 组件即将卸载<ul><li>解绑一些事件监听</li></ul></li></ul><h1 id="13-children"><a href="#13-children" class="headerlink" title="13. children"></a>13. children</h1><p>在子组件中接收，父组件下子组件标签范围内的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">List</span>(<span class="params">&#123;children&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">     &lt; ul &gt; &#123;children&#125; &lt; /ul&gt;</span><br><span class="line">     )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">List</span>&gt;</span><span class="tag">&lt;<span class="name">li</span>&gt;</span>列表内容&lt;/li &gt; <span class="tag">&lt;/<span class="name">List</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/&gt;</span> )</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>子组件中的children将接收到如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;li&gt;列表内容&lt;/li&gt;</span><br></pre></td></tr></table></figure><h1 id="14-区分"><a href="#14-区分" class="headerlink" title="14. 区分"></a>14. 区分</h1><p>我们需要区分两个概念，<strong>「DOM 结构」</strong> 和 <strong>「React 的层级结构」</strong>。 就像我们需要区分 <strong>「组件渲染」</strong> 和 <strong>「DOM 变更」</strong> 是两件事</p><ul><li><strong>操作方式</strong>:<ul><li><strong>DOM</strong>: 直接通过 JavaScript 操作。</li><li><strong>React</strong>: 声明式，通过组件状态和属性管理。</li></ul></li><li><strong>性能</strong>:<ul><li><strong>DOM</strong>: 直接操作可能影响性能。</li><li><strong>React</strong>: 通过虚拟 DOM 优化更新。</li></ul></li><li><strong>结构</strong>:<ul><li><strong>DOM</strong>: 静态树状结构。</li><li><strong>React</strong>: 组件树，动态且可组合。</li></ul></li></ul><h1 id="15-Hook"><a href="#15-Hook" class="headerlink" title="15. Hook"></a>15. Hook</h1><h2 id="15-1-useState"><a href="#15-1-useState" class="headerlink" title="15.1. useState"></a>15.1. useState</h2><p>实现向组件添加一个状态变量</p><p><code>const [state, setState] = useState(initialState)</code></p><h2 id="15-2-useEffect"><a href="#15-2-useEffect" class="headerlink" title="15.2. useEffect"></a>15.2. useEffect</h2><p>实现将组件与外部系统同步</p><p><code>useEffect(setup, dependencies?)</code></p><h2 id="15-3-useContext"><a href="#15-3-useContext" class="headerlink" title="15.3. useContext"></a>15.3. useContext</h2><p>用于小的全局状态管理</p><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-27-SpringBoot%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2024/10/28/2024-06-27-SpringBoot%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-异步配置"><a href="#1-异步配置" class="headerlink" title="1. 异步配置"></a>1. 异步配置</h1><p>在SpringBoot中简单使用异步编程非常简单，只需要两步</p><p><strong>使用<code>@EnableAsync</code>开启异步支持</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyConfig</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用<code>@Async</code>注解相关方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，使用<code>@Async</code>标记的方法必须是<code>public</code>的，而且返回值必须是<code>void</code>或者<code>Future</code></p><h1 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h1><h2 id="2-1-ThreadPoolExecutor"><a href="#2-1-ThreadPoolExecutor" class="headerlink" title="2.1. ThreadPoolExecutor"></a>2.1. ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>，它是java提供的类，一般会使用下面这个重载版本</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize, <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">    TimeUnit unit, BlockingQueue &lt;</span></span><br><span class="line"><span class="params">    Runnable &gt; workQueue,</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize,</span><br><span class="line">        maximumPoolSize,</span><br><span class="line">        keepAliveTime, unit,</span><br><span class="line">        workQueue, Executors.defaultThreadFactory(),</span><br><span class="line">        handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>corePoolSize</strong></p><p>线程池中核心线程数目，会一直驻留在线程池中（除非设置allowCoreThreadTimeOut为true，默认为false）。</p><p><strong>maximumPoolSize</strong></p><p>整个线程池允许创建的最大线程数，这个数目包含核心线程数。例如其设置为5，corePoolSize设置为3，那么最多可以再创建2个线程。</p><p><strong>workQueue</strong></p><p>当新任务到来时，如果没有闲着的核心线程，任务首先会被存放在队列中。</p><p><strong>keepAliveTime</strong></p><p>那些闲着的非核心线程的存活时间</p><p><strong>unit</strong></p><p>keepAliveTime 参数的时间单位。</p><p><strong>handler</strong></p><p>饱和策略，当线程池没有能力再接收新任务时的处理策略，平台为我们预定义了4种</p><ul><li><p>AbortPolicy：直接抛<code>RejectedExecutionException</code>异常，告知程序线程池已经满负荷了，无法接收新任务</p></li><li><p>CallerRunsPolicy：让调用线程池的那个线程执行新任务。其实就是因为线程池满负荷了没法执行，它自己把任务执行了。</p></li><li><p>DiscardOldestPolicy：将任务队列队首第一个任务给丢弃掉，腾出个位置给新任务。</p></li><li><p>DiscardPolicy：默默的把新任务扔了，连个水花都没有…</p></li></ul><p><strong>前三个参数最为重要</strong></p><p>配置线程池最大线程个数的一个公式，但是这个只做参考</p><ul><li>CPU 密集型任务（CPU 核心数+1）</li><li>I/O 密集型任务（2xCPU 核心数）<h2 id="2-2-ThreadPoolTaskExecutor"><a href="#2-2-ThreadPoolTaskExecutor" class="headerlink" title="2.2. ThreadPoolTaskExecutor"></a>2.2. ThreadPoolTaskExecutor</h2></li></ul><p>Spring提供了一个<code>ThreadPoolExecutor</code>的包装类<code>ThreadPoolTaskExecutor</code>，我们在Spring程序中一般使用这个类，各个参数含义与ThreadPoolExecutor几乎一样</p><p><strong>在配置类中申明一个TaskExecutor类型的Bean</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcurrencyConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TaskExecutor <span class="title function_">threadPoolExecutorCpu</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(<span class="number">2</span>);</span><br><span class="line">        executor.setMaxPoolSize(<span class="number">3</span>);</span><br><span class="line">        executor.setQueueCapacity(<span class="number">2</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(<span class="number">1</span>);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="literal">true</span>);</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">&quot;task-thread-&quot;</span>);</span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将线程池配置给<code>@Async</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async(&quot;threadPoolExecutorCpu&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runAsync</span><span class="params">(Integer id)</span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;start:&#123;&#125;,num:&#123;&#125;&quot;</span>,Thread.currentThread().getId(),id);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;end:&#123;&#125;,num:&#123;&#125;&quot;</span>,Thread.currentThread().getId(),id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-验证线程池配置"><a href="#2-3-验证线程池配置" class="headerlink" title="2.3. 验证线程池配置"></a>2.3. 验证线程池配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/run-async&quot;)</span></span><br><span class="line"> <span class="keyword">public</span> String <span class="title function_">runAsync</span><span class="params">(<span class="meta">@RequestParam(&quot;count&quot;)</span> Integer count)</span> &#123;</span><br><span class="line">     List&lt;Integer&gt; collect = IntStream.rangeClosed(<span class="number">1</span>, count).boxed().collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i : collect) &#123;</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; concurrencyService.runAsync(i)).start();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Thread.sleep(<span class="number">200</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             log.error(<span class="string">&quot;error&quot;</span>, e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="3-Async-使用"><a href="#3-Async-使用" class="headerlink" title="3. @Async 使用"></a>3. <code>@Async</code> 使用</h1><p>Spring 使用动态代理来使<code>@Async</code>其作用，所以要求其修饰的方法必须为<code>public</code>级别，且不能在同一个类调用。其修饰的方法返回值必须是<code>void</code>或者<code>Future</code>。所以在必要的时候，我们可以返回<code>CompletableFuture</code>，然后使用其强大的功能完成异步工作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">getFirstName</span><span class="params">()</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;start get first name&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;006&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Async</span></span><br><span class="line"><span class="keyword">public</span> CompletableFuture&lt;String&gt; <span class="title function_">getLastName</span><span class="params">()</span> &#123;</span><br><span class="line">log.info(<span class="string">&quot;start get last name&quot;</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.completedFuture(<span class="string">&quot;007&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CompletableFuture</code> 是处理异步编程非常强大的工具，我们应该在合适的时机优先使用</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-28-Linux%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/"/>
      <url>/2024/10/28/2024-06-28-Linux%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-HertzBeat"><a href="#1-HertzBeat" class="headerlink" title="1. HertzBeat"></a>1. HertzBeat</h1><h1 id="2-1panel"><a href="#2-1panel" class="headerlink" title="2. 1panel"></a>2. 1panel</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-30-Pycharm%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/28/2024-06-30-Pycharm%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-格式化代码"><a href="#1-格式化代码" class="headerlink" title="1. 格式化代码"></a>1. 格式化代码</h1><p>使用Black进行python代码的格式化规范</p><p>先安装<code>black[d]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install black[d] -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</span><br></pre></td></tr></table></figure><p>在Pycharm中安装插件<code>BlackConnect</code>，<code>File -&gt; Settings -&gt; Tools -&gt; BlackConnect</code>，在 <code>Local Instance (shared between projects)</code> 中：勾选 <code>Start local blackd instance when plugin loads</code>。按下 <code>Path</code> 输入框旁边的 <code>Detect</code> 按钮。插件将会检测到 <code>blackd</code> 可执行文件。</p><p>在 <code>Trigger Settings</code> 中勾选 <code>Trigger on code reformat</code>，来启用使用 <em>Black</em> 重新格式化代码。</p><p>保存文件时自动运行 Black：在插件设置中的 <code>Trigger Settings</code> 中勾选 <code>Trigger when saving changed files</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-09-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
      <url>/2024/10/28/2024-07-09-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-20-MySQL%E4%B9%8Bdelete/"/>
      <url>/2024/10/28/2024-07-20-MySQL%E4%B9%8Bdelete/</url>
      
        <content type="html"><![CDATA[<h1 id="1-delete和truncate"><a href="#1-delete和truncate" class="headerlink" title="1. delete和truncate"></a>1. delete和truncate</h1><p>delete和truncate都是用于删除数据库表中数据的SQL语句，但是它们有以下几个区别：</p><p>1 . <strong>对表结构的影响</strong>:</p><ul><li><code>DELETE</code> 语句删除表中的数据行，不会删除表的结构（表名、列等）。</li><li><code>TRUNCATE</code> 语句删除表中的所有数据行，不会删除表的结构（表名、列等），并重置表的自增长列的计数器。同时也会释放表占用的存储空间。</li></ul><p>2 . <strong>执行速度</strong>:</p><ul><li><code>TRUNCATE</code> 语句通常比 <code>DELETE</code> 语句执行得更快，因为它只需要重置表的数据页，而不需要遍历整个表来删除每一行数据。</li></ul><p>3 . <strong>事务日志记录</strong>:</p><ul><li><code>DELETE</code> 语句会将每个被删除的行记录到事务日志中，因此可以进行回滚操作。</li><li><code>TRUNCATE</code> 语句会直接从磁盘中删除数据页，不会记录到事务日志中，因此无法进行回滚。</li></ul><p>4 . <strong>WHERE 子句</strong>:</p><ul><li><code>DELETE</code> 语句可以使用 <code>WHERE</code> 子句来有选择地删除满足条件的行。</li><li><code>TRUNCATE</code> 语句无法使用 <code>WHERE</code> 子句，它会删除整个表的所有数据行。</li></ul><p>总的来说，如果需要删除表中的全部数据，并且不需要保留删除记录，那么使用 <code>TRUNCATE</code> 语句更加高效。如果需要有选择地删除部分数据行，并且需要保留删除记录以便于回滚，那么使用 <code>DELETE</code> 语句更合适。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure><h1 id="2-自增列的问题"><a href="#2-自增列的问题" class="headerlink" title="2. 自增列的问题"></a>2. 自增列的问题</h1><p>使用 <code>DELETE</code> 语句删除记录后，自增列的值不会自动重置。这是 MySQL 设计的一部分，旨在确保新的记录不会重复使用已删除记录的自增值。如果确实需要重置自增列的值，可以使用 <code>ALTER TABLE</code> 语句，但应谨慎操作，以避免数据完整性问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重置自增列的起始值，</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees AUTO_INCREMENT <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="comment">-- 下一条插入的新记录的 `id` 将会是 `2`，但如果已经存在 `id` 为 `2` 的记录，会导致插入失败</span></span><br></pre></td></tr></table></figure><h2 id="2-1-InnoDB-自增列"><a href="#2-1-InnoDB-自增列" class="headerlink" title="2.1. InnoDB 自增列"></a>2.1. InnoDB 自增列</h2><p>在 InnoDB 存储引擎中，自增列的当前计数器值是存储在内存中的。这意味着：</p><ul><li>在数据库运行期间，自增列的值会随着每次插入操作而递增。</li><li>如果数据库服务重启，自增列的计数器会重新初始化。</li></ul><p><strong>重启后的行为</strong></p><ul><li>MySQL 5.6 及更早版本：自增列的计数器会从表中最大的现有自增列值加一开始。</li><li>MySQL 5.7 及更高版本：自增列计数器的行为进行了优化，通常会继续从上次插入的最大值加一开始。</li></ul><h2 id="2-2-MyISAM-自增列"><a href="#2-2-MyISAM-自增列" class="headerlink" title="2.2. MyISAM 自增列"></a>2.2. MyISAM 自增列</h2><p>在 MyISAM 存储引擎中，自增列的当前计数器值是存储在磁盘上的。这意味着：</p><ul><li>自增列的值会随着每次插入操作而递增。</li><li>即使数据库服务重启，自增列的计数器值也不会丢失。</li></ul><p><strong>重启后的行为</strong></p><ul><li>MyISAM：自增列的值会继续从上一个自增值加一开始，无论数据库是否重启</li></ul><h1 id="3-delete-清空表之后，磁盘空间未发生变化"><a href="#3-delete-清空表之后，磁盘空间未发生变化" class="headerlink" title="3. delete 清空表之后，磁盘空间未发生变化"></a>3. delete 清空表之后，磁盘空间未发生变化</h1><h2 id="3-1-原理"><a href="#3-1-原理" class="headerlink" title="3.1. 原理"></a>3.1. 原理</h2><p>MySQL 中的delete数据删除操作有点像我们平日里做业务开发时用的逻辑删除，当你想要删除掉一行数据的时候，这行数据其实并没有被真正的删除掉，只是暂时给标记为删除了而已</p><p>一张表在经过 N 多次delete删除之后，就会出现大量这种情况，这种就称之为删除空洞</p><h2 id="3-2-optimize-table"><a href="#3-2-optimize-table" class="headerlink" title="3.2. optimize table"></a>3.2. optimize table</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimize <span class="keyword">table</span> table_name</span><br></pre></td></tr></table></figure><p>该命令可以用来重新整理表空间，并优化文件碎片</p><p>optimize 操作是 online DDL 的。online DDL 意味着在执行 optimize 重整表的时候，并不会阻塞正在进行的 CURD 操作。具体流程如下：</p><p>1 . 首先建立一个临时文件，这个临时文件用来扫描表原始表主键的所有数据页。</p><p>2 . 根据第一步获取到的表记录生成一个 B+Tree，将这个生成的 B+Tree 存储到临时文件中。</p><p>3 . 由于第二步会比较耗时，在第二步执行过程中，如果有针对原始表的 CRUD 操作，则先将操作记录到一个日志文件中，等到第二步的临时文件生成后，在把日志文件应用到临时文件中，就可以获取到一个最新的数据表了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-09-CI&amp;DI%E6%96%B9%E6%A1%88/"/>
      <url>/2024/10/28/2024-07-09-CI&amp;DI%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-方案"><a href="#1-方案" class="headerlink" title="1. 方案"></a>1. 方案</h1><p><strong>Gitness</strong></p><p>资源占用少，个人开发者</p><p><strong>gitlab + gitlab自带的CI/CD</strong></p><p>小型团队</p><p><strong>gitlab + Jenkins</strong></p><p>大型团队</p><h1 id="2-Gitness"><a href="#2-Gitness" class="headerlink" title="2. Gitness"></a>2. Gitness</h1><p><a href="https://docs.gitness.com/">https://docs.gitness.com/</a></p><h1 id="3-Gitlab-Jenkins"><a href="#3-Gitlab-Jenkins" class="headerlink" title="3. Gitlab + Jenkins"></a>3. Gitlab + Jenkins</h1><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">jenkins:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;jenkins/jenkins:2.60.2-alpine&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">jenkins</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:8080&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;50001:50000&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/jenkins:/var/jenkins_home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/data/home/:/home</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/docker:/bin/docker</span> <span class="comment">#宿主机的docker可执行映射到镜像里面 后面build的时候会用到</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="4-Gitlab-Gitlab-Runner"><a href="#4-Gitlab-Gitlab-Runner" class="headerlink" title="4. Gitlab + Gitlab Runner"></a>4. Gitlab + Gitlab Runner</h1><p>Gitlab只是个代码仓库，想要实现CI/CD还需安装<code>gitlab-runner</code>，<code>gitlab-runner</code>相当于Gitlab中任务的执行器，Gitlab会在需要执行任务时调用它</p><p>下载<code>gitlab-runner</code>的Docker镜像，选用<code>alpine-bleeding</code>，这个版本非常小巧。完整版可以选择latest</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">gitlab/gitlab-runner:alpine-bleeding</span></span><br></pre></td></tr></table></figure><p>创建文件<code>docker-compose.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">gitlab</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;gitlab/gitlab-ce:latest&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;192.168.163.129&#x27;</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        external_url &#x27;http://192.168.163.129:8929&#x27;</span></span><br><span class="line"><span class="string">        gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string"></span>      <span class="attr">GITLAB_ROOT_PASSWORD:</span> <span class="string">&#x27;Ytjt@123&#x27;</span> <span class="comment"># 这里设置密码，要大小写和数字</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8929:8929&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;2424:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/data:/var/opt/gitlab&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">&#x27;256m&#x27;</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">  <span class="attr">gitlab-runner:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;gitlab/gitlab-runner:alpine-bleeding&#x27;</span> <span class="comment"># alpine-bleeding很精简，完整版用latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab-runner</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 这两步骤是为了让容器内的gitlab-runner可以访问到docker</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/docker.sock:/var/run/docker.sock</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/bin/docker:/bin/dcoker</span></span><br><span class="line">      <span class="comment"># 将当前目录的config文件，映射到容器的/etc/gitlab-runner目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./gitlab-runner:/etc/gitlab-runner</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="comment"># 也是指定docker</span></span><br><span class="line">      <span class="attr">RUNNER_EXECUTOR:</span> <span class="string">&quot;docker&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">gitlab</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>注册时会出现交互界面，提示你输入注册地址、token、执行器类型等信息，执行器建议选择ssh，ssh能远程执行Linux命令，推荐使用这个</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-07-20-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
      <url>/2024/10/28/2024-07-20-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-优化的方向"><a href="#1-优化的方向" class="headerlink" title="1. 优化的方向"></a>1. 优化的方向</h1><ul><li>优化成本：硬件&gt;系统配置&gt;数据库表结构&gt;SQL及索引</li><li>优化效果：硬件&lt;系统配置&lt;数据库表结构&lt;SQL及索引</li></ul><p>SQL及索引优化是成本最低且效果最好的一种方式</p><h1 id="2-查询SQL的执行过程"><a href="#2-查询SQL的执行过程" class="headerlink" title="2. 查询SQL的执行过程"></a>2. 查询SQL的执行过程</h1><p>1 . 通过网络的通讯协议接收客户端传入的SQL<br>2 . 查看该SQL对应的结果在查询缓存中是否存在  </p><ul><li>存在则直接返回结果  </li><li>不存在则继续往下走  </li></ul><p>3 . 由解析器来解析当前SQL，最终形成初步的解析树<br>4 . 再由预处理器对解析树进行调整，完成占位符赋值等操作<br>5 . 查询优化器对最终的解析树进行优化，包括调整SQL顺序等<br>6 . 根据优化后的结果得出查询语句的执行计划，就是查询数据的具体实施方案，交给查询的执行引擎<br>7 . 查询执行引擎调用存储引擎提供的API，最后由存储引擎来完成数据的查询，然后返回结果</p><h1 id="3-SQL的执行顺序"><a href="#3-SQL的执行顺序" class="headerlink" title="3. SQL的执行顺序"></a>3. SQL的执行顺序</h1><p>写的顺序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> … <span class="keyword">from</span> … <span class="keyword">join</span> … <span class="keyword">on</span> … <span class="keyword">where</span> … <span class="keyword">group</span> <span class="keyword">by</span> … <span class="keyword">having</span> … <span class="keyword">order</span> <span class="keyword">by</span> … limit</span><br></pre></td></tr></table></figure><br>执行的顺序<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> … <span class="keyword">on</span> … <span class="keyword">join</span> … <span class="keyword">where</span> … <span class="keyword">group</span> <span class="keyword">by</span> … <span class="keyword">having</span> … <span class="keyword">select</span> … <span class="keyword">order</span> <span class="keyword">by</span> … limit …</span><br></pre></td></tr></table></figure></p><h1 id="4-SQL优化的方法"><a href="#4-SQL优化的方法" class="headerlink" title="4. SQL优化的方法"></a>4. SQL优化的方法</h1><h2 id="4-1-EXPLAIN"><a href="#4-1-EXPLAIN" class="headerlink" title="4.1. EXPLAIN"></a>4.1. EXPLAIN</h2><p>用EXPLAIN查看SQL执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `<span class="keyword">user</span>`</span><br><span class="line">  <span class="keyword">JOIN</span> `post` <span class="keyword">ON</span> `<span class="keyword">user</span>`.id <span class="operator">=</span> `post`.uid</span><br><span class="line"><span class="keyword">WHERE</span> user.`created_at` <span class="operator">&lt;</span> <span class="string">&#x27;2018-10-01 00:00:00&#x27;</span> <span class="keyword">AND</span> `post`.status <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>要重点关注的数据</strong></p><ul><li><code>type</code>列，连接类型。一个好的SQL语句至少要达到<code>range</code>级别。杜绝出现<code>all</code>级别。</li><li><code>key</code>列，使用到的索引名。如果没有选择索引，值是NULL。</li><li><code>key_len</code>列，索引长度。不损失精确性的情况下，长度越短越好</li><li><code>rows</code>列，扫描行数。该值是个预估值。</li><li><code>extra</code>列，详细说明。注意，常见的不太友好的值，如下：<code>Using temporary（临时表）</code>、<code>Using filesort（文件排序）</code></li></ul><p>针对<code>explain</code>命令生成的执行计划，这里有一个查看心法。我们可以先从查询类型<code>type</code>列开始查看，如果出现<code>all</code>关键字，后面的内容就都可以不用看了，代表全表扫描。再看<code>key</code>列，看是否使用了索引，<code>null</code>代表没有使用索引。然后看<code>rows</code>列，该列用来表示在SQL执行过程中被扫描的行数，该数值越大，意味着需要扫描的行数越多，相应的耗时越长，最后看<code>Extra</code>列，在这列中要观察是否有<code>Using filesort</code> 或者<code>Using temporary</code> 这样的关键字出现，这些是很影响数据库性能的</p><h2 id="4-2-避免使用select"><a href="#4-2-避免使用select" class="headerlink" title="4.2. 避免使用select *"></a>4.2. 避免使用<code>select *</code></h2><p>任何地方都不要使用 <code>select * from t</code> ，用具体的字段列表代替<code>*</code>，用哪些字段就写哪些字段，不要返回用不到的任何字段。  原因如下：</p><ul><li><code>SELECT *</code> 会增加很多不必要的消耗（CPU、IO、内存、网络带宽）</li><li>增加了使用覆盖索引的可能性</li><li>当表结构发生改变时，前端也需要更新</li></ul><p>所以要求直接在select后面接上字段名</p><h2 id="4-3-区分in和exists"><a href="#4-3-区分in和exists" class="headerlink" title="4.3. 区分in和exists"></a>4.3. 区分in和exists</h2><p>区分in和exists主要是造成了驱动顺序的改变（这是性能变化的关键）。如果是exists，那么以外层表为驱动表，先被访问；如果是IN，那么先执行子查询。所以<strong>IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况</strong></p><h2 id="4-4-in-和-not-in"><a href="#4-4-in-和-not-in" class="headerlink" title="4.4. in 和 not in"></a>4.4. in 和 not in</h2><p>in 和 not in 也要慎用，否则会导致全表扫描。对于连续的数值，能用 <code>between</code> 就不要用 <code>in</code>。如果一定要使用<code>in</code>，那么in包含的值不应过多</p><h2 id="4-5-where子句"><a href="#4-5-where子句" class="headerlink" title="4.5. where子句"></a>4.5. where子句</h2><p><strong>避免在where子句中对字段进行null值判断</strong></p><p>对于null的判断会导致引擎放弃使用索引而进行全表扫描。针对为null的数据可以给个默认值代替</p><p><strong>应尽量避免在 where 子句中使用!=操作符</strong></p><p><code>where</code> 子句中使用<code>!=</code>或<code>&lt;&gt;</code>操作符，将导致引擎放弃使用索引而进行全表扫描，可以使用 <code>or</code> 代替。</p><p><code>num!=10</code> 换为 <code>num&lt;10 or num&gt;10</code></p><p><strong>避免在where子句中对字段进行表达式操作</strong></p><p>这会造成引擎放弃使用索引</p><p><code>where salary=20000/2</code></p><p><strong>尽量避免在where子句中对字段进行函数操作</strong></p><p>这将导致引擎放弃使用索引而进行全表扫描</p><p><code>where substring(name,1,3)=&#39;abc&#39;</code></p><h2 id="4-6-or"><a href="#4-6-or" class="headerlink" title="4.6. or"></a>4.6. or</h2><p><strong>如果限制条件中其他字段没有索引，尽量少用or</strong></p><p><code>or</code>两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用<code>union all</code>或者是<code>union</code>（必要的时候）的方式来代替<code>or</code>会得到更好的效果。</p><h2 id="4-7-尽量用union-all代替union"><a href="#4-7-尽量用union-all代替union" class="headerlink" title="4.7. 尽量用union all代替union"></a>4.7. 尽量用union all代替union</h2><p><code>union</code>和<code>union all</code>的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，<code>union all</code>的前提条件是两个结果集没有重复数据。</p><h2 id="4-8-不建议使用-前缀模糊查询"><a href="#4-8-不建议使用-前缀模糊查询" class="headerlink" title="4.8. 不建议使用%前缀模糊查询"></a>4.8. 不建议使用<code>%</code>前缀模糊查询</h2><p>比如<code>like &#39;%abc&#39;</code>或者<code>like &#39;%abc%&#39;</code>，这种查询会导致索引失效而进行全表扫描。但是可以使用<code>like &#39;abc%&#39;</code>。</p><h2 id="4-9-避免隐式类型转换"><a href="#4-9-避免隐式类型转换" class="headerlink" title="4.9. 避免隐式类型转换"></a>4.9. 避免隐式类型转换</h2><p>比如<code>is_success</code>是<code>varchar(1)</code>类型，如果你传数值型的1或0，数据库会隐式转换为字符串形势的<code>&#39;1&#39;</code>或<code>&#39;0&#39;</code>则会导致索引失效。</p><h2 id="4-10-如果排序字段没有用到索引，就尽量少排序"><a href="#4-10-如果排序字段没有用到索引，就尽量少排序" class="headerlink" title="4.10. 如果排序字段没有用到索引，就尽量少排序"></a>4.10. 如果排序字段没有用到索引，就尽量少排序</h2><h2 id="4-11-关于JOIN优化"><a href="#4-11-关于JOIN优化" class="headerlink" title="4.11. 关于JOIN优化"></a>4.11. 关于JOIN优化</h2><p><strong>驱动表是join优化的突破口！ 那什么是驱动表呢？</strong></p><ul><li>指定了联接条件时，满足查询条件的记录行数少的表为驱动表</li><li>未指定联接条件时，行数少的表为驱动表（Important!）</li></ul><p>如果你搞不清楚该让谁做驱动表、谁 <code>join</code> 谁，就别指定谁 <code>left/right join</code> 谁了，直接使用<code>join</code>即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-04-11-MySQL%E6%97%A5%E5%BF%97/"/>
      <url>/2024/10/28/2024-04-11-MySQL%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-开启日志"><a href="#1-开启日志" class="headerlink" title="1. 开启日志"></a>1. 开启日志</h1><p>执行下面语句，看是否开启了binlog</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>使用delete误删数据，可依据binlog进行回滚</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-05-11-FastApi/"/>
      <url>/2024/10/28/2024-05-11-FastApi/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-05-08-Maven%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2024/10/28/2024-05-08-Maven%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>maven的xml配置文件，必须放在maven的conf文件夹下，否则配置到idea中无法找到配置文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-05-29-Quasar%E6%89%93%E5%8C%85APP/"/>
      <url>/2024/10/28/2024-05-29-Quasar%E6%89%93%E5%8C%85APP/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Capacitor打包APP"><a href="#1-Capacitor打包APP" class="headerlink" title="1. Capacitor打包APP"></a>1. Capacitor打包APP</h1><h2 id="1-1-准备环境"><a href="#1-1-准备环境" class="headerlink" title="1.1. 准备环境"></a>1.1. 准备环境</h2><p>1、下载好Android studio（安装版）</p><p>2、准备好与该Android studio相适配的jdk版本</p><p>3、在Android studio中下载Android SDK，选择与jdk版本相匹配的sdk版本，需要下载platform、tools，<a href="https://www.cnblogs.com/star12111/p/12789245.html">通过Android studio下载的sdk中没有tools文件夹的解决办法</a></p><p>4、配置环境变量<code>setx ANDROID_SDK_ROOT &quot;F:\AndroidWork\sdk&quot;</code>，<code>setx path &quot;%ANDROID_SDK_ROOT%\platform-tools&quot;</code>，<code>setx path &quot;%ANDROID_SDK_ROOT%\tools&quot;</code></p><p>5、默认gradle版本、gradle插件版本即可，只需修改源，<a href="https://seepine.com/dev/gradle/wrapper/">Gradle Wrapper 国内源 - Seepine’s Blog</a></p><h2 id="1-2-报错"><a href="#1-2-报错" class="headerlink" title="1.2. 报错"></a>1.2. 报错</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">* What went wrong:</span><br><span class="line">Unable to start the daemon process.</span><br><span class="line">This problem might be caused by incorrect configuration of the daemon.</span><br><span class="line">For example, an unrecognized jvm option is used.</span><br><span class="line">Please refer to the User Manual chapter on the daemon at https://docs.gradle.org/8.0.2/userguide/gradle_daemon.html</span><br><span class="line">Process command line: E:\jdk-17.0.11+9\bin\java.exe --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.lang.invoke=A</span><br><span class="line">LL-UNNAMED --add-opens=java.prefs/java.util.prefs=ALL-UNNAMED --add-opens=java.base/java.nio.charset=ALL-UNNAMED --add-opens=java.base/java.net=ALL-UNNAMED --add-opens=java.base/ja</span><br><span class="line">va.util.concurrent.atomic=ALL-UNNAMED -Xmx1536m -Dfile.encoding=UTF-8 -Duser.country=CN -Duser.language=zh -Duser.variant -cp C:\Users\Hou_Yi\.gradle\wrapper\dists\gradle-8.0.2-all</span><br><span class="line">\5owlw31sddu3apboq9xcnpod7\gradle-8.0.2\lib\gradle-launcher-8.0.2.jar org.gradle.launcher.daemon.bootstrap.GradleDaemon 8.0.2</span><br><span class="line">Please read the following process output to find out more:</span><br><span class="line">-----------------------</span><br><span class="line">Error occurred during initialization of VM</span><br><span class="line">Could not reserve enough space for 1572864KB object heap</span><br></pre></td></tr></table></figure><p>gradle.properties 中设置<code>org.gradle.jvmargs=-Xmx512m</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Quasar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-24-GitLab%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/10/28/2024-06-24-GitLab%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Gitlab-CE安装"><a href="#1-Gitlab-CE安装" class="headerlink" title="1. Gitlab-CE安装"></a>1. Gitlab-CE安装</h1><p><strong>Docker-Compose方式部署</strong></p><p>创建文件<code>docker-compose.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.6&#x27;</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">gitlab</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">gitlab:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">&#x27;gitlab/gitlab-ce:latest&#x27;</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">gitlab</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">&#x27;192.168.163.129&#x27;</span></span><br><span class="line">    <span class="attr">privileged:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">TZ:</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br><span class="line">      <span class="attr">GITLAB_OMNIBUS_CONFIG:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        external_url &#x27;http://192.168.163.129:8929&#x27;</span></span><br><span class="line"><span class="string">        gitlab_rails[&#x27;time_zone&#x27;] = &#x27;Asia/Shanghai&#x27;</span></span><br><span class="line"><span class="string"></span>      <span class="attr">GITLAB_ROOT_PASSWORD:</span> <span class="string">&#x27;Ytjt@123&#x27;</span> <span class="comment"># 这里设置密码，要大小写和数字</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;8929:8929&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;443:443&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;2424:22&#x27;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/config:/etc/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/logs:/var/log/gitlab&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;./gitlab/data:/var/opt/gitlab&#x27;</span></span><br><span class="line">    <span class="attr">shm_size:</span> <span class="string">&#x27;256m&#x27;</span></span><br></pre></td></tr></table></figure><p>执行 <code>docker compose up -d</code></p><p>最低服务器要求：2核 2G以上内存，2GB内存运行的时候内存直接爆掉</p>]]></content>
      
      
      
        <tags>
            
            <tag> GitLab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-12-Java%20web%20%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
      <url>/2024/10/28/2024-06-12-Java%20web%20%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po[&quot;Java web 技术与架构演进&quot;] --&gt; 4e1q0k9lsd6av841kp12f7bic6[&quot;Servlet&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 0cblpslmhsgi0eeg5nitvkk8uq[&quot;JSP(Java Server Pages)&quot;]</span><br><span class="line">0cblpslmhsgi0eeg5nitvkk8uq --&gt; 52hgca1ge7tofdpbeemf5m9f23[&quot;JSP Model1&quot;]</span><br><span class="line">52hgca1ge7tofdpbeemf5m9f23 --&gt; 5ibcln5atnn1rf1k6j1cum2aks[&quot;第一代&quot;]</span><br><span class="line">52hgca1ge7tofdpbeemf5m9f23 --&gt; 26udhcbdsoafe0hl5a8kec8d1a[&quot;第二代&quot;]</span><br><span class="line">0cblpslmhsgi0eeg5nitvkk8uq --&gt; 1vjmf115d2q7g6i6457potk504[&quot;JSP Model2&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 21nka23t8r0v52qoqksjh5b50c[&quot;Struts2&quot;]</span><br><span class="line">21nka23t8r0v52qoqksjh5b50c --&gt; 0fgfrktqjuqpoi0mn18o1jngon[&quot;形成Javaweb 经典三层架构&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 53po8qamnm15v1kq8dmh0e3t7p[&quot;Hibernate 框架&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 2u26u503i1k38m7fo92h2d2dvv[&quot;Spring 框架&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 0m87forg6qikoktvhbavs6rie8[&quot;SSH(Spring-Struts-Hibernate)框架&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 17dgojqvhd90m42qc3mn4bs4v1[&quot;SpringMVC&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 7kdo74unful149lpr50jh35oc1[&quot;SSM(Spring-SpringMVC-MyBatis)框架&quot;]</span><br><span class="line">0j2qp65qqvbdh1554ogjmi30po --&gt; 5ahnl83fhs2pos9k0lk2nvfh1s[&quot;SpringBoot&quot;]</span><br></pre></td></tr></table></figure><h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1. Servlet"></a>1. Servlet</h1><ul><li>Servlet 技术诞生用于使 web 服务器能够提供静态资源之外的动态内容，是扩展了 Web 服务器能力的 Java 软件组件。<br>○ Servlet 的运行依赖于 Servlet 容器（如 Tomcat、Jetty）。<br>○ Servlet 容器提供了遵循 Servlet 规范的接口，开发者实现自 Servlet 接口的 Java 类就称为一个 Servlet，在 Servlet 中定义用于响应请求的具体动态内容。<br>○ 在 Servlet 容器的配置中指定请求 URL 与处理请求的 Servlet 的映射关系，如 Tomcat 配置文件位于”/WEB-INF/web.xml”，映射关系内容示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; ...&gt;</span><br><span class="line">&lt;web-app ...&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;servletClass1&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line"></span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;servlet2&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;servletClass2&lt;/servlet-class&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;servlet1&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/url1&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;servlet2&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/url2&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure><p>○ Servlet 处理客户端请求流程：<br>（1）客户端请求到达 Servlet 容器，Servlet 容器解析请求信息创建相应的”HttpServletRequest”和”HttpServletResponse”对象。<br>（2）Servlet 容器根据请求 URL 映射配置创建或找到对应的 Servlet 实例，创建一个线程并传入“HttpServletRequest”与“HttpServletResponse”对象，再调用 Servlet 实例的 service()方法。<br>（3）Servlet 对象的 doGet()、doPost()等方法处理请求，返回内容交由 Servlet 容器组装成 HTTP 格式返回给客户端。<br>○demo 地址：<a href="https://github.com/congzhou09/servlet_maven_demo">servlet_maven_demo</a></p><h1 id="2-JSP-Java-Server-Pages"><a href="#2-JSP-Java-Server-Pages" class="headerlink" title="2. JSP(Java Server Pages)"></a>2. JSP(Java Server Pages)</h1><p>○ 由于 Servlet 编写前端内容太繁琐，sun 公司又推出了 JSP。<br>○ JSP 文件放到 Servlet 容器的 web 目录下。<br>○ 客户端可直接请求 JSP 文件，得到的内容不是 JSP 原文件而是其中 Java 代码被执行后的内容。<br>○ Servlet 处理请求的返回内容也可以是一个 JSP 文件。<br>○ demo 地址同上：<a href="https://github.com/congzhou09/servlet_maven_demo">servlet_maven_demo</a></p><h1 id="3-JSP-Model1-第一代"><a href="#3-JSP-Model1-第一代" class="headerlink" title="3. JSP Model1 第一代"></a>3. JSP Model1 第一代</h1><p>○ JavaWeb 早期的模型，它适合小型 Web 项目，开发成本低。服务器端只有 JSP 页面，所有的操作都在 JSP 页面中，连访问数据库的 API 也在 JSP 页面中完成。</p><p><img src="F:\笔记\博客\文章图片\jsp_model1_1.png" alt="img"></p><h1 id="4-JSP-Model1-第二代"><a href="#4-JSP-Model1-第二代" class="headerlink" title="4. JSP Model1 第二代"></a>4. JSP Model1 第二代</h1><p>○ 将业务逻辑内容放到 JavaBean，JSP 页面负责显示以及请求调度。虽然第二代比第一代好了些，但 JSP 仍然做了过多的工作，它耦合了视图工作和请求调度（控制器）的工作。</p><p><img src="F:\笔记\博客\文章图片\jsp_model1_2.png" alt="img"></p><h1 id="5-JSP-Model2"><a href="#5-JSP-Model2" class="headerlink" title="5. JSP Model2"></a>5. JSP Model2</h1><p>○ Servlet 与 JSP 之间可以共享数据，JSP Model2 模式将 Servlet 与 JSP 结合使用，做了初级的 MVC 分层：<br>（1）JSP：视图层，用来与用户打交道。负责接收用户的数据，以及显示数据给用户。<br>（2）Servlet：控制层，负责找到合适的模型对象来处理业务逻辑，根据处理结果找到合适的 JSP 页面对用户进行响应。<br>（3）JavaBean：模型层，完成具体的业务数据处理工作。</p><p><img src="F:\笔记\博客\文章图片\jsp_model2.png" alt="img"></p><h1 id="6-Struts-框架（以-Struts2-为准）"><a href="#6-Struts-框架（以-Struts2-为准）" class="headerlink" title="6. Struts 框架（以 Struts2 为准）"></a>6. Struts 框架（以 Struts2 为准）</h1><p>◇ Struts 目的是使视图和业务逻辑清晰的分离，提高开发效率，显著特点如下：<br>（1）提供 Action 机制来处理业务逻辑。<br>（2）提供了一套可在 JSP 中使用的标签，方便在 Action 与 JSP 之间共享数据。<br>◇ Struts 提供的 action 机制的实现基于 Servlet 的 Filter，相当于扩展了的 Filter，也就是 Filter 是 Struts 框架的入口，Struts 根据客户端请求及映射配置(struts-config.xml)实例化对应的 action 和调用其方法处理业务与数据，根据方法返回值及映射配置跳转到对应 JSP 页面或其他网络资源或另一个 action。</p><p><img src="F:\笔记\博客\文章图片\struts_workflow.png" alt="img"></p><p>◇ action 相对于 Servlet 的优点：<br>（1）action 不再继承于 Servlet 从而使业务处理与 Servlet API 解耦更易于测试。<br>（2）每个请求对应一个 action 实例，相比 Servlet 的同一个 URL 的多个请求共用一个 Servlet 对象是线程安全的。<br>◇ 互联网曾经出现很多<em>.do 网址的 JSP 网站而不是</em>.jsp，这通常由于每个.do 对应一个 action，当 action 处理完一系列的业务逻辑后，即使 forward 到 JSP 页面返回给浏览器，浏览器的地址栏中显示的仍然是最初请求的*.do 的 action 地址。<br>◇ demo 地址：<a href="https://github.com/congzhou09/struts2_maven_demo">struts2_maven_demo</a></p><h1 id="7-Javaweb-经典三层架构"><a href="#7-Javaweb-经典三层架构" class="headerlink" title="7. Javaweb 经典三层架构"></a>7. Javaweb 经典三层架构</h1><p>◇ Struts 项目中为避免所有的运算逻辑都放在 Action 导致 Action 类复用度低和逻辑混乱，通常让 action（仍属于 Servlet 范畴）只负责显示，与 JSP 共同组成表现层（web 层），独立出一层业务层（service 层）负责具体业务运算逻辑供 Action 调用，然后通过 JDBC 调用持久层完成数据库的读写的部分独立成数据访问层（dao 层）供业务层使用，由此形成了经典三层架构。<br>○ 业务层中不包含 JavaWeb API 而只关心业务逻辑，数据层只关心对数据库的访问细节而不涉及具体业务逻辑，提高了代码的可重用性。<br>○ MVC 定位为表现层的设计模式。</p><p><img src="F:\笔记\博客\文章图片\three_tier_architecture.png" alt="img"></p><h1 id="8-Hibernate-框架"><a href="#8-Hibernate-框架" class="headerlink" title="8. Hibernate 框架"></a>8. Hibernate 框架</h1><p>◆ Hibernate 是个 ORM（Object Relational Mapping，即对象关系映射）框架，通过创建持久化类来对应数据库中表属性及关联关系，然后通过操作持久化对象就能达到操作数据库的目的，而不需要与 SQL 语句打交道，大大降低了原 JDBC 方式的编程量。<br>◆ Hibernate 原理是对 JDBC 进行了封装，并能自动生成 SQL 语句。</p><h1 id="9-Spring-框架"><a href="#9-Spring-框架" class="headerlink" title="9. Spring 框架"></a>9. Spring 框架</h1><p>■ Spring 框架（Spring framwork，简称 Spring）是一个 JavaSE/EE 全栈开源框架，它从设计上就是分层分模块的架构，可以将对应模块功能的子框架整合到体系中。<br>■ Spring 带来的最显著改变：在 Spring 之前，web 层调用业务层、业务层调用持久层都是通过调用者 new 出被调用者的方式，之间强耦合、复用率低，Spring 通过其核心特性 IoC 实现强依赖的解耦，由 Spring 完成被调用者的 new 实例化并将其注入给依赖者。<br>● demo 地址：<a href="https://github.com/congzhou09/spring_maven_demo">spring_maven_demo</a></p><h1 id="10-SSH-Spring-Struts-Hibernate-框架"><a href="#10-SSH-Spring-Struts-Hibernate-框架" class="headerlink" title="10. SSH(Spring-Struts-Hibernate)框架"></a>10. SSH(Spring-Struts-Hibernate)框架</h1><p>● Spring 框架整合了 Struts 和 Hibernate，形成了 SSH 这个合成框架。<br>● SSH 框架中，Struts 负责表示层，Hibernate 负责持久层，Spring 通过 IoC 特性实现对业务层 JavaBean 的管理，以及对表示层与持久层的黏合。</p><h1 id="11-SpringMVC"><a href="#11-SpringMVC" class="headerlink" title="11. SpringMVC"></a>11. SpringMVC</h1><p>● Spring 开发者逐渐发现 Struts 存在设计缺陷，会导致性能、安全、减少配置复杂度、开发效率等方面的不足，遂开发了自己的 MVC 框架：SpringMVC。<br>● SpringMVC 接受请求的入口是 DispatcherServlet ，不同于 Struts 基于 Servlet 的 Filter，它是派生自 HttpServlet 的一个 Servlet，请求会交付给对应的 Controller 做处理。<br>● SpringMVC 的因其更清晰的层级分离、更强大直接的配置等优势逐渐成为 Spring Web 模块的主流子框架。<br>● demo 地址：<a href="https://github.com/congzhou09/spring_maven_demo">spring_maven_demo</a></p><h1 id="12-SSM-Spring-SpringMVC-MyBatis-框架"><a href="#12-SSM-Spring-SpringMVC-MyBatis-框架" class="headerlink" title="12. SSM(Spring-SpringMVC-MyBatis)框架"></a>12. SSM(Spring-SpringMVC-MyBatis)框架</h1><p>△ SSM 框架分别用 SpringMVC 和 MyBatis 替代 SSH 框架中的 Struts 和 Hibernate，MyBatis 适用于数据源复杂度较低的场景。</p><h1 id="13-SpringBoot"><a href="#13-SpringBoot" class="headerlink" title="13. SpringBoot"></a>13. SpringBoot</h1><p>● Spring Boot 是对 Spring 工作流层面的演进，实现基于 Spring 的更便捷的生产级别应用。<br>● Spring Boot 的优点：<br>（1）内嵌 Servlet 容器，独立运行的 Spring 项目，Spring Boot 可以内嵌 Tomcat，以 java -jar xx.jar 包的形式来运行一个 Spring Boot 应用，省略了 war 包部署的繁琐。<br>（2）提供 starter 机制简化 Maven 依赖管理与 Spring 配置，如仅需要引入“spring-boot-starter-web”就可以包含 Spring 和 SpringMVC 相关的依赖和配置。<br>● demo 地址：<a href="https://github.com/congzhou09/springboot_maven_demo">springboot_maven_demo</a></p><p><a href="https://congzhou09.github.io/knowledge/Java-web-%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B%E5%8E%86%E5%8F%B2.html#Javaweb-%E7%BB%8F%E5%85%B8%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84">参考文章</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-09-Google%20Search/"/>
      <url>/2024/10/28/2024-06-09-Google%20Search/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Google-Advanced-Search-Operators"><a href="#1-Google-Advanced-Search-Operators" class="headerlink" title="1. Google Advanced Search Operators"></a>1. Google Advanced Search Operators</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>&quot;&quot;</code></td><td>Allows searching for a specific phrase - exact match search. Individual word prevents synonyms</td><td>Basic,Mail</td></tr><tr><td><code>OR</code>/<code>AND</code></td><td>Boolean search function for OR searches as Google defaults to AND between words - must be all caps</td><td>Basic,Mail</td></tr><tr><td><code>\</code></td><td>Implements OR</td><td>Basic</td></tr><tr><td><code>()</code></td><td>Allows grouping of operators and helps dictate order</td><td>Basic,Mail</td></tr><tr><td><code>-</code></td><td>Excludes a word from results</td><td>Basic,Mail</td></tr><tr><td><code>*</code></td><td>Acts as a wildcard and will match any word or phrase</td><td>Basic</td></tr><tr><td><code>#..#</code></td><td># represents a number in this instance. Use to find numbers in a series.</td><td>Basic</td></tr><tr><td><code>$</code></td><td>Allows for search of USD</td><td>Basic</td></tr><tr><td><code>€</code></td><td>Allows for search of Euro</td><td>Basic</td></tr><tr><td><code>in</code></td><td>Allows searches for unit conversion (currency, unit or measure)</td><td>Basic</td></tr><tr><td><code>~</code></td><td>Prefix - Include synonyms (potentially defunct)</td><td>Basic</td></tr><tr><td><code>+</code></td><td>Prefix - Force exact match on single phrase</td><td>Basic,Mail</td></tr><tr><td><code>AROUND(X)</code></td><td>This is sandwiched between two words and the X declares how many words they must be mentioned between. I.e. if it’s (4) then the two keywords must be mentioned within 4 words of each other.</td><td>Advanced</td></tr><tr><td><code>_</code></td><td>Acts as wildcard for autocomplete</td><td>Advanced</td></tr></tbody></table></div><h1 id="2-Search-with-url"><a href="#2-Search-with-url" class="headerlink" title="2. Search with url"></a>2. Search with url</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>inurl:</code></td><td>Only returns results where the queried keyword(s) is present in the URL</td><td>Advanced</td></tr><tr><td><code>allinurl:</code></td><td>As above but only containing all of the specified words in the URL</td><td>Advanced</td></tr><tr><td><code>blogurl:</code></td><td>Find blog URLs under a specific domain. This was used in Google blog search, but I’ve found it does return some results in regular search.</td><td>Advanced</td></tr><tr><td><code>site:</code></td><td>Limit results to those from one site</td><td>Advanced</td></tr><tr><td><code>related:</code></td><td>Find similar domains to the queried domain</td><td>Advanced</td></tr></tbody></table></div><h1 id="3-Search-with-dates"><a href="#3-Search-with-dates" class="headerlink" title="3. Search with dates"></a>3. Search with dates</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>daterange:</code></td><td>Return results in a specified range (requires julian dates)</td><td>Advanced</td></tr><tr><td><code>after:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received anytime after a set date</td><td>Drive,Mail</td></tr><tr><td><code>before:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received before a certain date</td><td>Drive,Mail</td></tr><tr><td><code>older:</code></td><td>Search for messages older than a certain date</td><td>Mail</td></tr><tr><td><code>newer:</code></td><td>Search for messages newer than a certain date</td><td>Mail</td></tr></tbody></table></div><h1 id="4-Search-files"><a href="#4-Search-files" class="headerlink" title="4. Search files"></a>4. Search files</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>filename:</code></td><td>Search for messages with a particular type of file attached, or the exact name of a file</td><td>Mail</td></tr><tr><td><code>type:</code></td><td>Allows you to search drive by file type</td><td>Drive</td></tr><tr><td><code>owner:</code></td><td>Allows you to search drive by owner of file or folder</td><td>Drive</td></tr><tr><td><code>to:</code></td><td>Allows you to search drive for files shared with a specific person</td><td>Drive</td></tr><tr><td><code>title:</code></td><td>Searches drive for files with the keyword in their title alone</td><td>Drive</td></tr><tr><td><code>source:domain</code></td><td>Allows you to search for files or folders shared with everyone in your business</td><td>Drive</td></tr><tr><td><code>filetype:</code></td><td>Returns only files of a particular type associated with the keyword searched</td><td>Advanced</td></tr><tr><td><code>ext:</code></td><td>As above, based on extension</td><td>Advanced</td></tr><tr><td><code>after:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received anytime after a set date</td><td>Drive,Mail</td></tr><tr><td><code>before:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received before a certain date</td><td>Drive,Mail</td></tr><tr><td><code>is:trashed</code></td><td>Searches for the item in the Drive bin</td><td>Drive</td></tr></tbody></table></div><h1 id="5-Search-with-page-content"><a href="#5-Search-with-page-content" class="headerlink" title="5. Search with page content"></a>5. Search with page content</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>link:</code></td><td>Find pages that link to the target domain</td><td>Advanced</td></tr><tr><td><code>inanchor:</code></td><td>Find pages linked to with the specified anchor text/ phrase. Data is heavily sampled.</td><td>Advanced</td></tr><tr><td><code>allinanchor:</code></td><td>Find pages with all individual terms after “inanchor:” in the inbound anchor text.</td><td>Advanced</td></tr><tr><td><code>intitle:</code></td><td>Returns pages based on the searched query appearing in their title</td><td>Advanced</td></tr><tr><td><code>allintitle:</code></td><td>Similar to intitle: but only returns titles where all the words in the title match</td><td>Advanced</td></tr><tr><td><code>inposttile:</code></td><td>Finds pages with keywords in their post titles (i.e. for researching blogs)</td><td>&nbsp;</td></tr><tr><td><code>intext:</code></td><td>Finds pages where the keyword(s) are mentioned within the page content.</td><td>Advanced</td></tr><tr><td><code>allintext:</code></td><td>Similar to “intext,” but only results containing all of the specified words somewhere on the page will be returned.</td><td>Advanced</td></tr></tbody></table></div><h1 id="6-Keywords"><a href="#6-Keywords" class="headerlink" title="6. Keywords"></a>6. Keywords</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>Business</code></td><td>type E.g. cafe, restaurant, bar etc will return a selection of appropriate businesses in the are</td><td>Maps</td></tr><tr><td><code>Petrol/Charging</code></td><td>Station EV near me or perol station near me returns</td><td>Maps</td></tr><tr><td><code>Search</code></td><td>for a message with a google sheet attached</td><td>Mail</td></tr><tr><td><code>Search</code></td><td>for a message with a google presentation attached</td><td>Mail</td></tr></tbody></table></div><h1 id="7-Search-on-emails"><a href="#7-Search-on-emails" class="headerlink" title="7. Search on emails"></a>7. Search on emails</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>+</code></td><td>Prefix - Force exact match on single phrase</td><td>Basic,Mail</td></tr><tr><td><code>()</code></td><td>Allows grouping of operators and helps dictate order</td><td>Basic,Mail</td></tr><tr><td><code>-</code></td><td>Excludes a word from results</td><td>Basic,Mail</td></tr><tr><td><code>&quot;&quot;</code></td><td>Allows searching for a specific phrase - exact match search. Individual word prevents synonyms</td><td>Basic,Mail</td></tr><tr><td><code>OR</code>/<code>AND</code></td><td>Boolean search function for OR searches as Google defaults to AND between words - must be all caps</td><td>Basic,Mail</td></tr><tr><td><code>after:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received anytime after a set date</td><td>Drive,Mail</td></tr><tr><td><code>before:</code></td><td>Allows you to search drive or mail for files modified or mail sent/received before a certain date</td><td>Drive,Mail</td></tr><tr><td><code>is:starred</code></td><td>Searches only items that have been starred in drive</td><td>Drive,Mail</td></tr><tr><td><code>from:</code></td><td>Specify the sender in google mail</td><td>Mail</td></tr><tr><td><code>to:</code></td><td>Specify the recipient in google mail</td><td>Mail</td></tr><tr><td><code>cc:</code></td><td>Search by a recipient that was copied into an email</td><td>Mail</td></tr><tr><td><code>bcc:</code></td><td>Search by a recipient that was blind copied into an email</td><td>Mail</td></tr><tr><td><code>older:</code></td><td>Search for messages older than a certain date</td><td>Mail</td></tr><tr><td><code>newer:</code></td><td>Search for messages newer than a certain date</td><td>Mail</td></tr><tr><td><code>Search</code></td><td>for a message with a google sheet attached</td><td>Mail</td></tr><tr><td><code>Search</code></td><td>for a message with a google presentation attached</td><td>Mail</td></tr><tr><td><code>AROUND</code></td><td>Similar to the normal google search function, allows you to search for keywords near each other.</td><td>Mail</td></tr><tr><td><code>subject:</code></td><td>Search by keywords featured in the subject line</td><td>Mail</td></tr><tr><td><code>&#123;&#125;</code></td><td>Use for OR in mail instead of the OR function</td><td>Mail</td></tr><tr><td><code>label:</code></td><td>Search for messages that have a certain label</td><td>Mail</td></tr><tr><td><code>has:attachment</code></td><td>Search for messages that have an item attached</td><td>Mail</td></tr><tr><td><code>has:drive</code></td><td>Search for messages with a google drive attached</td><td>Mail</td></tr><tr><td><code>has:document</code></td><td>Search for messages with a google doc attached</td><td>Mail</td></tr><tr><td><code>has:youtube</code></td><td>Search for a message containing a youtube video</td><td>Mail</td></tr><tr><td><code>list:</code></td><td>Search for all messages from a particular mailing list</td><td>Mail</td></tr><tr><td><code>in:anywhere</code></td><td>Includes all folders in your search, including spam and bin</td><td>Mail</td></tr><tr><td><code>is:important</code></td><td>Search for messages that have been marked as important</td><td>Mail</td></tr><tr><td><code>label:important</code></td><td>Same as is:important</td><td>Mail</td></tr><tr><td><code>is:snoozed</code></td><td>Searches for messages that have been snoozed</td><td>Mail</td></tr><tr><td><code>is:unread</code></td><td>Searches for unread messages</td><td>Mail</td></tr><tr><td><code>is:read</code></td><td>searches for read messages only</td><td>Mail</td></tr><tr><td><code>has:yellow-star</code></td><td>Searches for messages with coloured star icon</td><td>Mail</td></tr><tr><td><code>has:blue-info</code></td><td>Searches for messages with colourd icon</td><td>Mail</td></tr><tr><td><code>is:chat</code></td><td>Searches for messagse from chat</td><td>Mail</td></tr><tr><td><code>deliveredto:</code></td><td>Search by email address for delivered messages</td><td>Mail</td></tr><tr><td><code>category:</code></td><td>Searches by messages based on category. Follow the colon with the categoy name, i.e. category:primary</td><td>Mail</td></tr><tr><td><code>size:</code></td><td>Messages larger than a certain size in bytes</td><td>Mail</td></tr><tr><td><code>larger:</code></td><td>Messages larger than a certain size in bytes</td><td>Mail</td></tr><tr><td><code>smaller:</code></td><td>Messages smaller than a certain size in bytes</td><td>Mail</td></tr><tr><td><code>has:userlabels</code></td><td>Search for messages that have custom user labels</td><td>Mail</td></tr><tr><td><code> </code></td><td>Search for messages that have no custom user labels</td><td>Mail</td></tr></tbody></table></div><h1 id="8-Some-other-useful-search-operators"><a href="#8-Some-other-useful-search-operators" class="headerlink" title="8. Some other useful search operators"></a>8. Some other useful search operators</h1><div class="table-container"><table><thead><tr><th>Operator</th><th>Description</th><th>Category</th></tr></thead><tbody><tr><td><code>define:</code></td><td>Pulls a card response from Google displaying the dictionary definition of the word or phrase</td><td>Advanced</td></tr><tr><td><code>cache:</code></td><td>Returns the most up to date cache of an indexed web page</td><td>Advanced</td></tr><tr><td><code>weather:</code></td><td>Brings up the featured snipped for weather for that location</td><td>Advanced</td></tr><tr><td><code>stocks:</code></td><td>Returns stock information for the specified ticker</td><td>Advanced</td></tr><tr><td><code>map:</code></td><td>Force google map results for a particular query</td><td>Advanced</td></tr><tr><td><code>movie:</code></td><td>Find information for the specified movie (particularly useful when that movie has an ambiguous name). If the movie is still in theatres it’ll also return screen times</td><td>Advanced</td></tr><tr><td><code>source:</code></td><td>Use in google news, returns results from the specified source</td><td>Advanced</td></tr><tr><td><code>loc:</code></td><td>Returns results for a specific location</td><td>Advanced</td></tr><tr><td><code>location:</code></td><td>As above but with Google news</td><td>Advanced</td></tr><tr><td><code>info:</code></td><td>Returns information related to a domain (pages with domain text, similar on-site pages, cache etc)</td><td>Advanced</td></tr><tr><td><code>near</code></td><td>Part of the google maps lazy searches e.g. book shops near work</td><td>Maps</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-27-Docker%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2024-06-27-Docker%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么需要最佳实践"><a href="#1-为什么需要最佳实践" class="headerlink" title="1. 为什么需要最佳实践"></a>1. 为什么需要最佳实践</h1><p>主要有以下几方面的需要:</p><ul><li>提高安全性</li><li>优化Docker image 的大小</li><li>充分利用Docker有用的功能</li><li>编写易于维护的Dockerfile 文件</li></ul><h1 id="2-容器应该是短暂的"><a href="#2-容器应该是短暂的" class="headerlink" title="2. 容器应该是短暂的"></a>2. 容器应该是短暂的</h1><p><strong>短暂</strong> 意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的</p><p>容器最初是针对无状态的应用而设计的，在逻辑上，容器内应用产生的临时数据也属于该容器的一部分。用容器创建起一个服务，用完之后销毁它。这些应用本身没有状态，状态通常保存在容器外部的数据库里，这是经典的架构与用法，也是容器的设计哲学。  </p><p>但当用户想把数据库本身也放到容器中时，事情就变得不一样了：数据库是有状态的，为了维持这个状态不随容器停止而销毁，数据库容器需要在容器上打一个洞，与底层操作系统上的数据卷相联通。这样的容器，不再是一个能够随意创建，销毁，搬运，转移的对象，而是与底层环境相绑定的对象。因此，传统应用使用容器的诸多优势，对于数据库容器来说都不复存在。</p><p><strong>总结</strong></p><p>对于开发环境而言，可以将数据库放入Docker中。对于生产环境的无状态应用，甚至一些带有衍生状态的不甚重要衍生数据系统（如Redis缓存），Docker也是一个不错的选择。但对于生产环境的核心关系型数据库而言，使用Docker前还望三思</p><h1 id="3-一个容器只运行一个进程"><a href="#3-一个容器只运行一个进程" class="headerlink" title="3. 一个容器只运行一个进程"></a>3. 一个容器只运行一个进程</h1><p>应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存</p><h1 id="4-docker镜像"><a href="#4-docker镜像" class="headerlink" title="4. docker镜像"></a>4. docker镜像</h1><p>使用固定版本的镜像，带有 <code>latest</code>标签的镜像就是最新版本的镜像，存在不稳定或未发现的问题</p><p>Alpine 镜像具备启动容器应用所需的一切，但更加轻量级</p><h1 id="5-使用-dockerignore-文件"><a href="#5-使用-dockerignore-文件" class="headerlink" title="5. 使用 .dockerignore 文件"></a>5. 使用 .dockerignore 文件</h1><p>创建一个名为<code>.dockerignore</code>的文件，然后列出所有要忽略的文件和文件夹，在构建镜像时，Docker会查看其内容并忽略其中指定的任何内容</p><h1 id="6-使用-docker的多阶段构建"><a href="#6-使用-docker的多阶段构建" class="headerlink" title="6. 使用 docker的多阶段构建"></a>6. 使用 docker的多阶段构建</h1><p>多阶段构建功能允许我们在构建过程中使用多个临时镜像，但只保留最新的镜像作为最终产物</p><h1 id="7-使用最低权限的用户"><a href="#7-使用最低权限的用户" class="headerlink" title="7. 使用最低权限的用户"></a>7. 使用最低权限的用户</h1><p>默认情况下，当Dockerfile没有指定用户时，它使用root用户。但实际上大多数情况下没有必要以root权限运行容器。最佳做法是在Docker镜像中创建一个专用用户和专用组来运行应用程序，并且在容器内使用该用户来运行应用程序。一些镜像中已经包含了一个通用用户，我们可以使用它。因此，我们不需要创建新的用户。例如，node.js 图像已经捆绑了一个名为 <code>node</code> 的通用用户，可以直接使用该用户在容器内运行应用程序</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-25-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2024/10/28/2024-06-25-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>基于《数据库系统概论》第5版 王珊 编著</strong></p><h1 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h1><h2 id="1-1-数据库系统概述"><a href="#1-1-数据库系统概述" class="headerlink" title="1.1. 数据库系统概述"></a>1.1. 数据库系统概述</h2><h3 id="1-1-1-四个基本概念"><a href="#1-1-1-四个基本概念" class="headerlink" title="1.1.1. 四个基本概念"></a>1.1.1. 四个基本概念</h3><p><strong>数据Data</strong></p><p>数据是数据库中存储的基本对象</p><p>数据的种类：文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</p><p><strong>DB数据库（Database）</strong></p><p>是<code>长期储存</code>在<code>计算机内</code>、<code>有组织</code>、<code>可共享</code>的大量<code>数据</code>的<code>集合</code></p><p>数据库的基本特征</p><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>数据独立性较高</li><li>易扩展</li></ul><p><strong>DBMS数据库管理系统（Database Management System）</strong></p><p>DBMS是位于用户与操作系统之间的一层<code>数据管理软件</code>，是基础软件</p><p>DBMS的用途：科学地组织和存储数据、高效地获取和维护数据</p><p>DBMS的主要功能</p><ul><li><p><code>数据定义功能</code><br>  提供数据定义语言（DDL）<br>  定义数据库中的数据对象</p></li><li><p><code>数据组织、存储和管理</code><br>  分类组织、存储和管理各种数据<br>  确定组织数据的文件结构和存取方式<br>  实现数据之间的联系<br>  提供多种存取方法提高存取效率</p></li><li><p><code>数据操纵功能</code><br>  提供数据操纵语言（DML）<br>  实现对数据库的基本操作（查询、插入、删除和修改）</p></li><li><p><code>数据库的事务管理和运行管理</code><br>  数据库在建立、运行和维护时由DBMS统一管理和控制<br>  保证数据的安全性、完整性、多用户对数据的并发使用<br>  发生故障后的系统恢复</p></li><li><p><code>数据库的建立和维护功能(实用程序)</code><br>  数据库初始数据装载转换<br>  数据库转储<br>  介质故障恢复<br>  数据库的重组织<br>  性能监视分析等</p></li><li><p><code>其它功能</code><br>  DBMS与网络中其它软件系统的通信<br>  两个DBMS系统的数据转换<br>  异构数据库之间的互访和互操作</p></li></ul><p>如：MySQL、Oracle、Microsoft SQL Server等，这些系统用来创建、管理和维护数据库</p><p><strong>DBS数据库系统（Database System）</strong></p><p>数据库系统的构成</p><ul><li>数据库 Database</li><li>数据库管理系统（及其开发工具）Database Management System</li><li>应用系统</li><li>数据库管理员 Database Administrator</li></ul><p>数据库系统的特点</p><ul><li>数据结构化</li><li>数据的共享性高，冗余度低，易扩充</li><li>数据独立性高<ul><li><code>物理独立性</code><br>  指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。当数据的物理存储改变了，应用程序不用改变。</li><li><code>逻辑独立性</code><br>  指用户的应用程序与数据库的逻辑结构是相互独立的。数据的逻辑结构改变了，用户程序也可以不变。</li><li>数据独立性是由DBMS的二级映像功能来保证的</li></ul></li><li>数据由DBMS统一管理和控制<ul><li>(1)·<code>数据的安全性（Security）保护·</code><br>  保护数据，以防止不合法的使用造成的数据的泄密和破坏。</li><li>(2)<code>数据的完整性（Integrity）检查</code><br>  将数据控制在有效的范围内，或保证数据之间满足一定的关系。</li><li>(3)<code>并发（Concurrency）控制</code><br>  对多用户的并发操作加以控制和协调，防止相互干扰而得到错误的结果。</li><li>(4)<code>数据库恢复（Recovery）</code><br>  将数据库从错误状态恢复到某一已知的正确状态。</li></ul></li></ul><p>如：电子商务网站，在线银行系统、医院的信息管理，这些系统可以使用各种类型的数据来支持业务需求和决策。</p><h3 id="1-1-2-数据管理技术的产生和发展"><a href="#1-1-2-数据管理技术的产生和发展" class="headerlink" title="1.1.2. 数据管理技术的产生和发展"></a>1.1.2. 数据管理技术的产生和发展</h3><p>什么是数据管理：对数据进行分类、组织、编码、存储、检索和维护</p><h2 id="1-2-数据模型"><a href="#1-2-数据模型" class="headerlink" title="1.2. 数据模型"></a>1.2. 数据模型</h2><h3 id="1-2-1-数据模型的概念"><a href="#1-2-1-数据模型的概念" class="headerlink" title="1.2.1. 数据模型的概念"></a>1.2.1. 数据模型的概念</h3><p>通俗地讲数据模型就是<code>现实世界的模拟</code></p><p><strong>数据模型应满足三方面要求：</strong></p><ul><li>能比较<code>真实</code>地模拟现实世界</li><li><code>容易</code>为人所<code>理解</code></li><li><p>便于在计算机上<code>实现</code></p><h3 id="1-2-2-两大类数据模型"><a href="#1-2-2-两大类数据模型" class="headerlink" title="1.2.2. 两大类数据模型"></a>1.2.2. 两大类数据模型</h3></li><li><p>(1) <code>概念模型 也称信息模型</code>，它是按<code>用户的观点</code>来对数据和信息建模，用于数据库设计。</p></li><li>(2) <code>逻辑模型</code>和<code>物理模型</code><br>  <strong>逻辑模型</strong>主要包括<code>网状模型</code>、<code>层次模型</code>、<code>关系模型</code>、<code>面向对象模型</code>等，按<code>计算机系统的观点</code>对数据建模，用于DBMS实现。<br>  <strong>物理模型</strong>是对数据最底层的抽象，描述数据在系统内部的表示方式和存取方法，在磁盘或磁带上的存储方式和存取方法。</li></ul><p>客观对象的抽象过程—两步抽象</p><ul><li>现实世界中的客观对象抽象为<code>概念模型</code>；</li><li>把<code>概念模型</code>转换为某一DBMS支持的<code>数据模型</code>。</li></ul><h3 id="1-2-3-数据模型的组成要素"><a href="#1-2-3-数据模型的组成要素" class="headerlink" title="1.2.3. 数据模型的组成要素"></a>1.2.3. 数据模型的组成要素</h3><ul><li><p>数据结构</p><p>  <strong>数据结构是所研究的对象类型的集合</strong>。这些对象是数据库的组成成分，数据结构指对象和对象间联系的表达和实现，是对系统静态特征的描述，包括两个方面：<br>  （1）数据本身：类型、内容、性质。例如关系模型中的域、属性、关系等。<br>  （2）数据之间的联系：数据之间是如何相互关联的，例如关系模型中的主码、外码联系等。</p></li><li><p>数据操作</p><p>  <strong>数据操作</strong></p><ul><li><p>对数据库中各种<code>对象(型)</code>的<code>实例(值)</code>允许执行的<code>操作</code>，及有关的<code>操作规则</code></p><p><strong>数据操作的类型</strong></p></li><li><p>查询</p></li><li>更新(包括插入、删除、修改)</li></ul></li><li><p>数据的完整性约束条件</p><ul><li><strong>数据的完整性约束条件</strong>是一组<code>完整性规则</code>的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。</li><li>完整性规则：给定的数据模型中数据及其联系所具有的制约和储存规则</li></ul></li></ul><h3 id="1-2-4-概念模型"><a href="#1-2-4-概念模型" class="headerlink" title="1.2.4. 概念模型"></a>1.2.4. 概念模型</h3><p>信息世界中的基本概念</p><ul><li>(1) <code>实体</code>（Entity）<br>  <code>客观存在并可相互区别的事物</code>称为实体。<br>  可以是具体的人、事、物或抽象的概念。</li><li>(2) <code>属性</code>（Attribute）<br>  <code>实体</code>所具有的某一<code>特性</code>称为属性。<br>  一个实体可以由若干个属性来刻画。</li><li>(3) <code>码</code>（Key）<br>  <code>唯一标识实体的属性</code>集称为码。<br>  (4) <code>域</code>（Domain）<br>  <code>属性</code>的<code>取值范围</code>称为该属性的域。</li><li>(5) <code>实体型</code>（Entity Type）<br>  用<code>实体名</code>及其<code>属性名集合</code>来抽象和刻画<code>同类实体</code>称为实体型</li><li>(6) <code>实体集</code>（Entity Set）<br>  <code>同一类型实体的集合</code>称为实体集</li><li>(7) <code>联系</code>（Relationship）<ul><li>现实世界中<code>事物内部</code>以及<code>事物之间</code>的<code>联系</code>在信息世界中反映为实体内部的联系和实体之间的联系。</li><li>实体<code>内部的联系</code>通常是指组成实体的<code>各属性之间</code>的联系</li><li>实体<code>之间的联系</code>通常是指<code>不同实体集之间</code>的联系</li></ul></li></ul><p>两个实体型之间的联系</p><ul><li>一对一联系（1:1）</li><li>一对多联系（1:n）</li><li>多对多联系（m:n）</li></ul><p>概念模型的一种表示方法：实体－联系方法(E-R方法)(Entity Relationship Diagram)</p><p><code>联系本身</code>也是一种<code>实体型</code>，<code>也可以有属性</code>。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来</p><h3 id="1-2-5-关系模型"><a href="#1-2-5-关系模型" class="headerlink" title="1.2.5. 关系模型"></a>1.2.5. 关系模型</h3><p>关系数据库系统采用<code>关系模型</code>作为数据的组织方式</p><p><code>关系模型中数据的逻辑结构</code>是一张<code>二维表</code>，它由<code>行</code>和<code>列</code>组成</p><p>几个名词解释：</p><ul><li><p><code>关系</code>（Relation）<br>  一个关系对应通常说的一张表</p></li><li><p><code>元组</code>（Tuple）<br>  表中的一行即为一个元组</p></li><li><p><code>属性</code>（Attribute）<br>  表中的一列即为一个属性，给每一个属性起一个名称即属性名</p></li><li><p><code>主码</code>（Key）<br>  表中的某个<code>属性组</code>，它可以<code>唯一确定一个元组</code>。</p></li><li><p><code>域</code>（Domain）<br>  属性的取值范围。</p></li><li><p><code>分量</code><br>  元组中的一个属性值。</p></li><li><p><code>关系模式</code><br>  对关系的描述<br>  关系名（属性1，属性2，…，属性n）<br>  学生（学号，姓名，年龄，性别，系，年级）</p></li><li><p>规范化</p><ul><li>关系必须是规范化的，满足一定的规范条件</li><li>最基本的规范条件：<code>关系的每一个分量必须是一个不可分的数据项, 不允许表中还有表</code></li></ul></li></ul><p>关系数据模型的操纵与完整性约束：</p><ul><li><code>数据操作</code>是集合操作，操作对象和操作结果都是关系  </li><li>关系的<code>完整性约束条件</code>  <ul><li>实体完整性  </li><li>参照完整性  </li><li>用户定义的完整性</li></ul></li></ul><p>优缺点：</p><ul><li><code>优点</code><ul><li>建立在严格的数学概念的基础上;</li><li>概念单一:<br>  实体和各类联系都用关系来表示;<br>  对数据的检索结果也是关系;</li><li>关系模型的存取路径对用户透明;<br>  具有更高的数据独立性，更好的安全保密性<br>  简化了程序员的工作和数据库开发建立的工作;</li></ul></li><li><code>缺点</code><ul><li>存取路径对用户透明导致查询效率往往不如非关系数据模型;</li><li>为提高性能，必须对用户的查询请求进行优化,增加了开发DBMS的难度;<h2 id="1-3-数据库系统结构和组成"><a href="#1-3-数据库系统结构和组成" class="headerlink" title="1.3. 数据库系统结构和组成"></a>1.3. 数据库系统结构和组成</h2></li></ul></li></ul><h3 id="1-3-1-数据库系统结构"><a href="#1-3-1-数据库系统结构" class="headerlink" title="1.3.1. 数据库系统结构"></a>1.3.1. 数据库系统结构</h3><p><strong>两种角度</strong></p><ul><li><p>从数据库<code>管理系统角度</code>看，数据库系统通常采用三级模式结构，是数据库系统<code>内部</code>的系统结构</p></li><li><p>从数据库<code>最终用户角度</code>看（数据库系统<code>外部</code>的体系结构） ，数据库系统的结构分为:  </p><ul><li>单用户结构  </li><li>主从式结构  </li><li>分布式结构  </li><li>客户／服务器  </li><li>浏览器／应用服务器／数据库服务器多层结构等</li></ul></li></ul><p><strong>数据库系统模式的概念</strong></p><blockquote><p>来自张教授的解疑：<code>模式是数据库结构的描述、关系模式是表的结构的描述</code>;</p></blockquote><p>“型” 和“值” 的概念：</p><ul><li>型(Type)<br>  对某一类数据的结构和属性的说明</li><li>值(Value)<br>  是型的一个具体赋值</li></ul><p>学生记录型：<br>（学号，姓名，性别，系别，年龄，籍贯）<br>一个记录值：<br>（900201，李明，男，计算机，22，江苏）</p><p>模式（Schema）：</p><ul><li><code>数据库逻辑结构和特征的描述</code></li><li><code>是型的描述</code></li><li>反映的是数据的结构及其联系</li><li>模式是相对稳定的</li></ul><p>实例（Instance）：</p><ul><li>模式的一个具体值</li><li><code>反映数据库某一时刻的状态</code></li><li><code>同一个模式可以有很多实例</code></li><li>实例随数据库中的数据的更新而变动</li></ul><p><code>例如</code>：在学生选课<code>数据库模式</code>中，包含学生记录、课程记录和学生选课记录</p><ul><li>2003年的一个学生数据库<code>实例</code>，包含：<br>  2003年学校中所有学生的记录<br>  学校开设的所有课程的记录<br>  所有学生选课的记录</li><li><code>2002</code>年度学生<code>数据库模式对应的实例</code>与<code>2003</code>年度学生<code>数据库模式对应的实例</code>是不同的</li></ul><p><strong>数据库系统的三级模式结构</strong></p><p>模式的地位：是数据库系统模式结构的中间层</p><ul><li>与数据的物理存储细节和硬件环境无关</li><li>与具体的应用程序、开发工具及高级程序设计语言无关</li></ul><p>模式的定义:</p><ul><li>数据的逻辑结构（数据项的名字、类型、取值范围等）</li><li>数据之间的联系</li><li>数据有关的安全性、完整性要求</li></ul><p>外模式（External Schema）（也称子模式或用户模式）</p><ul><li>数据库用户（包括应用程序员和最终用户）使用的<code>局部</code>数据的逻辑结构和特征的描述</li><li>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示</li></ul><p>外模式的地位：介于模式与应用之间</p><ul><li>模式与外模式的关系：一对多<br>  外模式通常是模式的子集;<br>  一个<code>数据库</code>可以有多个<code>外模式</code>。反映了不同的用户的应用需求、看待数据的方式、对数据保密的要求;<br>  对模式中同一数据，在外模式中的结构、类型、长度、保密级别等都可以不同;</li><li>外模式与应用的关系：一对多<br>  同一外模式也可以为某一用户的多个应用系统所使用;<br>  但一个应用程序只能使用一个外模式;</li></ul><p>外模式的用途</p><ul><li>保证数据库安全性的一个有力措施；</li><li>每个用户只能看见和访问所对应的外模式中的数据；</li></ul><p>内模式（Internal Schema）（也称存储模式）</p><ul><li>是数据<code>物理结构和存储方式</code>的描述</li><li>是<code>数据</code>在<code>数据库内部</code>的表示方式:<ul><li>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）</li><li>索引的组织方式</li><li>数据是否压缩存储</li><li>数据是否加密</li><li>数据存储记录结构的规定</li></ul></li><li><code>一个数据库只有一个内模式</code></li></ul><p><strong>——数据库模式、外模式、内模式总结——</strong></p><p>外模式(External Schema或User View)的例子:</p><ul><li>假设一个学校数据库,学生可以看到自己的成绩、课程信息等,这就是学生的外模式。</li><li>老师可以看到所有学生的成绩信息,这就是老师的外模式。</li><li>管理员可以查看和管理整个学校的所有信息,这就是管理员的外模式。</li></ul><p>模式(Conceptual Schema或Logical Schema)的例子:</p><ul><li>概念模式描述了整个学校数据库中所有的实体,如学生、课程、老师、成绩等,以及它们之间的关系。</li><li>比如学生和课程之间是多对多的关系,一个学生可以选多门课程,一门课程也可以有多个学生选修。</li></ul><p>内模式(Internal Schema或Physical Schema)的例子:</p><ul><li>内模式描述了数据在物理存储层面的组织方式,比如使用什么样的文件组织结构、索引机制等。</li><li>比如学生信息可以存储在B+树索引的文件中,成绩信息存储在hash表中。这些细节都属于内模式。</li></ul><p><strong>——数据库的二级映像功能——</strong></p><ul><li><p><code>三级模式是对数据的三个抽象级别</code></p></li><li><p><code>二级映象</code>在DBMS内部实现这<code>三个抽象层次</code>的<code>联系</code>和<code>转换</code></p><ul><li>外模式／模式映像</li><li>模式／内模式映像</li></ul></li></ul><p><strong>外模式／内模式映象定义了<code>数据局部逻辑结构</code>与<code>数据全局逻辑结构</code>的对应关系。</strong></p><ul><li>映象定义通常包含在各自外模式的描述中</li><li><strong>保证数据的逻辑独立性</strong><ul><li>当<code>模式改变</code>时（例如在模式中增加或删除了某些属性，只要不影响到各个外模式），数据库管理员<code>修改有关的外模式／模式映象</code>，使<code>外模式</code>保持<code>不变</code></li><li>应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称<code>数据的逻辑独立性</code>。</li></ul></li><li>同<code>一个模式</code>可以有任意<code>多个外模式</code></li></ul><p><strong>模式／内模式映象定义了<code>数据全局逻辑结构</code>与<code>存储结构之间</code>的对应关系。</strong></p><ul><li>数据库中<code>模式／内模式映象</code>是<code>唯一</code>的</li><li>该映象定义通常包含在模式描述中</li><li><strong>保证数据的物理独立性</strong><ul><li>当<code>内模式改变</code>时（例如把学生信息从文件存储改为数据库存储，或者把索引机制从B+树改为哈希表），数据库管理员<code>修改模式／内模式映象</code>，使模式保持<code>不变</code></li><li>应用程序不受影响。保证了数据与程序的物理独立性，简称<code>数据的物理独立性</code>。</li></ul></li></ul><h3 id="1-3-2-数据库的组成"><a href="#1-3-2-数据库的组成" class="headerlink" title="1.3.2. 数据库的组成"></a>1.3.2. 数据库的组成</h3><ul><li>数据库</li><li>数据库管理系统（及其开发工具）</li><li>应用系统</li><li>数据库管理员</li><li>硬件平台及数据库</li><li>软件</li><li>人员<h1 id="2-关系数据库"><a href="#2-关系数据库" class="headerlink" title="2. 关系数据库"></a>2. 关系数据库</h1></li></ul><h2 id="2-1-关系数据结构及形式化定义"><a href="#2-1-关系数据结构及形式化定义" class="headerlink" title="2.1. 关系数据结构及形式化定义"></a>2.1. 关系数据结构及形式化定义</h2><h3 id="2-1-1-关系"><a href="#2-1-1-关系" class="headerlink" title="2.1.1. 关系"></a>2.1.1. 关系</h3><p>给定一组域D1，D2，…，Dn</p><p><strong>域（Domain）：</strong></p><p><code>域</code>是一组具有<code>相同数据类型的值的集合</code>。例:  整数、实数</p><p><strong>笛卡尔积（Cartesian Product）</strong></p><p>笛卡尔积（Cartesian Product）</p><ul><li><code>所有域的所有取值的一个组合</code>（D1 x D2 x … x Dn）</li><li>不能重复；</li><li></li></ul><p><code>元组</code>（Tuple） ：<code>笛卡尔积中每一个元素</code>（d1，d2，…，dn）叫作<code>一个n元组</code></p><p><code>分量</code>（Component）  ：笛卡尔积元素（d1，d2，…，dn）中的每一个值di叫作一个<code>分量</code>;  </p><p><code>基数</code>（Cardinal number）：如果集合A有m个元素，集合B有n个元素，那么它们的笛卡尔积A×B就有m×n个元素。笛卡尔积的基数就是构成它的集合的基数的乘积。</p><p>笛卡尔积的表示方法:  </p><ul><li>笛卡尔积可表示为一个<code>二维表</code>;  </li><li>表中的<code>每行</code>对应一个<code>元组</code>，表中的每列对应一个<code>域</code></li></ul><p><strong>关系</strong></p><p>关系：笛卡尔积<code>D1×D2×…×Dn的</code>子集<code>叫作在</code>域<code>D1，D2，…，Dn上的</code>关系`，表示为：  </p><ul><li>R：关系名  </li><li>n：关系的<code>目</code>或<code>度</code>（Degree）</li></ul><p><code>元组</code>：<code>关系</code>中的每个元素是关系中的<code>元组</code>，通常用t表示</p><p>当n=1时，称该关系为<code>单元关系</code>（Unary relation）或<code>一元关系</code> ;<br>当n=2时，称该关系为<code>二元关系</code>（Binary relation）;</p><p><code>关系的表示</code>：关系也是一个<code>二维表</code>，表的<code>每行</code>对应一个<code>元组</code>，表的每<code>列</code>对应一个<code>域</code></p><p><code>属性</code>  ：</p><ul><li>关系中不同列可以对应相同的域;  </li><li>为了加以区分，必须对每<code>列</code>起一个<code>名字</code>，称为<code>属性</code>（Attribute）;  </li><li>n目关系必有n个属性;</li></ul><p><code>码</code>：</p><ul><li><code>候选码</code>（Candidate key）<br>  若关系中的某一<code>属性组</code>（一个或多个属性）的值能<code>唯一地标识一个元组</code>，则称该属性组为候选码;  其具备唯一性和最小性。</li><li><code>全码</code>（All-key）<br>  最极端的情况：<code>关系模式的所有属性组是这个关系模式的候选码，称为全码</code>（All-key），所有的属性组合在一起才能实现<code>唯一地标识一个元组</code></li><li><code>主码</code><br>  若一个关系有<code>多个候选码</code>，则<code>选定其中一个为主码</code>（Primary key）。有多种属性组合方式可以实现<code>唯一地标识一个元组</code>，则随意选一种组合为主码</li><li><code>主属性</code><br>  在一个表中，可能存在多个候选码。这时，通常会选择一个候选码作为<strong>主键（主属性）</strong><br>  主属性的特征包括：<ul><li><strong>唯一性</strong>：每个主属性值在表中都是唯一的，不会重复。</li><li><strong>非空性</strong>：主属性不能包含空值（NULL）。</li><li><strong>最小性</strong>：候选码应该是最小的唯一标识记录的属性集，即不能去掉其中任何一个属性而仍然唯一标识记录。</li></ul></li><li>非主属性<br>  <code>不包含在任何候选码中的属性称为非主属性</code>（ Non-Prime attribute）或非码属性（Non-key attribute） ;</li></ul><p><strong>三类关系</strong></p><ul><li><code>基本关系</code>（基本表或基表）<br>  实际存在的表，是实际存储数据的逻辑表示</li><li><code>查询表</code><br>  查询结果对应的表</li><li><code>视图表</code><br>  由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据</li></ul><p><code>基本关系(二维表)的性质</code><br>① 列是同质的（Homogeneous）;<br>② 不同的列可出自同一个域,其中的每一列称为一个属性,不同的属性要给予不同的属性名;<br>③ 列的顺序无所谓，列的次序可以任意交换;<br>④ 任意两个元组的候选码不能相同;<br>⑤ 行的顺序无所谓，行的次序可以任意交换;<br>⑥ 分量必须取原子值,这是规范条件中最基本的一条;</p><h3 id="2-1-2-关系模式"><a href="#2-1-2-关系模式" class="headerlink" title="2.1.2. 关系模式"></a>2.1.2. 关系模式</h3><p><strong>什么是关系模式</strong></p><p>关系模式（Relation Schema）是<code>型</code><br>关系是<code>值</code><br><code>关系模式</code>是对<code>关系</code>的<code>描述</code></p><p><strong>定义关系模式</strong></p><ul><li>R（U，D，DOM，F）<ul><li>R 关系名</li><li>U 组成该关系的属性名集合</li><li>D 属性组U中属性所来自的域</li><li>DOM 属性向域的映象集合</li><li>F 属性间的数据依赖关系集合</li></ul></li></ul><p>关系模式通常可以简记为<br>R (U) 或 R (A1，A2，…，An)  </p><ul><li>R: 关系名  </li><li>A1，A2，…，An : 属性名  </li></ul><p>注：域名及属性向域的映象常常直接说明为属性的类型、长度</p><h3 id="2-1-3-关系模式和关系的对比"><a href="#2-1-3-关系模式和关系的对比" class="headerlink" title="2.1.3. 关系模式和关系的对比"></a>2.1.3. 关系模式和关系的对比</h3><ul><li><strong>关系模式</strong><br>  对关系的描述<br>  静态的、稳定的</li><li><strong>关系</strong><br>  关系模式在某一时刻的状态或内容<br>  动态的、随时间不断变化的<br>  关系模式和关系往往统称为关系</li></ul><p>在数据库学科中可以把关系模式理解为表的结构、属性之间的关系、约束条件，把关系理解为二维表</p><h3 id="2-1-4-关系数据库"><a href="#2-1-4-关系数据库" class="headerlink" title="2.1.4. 关系数据库"></a>2.1.4. 关系数据库</h3><ul><li><code>关系数据库</code><br>  在一个给定的应用领域中，所有关系的集合构成一个关系数据库</li><li><code>关系数据库模式</code>包括<br>  若干域的定义;<br>  在这些域上定义的若干关系模式;</li><li><code>关系数据库</code>的·<code>型</code>·与<code>值</code><br>  关系数据库的<code>型</code>: <code>关系数据库模式</code>, 对关系数据库的描述。<br>  关系数据库的<code>值</code>: 关系模式在<code>某一时刻对应的关系的集合</code>，简称为关系数据库<h2 id="2-2-关系操作、关系完整性、关系代数"><a href="#2-2-关系操作、关系完整性、关系代数" class="headerlink" title="2.2. 关系操作、关系完整性、关系代数"></a>2.2. 关系操作、关系完整性、关系代数</h2></li></ul><h3 id="2-2-1-关系操作"><a href="#2-2-1-关系操作" class="headerlink" title="2.2.1. 关系操作"></a>2.2.1. 关系操作</h3><h3 id="2-2-2-关系完整性"><a href="#2-2-2-关系完整性" class="headerlink" title="2.2.2. 关系完整性"></a>2.2.2. 关系完整性</h3><p>关系完整性旨在确保数据库中的数据保持一致性和准确性</p><ul><li><strong>实体完整性和参照完整性：</strong><br>  关系模型必须满足的完整性约束条件;<br>  称为关系的<code>两个不变性</code>，应该由关系系统自动支持;</li><li><strong>用户定义的完整性：</strong><br>  应用领域需要遵循的约束条件，体现了具体领域中的语义约束 ;</li></ul><p><strong>实体完整性</strong></p><p>实体完整性确保数据库表中的每一行都有一个唯一的标识符，即主键。主键不能包含空值（NULL），并且在整个表中必须唯一。</p><p><strong>参照完整性</strong></p><p>参照完整性确保外键值在参照表中是有效的，即外键必须匹配参照表中的某个主键值，或为空（如果允许空值）。</p><p>考虑两个表 <code>Students</code> 和 <code>Enrollments</code>：</p><p><code>Students</code> 表：</p><div class="table-container"><table><thead><tr><th>StudentID</th><th>Name</th></tr></thead><tbody><tr><td>1</td><td>Alice</td></tr><tr><td>2</td><td>Bob</td></tr></tbody></table></div><p><code>Enrollments</code> 表：</p><div class="table-container"><table><thead><tr><th>EnrollmentID</th><th>StudentID</th><th>Course</th></tr></thead><tbody><tr><td>1001</td><td>1</td><td>Math</td></tr><tr><td>1002</td><td>2</td><td>Science</td></tr></tbody></table></div><ul><li><code>StudentID</code> 是 <code>Students</code> 表的主键。</li><li><code>Enrollments</code> 表的 <code>StudentID</code> 列是外键，参照 <code>Students</code> 表的 <code>StudentID</code>。</li></ul><p>确保 <code>Enrollments</code> 表中的每个 <code>StudentID</code> 都存在于 <code>Students</code> 表中。比如，不能在 <code>Enrollments</code> 表中插入 <code>StudentID</code> 为 3 的记录，因为 <code>Students</code> 表中没有 <code>StudentID</code> 为 3 的学生。</p><p><strong>外键 (Foreign Key)</strong>：在数据库中，外键是指一个表中的字段，它引用了另一个表的主键。外键用于建立表之间的关系，确保数据的一致性和完整性</p><p><strong>用户定义的完整性</strong></p><p>用户定义的完整性是根据具体业务需求定义的约束。这些约束可以是任意复杂的规则，通常通过 CHECK 约束、自定义触发器等实现。</p><p>考虑一个 <code>Employees</code> 表：</p><div class="table-container"><table><thead><tr><th>EmployeeID</th><th>Name</th><th>Age</th><th>Salary</th></tr></thead><tbody><tr><td>1</td><td>John</td><td>30</td><td>50000</td></tr><tr><td>2</td><td>Jane</td><td>25</td><td>60000</td></tr></tbody></table></div><p>假设业务规则规定员工的薪水必须大于 30000 且小于 100000。</p><p>可以通过 CHECK 约束来实现：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employees (</span><br><span class="line">    EmployeeID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    Age <span class="type">INT</span>,</span><br><span class="line">    Salary <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">CHECK</span> (Salary <span class="operator">&gt;</span> <span class="number">30000</span> <span class="keyword">AND</span> Salary <span class="operator">&lt;</span> <span class="number">100000</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>这确保了任何插入或更新到 <code>Employees</code> 表的记录都符合薪水在 30000 到 100000 之间的规则。</p><h3 id="2-2-3-关系代数"><a href="#2-2-3-关系代数" class="headerlink" title="2.2.3. 关系代数"></a>2.2.3. 关系代数</h3><p><strong>关系代数运算符</strong></p><p>交、差、并、笛卡尔积、选择、投影、连接、除、与、或、非…</p><p><strong>传统集合运算</strong></p><p><strong>专门的关系运算</strong></p><p>左外连接</p><p>右外连接</p><p>外连接</p><h1 id="3-关系数据库标准语言SQL（略）"><a href="#3-关系数据库标准语言SQL（略）" class="headerlink" title="3. 关系数据库标准语言SQL（略）"></a>3. 关系数据库标准语言SQL（略）</h1><h1 id="4-数据库安全性"><a href="#4-数据库安全性" class="headerlink" title="4. 数据库安全性"></a>4. 数据库安全性</h1><h1 id="5-数据库完整性"><a href="#5-数据库完整性" class="headerlink" title="5. 数据库完整性"></a>5. 数据库完整性</h1><h1 id="6-关系数据理论"><a href="#6-关系数据理论" class="headerlink" title="6. 关系数据理论"></a>6. 关系数据理论</h1><h1 id="7-数据库设计"><a href="#7-数据库设计" class="headerlink" title="7. 数据库设计"></a>7. 数据库设计</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-06-27-Lombok%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/10/28/2024-06-27-Lombok%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Lombok-是什么"><a href="#1-Lombok-是什么" class="headerlink" title="1. Lombok 是什么"></a>1. Lombok 是什么</h1><p>Lombok 提供了一组注解和工具，用于在编译期自动生成样板代码。这些样板代码通常是一些重复性的、无趣的、但是必需的代码，例如 <code>getter</code> 和 <code>setter</code> 方法、构造函数、<code>equals</code> 和 <code>hashCode</code> 方法等。借助 Lombok，你就不必手动编写这些繁琐的代码，它会在编译时自动帮你生成这些方法，让你的代码文件简洁而整洁。</p><h1 id="2-Lombok-的用途"><a href="#2-Lombok-的用途" class="headerlink" title="2. Lombok 的用途"></a>2. Lombok 的用途</h1><p><strong>简化 Getter 和 Setter 方法：</strong> 在传统的 Java 开发中，你经常需要为每个类的属性手动编写 Getter 和 Setter 方法，但是有了 Lombok，你只需要在属性上加上 <code>@Getter</code> 和 <code>@Setter</code> 注解，Lombok 就会为你自动生成这些方法。</p><p><strong>自动生成构造函数：</strong> 通过 <code>@NoArgsConstructor</code>、<code>@RequiredArgsConstructor</code> 或 <code>@AllArgsConstructor</code> 注解，你可以快速生成无参构造函数、带有必需参数的构造函数或者带有全部参数的构造函数。</p><p><strong>自动生成 equals 和 hashCode 方法：</strong> 通过 <code>@EqualsAndHashCode</code> 注解，Lombok 会根据类的字段自动生成 <code>equals()</code> 和 <code>hashCode()</code> 方法，让你的类更易于比较和使用在集合中。</p><p><strong>日志记录更轻松：</strong> 使用 <code>@Slf4j</code> 注解，你可以直接在类中使用 <code>log</code> 对象，而无需手动创建日志记录器。</p><p><strong>简化异常抛出：</strong> 通过 <code>@SneakyThrows</code> 注解，你可以在方法中抛出受检异常，而无需显式地在方法上声明或捕获它们。</p><p><strong>数据类简化：</strong> 使用 <code>@Data</code> 注解，Lombok 会为你自动生成所有常用方法，如 Getter、Setter、<code>toString()</code> 等，让你的数据类更加简洁。</p><p><strong>链式调用：</strong> 使用 <code>@Builder</code> 注解，Lombok 可以帮你创建一个更优雅的构建器模式，让你的对象初始化更加流畅。</p><h1 id="3-如何使用-Lombok"><a href="#3-如何使用-Lombok" class="headerlink" title="3. 如何使用 Lombok"></a>3. 如何使用 Lombok</h1><ul><li>在你的 Java 项目中添加 Lombok 依赖</li><li>在 IDE 中安装好Lombok插件，<code>lombok</code>, 搜索该插件并安装</li><li>idea开启 <code>settings—&gt;build—&gt;compiler—&gt;annotation—&gt;勾选enable annotation processing</code></li><li>在类或字段上添加相应的注解即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 注意查看最新的 Lombok 版本，并替换此处的版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-Lombok注解"><a href="#4-Lombok注解" class="headerlink" title="4. Lombok注解"></a>4. Lombok注解</h1><h2 id="4-1-Getter-Setter-注解"><a href="#4-1-Getter-Setter-注解" class="headerlink" title="4.1. @Getter @Setter 注解"></a>4.1. @Getter @Setter 注解</h2><p><code>@Getter</code> 和 <code>@Setter</code> 是 Lombok 提供的两个注解，它们可以帮助我们自动在 Java 类中生成 <code>getter</code> 和 <code>setter</code> 方法</p><p>当然，如果你只想为某个特定的字段生成 <code>getter</code> 或者 <code>setter</code> 方法，那么你可以直接将注解加到字段上</p><h2 id="4-2-Constructor-注解"><a href="#4-2-Constructor-注解" class="headerlink" title="4.2. @Constructor 注解"></a>4.2. @Constructor 注解</h2><p>Lombok 的三个构造器注解：<code>@NoArgsConstructor</code>, <code>@RequiredArgsConstructor</code> 和 <code>@AllArgsConstructor</code>，这三个注解可以为你省去编写繁琐的构造方法的麻烦</p><p><code>@NoArgsConstructor</code>：这个注解会让 Lombok 为你的类生成一个无参数的构造方法</p><p><code>@RequiredArgsConstructor</code>：这个注解稍微复杂一些，它会让 Lombok 为你的类生成一个构造方法，构造方法的参数是类中所有需要特殊处理的字段，也就是说，标记为 <code>final</code> 和 <code>@NonNull</code> 的字段会被作为参数</p><p><code>@AllArgsConstructor</code>：这个注解会让 Lombok 为你的类生成一个包含所有字段的构造方法</p><h2 id="4-3-Builder-注解"><a href="#4-3-Builder-注解" class="headerlink" title="4.3. @Builder 注解"></a>4.3. @Builder 注解</h2><p>Builder 设计模式是一种创建型设计模式，主要解决了一些对象的构造过程中的问题。它提供了一种链式方法来创建一个复杂的对象</p><p>Lombok 提供了 <code>@Builder</code> 注解，可以帮助我们简化 builder 模式的实现过程</p><p>例如，考虑一个 User 类，包含 name、age 和 email 这三个字段。如果我们希望通过 Builder 模式创建 User 对象，那么可以这样做</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Builder;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以通过下面的方式来创建 User 对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> User.builder()</span><br><span class="line">    .name(<span class="string">&quot;Tom&quot;</span>)</span><br><span class="line">    .age(<span class="number">25</span>)</span><br><span class="line">    .email(<span class="string">&quot;tom@example.com&quot;</span>)</span><br><span class="line">    .build();</span><br><span class="line">System.out.println(user);</span><br></pre></td></tr></table></figure><p>这段代码会输出：<code>User(name=Tom, age=25, email=&quot;tom@example.com&quot;</code></p><p>从上面的例子可以看出，Lombok 生成了一个名为 builder 的静态方法，以及 name，age 和 email 的链式设置方法，最后通过 build 方法来构建 User 对象</p><h2 id="4-4-Value-注解"><a href="#4-4-Value-注解" class="headerlink" title="4.4. @Value 注解"></a>4.4. @Value 注解</h2><p><code>@Value</code> 是 Lombok 提供的一个强大的注解，可以帮助我们快速创建不可变类</p><p>使用 <code>@Value</code> 非常简单，只需要在类定义上添加 <code>@Value</code> 注解即可</p><p>自动为所有字段添加 <code>private final</code> 修饰符，使得它们在初始化后就不能再被改变。</p><p>自动生成所有字段的 Getter 方法，因为字段是 <code>final</code> 的，所以没有 Setter 方法。</p><p>自动生成 <code>equals()</code>, <code>hashCode()</code> 和 <code>toString()</code> 方法。</p><p>自动生成一个全参数的构造方法。</p><p>实际上，<code>@Value</code> 就是 <code>@Getter @FieldDefaults(makeFinal = true, level = AccessLevel.PRIVATE) @AllArgsConstructor @EqualsAndHashCode @ToString</code> 的集合</p><h2 id="4-5-Log-系列注解"><a href="#4-5-Log-系列注解" class="headerlink" title="4.5. @Log 系列注解"></a>4.5. @Log 系列注解</h2><p>Lombok 提供了 <code>@Log</code> 系列注解，用于自动创建并初始化日志记录器。这一系列注解包括：<code>@Log</code>, <code>@Log4j</code>, <code>@Log4j2</code>, <code>@Slf4j</code>, <code>@JBossLog</code> 等，对应于不同的日志框架。每个注解都会在编译时生成一个名为 <code>log</code> 的静态字段，该字段被初始化为对应的日志框架的 Logger 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 直接使用 log 记录日志</span></span><br><span class="line">        log.info(<span class="string">&quot;This is an information message.&quot;</span>);</span><br><span class="line">        log.error(<span class="string">&quot;This is an error message.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-Data-注解"><a href="#4-6-Data-注解" class="headerlink" title="4.6. @Data 注解"></a>4.6. @Data 注解</h2><p><code>@Data</code> 是个万金油注解。一个 <code>@Data</code> 注解相当于同时使用了 <code>@Getter</code> 、<code>@Setter</code> 、<code>@RequiredArgsConstructor</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code></p><h1 id="5-Lombok-实现原理"><a href="#5-Lombok-实现原理" class="headerlink" title="5. Lombok 实现原理"></a>5. Lombok 实现原理</h1><p>Lombok 实现了一系列自己的注解处理器，每一个处理器都负责处理一种或几种注解</p><p>仅作用于编译阶段：由于 Lombok 是在编译阶段修改语法树，所以它不能处理运行时的注解</p><h1 id="6-避免-Lombok-的常见陷阱"><a href="#6-避免-Lombok-的常见陷阱" class="headerlink" title="6. 避免 Lombok 的常见陷阱"></a>6. 避免 Lombok 的常见陷阱</h1><h2 id="6-1-慎用-Data"><a href="#6-1-慎用-Data" class="headerlink" title="6.1. 慎用 @Data"></a>6.1. 慎用 @Data</h2><p><code>@Data</code> 是一个实用的注解，它包含了 <code>@Getter</code>、<code>@Setter</code>、<code>@ToString</code>、<code>@EqualsAndHashCode</code> 和 <code>@RequiredArgsConstructor</code>。这在一般情况下非常方便，但是当你需要自定义一些方法时，就可能会遇到问题。</p><p>例如，你可能需要自定义 <code>equals</code> 和 <code>hashCode</code> 方法，但是由于 <code>@Data</code> 注解自动生成了这些方法，所以你的自定义方法会被覆盖。</p><h2 id="6-2-不要滥用-Lombok"><a href="#6-2-不要滥用-Lombok" class="headerlink" title="6.2. 不要滥用 Lombok"></a>6.2. 不要滥用 Lombok</h2><p>虽然 Lombok 的注解可以极大地简化我们的代码，但是这并不意味着我们应该在所有地方都使用它。在一些情况下，手动编写代码可能会更好。</p><p>例如，你可能需要自定义某个字段的 getter 或 setter 方法，或者你需要自定义 <code>equals</code>、<code>hashCode</code> 或 <code>toString</code> 方法。在这些情况下，使用 Lombok 的注解可能会导致你的自定义代码被覆盖</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-26-Python%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
      <url>/2024/10/28/2024-03-26-Python%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-gradio"><a href="#1-gradio" class="headerlink" title="1. gradio"></a>1. gradio</h1><p>用于创建机器学习模型的交互式界面。它使得展示和测试模型变得简单快捷，无需深入了解复杂的前端技术</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 3.8 or higher</span></span><br><span class="line">pip install gradio</span><br></pre></td></tr></table></figure><h1 id="2-DrissionPage"><a href="#2-DrissionPage" class="headerlink" title="2. DrissionPage"></a>2. DrissionPage</h1><p>比selenium好用</p><p>基于python的网页自动化工具。既能控制浏览器，也能收发数据包。可兼顾浏览器自动化的便利性和requests的高效率。功能强大，内置无数人性化设计和便捷功能。语法简洁而优雅，代码量少。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 版本：3.6 及以上</span></span><br><span class="line">pip install DrissionPage</span><br></pre></td></tr></table></figure><h1 id="3-openpyxl"><a href="#3-openpyxl" class="headerlink" title="3. openpyxl"></a>3. openpyxl</h1><p>操作<code>.xlsx</code>文件</p><h1 id="4-rich"><a href="#4-rich" class="headerlink" title="4. rich"></a>4. rich</h1><p>在终端I/O中利用其格式化和日志风格。显示进度条等其他功能，功能丰富。</p><h1 id="5-tqdm"><a href="#5-tqdm" class="headerlink" title="5. tqdm"></a>5. tqdm</h1><p>显示进度条</p><h1 id="6-logging"><a href="#6-logging" class="headerlink" title="6. logging"></a>6. logging</h1><p>日志库</p><h1 id="7-pyecharts"><a href="#7-pyecharts" class="headerlink" title="7. pyecharts"></a>7. pyecharts</h1><p>数据可视化</p><p><code>bar_chart_race</code>  专门绘制动态条形图的库</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-04-05-%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2024/10/28/2024-04-05-%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-网页元素大小与间距规范"><a href="#1-网页元素大小与间距规范" class="headerlink" title="1. 网页元素大小与间距规范"></a>1. 网页元素大小与间距规范</h1><h1 id="2-div标签"><a href="#2-div标签" class="headerlink" title="2. div标签"></a>2. div标签</h1><p><code>&lt;div&gt;</code> 标签定义 HTML 文档中的一个分隔区块或者一个区域部分</p><p><code>&lt;div&gt;</code>标签常用于组合块级元素，以便通过 CSS 来对这些元素进行格式化</p><h1 id="3-CSS"><a href="#3-CSS" class="headerlink" title="3. CSS"></a>3. CSS</h1><p>HTML 标签用于定义文档内容，CSS定义如何显示 HTML 元素</p><h2 id="3-1-选择器"><a href="#3-1-选择器" class="headerlink" title="3.1. 选择器"></a>3.1. 选择器</h2><p>要在HTML元素中设置CSS样式，需要在元素中设置<code>id</code>或<code>class</code>选择器（ID属性不要以数字开头，数字开头的ID在 Mozilla/Firefox 浏览器中不起作用）</p><p><strong>id 选择器</strong></p><p>CSS 中 id 选择器以 <code>#</code>来定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>样式<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-id">#para1</span></span></span><br><span class="line"><span class="language-css">&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css"><span class="attribute">color</span>:blue;</span></span><br><span class="line"><span class="language-css">&#125; </span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;para1&quot;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>class 选择器</strong></p><p>class 选择器有别于id选择器，class可以在多个元素中使用</p><p>CSS中class 选择器以一个点 <code>.</code> 号定义</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.center</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">text-align</span>:center;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.color</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">color</span>:<span class="number">#ff0000</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题居中<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;center color&quot;</span>&gt;</span>段落居中，颜色为红色。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-CSS-盒子模型-Box-Model"><a href="#3-2-CSS-盒子模型-Box-Model" class="headerlink" title="3.2. CSS 盒子模型(Box Model)"></a>3.2. CSS 盒子模型(Box Model)</h2><p>页面可以看成是由一个个盒子堆砌而成，盒子里面装的就是元素的内容</p><p>盒子的从外到内分别是</p><ul><li><strong>Margin(外边距)</strong> 是该盒子和其他元素之间的空白区域，大小通过margin 相关属性设置</li><li><strong>Border(边框)</strong> 包裹在内边距和内容外的边框，大小通过border相关属性设置</li><li><strong>Padding(内边距)</strong> 包围在内容区域外部的空白区域，大小通过padding 相关属性设置</li><li><strong>Content(内容)</strong> 这个区域是用来显示内容，大小可以通过设置width和height</li></ul><p>盒子的范围到边框为止 —— 不会延伸到margin</p><h2 id="3-3-Grid-网格布局"><a href="#3-3-Grid-网格布局" class="headerlink" title="3.3. Grid 网格布局"></a>3.3. Grid 网格布局</h2><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-02-27-%E6%8E%A5%E5%8F%A3%E9%98%B2%E9%87%8D%E5%A4%84%E7%90%86/"/>
      <url>/2024/10/28/2024-02-27-%E6%8E%A5%E5%8F%A3%E9%98%B2%E9%87%8D%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用场景"><a href="#1-使用场景" class="headerlink" title="1. 使用场景"></a>1. 使用场景</h1><p>在Web应用程序中，用户可能会重复提交表单，例如在点击提交按钮后仍连续多次点击、由于网络延迟造成用户误以为提交未成功而再次提交。这可能导致一些问题，例如重复的数据插入或重复的业务逻辑处理。接口防重处理的主要作用是在用户提交表单请求后，对请求进行拦截和处理，防止重复提交</p><h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h1><p>生成唯一的key，key的组成为url+token+参数，意味着每一个用户的每一个请求都对应redis中的一个key，该key对应的值存空字符串即可（因为我们只需要key来保证唯一性，值不存东西也行）。首先，我们获取这个key，如果redis中没有这个key说明用户第一次请求，则不拦截请求并将key存进redis。如果redis中有key，说明在限制时间里（key没过期）用户再次进行了请求，则拦截返回错误信息</p><p>以上逻辑可以使用AOP或者拦截器、过滤器实现</p><h1 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h1><h2 id="3-1-解决HttpServletRequest-流数据不可重复读"><a href="#3-1-解决HttpServletRequest-流数据不可重复读" class="headerlink" title="3.1. 解决HttpServletRequest 流数据不可重复读"></a>3.1. 解决HttpServletRequest 流数据不可重复读</h2><p>在项目中经常出现多次读取HTTP请求体的情况，这时候可能就会报错，原因是读取HTTP请求体的操作，最终都要调用HttpServletRequest的getInputStream()方法和getReader()方法，而这两个方法总共只能被调用一次，第二次调用就会报错。<code>I/O error while reading input message; nested exception is java.io.IOException: Stream closed</code></p><p><strong>实现一个过滤器</strong></p><p>包装请求之后，缓存的值总是存在，所以可以多次读取请求体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CachingRequestBodyFilter</span> <span class="keyword">extends</span> <span class="title class_">GenericFilterBean</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain chain)</span>  </span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException &#123;  </span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">currentRequest</span> <span class="operator">=</span> (HttpServletRequest) servletRequest;  </span><br><span class="line">        <span class="type">MultipleReadHttpRequest</span> <span class="variable">wrappedRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipleReadHttpRequest</span>(currentRequest);  </span><br><span class="line">        chain.doFilter(wrappedRequest, servletResponse);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>自定义一个请求包装类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipleReadHttpRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpServletRequestWrapper</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> ByteArrayOutputStream cachedContent;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MultipleReadHttpRequest</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="built_in">super</span>(request);  </span><br><span class="line">        <span class="comment">// Read the request body and populate the cachedContent  </span></span><br><span class="line">        cachedContent = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();  </span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> request.getInputStream();  </span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];  </span><br><span class="line">        <span class="type">int</span> bytesRead;  </span><br><span class="line">        <span class="keyword">while</span> ((bytesRead = inputStream.read(buffer)) != -<span class="number">1</span>) &#123;  </span><br><span class="line">            cachedContent.write(buffer, <span class="number">0</span>, bytesRead);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> ServletInputStream <span class="title function_">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(cachedContent.toByteArray());  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ServletInputStream</span>() &#123;  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFinished</span><span class="params">()</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReadListener</span><span class="params">(ReadListener readListener)</span> &#123;  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="meta">@Override</span>  </span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">                <span class="keyword">return</span> byteArrayInputStream.read();  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> BufferedReader <span class="title function_">getReader</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;  </span><br><span class="line">        <span class="type">InputStreamReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(cachedContent.toByteArray()));  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(reader);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注册拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptorConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> DuplicateRequestInterceptor duplicateRequestInterceptor;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;  </span><br><span class="line">        registry.addInterceptor(duplicateRequestInterceptor).addPathPatterns(<span class="string">&quot;/**&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现拦截器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DuplicateRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">REDIS_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;duplicate_request_&quot;</span>;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 过期时间，单位为秒  </span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        <span class="comment">// 替换 HttpServletRequest 为 MultipleReadHttpRequest   </span></span><br><span class="line">        <span class="type">MultipleReadHttpRequest</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MultipleReadHttpRequest</span>(request);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> wrapper.getRequestURI();  </span><br><span class="line">        <span class="comment">// 从请求头中获取token  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Optional.ofNullable(wrapper.getHeader(<span class="string">&quot;Satoken&quot;</span>)).orElse(<span class="string">&quot;&quot;</span>);  </span><br><span class="line">        <span class="comment">// 获取请求参数  </span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">params</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();  </span><br><span class="line">        params.append(IOUtils.toString(wrapper.getInputStream(), <span class="string">&quot;UTF-8&quot;</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> REDIS_KEY_PREFIX + url + <span class="string">&quot;_&quot;</span> + token + <span class="string">&quot;_&quot;</span> + params.toString();  </span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">exist</span> <span class="operator">=</span> redisTemplate.hasKey(key);  </span><br><span class="line">        <span class="keyword">if</span> (Boolean.TRUE.equals(exist)) &#123;  </span><br><span class="line">            log.info(key.toString());  </span><br><span class="line">            <span class="keyword">try</span> (<span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter()) &#123;  </span><br><span class="line">                writer.write(<span class="string">&quot;DuplicateRequest&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 拦截请求  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 将key存入Redis，设置过期时间  </span></span><br><span class="line">            redisTemplate.opsForValue().set(key, <span class="string">&quot;&quot;</span>, EXPIRE_TIME, TimeUnit.SECONDS);  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 放行请求  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-02-JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
      <url>/2024/10/28/2024-03-02-JRebel%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>热部署能够使研发人员对代码的绝大部分修改都能够立即生效。在一个可控的范围内，帮助研发同学减少频繁的重启服务次数，节省碎片化的时间</p><h1 id="2-JRebel"><a href="#2-JRebel" class="headerlink" title="2. JRebel"></a>2. <a href="https://manuals.jrebel.com/">JRebel</a></h1><h2 id="2-1-本地热部署"><a href="#2-1-本地热部署" class="headerlink" title="2.1. 本地热部署"></a>2.1. 本地热部署</h2><p><strong>安装JRebel</strong></p><p>IDEA中安装<code>JRebel and XRebel for IntelliJ</code> 插件</p><p><a href="https://www.guidgen.com/">在线生成GUID</a></p><p>打开jrebel 的设置面板，选择Connect to online licensing service</p><p>服务器地址：<code>chaojiniu.top:8888/&#123;GUID&#125;</code></p><p>邮箱地址：任意邮箱</p><p><strong>设置成离线工作模式</strong></p><p>在设置中点击work offline，切换为离线模式</p><p><strong>设置自动编译</strong></p><p>由于JRebel是实时监控class文件的变化来实现热部署的，所以在IDEA环境下需要打开自动编译功能才能实现随时修改，随时生效。</p><ul><li>compiler下勾选<code>Build project automatically</code></li><li>advanced Setting 下勾选 <code>Allow auto-make to start even if developed application is currently running</code></li></ul><h2 id="2-2-远程热部署"><a href="#2-2-远程热部署" class="headerlink" title="2.2. 远程热部署"></a>2.2. 远程热部署</h2><ul><li>打开jrebel 的设置面板，点击Startup 初始化配置，选择run on remote，点击确认</li><li>打开JRebel Panel 窗口，将需要热部署的项目打包，生成 <code>rebel.xml</code> 和 <code>rebel-remote.xml</code></li><li>通过 maven package 重新打包生成 jar 包，上传至服务器</li><li>服务器端启动服务</li><li>本地 JRebel -&gt; Remote Servers 添加远程服务器</li><li>点击 Test Connection，点击 OK 确认</li><li>可以先远程热部署后，再点击远程调试 Debug，即可实现先热部署再调试，大大加快开发效率</li></ul><h2 id="2-3-远程调试"><a href="#2-3-远程调试" class="headerlink" title="2.3. 远程调试"></a>2.3. 远程调试</h2><ul><li>右上角点击，Edit Configurations，点击 + 号，创建 Remote 应用</li><li>填写远程服务器信息</li><li>复制 Command line arguments for remote JVM 下的命令（命令将在启动的时候来使用）</li><li>启动服务  <code>java -jar</code> 拼接上一步获得的命令</li><li>点击 Debug 即可进行远程调试</li></ul><h1 id="3-基于-Docker-远程调试与部署"><a href="#3-基于-Docker-远程调试与部署" class="headerlink" title="3. 基于 Docker 远程调试与部署"></a>3. 基于 Docker 远程调试与部署</h1><h1 id="4-远程调试，服务阻塞怎么办"><a href="#4-远程调试，服务阻塞怎么办" class="headerlink" title="4. 远程调试，服务阻塞怎么办"></a>4. 远程调试，服务阻塞怎么办</h1>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-08-JUC/"/>
      <url>/2024/10/28/2024-03-08-JUC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>JUC实际上就是我们对于jdk中<code>java.util .concurrent</code> 工具包的简称。这个包下都是Java处理线程相关的类，自jdk1.5后出现</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-13-Java%E5%A4%84%E7%90%86NPE/"/>
      <url>/2024/10/28/2024-03-13-Java%E5%A4%84%E7%90%86NPE/</url>
      
        <content type="html"><![CDATA[<p><strong>空指针异常（NullPointException，简称 NPE）</strong></p><p>1 ）返回类型为基本数据类型，而return包装数据类型的对象时，自动拆箱就有可能产生NPE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">()</span> &#123; </span><br><span class="line"><span class="keyword">return</span> Integer对象; <span class="comment">// 如果为null，因为自动拆箱所以会抛NPE。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2 ） 数据库的查询结果可能为null。因此所有的POJO类属性必须使用包装数据类型。<br>3 ） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。<br>4 ） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。<br>5 ） 对于Session中获取的数据，建议NPE检查，避免空指针。<br>6 ） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。</p><p><strong>使用JDK8的Optional类来防止NPE问题</strong></p><p>Optional 类可以让我们以函数式编程的方式处理 null 值，抛弃了 Java 8 之前需要嵌套大量 if-else 代码块，使代码可读性有了很大的提高，但是应尽量避免使用 Optional 类型声明实体类的属性</p><p>使用Optional类的主要目的是在可能为null的值上进行操作时提供一种安全的方式，而不是直接使用null</p><ol><li>使用Optional的工厂方法创建Optional对象：这样可以将一个可能为null的值包装到Optional对象中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.ofNullable(value);</span><br></pre></td></tr></table></figure><ol><li>使用Optional的方法来处理Optional对象：使用<code>ifPresent</code>方法可以在Optional对象存在值的情况下执行一些操作。这样可以避免使用null进行操作时的NPE。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.ofNullable(value);</span><br><span class="line">optionalValue.ifPresent(val -&gt; System.out.println(val));</span><br></pre></td></tr></table></figure><ol><li>使用orElse方法提供默认值：使用<code>orElse</code>方法可以在Optional对象为空时提供一个默认值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.ofNullable(value);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> optionalValue.orElse(<span class="string">&quot;Default value&quot;</span>);</span><br></pre></td></tr></table></figure><ol><li>使用orElseThrow方法抛出异常：使用<code>orElseThrow</code>方法可以在Optional对象为空时抛出指定的异常。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;String&gt; optionalValue = Optional.ofNullable(value);</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> optionalValue.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Value is null&quot;</span>));</span><br></pre></td></tr></table></figure></li></ol><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptionalExample</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 假设这是一个可能为null的值  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 使用Optional的工厂方法创建Optional对象  </span></span><br><span class="line">        Optional&lt;String&gt; optionalValue = Optional.ofNullable(value);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 使用ifPresent方法执行操作，避免NPE  </span></span><br><span class="line">        optionalValue.ifPresent(val -&gt; System.out.println(<span class="string">&quot;Value: &quot;</span> + val));  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 使用orElse提供默认值  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> optionalValue.orElse(<span class="string">&quot;Default value&quot;</span>);  </span><br><span class="line">        System.out.println(<span class="string">&quot;Result: &quot;</span> + result);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 使用orElseThrow抛出异常  </span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="type">String</span> <span class="variable">result2</span> <span class="operator">=</span> optionalValue.orElseThrow(() -&gt; <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Value is null&quot;</span>));  </span><br><span class="line">            System.out.println(<span class="string">&quot;Result 2: &quot;</span> + result2);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;Exception: &quot;</span> + e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-12-Java%E5%88%A4%E7%AD%89%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/10/28/2024-03-12-Java%E5%88%A4%E7%AD%89%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>Object.equals</strong></p><ul><li>equals是Object类中的方法，只能判断引用类型</li><li>equals 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer、String</li></ul><p><strong>Objects.equals</strong></p><p>Objects（<code>java.util.Objects</code>）该类由<code>static</code>用于对对象进行<code>static</code>实用方法组成。 这些实用程序包括用于计算对象的哈希码的<code>null</code> -safe或<code>null</code>方法，为对象返回一个字符串，并比较两个对象</p><p>源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object a, Object b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (a == b) || (a != <span class="literal">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先，进行了对象地址的判断，如果是真，则不再继续判断。</li><li>如果不相等，则先判断a不为空。所以，如果都是null，在第一个判断上就为true了。如果不为空，地址不同，就重要的是判断a.equals(b)。</li></ul><p>注意</p><ul><li>Objects.equals方法在两个入参类型不同时，会直接返回false</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-15-Mybatis%E4%B9%8Bpagehelper%E6%8F%92%E4%BB%B6/"/>
      <url>/2024/10/28/2024-03-15-Mybatis%E4%B9%8Bpagehelper%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>属于物理分页。pagehelper插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数</p><p>MyBatis中的插件是通过拦截器来实现的，真正执行Sql的是四大对象：Executor，StatementHandler，ParameterHandler，ResultSetHandler。</p><p>当程序执行mapper方法时，就会被拦截器<code>PageInterceptor</code>拦截到</p><h1 id="2-在SpringBoot-中配置"><a href="#2-在SpringBoot-中配置" class="headerlink" title="2. 在SpringBoot 中配置"></a>2. 在SpringBoot 中配置</h1><h2 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1. 添加依赖"></a>2.1. 添加依赖</h2><p>PageHelper自带了mybatis、mybatis-spring，不排除会报错循环依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-2-参数配置"><a href="#2-2-参数配置" class="headerlink" title="2.2. 参数配置"></a>2.2. 参数配置</h2><p>在application.yml中配置分页插件的可选参数</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pagehelper:</span>  </span><br><span class="line">  <span class="attr">helper-dialect:</span> <span class="string">mysql</span>  </span><br><span class="line">  <span class="attr">reasonable:</span> <span class="literal">true</span>  </span><br><span class="line">  <span class="attr">support-methods-arguments:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">params:</span> <span class="string">count=countSql</span></span><br></pre></td></tr></table></figure><p><strong>下面几个参数都是针对默认 dialect 情况下的参数。使用自定义 dialect 实现时，下面的参数没有任何作用。</strong></p><ul><li><code>helper-dialect</code>：配置<code>helper-dialect</code>属性来指定分页插件使用哪种方言（不配置的话pageHelper也会自动检测）。配置时，可以使用下面的缩写值：<code>oracle</code>,<code>mysql</code>,<code>mariadb</code>,<code>sqlite</code>,<code>hsqldb</code>,<code>postgresql</code>,<code>db2</code>,<code>sqlserver</code>,<code>informix</code>,<code>h2</code>,<code>sqlserver2012</code>,<code>derby</code>，使用 SqlServer2012 数据库时，需要手动指定为 <code>sqlserver2012</code>，否则会使用 SqlServer2005 的方式进行分页</li><li><code>offset-as-page-num</code>：默认值为 <code>false</code>，该参数对使用 <code>RowBounds</code> 作为分页参数时有效。 当该参数设置为 <code>true</code> 时，会将 <code>RowBounds</code> 中的 <code>offset</code> 参数当成 <code>pageNum</code> 使用，可以用页码和页面大小两个参数进行分页</li><li><code>row-bounds-with-count</code>：默认值为<code>false</code>，该参数对使用 <code>RowBounds</code> 作为分页参数时有效。 当该参数设置为<code>true</code>时，使用 <code>RowBounds</code> 分页会进行 count 查询</li><li><code>page-size-zero</code>：默认值为 <code>false</code>，当该参数设置为 <code>true</code> 时，如果 <code>pageSize=0</code> 或者 <code>RowBounds.limit = 0</code> 就会查询出全部的结果（相当于没有执行分页查询，但是返回结果仍然是 <code>Page</code> 类型）</li><li><code>reasonable</code>：分页合理化参数，默认值为<code>false</code>。当该参数设置为 <code>true</code> 时，<code>pageNum&lt;=0</code> 时会查询第一页， <code>pageNum&gt;pages</code>（超过总数时），会查询最后一页。默认<code>false</code> 时，直接根据参数进行查询，如果<code>pageNum&lt;=0</code>或<code>pageNum&gt;总页数</code>会返回空数据</li><li><code>params</code>：为了支持<code>startPage(Object params)</code>方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值， 可以配置 <code>pageNum,pageSize,count,pageSizeZero,reasonable</code>，不配置映射的用默认值， 默认值为<code>pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero</code></li><li><code>support-methods-arguments</code>：支持通过 Mapper 接口参数来传递分页参数，默认值<code>false</code>。当该参数设置为 <code>true</code> 时，分页插件会从查询方法的参数值中，自动根据上面 <code>params</code> 配置的字段中取值，查找到合适的值时就会自动分页</li><li><code>auto-runtime-dialect</code>：默认值为 <code>false</code>。设置为 <code>true</code> 时，允许在运行时根据多数据源自动识别对应方言的分页 （不支持自动选择<code>sqlserver2012</code>，只能使用<code>sqlserver</code>）</li><li><code>close-conn</code>：默认值为 <code>true</code>。当使用运行时动态数据源或没有设置 <code>helperDialect</code> 属性自动获取数据库类型时，会自动获取一个数据库连接， 通过该属性来设置是否关闭获取的这个连接，默认<code>true</code>关闭，设置为 <code>false</code> 后，不会关闭获取的连接，这个参数的设置要根据自己选择的数据源来决定</li></ul><p><strong>重要提示：</strong></p><p>当 <code>offsetAsPageNum=false</code> 的时候，由于 <code>PageNum</code> 问题，<code>RowBounds</code>查询的时候 <code>reasonable</code> 会强制为 <code>false</code>。使用 <code>PageHelper.startPage</code> 方法不受影响。</p><h2 id="2-3-实现分页"><a href="#2-3-实现分页" class="headerlink" title="2.3. 实现分页"></a>2.3. 实现分页</h2><ul><li>使用 <code>PageHelper.startPage(pageNum,pageSize)</code> 开启分页</li><li>中间有个获取数据的方法，如<code>userInfoMapper.list()</code></li><li>创建 <code>PageInfo pageInfo = new PageInfo&lt;&gt;(taskResultList)</code> 分页对象</li></ul><p>关键点在于中间获取数据的方法，该方法很容易导致分页返回的总记录数 total 错误。如果中间获取数据的方法，只是一个简单的从数据库查询就返回，没有经过其他任何操作的话，分页是没有问题的。如果中间获取数据的方法，从数据库查询数据后，还要对查询到的数据进行处理，那么分页结果会有问题的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Result <span class="title function_">page</span> <span class="params">(<span class="meta">@PathVariab1e(value =”pageSize&quot; )</span> Integer pageSize,<span class="meta">@PathVariab1e(value =”pageNum&quot; )</span> Integer pageNum)</span> &#123;</span><br><span class="line"><span class="comment">//开启分页</span></span><br><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line"><span class="comment">//获取数据</span></span><br><span class="line">List&lt;TaskResult&gt; taskResultList = taskResultService.list(); </span><br><span class="line"><span class="comment">//创建分页对象</span></span><br><span class="line"><span class="type">PageInfo</span> <span class="variable">pageInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;&gt; (taskResultList); </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="literal">true</span>,<span class="number">200</span>,<span class="string">&quot;查询成功&quot;</span>,pageInfo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong></p><p>在mapper.xml中编写sql语句的时候不要在末尾加分号，因为sql语句后面要拼接limit分页语句</p><p>PageHelper.startPage(pageNum,pageSize) 只对在该方法调用后紧跟的 MyBatis 查询方法得到的数据进行分页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">List&lt;BrandBo&gt; brands= brandMapper.getBrand();</span><br></pre></td></tr></table></figure><p><strong>分页类 PageInfo 的常用属性</strong></p><ul><li>pageNum：当前页的页码（从1开始）。</li><li>pageSize：每页显示的条数。</li><li>size：当前页显示的真实条数。</li><li>total：总记录数。</li><li>pages：总页数（由pageSize和total决定）。</li><li>prePage：上一页的页码。</li><li>nextPage：下一页的页码。</li><li>isFirstPage：是否为第一页。</li><li>isLastPage：是否为最后一页。</li><li>hasPreviousPage：是否存在上一页。</li><li>hasNextPage：是否存在下一页。</li><li>navigatePages：导航分页的页码数，即在页面上同时显示的页码数量。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">假设总共有10页数据，而navigatePages设置为5：</span><br><span class="line"></span><br><span class="line">当前页为第1页时，导航分页的页码为[1, 2, 3, 4, 5]。</span><br><span class="line">当前页为第3页时，导航分页的页码为[1, 2, 3, 4, 5]。</span><br><span class="line">当前页为第5页时，导航分页的页码为[3, 4, 5, 6, 7]。</span><br><span class="line">当前页为第8页时，导航分页的页码为[6, 7, 8, 9, 10]。</span><br><span class="line">当前页为第10页时，导航分页的页码为[6, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure><ul><li>navigatepageNums：导航分页的页码列表，包含从起始页码到结束页码的所有页码</li></ul><h1 id="3-ThreadLocal问题（重点）"><a href="#3-ThreadLocal问题（重点）" class="headerlink" title="3. ThreadLocal问题（重点）"></a>3. ThreadLocal问题（重点）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 开始分页</span></span><br><span class="line"> <span class="comment">// @param pageNum      页码</span></span><br><span class="line"> <span class="comment">// @param pageSize     每页显示数量</span></span><br><span class="line"> <span class="comment">// @param count        是否进行count查询</span></span><br><span class="line"> <span class="comment">// @param reasonable   分页合理化,null时用默认配置</span></span><br><span class="line"> <span class="comment">// @param pageSizeZero true且pageSize=0时返回全部结果，false时分页,null时用默认配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; Page&lt;E&gt; <span class="title function_">startPage</span><span class="params">(<span class="type">int</span> pageNum, <span class="type">int</span> pageSize, <span class="type">boolean</span> count, Boolean reasonable, Boolean pageSizeZero)</span> &#123;  </span><br><span class="line">    Page&lt;E&gt; page = <span class="keyword">new</span> <span class="title class_">Page</span>(pageNum, pageSize, count);  </span><br><span class="line">    page.setReasonable(reasonable);  </span><br><span class="line">    page.setPageSizeZero(pageSizeZero);</span><br><span class="line">    <span class="comment">// 1、获取本地分页  </span></span><br><span class="line">    Page&lt;E&gt; oldPage = getLocalPage();  </span><br><span class="line">    <span class="keyword">if</span> (oldPage != <span class="literal">null</span> &amp;&amp; oldPage.isOrderByOnly()) &#123;  </span><br><span class="line">        page.setOrderBy(oldPage.getOrderBy());  </span><br><span class="line">    &#125;  </span><br><span class="line"><span class="comment">// 2、设置本地分页</span></span><br><span class="line">    setLocalPage(page);  </span><br><span class="line">    <span class="keyword">return</span> page;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别来看下：<code>getLocalPage()</code>和<code>setLocalPage(page)</code>，</p><p><strong>getLocalPage()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Page&lt;T&gt; <span class="title function_">getLocalPage</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> (Page)LOCAL_PAGE.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量 <code>LOCAL_PAGE</code>是ThreadLocal，独属于每个线程的本地缓存对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br></pre></td></tr></table></figure><p>当一个请求来的时候，会获取持有当前请求的线程的ThreadLocal，调用<code>LOCAL_PAGE.get()</code>，查看当前线程是否有未执行的分页配置</p><p><strong>setLocalPage(page)</strong></p><p>设置线程的分页配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setLocalPage</span><span class="params">(Page page)</span> &#123;</span><br><span class="line">    LOCAL_PAGE.set(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Intercept方法</strong></p><p>pageHelper通过<code>PageInterceptor</code>实现分页效果，我们只需要关注Intercept方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line">        <span class="type">MappedStatement</span> <span class="variable">ms</span> <span class="operator">=</span> (MappedStatement) args[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Object</span> <span class="variable">parameter</span> <span class="operator">=</span> args[<span class="number">1</span>];</span><br><span class="line">        <span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> (RowBounds) args[<span class="number">2</span>];</span><br><span class="line">        <span class="type">ResultHandler</span> <span class="variable">resultHandler</span> <span class="operator">=</span> (ResultHandler) args[<span class="number">3</span>];</span><br><span class="line">        <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> (Executor) invocation.getTarget();</span><br><span class="line">        CacheKey cacheKey;</span><br><span class="line">        BoundSql boundSql;</span><br><span class="line">        <span class="comment">// 由于逻辑关系，只会进入一次</span></span><br><span class="line">        <span class="keyword">if</span> (args.length == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">//4 个参数时</span></span><br><span class="line">            boundSql = ms.getBoundSql(parameter);</span><br><span class="line">            cacheKey = executor.createCacheKey(ms, parameter, rowBounds, boundSql);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//6 个参数时</span></span><br><span class="line">            cacheKey = (CacheKey) args[<span class="number">4</span>];</span><br><span class="line">            boundSql = (BoundSql) args[<span class="number">5</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        checkDialectExists();</span><br><span class="line">        <span class="comment">//对 boundSql 的拦截处理</span></span><br><span class="line">        <span class="keyword">if</span> (dialect <span class="keyword">instanceof</span> BoundSqlInterceptor.Chain) &#123;</span><br><span class="line">            boundSql = ((BoundSqlInterceptor.Chain) dialect).doBoundSql(BoundSqlInterceptor.Type.ORIGINAL, boundSql, cacheKey);</span><br><span class="line">        &#125;</span><br><span class="line">        List resultList;</span><br><span class="line">        <span class="comment">//调用方法判断是否需要进行分页，如果不需要，直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (!dialect.skip(ms, parameter, rowBounds)) &#123;</span><br><span class="line">            <span class="comment">//判断是否需要进行 count 查询</span></span><br><span class="line">            <span class="keyword">if</span> (dialect.beforeCount(ms, parameter, rowBounds)) &#123;</span><br><span class="line">                <span class="comment">//查询总数</span></span><br><span class="line">                <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> count(executor, ms, parameter, rowBounds, <span class="literal">null</span>, boundSql);</span><br><span class="line">                <span class="comment">//处理查询总数，返回 true 时继续分页查询，false 时直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (!dialect.afterCount(count, parameter, rowBounds)) &#123;</span><br><span class="line">                    <span class="comment">//当查询总数为 0 时，直接返回空的结果</span></span><br><span class="line">                    <span class="keyword">return</span> dialect.afterPage(<span class="keyword">new</span> <span class="title class_">ArrayList</span>(), parameter, rowBounds);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            resultList = ExecutorUtil.pageQuery(dialect, executor,</span><br><span class="line">                    ms, parameter, rowBounds, resultHandler, boundSql, cacheKey);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//rowBounds用参数值，不使用分页插件处理时，仍然支持默认的内存分页</span></span><br><span class="line">            resultList = executor.query(ms, parameter, rowBounds, resultHandler, cacheKey, boundSql);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dialect.afterPage(resultList, parameter, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(dialect != <span class="literal">null</span>)&#123;</span><br><span class="line">            dialect.afterAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Intercept方法的最后，会在sql方法执行完成后，清理page缓存：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(dialect != <span class="literal">null</span>)&#123;</span><br><span class="line">        dialect.afterAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这个<code>afterAll()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterAll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//这个方法即使不分页也会被执行，所以要判断 null</span></span><br><span class="line">    <span class="type">AbstractHelperDialect</span> <span class="variable">delegate</span> <span class="operator">=</span> autoDialect.getDelegate();</span><br><span class="line">    <span class="keyword">if</span> (delegate != <span class="literal">null</span>) &#123;</span><br><span class="line">        delegate.afterAll();</span><br><span class="line">        autoDialect.clearDelegate();</span><br><span class="line">    &#125;</span><br><span class="line">    clearPage();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用了<code>startPage()</code>，但是没有执行对应的sql，那么就表明，当前线程ThreadLocal被设置了分页参数，可是没有被使用，当下一个使用此线程的请求来时，就可能会出现问题（为什么是可能出现问题呢，继续往下看）。</p><p>如果程序在执行sql前，发生异常了，就没办法执行finally当中的<code>clearPage()</code>方法，也会造成线程的ThreadLocal被污染。</p><p>所以，官方给我们的建议，在使用PageHelper进行分页时，执行sql的代码要紧跟<code>startPage()</code>方法。</p><p>除此之外，我们可以手动调用<code>clearPage()</code>方法，在存在问题的方法之前。</p><blockquote><p>需要注意：不要分页的方法前手动调用clearPage，将会导致你的分页出现问题。</p></blockquote><p><strong>为什么是可能出现问题呢</strong></p><p>这个取决于我们启动服务所使用的容器，比如tomcat，在其内部处理请求是通过线程池的方式。</p><p>假设线程1持有没有被清除的page参数，不断调用同一个方法，后面两个请求使用的是线程2和线程3没有问题，再一个请求轮到线程1了，此时就会出现问题了。</p><h1 id="4-重要提示"><a href="#4-重要提示" class="headerlink" title="4. 重要提示"></a>4. 重要提示</h1><h2 id="4-1-PageHelper-startPage方法重要提示"><a href="#4-1-PageHelper-startPage方法重要提示" class="headerlink" title="4.1. PageHelper.startPage方法重要提示"></a>4.1. <code>PageHelper.startPage</code>方法重要提示</h2><p>只有紧跟在<code>PageHelper.startPage</code>方法后的第一个Mybatis的查询（Select）方法会被分页。</p><h2 id="4-2-请不要配置多个分页插件"><a href="#4-2-请不要配置多个分页插件" class="headerlink" title="4.2. 请不要配置多个分页插件"></a>4.2. 请不要配置多个分页插件</h2><p>请不要在系统中配置多个分页插件(使用Spring时,<code>mybatis-config.xml</code>和<code>Spring&lt;bean&gt;</code>配置方式，请选择其中一种，不要同时配置多个分页插件)！</p><h2 id="4-3-分页插件不支持带有for-update语句的分页"><a href="#4-3-分页插件不支持带有for-update语句的分页" class="headerlink" title="4.3. 分页插件不支持带有for update语句的分页"></a>4.3. 分页插件不支持带有<code>for update</code>语句的分页</h2><p>对于带有<code>for update</code>的sql，会抛出运行时异常，对于这样的sql建议手动分页，毕竟这样的sql需要重视。</p><h2 id="4-4-分页插件不支持嵌套结果映射"><a href="#4-4-分页插件不支持嵌套结果映射" class="headerlink" title="4.4. 分页插件不支持嵌套结果映射"></a>4.4. 分页插件不支持嵌套结果映射</h2><p>由于嵌套结果方式会导致结果集被折叠，因此分页查询的结果在折叠后总数会减少，所以无法保证分页结果数量正确。</p><h1 id="5-pageHelper-实现一对多分页查询（重点）"><a href="#5-pageHelper-实现一对多分页查询（重点）" class="headerlink" title="5. pageHelper 实现一对多分页查询（重点）"></a>5. pageHelper 实现一对多分页查询（重点）</h1><h2 id="5-1-背景"><a href="#5-1-背景" class="headerlink" title="5.1. 背景"></a>5.1. 背景</h2><p>解决pageHelper 不支持嵌套结果映射（一对多）的问题</p><p>假设我们有两个实体类：Order 和 OrderItem，它们之间的关系是一对多，即一个 Order 对应多个 OrderItem</p><p>现在需要联表查询，实现以主表数据的分页结果为基础进行联表查询</p><h2 id="5-2-MySqlDialect类的分页原理"><a href="#5-2-MySqlDialect类的分页原理" class="headerlink" title="5.2. MySqlDialect类的分页原理"></a>5.2. MySqlDialect类的分页原理</h2><p>MysqlDialect里面有两个方法 getPageSql 和 processPageParameter</p><p>getPageSql 方法是为了在sql最后加上LIMIT语句</p><p>processPageParameter方法是为了添加分页参数到参数Map里</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eq.question_id, eq.content <span class="keyword">as</span> content1, eq.type, eq.question_tag_id,eq.difficulty,eqi.question_item_id, eqi.content <span class="keyword">as</span> content2,eqi.answer,eqi.question_id</span><br><span class="line"><span class="keyword">from</span> ex_question <span class="keyword">as</span> eq</span><br><span class="line"><span class="keyword">join</span> ex_question_item <span class="keyword">as</span> eqi <span class="keyword">on</span> eq.question_id <span class="operator">=</span> eqi.question_id</span><br></pre></td></tr></table></figure><p>对于以上sql，使用<code>Page page = PageHelper.startPage(pageNum, pageSize)</code>分页查询的时候分页插件就会在sql的最后面帮我们加上<code>limit ?,?</code>，然后进行分页查询。那就会产生分页查询不准确的问题。因为先对join查询数据做了分页（不是对主数据分页），查出数据后再映射一对多实体</p><p>正确的逻辑应该是如下：首先使用子查询（<code>eq_pre</code>）从<code>ex_question</code>表中选择了LIMIT之后的结果。然后，将子查询的结果与<code>ex_question_item</code>表进行联接，以获取所需的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> eq.question_id, eq.content <span class="keyword">as</span> content1, eq.type, eq.question_tag_id, eq.difficulty, eqi.question_item_id, eqi.content <span class="keyword">as</span> content2, eqi.answer, eqi.question_id  </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> eq_pre.question_id, eq_pre.content, eq_pre.type, eq_pre.question_tag_id, eq_pre.difficulty  </span><br><span class="line"><span class="keyword">from</span> ex_question <span class="keyword">as</span> eq_pre  </span><br><span class="line">limit ?,?) <span class="keyword">as</span> eq  </span><br><span class="line"><span class="keyword">join</span> ex_question_item <span class="keyword">as</span> eqi <span class="keyword">on</span> eq.question_id <span class="operator">=</span> eqi.question_id</span><br></pre></td></tr></table></figure><h2 id="5-3-重写MySqlDialect"><a href="#5-3-重写MySqlDialect" class="headerlink" title="5.3. 重写MySqlDialect"></a>5.3. 重写MySqlDialect</h2><p>重写后生效需配置<code>pagehelper.helperDialect=实现类的全限定名称</code></p><p>核心思路就是根据正则表达式匹配，然后把<code>limit?,?</code>语句和参数插入到合适的位置，实现对主表分页的语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageMySqlDialectPlus</span> <span class="keyword">extends</span> <span class="title class_">MySqlDialect</span> &#123;  </span><br><span class="line"><span class="comment">//   只需注意/*fixed*/ 和/*limit*/ 这两个注释 fixed代表开启 limit代表插入位置这样就可以既可自定义 也可用原来的pageheper  </span></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPageSql</span><span class="params">(String sql, Page page, CacheKey pageKey)</span> &#123;  </span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">compileFixed</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;/\\*fixed\\*/&quot;</span>);  </span><br><span class="line">        <span class="type">String</span> <span class="variable">compileLimit</span> <span class="operator">=</span> <span class="string">&quot;/\\*limit\\*/&quot;</span>;  </span><br><span class="line">  </span><br><span class="line">        log.info(<span class="string">&quot;替换前的sql=&quot;</span> + sql);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (compileFixed.matcher(sql).find()) &#123;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span> (page.getStartRow() == <span class="number">0</span>) &#123;  </span><br><span class="line">                sql = sql.replaceFirst(compileLimit, <span class="string">&quot; LIMIT ? &quot;</span>);  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                sql = sql.replaceFirst(compileLimit, <span class="string">&quot; LIMIT ?, ? &quot;</span>);  </span><br><span class="line">  </span><br><span class="line">            &#125;  </span><br><span class="line">            log.info(<span class="string">&quot;替换后的sql=&quot;</span> + sql);  </span><br><span class="line">            <span class="keyword">return</span> sql;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getPageSql(sql, page, pageKey);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需注意<code>/*fixed*/</code> 和<code>/*limit*/</code> 这两个注释即可，fixed代表开启limit插入功能，limit代表插入位置，这样既可走自定义也可走原来的方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fixed*/</span> <span class="keyword">select</span> eq.question_id, eq.content <span class="keyword">as</span> content1, eq.type, eq.question_tag_id, eq.difficulty, eqi.question_item_id, eqi.content <span class="keyword">as</span> content2, eqi.answer, eqi.question_id  </span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> eq_pre.question_id, eq_pre.content, eq_pre.type, eq_pre.question_tag_id, eq_pre.difficulty  </span><br><span class="line"><span class="keyword">from</span> ex_question <span class="keyword">as</span> eq_pre  </span><br><span class="line"><span class="comment">/*limit*/</span>) <span class="keyword">as</span> eq  </span><br><span class="line"><span class="keyword">join</span> ex_question_item <span class="keyword">as</span> eqi <span class="keyword">on</span> eq.question_id <span class="operator">=</span> eqi.question_id</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-03-24-Quasar%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/28/2024-03-24-Quasar%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h1><p>Vue版本选择Vue3</p><p>Vue组件风格选择：composition API（组合式API）</p><p>CSS preprocessor（CSS预处理器）选择：SCSS</p><p>其他选择：ESLint（选Prettier规则，这样可以搭配vscode中的插件进行自动格式化）、Pinia、Axios、Vue-i18n、Vite、Vue-router</p><h1 id="2-父子组件通信"><a href="#2-父子组件通信" class="headerlink" title="2. 父子组件通信"></a>2. 父子组件通信</h1><ul><li>封装子组件，先定义子组件需要接收的属性、数据</li><li>在父组件中，调用子组件，通过子组件的props传入子组件所需属性、数据</li><li>对于弹窗类的子组件，需要在子组件中使用<code>:model-value=&quot;switch&quot;</code>双向绑定来控制弹窗的显示状态。父组件在调用时，将switch置为true传入子组件<code>v-model:switch=&quot;switch&quot;</code>，则子组件打开。子组件关闭时，需要在子组件中使用<code>$emit</code>，将父组件中定义的switch置为false，则子组件关闭</li><li>在父组件中调用子组件，可将父组件中的函数与子组件中的函数绑定</li><li>在子组件中改动的父组件的数据，最后一定要通过<code>$emit</code>传回给父组件</li><li><strong>子组件中不提供数据，只是通用模板的封装，数据是存在于父组件中的，数据源于父组件，最后要归于父组件</strong><h1 id="3-删除数组中的数据"><a href="#3-删除数组中的数据" class="headerlink" title="3. 删除数组中的数据"></a>3. 删除数组中的数据</h1></li></ul><p>在Vue或类似的现代前端框架中，使用过滤操作来“删除”数据项，而不是直接的删除操作，有几个原因：</p><ul><li><strong>不变性（Immutability）</strong>: 通过过滤创建一个新数组，而不是直接修改原始数组，可以保持数据的不变性。这是函数式编程中的一个常见概念，有助于避免副作用，使状态管理更加可预测。</li><li><strong>响应式更新</strong>: 在Vue中，数组的响应式更新是通过替换数组或更新数组的长度来触发的。直接使用过滤方法返回一个新数组，可以确保Vue能够检测到数据的变化，并自动更新DOM。如果直接在原数组上进行删除操作（如使用<code>splice</code>），虽然Vue也能检测到变化，但使用过滤方法在概念上更简单，代码更清晰。</li><li><strong>简洁性</strong>: 使用过滤方法可以用一行代码实现删除功能，代码更加简洁明了。过滤方法直接表达了“我们想要的是除了某项之外的所有项”的意图，这比手动遍历数组并删除特定项要直观得多。</li><li><strong>功能性</strong>: 过滤方法是一种声明式编程的体现，它描述了我们想要的结果（一个不包含被删除项的新数组），而不是如何通过各种操作达到这个结果。这种方式使得代码更容易理解和维护。</li></ul><p>总之，使用过滤操作来“删除”数据项，是一种更符合现代前端框架设计哲学的做法，它提高了代码的清晰度、可维护性和响应式能力。</p><h1 id="4-页面交互样式统一"><a href="#4-页面交互样式统一" class="headerlink" title="4. 页面交互样式统一"></a>4. 页面交互样式统一</h1><p>网格：一整个大的页面作为一个div，在该div中再划分div布置页面内容，页脚footer的div应与最外层div同级</p><p>组件的样式，使用自带的样式，不自己写css实现</p><p>消息提示notify统一从 top弹出</p><p>全局统一颜色：警告、成功、失败、信息等</p><p>全局使用统一风格：如蓝白灰色</p><p>全局组件采用圆润风格，有轻微阴影</p><p>全局的组件应该统一采用卡片的方式进行布置</p><p>页面的设计、布局、交互，尽量做到在PC、移动端都能顺手且美观</p><h1 id="5-响应式布局"><a href="#5-响应式布局" class="headerlink" title="5. 响应式布局"></a>5. 响应式布局</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;row&quot;</span>&gt; &lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>布局怎么区分是用column（列）还是row（行）</strong></p><p>左右划分是在行内进行的，表示占几列（col）</p><p>上下划分是在列内进行的，表示占几行（col）</p><p><strong>什么是响应式布局</strong></p><p>页面的设计与开发应当根据用户行为以及设备环境(系统平台、屏幕尺寸、屏幕定向等)进行相应的响应和调整</p><p>响应式网站常见特点：</p><ul><li><p>同时适配PC + 平板 + 手机等</p></li><li><p>标签导航在接近手持终端设备时改变为经典的抽屉式导航</p></li><li><p>网站的布局会根据视口来调整模块的大小和位置</p></li></ul><h1 id="6-vue-echarts切换定制主题"><a href="#6-vue-echarts切换定制主题" class="headerlink" title="6. vue-echarts切换定制主题"></a>6. vue-echarts切换定制主题</h1><p>从echarts官网保存定制主题的<code>.json</code>文件，该文件内容格式如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;themeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;westeros&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;theme&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>只需要保留<code>theme</code>后面的值即可</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>引入json文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> westeros <span class="keyword">from</span> <span class="string">&quot;westeros.json&quot;</span>;</span><br></pre></td></tr></table></figure><p>注册主题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; registerTheme &#125; <span class="keyword">from</span> <span class="string">&quot;echarts/core&quot;</span>;</span><br><span class="line"><span class="title function_">registerTheme</span>(<span class="string">&quot;theme&quot;</span>, westeros);</span><br></pre></td></tr></table></figure><p>使用主题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">provide</span>(<span class="variable constant_">THEME_KEY</span>, <span class="string">&quot;theme&quot;</span>);</span><br></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> westeros <span class="keyword">from</span> <span class="string">&quot;westeros.json&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; registerTheme &#125; <span class="keyword">from</span> <span class="string">&quot;echarts/core&quot;</span>;</span><br><span class="line"><span class="title function_">registerTheme</span>(<span class="string">&quot;theme&quot;</span>, westeros);</span><br><span class="line"><span class="title function_">provide</span>(<span class="variable constant_">THEME_KEY</span>, <span class="string">&quot;theme&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="7-vue-i18n国际化"><a href="#7-vue-i18n国际化" class="headerlink" title="7. vue-i18n国际化"></a>7. vue-i18n国际化</h1><p>在创建项目的时候勾选vue-i18n，否则需要手动做配置</p><p>翻译内容需要手动准备</p><p>en</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add your translations here</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">failed</span>: <span class="string">&quot;Action failed&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">success</span>: <span class="string">&quot;Action was successful&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">welcome</span>: <span class="string">&quot;Welcome&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">goodbye</span>: <span class="string">&quot;Goodbye&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">hello</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">language</span>: <span class="string">&quot;Language&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>zh</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add your translations here</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">failed</span>: <span class="string">&quot;失败&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">success</span>: <span class="string">&quot;成功&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">welcome</span>: <span class="string">&quot;欢迎&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">goodbye</span>: <span class="string">&quot;再见&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">hello</span>: <span class="string">&quot;你好&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">language</span>: <span class="string">&quot;语言&quot;</span>,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>按官网步骤一步步来即可</p><h1 id="8-Vue-Router实现路由鉴权"><a href="#8-Vue-Router实现路由鉴权" class="headerlink" title="8. Vue Router实现路由鉴权"></a>8. Vue Router实现路由鉴权</h1><p>前端实现页面级的权限控制</p><p>路由动态渲染、身份验证</p><h2 id="8-1-meta属性"><a href="#8-1-meta属性" class="headerlink" title="8.1. meta属性"></a>8.1. meta属性</h2><p>给路由添加额外的附加信息，如过渡名称、谁可以访问路由等。这些事情可以通过接收属性对象的<code>meta</code>属性来实现，并且它可以在路由地址和导航守卫上都被访问到</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncRouterMap = [&#123;</span><br><span class="line"></span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/permission&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">Layout</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;权限测试&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;</span><br><span class="line">        <span class="comment">//访问页面需要的角色</span></span><br><span class="line">            <span class="attr">role</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;super_editor&#x27;</span>]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Permission</span>,</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;权限测试页&#x27;</span>,</span><br><span class="line">                <span class="attr">meta</span>: &#123;</span><br><span class="line">                <span class="comment">//访问页面需要的角色</span></span><br><span class="line">                    <span class="attr">role</span>: [<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;super_editor&#x27;</span>]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>如何访问这个 <code>meta</code> 字段呢</strong></p><p>一个路由匹配到的所有路由记录会暴露为 <code>route</code> 对象的<code>route.matched</code> 数组。我们需要遍历这个数组来检查路由记录中的 <code>meta</code> 字段，但是 Vue Router 还为你提供了一个 <code>route.meta</code> 方法，它是一个非递归合并所有 <code>meta</code> 字段（从父字段到子字段）的方法</p><h2 id="8-2-动态路由"><a href="#8-2-动态路由" class="headerlink" title="8.2. 动态路由"></a>8.2. 动态路由</h2><p>动态路由主要通过两个函数实现。<code>router.addRoute()</code> 和 <code>router.removeRoute()</code></p><h1 id="9-实现轮播文字效果"><a href="#9-实现轮播文字效果" class="headerlink" title="9. 实现轮播文字效果"></a>9. 实现轮播文字效果</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;roll&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;&#123;list[index]&#125;&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">setup</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">import</span> &#123; reactive, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> list = <span class="title function_">reactive</span>([<span class="string">&#x27;轮播文字11111111&#x27;</span>, <span class="string">&#x27;轮播文字222222222222&#x27;</span>, <span class="string">&#x27;轮播文字33333333333333333333&#x27;</span>])</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">const</span> index = <span class="title function_">ref</span>(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> (index.<span class="property">value</span> === list.<span class="property">length</span> - <span class="number">1</span> ? (index.<span class="property">value</span> = <span class="number">0</span>) : index.<span class="property">value</span>++), <span class="number">2000</span>)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.box</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">position</span>: relative;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">height</span>: <span class="number">50px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="number">90deg</span>,</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="built_in">rgba</span>(<span class="number">13</span>, <span class="number">0</span>, <span class="number">36</span>, <span class="number">1</span>) <span class="number">0%</span>,</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="built_in">rgba</span>(<span class="number">46</span>, <span class="number">59</span>, <span class="number">202</span>, <span class="number">0.8</span>) <span class="number">100%</span></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  );</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">10px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="selector-class">.inner</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">position</span>: absolute;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">height</span>: <span class="number">100%</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">display</span>: flex;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="attribute">align-items</span>: center;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.roll-enter-active</span>,</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.roll-leave-active</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transition</span>: all <span class="number">0.4s</span> ease-in-out;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.roll-enter-from</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(<span class="number">100%</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"><span class="selector-class">.roll-leave-to</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100%</span>);</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">&#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Quasar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-25-SpringBoot%E6%95%B4%E5%90%88Quartz/"/>
      <url>/2024/10/28/2024-01-25-SpringBoot%E6%95%B4%E5%90%88Quartz/</url>
      
        <content type="html"><![CDATA[<h1 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h1><p>定时任务是指调度程序在指定的时间或周期触发执行的任务  </p><p>使用场景：发送邮件、统计、状态修改、消息推送、活动开启、增量索引</p><h1 id="2-定时任务实现方式"><a href="#2-定时任务实现方式" class="headerlink" title="2. 定时任务实现方式"></a>2. 定时任务实现方式</h1><p><strong>Timer</strong>：是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。</p><p><strong>ScheduledExecutorService</strong>：也是jdk自带的一个类，是基于线程池设计的定时任务类，每个调度任务都会分配到线程池中的一个线程去执行，也就是说任务是并发执行，互不影响。</p><p><strong>Spring Task</strong>：Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。除spring相关的包外不需要额外的包，支持注解和配置文件两种形式。</p><p><strong>Quartz</strong>：这是一个功能比较强大的的任务调度框架，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。</p><h1 id="3-SpringBoot整合Quartz"><a href="#3-SpringBoot整合Quartz" class="headerlink" title="3. SpringBoot整合Quartz"></a>3. SpringBoot整合<a href="http://www.quartz-scheduler.org/documentation/">Quartz</a></h1><h2 id="3-1-为什么使用Quartz"><a href="#3-1-为什么使用Quartz" class="headerlink" title="3.1. 为什么使用Quartz"></a>3.1. 为什么使用Quartz</h2><p>某些场景，单靠 Spring 提供的 <code>@Schedule</code> 实现不了。比如我们需要对定时任务进行增删改查，<code>@Schedule</code> 就实现不了，你不可能每次新增一个定时任务都去手动改代码来添加吧。而 Quartz 就能够实现对任务的增删改查</p><p>Quartz 适用于各种类型的应用程序。无论是简单的定时任务还是复杂的分布式调度，Quartz都是一个强大而可靠的选择 </p><h2 id="3-2-Quartz的特性"><a href="#3-2-Quartz的特性" class="headerlink" title="3.2. Quartz的特性"></a>3.2. Quartz的特性</h2><p><strong>任务的调度（Job Scheduling）</strong></p><p>当一个<strong>触发器</strong>（Trigger）触发时，任务（Job） 就会被调度执行，触发器就是用来定义何时触发的。可以指定任务的执行时间，以及执行频率（例如，每天一次、每小时一次等）。</p><p>任务只需在调度器中添加一次，就可以有多个触发器进行注册</p><p><strong>任务的执行（Job Execution）</strong></p><p>实现了 Job 接口的 Java 类就是 Job，习惯称为<strong>任务类</strong>（Job class）。</p><p>当 Trigger 触发时，Scheduler 就会通知实现了 JobListener 和 TriggerListener 接口的 Java 对象。当然，这些 Java 对象在 Job 执行后也会被通知到。</p><p>当 Job 执行完毕时，会返回一个码JobCompletionCode，这个 JobCompletionCode 能够表示 Job 执行成功还是失败，我们就能通过这个 Code 来判断后续该做什么操作，比如重新执行这个 Job。</p><p><strong>任务的持久化（Job Persistence）</strong></p><p>Quartz允许将作业和触发器存储在数据库中，以便在应用程序重新启动后仍然保持调度状态。这样可以确保作业不会丢失，并且可以轻松地管理和监控调度任务。</p><p>Quartz 的设计包括了一个 JobStore 接口，该接口可以为存储 Job 提供各种机制。</p><p>通过 JDBCJobStore，可以将 Job 和 Trigger 持久化到关系型数据库中。</p><p>通过 RAMJobStore，可以将 Job 和 Trigger 存储到内存中（优点就是无须数据库，缺点就是这不是持久化的）。</p><p><strong>事务</strong></p><p>Quartz 可以通过使用 JobStoreCMT（JDBCJobStore的一个子类）参与 JTA 事务。</p><p>Quartz 可以围绕任务的执行来管理 JTA（Java Transaction API） 事务（开始并且提交它们），以便任务执行的工作自动发生在 JTA 事务中。</p><p><strong>错误恢复</strong></p><p>Quartz具有错误恢复机制，以确保在作业执行期间发生故障时能够进行恢复。可以配置Quartz重新执行失败的作业，并指定最大重试次数。</p><p><strong>集群和分布式</strong></p><p>故障转移、负载均衡</p><p>Quartz 的内置集群功能依赖于 JDBCJobStore 实现的数据库持久性。</p><p>Quartz 的 Terracotta 扩展提供了集群功能，而无需备份数据库。</p><p><strong>监听器和插件</strong></p><p>应用程序可以通过实现一个或多个监听器接口来捕获调度事件以监听或控制 Job / Trigger 的行为。</p><p>插件机制，我们可向 Quartz 添加功能，例如保存 Job 执行的历史记录，或从文件加载 Job 和 Trigger 的定义。</p><h2 id="3-3-Quartz核心元素"><a href="#3-3-Quartz核心元素" class="headerlink" title="3.3. Quartz核心元素"></a>3.3. Quartz核心元素</h2><p>Quartz核心要素有Scheduler、Trigger、Job、JobDetail，其中trigger和job、jobDetail为元数据，而Scheduler为实际进行调度的控制器。</p><ul><li>Trigger</li></ul><p>Trigger用于定义调度任务的时间规则，在Quartz中主要有四种类型的Trigger：SimpleTrigger、CronTrigger、DataIntervalTrigger和NthIncludedTrigger。</p><ul><li>Job&amp;JobDetail</li></ul><p>Quartz将任务分为Job、JobDetail两部分，其中Job用来定义任务的执行逻辑，而JobDetail用来描述Job的定义（例如Job接口的实现类以及其他相关的静态信息）。对Quartz而言，主要有两种类型的Job，StateLessJob、StateFulJob</p><ul><li>Scheduler</li></ul><p>实际执行调度逻辑的控制器，Quartz提供了DirectSchedulerFactory和StdSchedulerFactory等工厂类，用于支持Scheduler相关对象的产生</p><p><strong>核心元素间关系</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[SchedulerFactory] --&gt;B(Scheduler) </span><br><span class="line">B --&gt; C(Trigger) </span><br><span class="line">B --&gt; D(JobDetail)</span><br><span class="line">C --&gt; |n:1| D</span><br><span class="line">D --&gt;E(Job)</span><br></pre></td></tr></table></figure><h1 id="4-Quartz的基本使用"><a href="#4-Quartz的基本使用" class="headerlink" title="4. Quartz的基本使用"></a>4. Quartz的基本使用</h1><p>引入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-quartz<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>编写一个自定义类继承QuartzJobBean，该类用于具体逻辑的执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写一个自定义类，将该类交由Spring管理（使用<code>@Component</code>  ），在该类中注入<code>Scheduler</code>（<code>@Autowired</code>），之后可以创建一个方法，在方法中实现Scheduler任务调度器和Trigger任务触发器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoScheduler</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleExam</span><span class="params">(Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> SchedulerException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建一个JobDataMap，用于传递参数  </span></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDataMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobDataMap</span>();  </span><br><span class="line">        jobDataMap.put(<span class="string">&quot;examId&quot;</span>, (Integer) map.get(<span class="string">&quot;examId&quot;</span>));  </span><br><span class="line">        <span class="comment">// 创建任务  </span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(ExamEndTimeJob.class)  </span><br><span class="line">                .withIdentity(<span class="string">&quot;ExamEndTimeJob&quot;</span>, <span class="string">&quot;group1&quot;</span>)  </span><br><span class="line">                <span class="comment">// 将examId 参数传递给Job任务  </span></span><br><span class="line">                .usingJobData(jobDataMap)  </span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 时间格式转化  </span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> (LocalDateTime) map.get(<span class="string">&quot;endTime&quot;</span>);  </span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(endTime.atZone(ZoneId.systemDefault()).toInstant());  </span><br><span class="line">        <span class="comment">// 创建触发器  </span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()  </span><br><span class="line">                .withIdentity(<span class="string">&quot;examTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)  </span><br><span class="line">                .startAt(date)  <span class="comment">// 在指定时间执行任务  </span></span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 将任务和触发器添加到调度器  </span></span><br><span class="line">        scheduler.scheduleJob(job, trigger);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 启动调度器  </span></span><br><span class="line">        scheduler.start();  </span><br><span class="line">        log.info(<span class="string">&quot;任务调度器创建完成，将在:&quot;</span> + endTime.toString() + <span class="string">&quot;执行&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p><strong>传递参数</strong></p><p>在创建Scheduler任务调度器时给Job类传递参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个JobDataMap，用于传递参数  </span></span><br><span class="line"><span class="type">JobDataMap</span> <span class="variable">jobDataMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobDataMap</span>();  </span><br><span class="line">jobDataMap.put(<span class="string">&quot;examId&quot;</span>, (Integer) map.get(<span class="string">&quot;examId&quot;</span>));  </span><br><span class="line"><span class="comment">// 创建任务  </span></span><br><span class="line"><span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(ExamEndTimeJob.class)  </span><br><span class="line">        .withIdentity(<span class="string">&quot;ExamEndTimeJob&quot;</span>, <span class="string">&quot;group1&quot;</span>)  </span><br><span class="line">        <span class="comment">// 将examId 参数传递给Job任务  </span></span><br><span class="line">        .usingJobData(jobDataMap)  </span><br><span class="line">        .build();</span><br></pre></td></tr></table></figure><p>Job类中接收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JobDataMap</span> <span class="variable">dataMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">examId</span> <span class="operator">=</span> dataMap.getInt(<span class="string">&quot;examId&quot;</span>);</span><br></pre></td></tr></table></figure><h1 id="5-Quartz使用问题"><a href="#5-Quartz使用问题" class="headerlink" title="5. Quartz使用问题"></a>5. Quartz使用问题</h1><p>Scheduler调度器，应该由Spring注册，而不是new，这样Spring才会管理到Scheduler调度器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExamScheduler</span> &#123;  </span><br><span class="line">    <span class="meta">@Autowired</span>  </span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleExam</span><span class="params">(Map&lt;String, Object&gt; map)</span> <span class="keyword">throws</span> SchedulerException &#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 不能通过new来创建调度器  </span></span><br><span class="line"><span class="comment">//        Scheduler scheduler = new StdSchedulerFactory().getScheduler();  </span></span><br><span class="line">        <span class="comment">// 创建一个JobDataMap，用于传递参数  </span></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDataMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobDataMap</span>();  </span><br><span class="line">        jobDataMap.put(<span class="string">&quot;examId&quot;</span>, (Integer) map.get(<span class="string">&quot;examId&quot;</span>));  </span><br><span class="line">        <span class="comment">// 创建任务  </span></span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">job</span> <span class="operator">=</span> JobBuilder.newJob(ExamEndTimeJob.class)  </span><br><span class="line">                .withIdentity(<span class="string">&quot;ExamEndTimeJob&quot;</span>, <span class="string">&quot;group1&quot;</span>)  </span><br><span class="line">                <span class="comment">// 将examId 参数传递给Job任务  </span></span><br><span class="line">                .usingJobData(jobDataMap)  </span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 时间格式转化  </span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">endTime</span> <span class="operator">=</span> (LocalDateTime) map.get(<span class="string">&quot;endTime&quot;</span>);  </span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(endTime.atZone(ZoneId.systemDefault()).toInstant());  </span><br><span class="line">        <span class="comment">// 创建触发器  </span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()  </span><br><span class="line">                .withIdentity(<span class="string">&quot;examTrigger&quot;</span>, <span class="string">&quot;group1&quot;</span>)  </span><br><span class="line">                .startAt(date)  <span class="comment">// 在指定时间执行任务  </span></span><br><span class="line">                .build();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 将任务和触发器添加到调度器  </span></span><br><span class="line">        scheduler.scheduleJob(job, trigger);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 启动调度器  </span></span><br><span class="line">        scheduler.start();  </span><br><span class="line">        log.info(<span class="string">&quot;任务调度器创建完成，将在:&quot;</span> + endTime.toString() + <span class="string">&quot;执行&quot;</span>);  </span><br><span class="line">  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="6-任务的持久化"><a href="#6-任务的持久化" class="headerlink" title="6. 任务的持久化"></a>6. 任务的持久化</h1>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-29-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2024/10/28/2024-01-29-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>主要涉及三个关键词：</p><ul><li>同源策略（Same-origin policy，简称 SOP）</li><li>跨站请求伪造（Cross-site request forgery，简称 CSRF）</li><li>跨域资源共享（Cross-Origin Resource Sharing，简称 CORS）</li></ul><h1 id="2-什么是跨域"><a href="#2-什么是跨域" class="headerlink" title="2. 什么是跨域"></a>2. 什么是跨域</h1><p>跨域请求（Cross-Origin Request）是指在浏览器中发送AJAX请求时，请求的目标资源位于不同的域（域名、端口或协议）下的情况</p><p>构成跨域的条件：</p><ul><li>浏览器发送AJAX请求</li><li>域名、端口或协议不同</li></ul><h1 id="3-浏览器的同源策略"><a href="#3-浏览器的同源策略" class="headerlink" title="3. 浏览器的同源策略"></a>3. 浏览器的同源策略</h1><p>协议、域名、端口都一样，就是同源</p><p><strong>本质上 SOP 并不是禁止跨域请求，而是在请求后拦截了请求的响应</strong></p><p>其实 <strong>SOP 不是单一的定义</strong>，而是在不同情况下有不同的解释：</p><ul><li>限制 cookies、DOM 和 JavaScript 的命名区域</li><li>限制 iframe、图片等各种资源的内容操作</li><li>限制 ajax 请求，准确来说是<strong>限制操作 ajax 响应结果</strong></li></ul><p>如果没有了 SOP：</p><ul><li>一个浏览器打开几个 tab，数据就泄露了</li><li>你用 iframe 打开一个银行网站，你可以肆意读取网站的内容，就能获取用户输入的内容</li><li>更加肆意地进行 CSRF</li></ul><h1 id="4-跨站请求伪造-CSRF"><a href="#4-跨站请求伪造-CSRF" class="headerlink" title="4. 跨站请求伪造 CSRF"></a>4. 跨站请求伪造 CSRF</h1><p>CSRF（Cross-site request forgery）跨站请求伪造，是一种常见的攻击方式。是指 A 网站正常登陆后，cookie 正常保存，其他网站 B 通过某种方式调用 A 网站接口进行操作，A 的接口在请求时会自动带上 cookie</p><p>上面说了，SOP 可以通过 html tag 加载资源，而且 SOP 不阻止接口请求而是拦截请求结果，CSRF 恰恰占了这两个便宜</p><p><strong>所以 SOP 不能作为防范 CSRF 的方法</strong></p><p>对于 GET 请求，直接放到<code>&lt;img&gt;</code>就能神不知鬼不觉地请求跨域接口</p><p>对于 POST 请求，可以使用 form 提交</p><p>对于 ajax 请求，在获得数据之后你能肆意进行 js 操作。这时候虽然同源策略会阻止响应，但依然会发出请求。因为<strong>执行响应拦截的是浏览器</strong>而不是后端程序。事实上你的<strong>请求已经发到服务器</strong>并返回了结果，但是迫于安全策略，浏览器不允许你<strong>继续进行 js 操作</strong>，所以报出你熟悉的 blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource</p><p>不过浏览器并不是让所有请求都发送成功，上述情况仅限于<strong>简单请求</strong>，相关知识会在下面 CORS 一节详细解释</p><h1 id="5-跨域资源共享-CORS"><a href="#5-跨域资源共享-CORS" class="headerlink" title="5. 跨域资源共享 CORS"></a>5. 跨域资源共享 CORS</h1><p>跨域是浏览器限制，但是如果服务器设置了 CORS 相关配置，在返回服务器的信息头部会加上 <code>Access-Control-Allow-Origin</code>，浏览器看到这个字段的值与当前的源匹配，就会解锁跨域限制</p><p>CORS将请求分为：简单请求、非简单请求</p><h2 id="5-1-简单请求"><a href="#5-1-简单请求" class="headerlink" title="5.1. 简单请求"></a>5.1. 简单请求</h2><p>满足以下所有条件，则为简单请求</p><ul><li>请求方法为GET、HEAD、POST之一</li><li>HTTP头部信息只包含了以下字段：Accept、Accept-Language、Content-Language、Content-Type（但仅限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain）</li></ul><p><strong>处理方法：</strong></p><p>对于简单请求，CORS的策略是请求时在请求头中增加一个<code>Origin</code>字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost:8080</span><br><span class="line">Origin: http://localhost :8081</span><br><span class="line">Referer: http://localhost : 8081/index. html</span><br></pre></td></tr></table></figure><p>服务器收到请求后，根据该字段判断是否允许该请求访问，如果允许，则在HTTP头信息中添加<code>Access-Control-Allow-Origin</code>字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control -Allow-Origin: http://localhost:8081</span><br><span class="line">Content-Length: 20</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Date: Thu, 12 Jul 2018 12:51:14 GMT</span><br></pre></td></tr></table></figure><h2 id="5-2-非简单请求"><a href="#5-2-非简单请求" class="headerlink" title="5.2. 非简单请求"></a>5.2. 非简单请求</h2><p>如果请求不满足简单请求，则为非简单请求</p><p><strong>处理方法：</strong></p><p>非简单请求会在正式请求之前，先发送一个预检请求，称为OPTIONS请求</p><p>OPTIONS请求方法的作用是：用来请求服务器告知其支持的 HTTP 方法和其他一些选项，如是否支持跨域请求、支持哪些请求头等。预检请求会先发送一个OPTIONS请求，服务器响应该请求后，浏览器才会发起正式请求</p><p>非简单请求会在请求头中添加一个名为 <code>Origin</code> 的字段，该字段表示源地址，即发起请求的页面或域名。当服务器响应时，如果允许该源地址的请求，则会在响应头中添加一个名为 <code>Access-Control-Allow-Origin</code> 的字段，该字段的值为该源地址，表示允许该源地址的请求</p><h1 id="6-CORS-与-cookie"><a href="#6-CORS-与-cookie" class="headerlink" title="6. CORS 与 cookie"></a>6. CORS 与 cookie</h1><p>与同域不同，用于跨域的 CORS 请求默认不发送 Cookie 和 HTTP 认证信息，前后端都要在配置中设定请求时带上 cookie。</p><p>这就是为什么在进行 CORS 请求时 axios 需要设置 withCredentials: true。</p><h1 id="7-怎么解决跨域问题"><a href="#7-怎么解决跨域问题" class="headerlink" title="7. 怎么解决跨域问题"></a>7. 怎么解决跨域问题</h1><p>跨域问题可以从以下方面解决：</p><ul><li><strong>应用层面解决</strong>：例如 Spring Boot 项目中解决跨域问题。</li><li><strong>反向代理解决</strong>：例如 Nginx 中解决跨域问题。</li><li><strong>网关中解决</strong>：例如 Spring Cloud Gateway 中解决跨域问题。</li></ul><p>它们的使用优先级是：网关层 &gt; 代理层 &gt;  应用层。因为越靠前覆盖范围就越大，解决跨域问题就越容易。</p><h2 id="7-1-Spring-Boot-中解决跨域"><a href="#7-1-Spring-Boot-中解决跨域" class="headerlink" title="7.1. Spring Boot 中解决跨域"></a>7.1. Spring Boot 中解决跨域</h2><p>在 Spring Boot 中跨域问题有以下 5 种解决方案：</p><ul><li>使用 <code>@CrossOrigin</code> 注解实现跨域【局域类跨域】</li><li>通过配置文件实现跨域【全局跨域】</li><li>通过 CorsFilter 对象实现跨域【全局跨域】</li><li>通过 Response 对象实现跨域【局域方法跨域】</li><li>通过实现 ResponseBodyAdvice 实现跨域【全局跨域】</li></ul><p><strong>通过注解跨域</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;*&quot;)</span></span><br></pre></td></tr></table></figure><p><strong>通过配置文件跨域</strong></p><ul><li>创建一个新配置文件。</li><li>添加 <code>@Configuration</code> 注解，实现 WebMvcConfigurer 接口。</li><li>重写 addCorsMappings 方法，设置允许跨域的代码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 一定不要忽略此注解  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;  </span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>) <span class="comment">// 所有接口  </span></span><br><span class="line">        .allowCredentials(<span class="literal">true</span>) <span class="comment">// 是否发送 Cookie  </span></span><br><span class="line">        .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>) <span class="comment">// 支持域  </span></span><br><span class="line">        .allowedMethods(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;DELETE&quot;</span>&#125;) <span class="comment">// 支持方法  </span></span><br><span class="line">        .allowedHeaders(<span class="string">&quot;*&quot;</span>)  </span><br><span class="line">        .exposedHeaders(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-Nginx-中解决跨域"><a href="#7-2-Nginx-中解决跨域" class="headerlink" title="7.2. Nginx 中解决跨域"></a>7.2. Nginx 中解决跨域</h2><p>在 Nginx 服务器的配置文件中添加以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  your_domain.com;  </span><br><span class="line">    location /api &#123;  </span><br><span class="line">        # 允许跨域请求的域名，* 表示允许所有域名访问  </span><br><span class="line">        add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;  </span><br><span class="line">  </span><br><span class="line">        # 允许跨域请求的方法  </span><br><span class="line">        add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;  </span><br><span class="line">  </span><br><span class="line">        # 允许跨域请求的自定义 Header  </span><br><span class="line">        add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Origin, X-Requested-With, Content-Type, Accept&#x27;;  </span><br><span class="line">  </span><br><span class="line">        # 允许跨域请求的 Credential  </span><br><span class="line">        add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;  </span><br><span class="line">  </span><br><span class="line">        # 预检请求的存活时间，即 Options 请求的响应缓存时间  </span><br><span class="line">        add_header &#x27;Access-Control-Max-Age&#x27; 3600;  </span><br><span class="line">  </span><br><span class="line">        # 处理预检请求  </span><br><span class="line">        if ($request_method = &#x27;OPTIONS&#x27;) &#123;  </span><br><span class="line">            return 204;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    # 其他配置...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，<code>location /api</code> 代表配置针对 <code>/api</code>路径的请求进行跨域设置。可以根据具体需要修改 location 的值和其他相关参数。配置中的 add_header 指令用于设置响应头部，常用的响应头部包括以下这些：</p><ul><li><strong>Access-Control-Allow-Origin</strong>：用于指定允许跨域的域名，可以设置为 * 表示允许所有域名访问。</li><li><strong>Access-Control-Allow-Methods</strong>：用于指定允许的跨域请求的方法，例如 GET、POST、OPTIONS 等。</li><li><strong>Access-Control-Allow-Headers</strong>：用于指定允许的跨域请求的自定义 Header。</li><li><strong>Access-Control-Allow-Credentials</strong>：用于指定是否允许跨域请求发送和接收 Cookie。</li><li><strong>Access-Control-Max-Age</strong>：用于设置预检请求（OPTIONS 请求）的响应缓存时间。</li></ul><h2 id="7-3-网关中解决跨域"><a href="#7-3-网关中解决跨域" class="headerlink" title="7.3. 网关中解决跨域"></a>7.3. 网关中解决跨域</h2><p>Spring Cloud Gateway 中解决跨域问题可以通过以下两种方式实现：</p><ul><li>通过在配置文件中配置跨域实现。</li><li>通过在框架中添加 CorsWebFilter 来解决跨域问题。</li></ul><p><strong>配置文件中设置跨域</strong></p><p>在 application.yml 中添加以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  cloud:  </span><br><span class="line">    gateway:  </span><br><span class="line">      globalcors:  </span><br><span class="line">        corsConfigurations:  </span><br><span class="line">          &#x27;[/**]&#x27;: # 这里的&#x27;/**&#x27;表示对所有路由生效，可以根据需要调整为特定路径  </span><br><span class="line">            allowedOrigins: &quot;*&quot; # 允许所有的源地址，也可以指定具体的域名  </span><br><span class="line">            allowedMethods: # 允许的 HTTP 方法类型  </span><br><span class="line">              - GET  </span><br><span class="line">              - POST  </span><br><span class="line">              - PUT  </span><br><span class="line">              - DELETE  </span><br><span class="line">              - OPTIONS  </span><br><span class="line">            allowedHeaders: &quot;*&quot; # 允许所有的请求头，也可以指定具体的请求头  </span><br><span class="line">            allowCredentials: true # 是否允许携带凭证（cookies）  </span><br><span class="line">            maxAge: 3600 # CORS预检请求的有效期（秒）</span><br></pre></td></tr></table></figure><p><strong>添加 CorsWebFilter 来解决跨域问题</strong></p><p>Spring-Framework 5.3 版本之后，关于 CORS 跨域配置类 CorsConfiguration 中将 addAllowedOrigin 方法名修改为 addAllowedOriginPattern，因此配置了变成了以下这样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();  </span><br><span class="line">        <span class="comment">// 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改  </span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">        <span class="comment">// 放行的请求头  </span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);  </span><br><span class="line">        <span class="comment">// 放行的请求类型，有 GET, POST, PUT, DELETE, OPTIONS  </span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;*&quot;</span>);   </span><br><span class="line">        <span class="comment">// 暴露头部信息  </span></span><br><span class="line">        config.addExposedHeader(<span class="string">&quot;*&quot;</span>);   </span><br><span class="line">        <span class="comment">// 是否允许发送 Cookie  </span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);   </span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();  </span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>(source);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-30-Jackson/"/>
      <url>/2024/10/28/2024-01-30-Jackson/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常用的Jackson注解"><a href="#1-常用的Jackson注解" class="headerlink" title="1. 常用的Jackson注解"></a>1. 常用的Jackson注解</h1><h2 id="1-1-JsonProperty"><a href="#1-1-JsonProperty" class="headerlink" title="1.1. @JsonProperty"></a>1.1. @JsonProperty</h2><p>属性级别的注解，它主要有以下几个常用的属性</p><p><strong>value</strong></p><p>指定 JSON 中的属性名称，如果不设置则使用 Java 属性名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@JsonProperty(value=&quot;FirstName&quot;)</span>  <span class="comment">// 在序列化和反序列化时将以 FirstName 进行</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>defaultValue</strong></p><p>指定属性的默认值，如 <code>@JsonProperty(defaultValue = &quot;abcd&quot;)</code></p><p><strong>required</strong></p><p>指定属性是否是必填的，在反序列化时如果缺失该属性会抛出异常。如：<code>@JsonProperty(required = true)</code></p><p><strong>access</strong></p><p>控制属性的读写权限，可选值有 <code>READ_ONLY</code>、<code>WRITE_ONLY</code> 和 <code>READ_WRITE</code>。例如：<code>@JsonProperty(access = JsonProperty.Access.WRITE_ONLY)</code></p><h2 id="1-2-JsonIgnore"><a href="#1-2-JsonIgnore" class="headerlink" title="1.2. @JsonIgnore"></a>1.2. @JsonIgnore</h2><p>在序列化和反序列化时，忽略某个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="meta">@JsonIgnore</span>  <span class="comment">// 在序列化和反序列化时将忽略 firstName</span></span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-JsonIgnoreProperties"><a href="#1-3-JsonIgnoreProperties" class="headerlink" title="1.3. @JsonIgnoreProperties"></a>1.3. @JsonIgnoreProperties</h2><p>加在类上，用于在序列化和反序列化时，忽略类中的多个属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreProperties(&#123;&quot;bar&quot;, &quot;baz&quot;&#125;)</span> <span class="comment">// 在序列化和反序列化时将忽略 bar 和 baz</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> String foo;</span><br><span class="line">    <span class="keyword">private</span> String bar;</span><br><span class="line">    <span class="keyword">private</span> Integer baz;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-JsonPropertyOrder"><a href="#1-4-JsonPropertyOrder" class="headerlink" title="1.4. @JsonPropertyOrder"></a>1.4. @JsonPropertyOrder</h2><p>加在类上，用于在序列化和反序列化时，更改属性的排列顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonPropertyOrder(value = &#123;&quot;lastName&quot;,&quot;firstName&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 默认</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;,</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 修改顺序后</span><br><span class="line">&#123;</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;,</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-JsonIgnoreType"><a href="#1-5-JsonIgnoreType" class="headerlink" title="1.5. @JsonIgnoreType"></a>1.5. @JsonIgnoreType</h2><p>加在类上，当该类作为其他类的子类时，在序列化和反序列化时，会忽略该类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonIgnoreType</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address1;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;,</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-JsonFormat"><a href="#1-6-JsonFormat" class="headerlink" title="1.6. @JsonFormat"></a>1.6. @JsonFormat</h2><p>在序列化某些类型（尤其是日期）时，设置序列化和反序列化的格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Date createdDate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-JsonUnwrapped"><a href="#1-7-JsonUnwrapped" class="headerlink" title="1.7. @JsonUnwrapped"></a>1.7. @JsonUnwrapped</h2><p>加在类上，当该类作为其他类的子类时，在序列化和反序列化时，自动按一定规则解包（<code>prefix</code>属性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String address1;</span><br><span class="line">    <span class="keyword">private</span> String address2;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String zip;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String firstName;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@JsonUnwrapped</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 常规情况下的序列化结果</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;,</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;,</span><br><span class="line">  &quot;address&quot; : &#123;</span><br><span class="line">    &quot;address1&quot; : &quot;123 Main Street&quot;,</span><br><span class="line">    &quot;address2&quot; : null,</span><br><span class="line">    &quot;city&quot; : &quot;Hollywood&quot;,</span><br><span class="line">    &quot;state&quot; : &quot;CA&quot;,</span><br><span class="line">    &quot;zip&quot; : &quot;33023&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有添加前缀解包规则</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;,</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;,</span><br><span class="line">  &quot;address1&quot; : &quot;123 Main Street&quot;,</span><br><span class="line">  &quot;address2&quot; : null,</span><br><span class="line">  &quot;city&quot; : &quot;Hollywood&quot;,</span><br><span class="line">  &quot;state&quot; : &quot;CA&quot;,</span><br><span class="line">  &quot;zip&quot; : &quot;33023&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 添加前缀解包规则</span><br><span class="line">&#123;</span><br><span class="line">  &quot;firstName&quot; : &quot;Harrison&quot;,</span><br><span class="line">  &quot;lastName&quot; : &quot;Ford&quot;,</span><br><span class="line">  &quot;addr.address1&quot; : &quot;123 Main Street&quot;,</span><br><span class="line">  &quot;addr.address2&quot; : null,</span><br><span class="line">  &quot;addr.city&quot; : &quot;Hollywood&quot;,</span><br><span class="line">  &quot;addr.state&quot; : &quot;CA&quot;,</span><br><span class="line">  &quot;addr.zip&quot; : &quot;33023&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-JsonGetter"><a href="#1-8-JsonGetter" class="headerlink" title="1.8. @JsonGetter"></a>1.8. @JsonGetter</h2><h2 id="1-9-JsonAnyGetter-and-JsonAnySetter"><a href="#1-9-JsonAnyGetter-and-JsonAnySetter" class="headerlink" title="1.9. @JsonAnyGetter and @JsonAnySetter"></a>1.9. @JsonAnyGetter and @JsonAnySetter</h2><h2 id="1-10-JsonValue"><a href="#1-10-JsonValue" class="headerlink" title="1.10. @JsonValue"></a>1.10. @JsonValue</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-30-SpringCache/"/>
      <url>/2024/10/28/2024-01-30-SpringCache/</url>
      
        <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>从 3.1 版本开始，Spring 框架提供了对现有 Spring 应用透明地添加缓存的支持。与事务支持类似，缓存抽象允许一致使用各种缓存解决方案，对代码的影响最小。</p><p>在 Spring Framework 4.1 中，缓存抽象得到了极大的扩展，支持 <code>JSR-107</code> 注解 和更多的自定义选项</p><p>Spring 提供的核心缓存抽象位于 <code>spring-context</code>模块中</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><p>如果是 Spring Boot 项目，可以利用 <code>spring-boot-starter-cache</code> 来轻松添加缓存依赖项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该 Starter 包含了<code>spring-context-support</code>模块，它位于 <code>spring-context</code>模块之上，并提供了更多由 <code>EhCache</code>或 <code>Caffeine</code>支持的 <code>CacheManager</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-02-01-SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/"/>
      <url>/2024/10/28/2024-02-01-SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringBoot常用注解（重点）"><a href="#1-SpringBoot常用注解（重点）" class="headerlink" title="1. SpringBoot常用注解（重点）"></a>1. SpringBoot常用注解（重点）</h1><p><strong>配置相关的</strong></p><ul><li>@SpringBootApplication：这是Spring Boot应用的主注解，它包含了@ComponentScan、@EnableAutoConfiguration和@Configuration三个注解，用于开启组件扫描、自动配置和配置类扫描等功能。</li><li>@EnableAutoConfiguration：这个注解用于自动配置Spring应用，从classpath下的<code>META-INF/spring.factories</code>中读取自动配置类，根据配置自动装配Bean。</li><li>@Configuration：这个注解用于标记一个配置类，表示该类包含了一些配置信息，可以用@Bean注解定义一些Bean。</li><li>@ConditionalOnProperty：这个注解用于根据配置文件中的属性值来判断是否需要启用某个配置。</li></ul><p><strong>请求相关的</strong></p><ul><li>@RestController：这个注解用于标记一个Controller类，它包含了@Controller和@ResponseBody注解的功能，用于处理HTTP请求并返回JSON、XML等格式的响应数据</li><li>@RequestMapping：这个注解用于标记一个请求处理方法，指定处理的URL路径和HTTP请求方法。</li><li>@GetMapping、@PostMapping、@PutMapping、@DeleteMapping：这些注解是对@RequestMapping注解的补充，分别表示处理GET、POST、PUT、DELETE请求的方法。</li><li>@PathVariable：这个注解用于将URL路径中的变量映射到方法参数上。</li><li>@RequestParam：这个注解用于将HTTP请求参数映射到方法参数上。</li><li>@RequestBody：这个注解用于将HTTP请求体中的数据映射到方法参数上。</li><li>@ResponseBody：表示方法的返回值将直接作为响应的内容返回给客户端，不会经过视图解析器进行视图渲染。可以将@ResponseBody注解应用在控制器类的方法上，也可以将其应用在方法的参数上</li></ul><p><strong>注入相关的</strong></p><ul><li>@Bean：将对应的实例对象放进IOC容器</li><li>@Autowired：自动装配一个IOC容器中存在的Bean</li><li>@Resource：</li><li>@Component：这个注解用于标记一个组件，表示该组件可以被Spring容器扫描并管理。</li><li>@Service</li><li>@Mapper</li><li>@Repository</li></ul><h1 id="2-Controller-amp-Service-amp-Component"><a href="#2-Controller-amp-Service-amp-Component" class="headerlink" title="2. @Controller&amp;@Service&amp;@Component"></a>2. <code>@Controller</code>&amp;<code>@Service</code>&amp;<code>@Component</code></h1><p><code>@Controller</code>和<code>@Service</code>都派生于<code>@Component</code>，都是Spring的注解</p><p><code>@Component</code>用来标记所有被Spring容器管理的组件，本质上都是把实例化对象交给Spring管理</p><p>在平时的开发中，我们通常在控制层采用注解<code>@Controller</code>，在业务层采用注解<code>@Service</code></p><p>Spring在启动时，有一个非常核心的类<code>ConfigurationClassPostProcessor</code>会对类路径下的所有类进行扫描，将符合条件的bean扫描出来添加到<code>beanDefinitionMap</code>集合中，方便接下来的实例化。</p><p>如果不使用SpringMVC时，三者使用其实是没有什么差别的，但如果使用了SpringMVC，<code>@Controller</code>就被赋予了特殊的含义</p><p>Spring会遍历上面扫描出来的所有bean，过滤出那些添加了注解<code>@Controller</code>的bean，将Controller中所有添加了注解<code>@RequestMapping</code>的方法解析出来封装成<code>RequestMappingInfo</code>存储到<code>RequestMappingHandlerMapping</code>中的<code>mappingRegistry</code>。后续请求到达时，会从<code>mappingRegistry</code>中查找能够处理该请求的方法</p><h1 id="3-Repository-amp-Mapper"><a href="#3-Repository-amp-Mapper" class="headerlink" title="3. @Repository&amp;@Mapper"></a>3. <code>@Repository</code>&amp;<code>@Mapper</code></h1><p><code>@Repository</code>是属于Spring的注解，<code>@Mapper</code>是属于Mybatis的注解</p><p><code>@Repository</code>是<code>@Component</code>的一个派生品</p><p><strong>@Repository和@Mapper的异同</strong></p><p>在程序中，Mybatis需要找到对应的mapper，在编译时候动态生成代理类，实现数据库查询功能<br><code>@Mapper</code>和<code>@Repository</code>注解的使用方式一样，都是在持久层的接口上添加注解。但是如果只是单独的使用<code>@Mapper</code>注解的话，在idea中进行自动装配的时候，会出现警告，提示找不到这个bean。但是这个不影响程序运行，可以直接忽略。  想要不出现这个警告，可以在idea设置中对这种警告进行忽略，也可以在使用<code>@Mapper</code>的地方同时使用  <code>@Repository</code>注解。这样Spring会扫描<code>@Repository</code>并识别这个bean，就不会出现这个警告</p><p><code>@Repository</code> + 在SpringBoot的启动类上使用<code>@MapperScan</code>注解 = <code>@Mapper</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapperScan(value = &#123;&quot;com.bf.spring4.mapper&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h1 id="4-Autowired-amp-Bean-amp-Resource"><a href="#4-Autowired-amp-Bean-amp-Resource" class="headerlink" title="4. @Autowired&amp;@Bean&amp;@Resource"></a>4. <code>@Autowired</code>&amp;<code>@Bean</code>&amp;<code>@Resource</code></h1><p><code>@Bean</code>修饰的只有方法，并且功能单一，就是初始化一个bean然后交给IOC容器管理。</p><p><code>@Autowired</code>可以修饰常量和方法，用于自动装配（自动装配的前提你要先有才能装配，你直接引用资源就行，没有相当于白扯）</p><p><code>@Resource</code>可以修饰常量和方法，用于自动装配（自动装配的前提你要先有才能装配，你直接引用资源就行，没有相当于白扯）</p><p><code>@Autowired</code> 和 <code>@Resource</code> 的区别主要体现在以下 5 点：</p><ol><li>来源不同；</li><li>依赖查找的顺序不同；</li><li>支持的参数不同；</li><li>依赖注入的用法不同；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-02-05-Java%20Web/"/>
      <url>/2024/10/28/2024-02-05-Java%20Web/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1. Servlet"></a>1. Servlet</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1. 基本概念"></a>1.1. 基本概念</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  A(http请求)--&gt;B(Web服务器如Tomcat);</span><br><span class="line">  B--&gt;C(Servlet);</span><br></pre></td></tr></table></figure><p>Servlet 就是处理http请求的类，它接收http请求，并给出响应</p><h2 id="1-2-Servlet和Servlet容器"><a href="#1-2-Servlet和Servlet容器" class="headerlink" title="1.2. Servlet和Servlet容器"></a>1.2. Servlet和Servlet容器</h2><p><strong>Servlet的运行</strong></p><p>Servlet 在 Servlet容器的管理下运行，Servlet 需要先在Servlet Container 中注册才能运行 </p><p>Servlet在Servlet Container 中的生命周期，init-service-destroy</p><p>Servlet Container接收到HTTP请求时，它会根据请求的URL映射到相应的Servlet，并调用Servlet的相应方法（如doGet、doPost等）来处理请求</p><p><strong>Servlet Container</strong></p><p>常见的Servlet Container，Apache Tomcat、Jetty</p><p>Servlet Container 会创建一个ServletContext对象，ServletContext用作服务器或容器的内存并且记住与web应用程序关联的所有servlets，filters和listeners，通常被描述为 <code>web.xml</code>，在我们终止容器之前，ServletContext一直在容器中</p><p>Servlet的load-on-startup参数起着重要的作用。如果此参数的值大于零，则只有在启动时服务器才初始化它。如果未指定此参数，则在请求第一次到达Servlet的init()时调用它</p><h2 id="1-3-Request-Response-Session"><a href="#1-3-Request-Response-Session" class="headerlink" title="1.3. Request,Response,Session"></a>1.3. Request,Response,Session</h2><p>在Servlet中请求用HttpServletRequest表示，响应用HttpServletResponse表示。这些对象的生命周期是短暂的。当客户端获得响应返回时，Servlet Container 将为此次的请求和响应对象做垃圾收集标记。</p><p>HttpSession是维护客户端与服务器之间请求状态的，这是将对象绑定到用户会话，以便特定用户相关的信息可以跨多个请求持久化。我们可以在<code>web.xml</code>中为会话指定超时时间，这个时间就是它的生命周期</p><h2 id="1-4-Servlets间共享数据"><a href="#1-4-Servlets间共享数据" class="headerlink" title="1.4. Servlets间共享数据"></a>1.4. Servlets间共享数据</h2><p>根据所需的作用域，Servlet可以有多种方式共享数据。因为不同的对象有不同的生存期</p><h2 id="1-5-处理多线程"><a href="#1-5-处理多线程" class="headerlink" title="1.5. 处理多线程"></a>1.5. 处理多线程</h2><p>多个HttpServletRequest对象彼此共享Servlet，这样每个请求都使用Servlet实例自己的线程进行操作</p><p>为了线程安全，我们不应该将请求或会话作用域的数据分配为Servlet的实例变量</p><h1 id="2-Filter"><a href="#2-Filter" class="headerlink" title="2. Filter"></a>2. Filter</h1><p>Filter是一种用于在Servlet之前或之后执行预处理或后处理任务的组件</p><p>Filter可以用于对请求进行过滤、验证和修改，也可以对响应进行处理，例如添加额外的头信息或修改响应内容</p><p>Filter可以按照配置的顺序链接在一起，形成一个过滤器链，每个过滤器都可以对请求和响应进行处理</p><h1 id="3-Listener"><a href="#3-Listener" class="headerlink" title="3. Listener"></a>3. Listener</h1><p>Listener是一种用于监听Web应用程序中事件和生命周期的组件</p><p>Listener可以监听Web应用程序的启动和关闭事件，以及会话的创建和销毁事件</p><p>Listener可以在特定事件发生时执行自定义的逻辑，例如初始化资源、加载配置、记录日志等</p><h1 id="4-JSP"><a href="#4-JSP" class="headerlink" title="4. JSP"></a>4. JSP</h1><p>Java Server Pages，JSP页面在服务器端被编译为Servlet，并在客户端请求时动态生成HTML响应</p><h1 id="5-JSTL"><a href="#5-JSTL" class="headerlink" title="5. JSTL"></a>5. JSTL</h1><p>JavaServer Pages Standard Tag Library，JSTL是一组基于JSP的自定义标签，用于简化JSP页面的开发</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-02-26-%E5%B8%B8%E7%94%A8%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
      <url>/2024/10/28/2024-02-26-%E5%B8%B8%E7%94%A8%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主子表"><a href="#1-主子表" class="headerlink" title="1. 主子表"></a>1. 主子表</h1><p>主子表是一种常见的关系型数据库设计模式，也称为主从表或父子表。在主子表模式中，存在两个相关的表，一个是主表（或父表），另一个是子表。</p><p>子表中的每条记录都与主表中的某一记录相关联。主子表之间的关系通常通过外键来建立。子表中的外键列引用主表中的主键列，以确保数据的完整性和一致性。</p><p>主子表模式的设计通常用于处理一对多的关系。例如，一个学校的数据库中可能有两张表：学生表和成绩表。学生表是主表，每个学生对应一条记录；成绩表是子表，每个学生的成绩对应一条记录，并通过外键与学生表建立关联。这样，可以通过主表和子表的关系来查询某个学生的成绩信息。</p><h1 id="2-树结构表"><a href="#2-树结构表" class="headerlink" title="2. 树结构表"></a>2. 树结构表</h1><p>树结构表用于表示具有层级关系的数据。树结构表可以用于表示许多实际情况，如组织结构、文件系统、商品分类等。</p><p>在树结构表中，通常使用两个字段来表示节点之间的关系。一个是主键字段，用于唯一标识每个节点；另一个是指向父节点的外键字段，用于建立节点之间的层级关系。通过使用递归查询或者使用非递归的查询方式，可以对树结构表进行遍历、查找、插入和删除操作</p><p>在处理大型树结构表时，查询和维护操作可能会变得复杂和低效。为了提高性能，可以使用一些优化技术，如使用路径字段、递归查询优化、使用索引等。其中路径字段最为常用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-02-07-Vue%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/10/28/2024-02-07-Vue%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Vue的开发环境"><a href="#1-Vue的开发环境" class="headerlink" title="1. Vue的开发环境"></a>1. Vue的开发环境</h1><p>需要先安装好node.js</p><p><strong>安装Vue</strong></p><p>使用管理员cmd运行 <code>npm install vue -g</code></p><p><strong>安装Vue-cli</strong></p><p>Vue 构建工具，Vue CLI 使用了Webpack作为构建工具，Vue CLI = Vue + 一堆的js插件</p><p>使用管理员权限运行  <code>npm install vue-cli -g</code> 或者 <code>npm install -g @vue/cli</code> （安装的是最新版）</p><p>Vue.js 的版本和 Vue CLI 的版本是两个不同的概念，它们之间并没有直接的关系，使用 Vue CLI 来创建和管理项目。Vue CLI 会自动安装与当前项目兼容的 Vue.js 版本。如果您在使用 Vue CLI 创建项目时指定了要使用的 Vue.js 版本，那么 Vue CLI 会自动安装指定版本的 Vue.js</p><h1 id="2-用Vue-cli-构建Vue项目"><a href="#2-用Vue-cli-构建Vue项目" class="headerlink" title="2. 用Vue-cli 构建Vue项目"></a>2. 用Vue-cli 构建Vue项目</h1><p>创建项目文件夹，切换到该文件夹下，构建vue项目，使用管理员权限运行 <code>vue create vue01</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(*) Babel</span><br><span class="line">( ) TypeScript</span><br><span class="line">( ) Progressive Web App (PWA) Support</span><br><span class="line">(*) Router</span><br><span class="line">(*) Vuex</span><br><span class="line">(*) CSS Pre-processors</span><br><span class="line">( ) Linter / Formatter</span><br><span class="line">( ) Unit Testing</span><br><span class="line">( ) E2E Testing</span><br></pre></td></tr></table></figure><p>若下载依赖速度慢可以<code>npm config set registry https://registry.npm.taobao.org</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">? Vue build standalone</span><br><span class="line">? Install vue-router? Yes</span><br><span class="line">? Use ESLint to lint your code? No</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Setup e2e tests with Nightwatch? No</span><br><span class="line">? Should we run `npm install` for you after the project has been created? (recommended) npm</span><br></pre></td></tr></table></figure><p>启动项目，使用管理员权限运行<code>npm run serve</code></p><p>安装依赖，使用管理员权限运行 <code>npm install name</code></p><h2 id="2-1-项目结构"><a href="#2-1-项目结构" class="headerlink" title="2.1. 项目结构"></a>2.1. 项目结构</h2><p>以 vue-admin-template 为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api 前端的所有请求</span><br><span class="line">assets 主题、字体等静态资源</span><br><span class="line">components 全局公用组件</span><br><span class="line">icons  项目所有 svg icons</span><br><span class="line">mock  项目mock 模拟数据</span><br><span class="line">router 管理前端路由</span><br><span class="line">App.vue 是根组件</span><br><span class="line">main.js  相当于main方法，是整个项目的入口js</span><br><span class="line">store 全局store管理</span><br><span class="line">utils  全局公用方法</span><br><span class="line">styles  全局样式</span><br><span class="line">views 视图，存放各个页面的自定义组件</span><br><span class="line">layout 布局</span><br><span class="line">permission.js  权限管理，根据用户的不同权限可以实现动态路由</span><br><span class="line">项目中 @指的是src目录</span><br></pre></td></tr></table></figure><h2 id="2-2-package-json"><a href="#2-2-package-json" class="headerlink" title="2.2. package.json"></a>2.2. package.json</h2><p>方便快捷的管理项目依赖的资源，避免资源间的版本冲突等问题</p><p>构建一个vue项目时，只需用package.json即可。执行 <code>npm install</code>，npm会自动从package.json中读取依赖，进行下载</p><h2 id="2-3-Vue-CLI-多种环境"><a href="#2-3-Vue-CLI-多种环境" class="headerlink" title="2.3. Vue CLI 多种环境"></a>2.3. Vue CLI 多种环境</h2><p>.env.development：本地</p><p>.env.staging：测试环境</p><p>.env.production：正式环境</p><h2 id="2-4-版本问题"><a href="#2-4-版本问题" class="headerlink" title="2.4. 版本问题"></a>2.4. 版本问题</h2><p>vue版本查看：<code>vue -V</code></p><p>Vue CLI 4.5以下，对应的是Vue2</p><p>Vue CLI 4.5及以上，对应的是Vue3，当然，创建项目的时候可以选择Vue2</p><ul><li><code>^</code> 符号表示兼容的更新，例如 <code>^5.0.0</code> 表示可以安装 <code>5.x.x</code> 版本系列的最新版本，但不包括 <code>6.0.0</code> 或更高版本。</li><li><code>~</code> 符号表示只安装修订版本的更新，例如 <code>~5.0.0</code> 表示可以安装 <code>5.0.x</code> 版本系列的最新版本，但不包括 <code>5.1.0</code> 或更高版本。</li><li><code>&gt;</code> 和 <code>&lt;</code> 符号分别表示大于和小于某个特定版本，例如 <code>&gt;4.0.0</code> 表示可以安装大于 <code>4.0.0</code> 的任何版本。</li><li><code>&gt;=</code> 和 <code>&lt;=</code> 符号分别表示大于等于和小于等于某个特定版本，例如 <code>&gt;=4.0.0</code> 表示可以安装大于等于 <code>4.0.0</code> 的任何版本，包括 <code>4.0.0</code> 本身。</li></ul><h1 id="3-Vue项目运行流程"><a href="#3-Vue项目运行流程" class="headerlink" title="3. Vue项目运行流程"></a>3. Vue项目运行流程</h1><p><strong>执行 npm run dev 命令后，发生了什么</strong></p><ol><li>npm 解析并执行在 package.json 文件中定义的 dev 脚本</li><li>在 dev 脚本中，一般会执行 vue-cli-service 命令，用于启动开发服务器和构建项目。</li><li>vue-cli-service 命令会加载 Vue CLI 的配置文件，并根据配置进行相应的操作。</li><li>根据配置，vue-cli-service 会启动一个开发服务器，监听指定的端口（通常是8080）。</li><li>在启动开发服务器时，vue-cli-service 会读取项目配置文件（如 vue.config.js），并执行其中的配置选项。</li><li>在项目构建过程中，vue-cli-service 会根据配置进行一系列操作，如编译 Vue 单文件组件、处理样式文件、打包 JavaScript 文件等。</li><li>构建完成后，开发服务器会将构建后的文件提供给浏览器进行访问。</li><li>浏览器发送HTTP请求到开发服务器，并接收响应。</li><li>开发服务器将构建后的文件提供给浏览器，浏览器解析并渲染页面。</li><li>当文件发生变化时，开发服务器会自动重新构建项目，并通知浏览器刷新页面，以便实时预览更改</li><li>浏览器加载<code>index.html</code>作为初始页面，并解析其中的HTML、CSS和JavaScript代码。</li><li>在<code>index.html</code>中，浏览器加载并执行<code>main.js</code>文件。</li><li>在<code>main.js</code>中，首先引入Vue库和其他依赖项。</li><li>创建Vue实例，并将其挂载到<code>index.html</code>中的根DOM元素上。</li><li>随后就被实例中的组件中的模板中的内容所取代</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">0(浏览器)--&gt;A;</span><br><span class="line">   A(index.html)--&gt;B(main.js);</span><br><span class="line">   B--&gt;C(创建App.vue实例);</span><br><span class="line">   C--&gt;|挂载到id为app的挂载点|A;</span><br></pre></td></tr></table></figure><h1 id="4-部署Vue项目"><a href="#4-部署Vue项目" class="headerlink" title="4. 部署Vue项目"></a>4. 部署Vue项目</h1><h2 id="4-1-打包"><a href="#4-1-打包" class="headerlink" title="4.1. 打包"></a>4.1. 打包</h2><p>打包应用时应读取生产环境下的配置 <code>.env.production</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build:prod</span><br></pre></td></tr></table></figure><h2 id="4-2-配置nginx"><a href="#4-2-配置nginx" class="headerlink" title="4.2. 配置nginx"></a>4.2. 配置nginx</h2><p>进入nginx/conf.d 目录，创建 vue.conf文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen80;</span><br><span class="line">server_name locahost;</span><br><span class="line">location / &#123;</span><br><span class="line">root /usr/app/dist;</span><br><span class="line">index index.html;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-10-SpringBootStarter%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/10/28/2024-01-10-SpringBootStarter%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本步骤"><a href="#1-基本步骤" class="headerlink" title="1. 基本步骤"></a>1. 基本步骤</h1><ul><li>创建一个starter项目，关于项目的命名，Spring 官方 Starter通常命名为<code>spring-boot-starter-&#123;name&#125;</code>如 spring-boot-starter-web， Spring官方建议非官方Starter命名应遵循<code>&#123;name&#125;-spring-boot-starter</code>的格式</li><li>一个/多个自定义配置的属性配置类（ConfigurationProperties类）如果你的项目不使用配置信息则可以跳过这一步</li><li>一个/多个自动配置类（AutoConfiguration类），引用定义好的配置信息。在AutoConfiguration中实现starter应该完成的所有操作</li><li>把自动配置类（AutoConfiguration类）写入到 Spring Boot 的 SPI 机制配置文件：spring.factories</li><li>打包项目，之后在一个SpringBoot项目中引入该项目依赖，然后就可以使用该starter了</li></ul><h1 id="2-Java-SPI-机制简介"><a href="#2-Java-SPI-机制简介" class="headerlink" title="2. Java SPI 机制简介"></a>2. Java SPI 机制简介</h1><p>SPI 全称 Service Provider Interface，是 Java 提供的一套用来被第三方实现或者扩展的 API，它可以用来启用框架扩展和替换组件。</p><p>SPI 的大概流程是：调用方 –&gt; 标准服务接口 –&gt; 本地服务发现（配置文件） –&gt; 具体实现</p><p>所以 Java SPI 实际上是<strong>基于接口的编程＋策略模式＋配置文件组合实现的动态加载机制</strong></p><p>一个 SPI 的典型案例就是 JDBC 的驱动，Java JDBC 定义接口规范（java.sql.Driver），各个数据库厂商（MySQL/Oracle/MS SQLServer 等）去完成具体的实现，然后通过 SPI 配置文件引入具体的实现类</p><p><strong>一个简单的 Java SPI 开发步骤</strong></p><ul><li>定义一个业务接口</li><li>编写接口实现类</li><li>创建 SPI 的配置文件，实现类路径写入配置文件中</li><li>通过 Java SPI 机制调用</li></ul><p>step1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bumblebee</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>step3：在<code>META-INF/services</code> 文件夹下创建一个文件，名称为Robot的全路径类名 <code>ora.apache.spi.Robot</code>，内容为实现类的全路径类名<code>org.apache.spi.Bumblebee</code></p><p>step4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">ServiceLoader&lt;Robot&gt; serviceLoader = ServiceLoader.load(Robot.class);</span><br><span class="line">System.out.println(<span class="string">&quot;java spi&quot;</span>);</span><br><span class="line">serviceLoader.forEach(Robot::sayHello);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Spring-Boot-SPI-机制实现"><a href="#3-Spring-Boot-SPI-机制实现" class="headerlink" title="3. Spring Boot SPI 机制实现"></a>3. Spring Boot SPI 机制实现</h1><p> Spring Boot 的 SPI 实现了，基本流程是一样的：读取配置文件 –&gt; 将具体的实现类装配到 Spring Boot 的上下文环境中</p><h1 id="4-开发一个自定义-starter"><a href="#4-开发一个自定义-starter" class="headerlink" title="4. 开发一个自定义 starter"></a>4. 开发一个自定义 starter</h1><h2 id="4-1-创建一个SpringBoot项目"><a href="#4-1-创建一个SpringBoot项目" class="headerlink" title="4.1. 创建一个SpringBoot项目"></a>4.1. 创建一个SpringBoot项目</h2><p>项目的命名应遵循<code>&#123;name&#125;-spring-boot-starter</code>的格式</p><p>先在pom.xml中引入起始的依赖项（spring-boot-starter是必须的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lance.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-source-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-2-创建属性配置类（可选）"><a href="#4-2-创建属性配置类（可选）" class="headerlink" title="4.2. 创建属性配置类（可选）"></a>4.2. 创建属性配置类（可选）</h2><p>创建User类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    构造器</span></span><br><span class="line"><span class="comment">    getters and setters</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个用于自定义配置的属性类。可以使用<code>@ConfigurationProperties</code>注解定义一组属性，并提供它们的getter和setter方法，以便在应用程序中进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;my.user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyProperties</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>; <span class="comment">// 默认值</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    getters and setters</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-3-创建自动配置类"><a href="#4-3-创建自动配置类" class="headerlink" title="4.3. 创建自动配置类"></a>4.3. 创建自动配置类</h2><p>在应用程序启动时，如果类路径中存在User类，则MyAutoConfiguration类将运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass(User.class)</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties(MyProperties.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAutoConfiguration</span> &#123;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line">MyProperties myProperties;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyAutoConfiguration.class);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyAutoConfiguration</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span> <span class="comment">// 它会保证你的bean只有一个，即你的实例只有一个</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">userManager</span><span class="params">()</span> &#123;  </span><br><span class="line">        logger.info(<span class="string">&quot;User bean start to create.&quot;</span>);  </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(myProperties.getUserName(),myProperties.getPassword());</span><br><span class="line">        logger.info(<span class="string">&quot;user\t&quot;</span>+ user.toString());</span><br><span class="line">        <span class="keyword">return</span> user;  </span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><p>运行之后，可在<code>application.properties</code> 中，修改属性值</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">my.user.userName=root</span>  </span><br><span class="line"><span class="string">my.user.password=root</span></span><br></pre></td></tr></table></figure><h2 id="4-4-创建spring-factories"><a href="#4-4-创建spring-factories" class="headerlink" title="4.4. 创建spring.factories"></a>4.4. 创建spring.factories</h2><p>在<code>src/main/resources/META-INF</code>目录中添加一个<code>spring.factories</code>文件，将AutoConfiguration类在该文件中进行声明</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hy.MyAutoConfiguration</span></span><br></pre></td></tr></table></figure><h2 id="4-5-打包Starter"><a href="#4-5-打包Starter" class="headerlink" title="4.5. 打包Starter"></a>4.5. 打包Starter</h2><p>在项目的根目录中运行以下命令进行打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean install</span><br></pre></td></tr></table></figure><h2 id="4-6-自定义-starter-优化"><a href="#4-6-自定义-starter-优化" class="headerlink" title="4.6. 自定义 starter 优化"></a>4.6. 自定义 starter 优化</h2><p>属性配置自动提示功能：使用 Spring Boot 官方提供的 starter 的时候，在 application.properties 中编写属性配置是有自动提示功能的，要实现这个也很简单，引入一下依赖即可，该插件引入后，打包时会检查 @ConfigurationProperties 下的类，自动生成 spring-configuration-metadata.json 文件用于编写属性提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动优化：前面有提到 Spring Boot 的 SPI 加载流程，会先加载自动配置元数据配置文件，引入以下依赖，该插件会自动生成 META-INF/spring-autoconfigure-metadata.properties，供 AutoConfigurationImportSelector 过滤加载，提升启动性能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-7-在其他项目引入"><a href="#4-7-在其他项目引入" class="headerlink" title="4.7. 在其他项目引入"></a>4.7. 在其他项目引入</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hy<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-10-SpringBoot%E7%94%9F%E6%80%81/"/>
      <url>/2024/10/28/2024-01-10-SpringBoot%E7%94%9F%E6%80%81/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(SpringBoot)--&gt;A.1(基础入门)</span><br><span class="line">A.1 --&gt; A.1.1(基本特性)</span><br><span class="line">A.1 --&gt; A.1.2(核心模块)</span><br><span class="line">A.1 --&gt; A.1.3(版本选择)</span><br><span class="line">A.1 --&gt; A.1.4(环境要求)</span><br><span class="line">A.1 --&gt; A.1.5(安装集成)</span><br><span class="line">A.1 --&gt; A.1.6(Maven Wrapper)</span><br><span class="line">A.1 --&gt; A.1.7(SpringBoot Cli)</span><br><span class="line">A(SpringBoot)--&gt;A.2(配置管理)</span><br><span class="line">A.2 --&gt; A.2.1(配置类)</span><br><span class="line">A.2 --&gt; A.2.2(配置文件)</span><br><span class="line">A.2 --&gt; A.2.3(配置绑定)</span><br><span class="line">A.2 --&gt; A.2.4(外部化配置)</span><br><span class="line">A.2 --&gt; A.2.5(导入配置)</span><br><span class="line">A.2 --&gt; A.2.6(随机值配置)</span><br><span class="line">A.2 --&gt; A.2.7(多文档配置)</span><br><span class="line">A.2 --&gt; A.2.8(Profiles配置)</span><br><span class="line">A.2 --&gt; A.2.9(配置加载机制)</span><br><span class="line">A.2 --&gt; A.2.10(配置加密)</span><br><span class="line">A.2 --&gt; A.2.11(配置迁移)</span><br><span class="line">A(SpringBoot)--&gt;A.3(自动配置)</span><br><span class="line">A.3 --&gt; A.3.1(命名规范)</span><br><span class="line">A.3 --&gt; A.3.2(自动配置加载原理)</span><br><span class="line">A.3 --&gt; A.3.3(自动配置原理)</span><br><span class="line">A.3 --&gt; A.3.4(自动配置报告)</span><br><span class="line">A.3 --&gt; A.3.5(自动配置排除)</span><br><span class="line">A.3 --&gt; A.3.6(自动配置替换)</span><br><span class="line">A(SpringBoot)--&gt;A.4(Starters)</span><br><span class="line">A.4 --&gt; A.4.1(命名规范)</span><br><span class="line">A.4 --&gt; A.4.2(Starters分类)</span><br><span class="line">A(SpringBoot)--&gt;A.5(启动过程及应用)</span><br><span class="line">A.5 --&gt; A.5.1(启动入口)</span><br><span class="line">A.5 --&gt; A.5.2(关闭启动日志)</span><br><span class="line">A.5 --&gt; A.5.3(启动失败分析器)</span><br><span class="line">A.5 --&gt; A.5.4(全局懒加载)</span><br><span class="line">A.5 --&gt; A.5.5(启动图案)</span><br><span class="line">A.5 --&gt; A.5.6(启动事件及监听器)</span><br><span class="line">A.5 --&gt; A.5.7(启动运行器)</span><br><span class="line">A.5 --&gt; A.5.8(应用启动流程)</span><br><span class="line">A(SpringBoot)--&gt;A.6(日志管理)</span><br><span class="line">A.6 --&gt; A.6.1(日志框架)</span><br><span class="line">A.6 --&gt; A.6.2(日志格式)</span><br><span class="line">A.6 --&gt; A.6.3(控制台日志)</span><br><span class="line">A.6 --&gt; A.6.4(日志文件)</span><br><span class="line">A.6 --&gt; A.6.5(日志级别)</span><br><span class="line">A.6 --&gt; A.6.6(日志归档)</span><br><span class="line">A.6 --&gt; A.6.7(日志配置文件)</span><br><span class="line">A.6 --&gt; A.6.8(日志框架切换)</span><br><span class="line">A.6 --&gt; A.6.9(彩色日志)</span><br><span class="line">A.6 --&gt; A.6.10(日志关闭钩子)</span><br><span class="line">A(SpringBoot)--&gt;A.7(Web核心应用)</span><br><span class="line">A.7 --&gt; A.7.1(Web支持)</span><br><span class="line">A.7 --&gt; A.7.2(嵌入式容器)</span><br><span class="line">A.7 --&gt; A.7.3(自定义Web配置)</span><br><span class="line">A.7 --&gt; A.7.4(组件注册)</span><br><span class="line">A.7.4 --&gt; A.7.4.1(拦截器)</span><br><span class="line">A.7.4 --&gt; A.7.4.2(消息转换器)</span><br><span class="line">A.7.4 --&gt; A.7.4.3(类型转换器)</span><br><span class="line">A.7.4 --&gt; A.7.4.4(Servlet)</span><br><span class="line">A.7.4 --&gt; A.7.4.5(Filter)</span><br><span class="line">A.7.4 --&gt; A.7.4.6(Listener)</span><br><span class="line">A.7 --&gt; A.7.5(静态资源处理)</span><br><span class="line">A.7 --&gt; A.7.6(模板引擎)</span><br><span class="line">A.7 --&gt; A.7.7(异常处理)</span><br><span class="line">A.7 --&gt; A.7.8(参数校验)</span><br><span class="line">A.7 --&gt; A.7.9(国际化)</span><br><span class="line">A.7 --&gt; A.7.10(分布式会话)</span><br><span class="line">A.7 --&gt; A.7.11(跨域处理)</span><br><span class="line">A.7 --&gt; A.7.12(安全机制)</span><br><span class="line">A.7 --&gt; A.7.13(REST服务调用)</span><br><span class="line">A(SpringBoot)--&gt;A.8(数据库)</span><br><span class="line">A.8 --&gt; A.8.1(数据库支持)</span><br><span class="line">A.8 --&gt; A.8.2(嵌入式数据库)</span><br><span class="line">A.8 --&gt; A.8.3(数据源)</span><br><span class="line">A.8 --&gt; A.8.4(连接池)</span><br><span class="line">A.8 --&gt; A.8.5(数据库初始化)</span><br><span class="line">A.8 --&gt; A.8.6(事务管理)</span><br><span class="line">A.8 --&gt; A.8.7(Jbdc Template)</span><br><span class="line">A.8 --&gt; A.8.8(SpringData JPA)</span><br><span class="line">A.8 --&gt; A.8.9(Mybatis)</span><br><span class="line">A.8 --&gt; A.8.10(Mybatis-Plus)</span><br><span class="line">A(SpringBoot)--&gt;A.9(NoSQL)</span><br><span class="line">A.9 --&gt; A.9.1(NoSQL支持)</span><br><span class="line">A.9 --&gt; A.9.2(starter-Redis)</span><br><span class="line">A.9 --&gt; A.9.3(starter-MongoDB)</span><br><span class="line">A.9 --&gt; A.9.4(starter-Elasticsearch)</span><br><span class="line">A(SpringBoot)--&gt;A.10(计划任务)</span><br><span class="line">A.10 --&gt; A.10.1(Spring计划任务)</span><br><span class="line">A.10.1 --&gt; A.10.1.1(计划任务集成)</span><br><span class="line">A.10.1 --&gt; A.10.1.2(Cron表达式)</span><br><span class="line">A.10.1 --&gt; A.10.1.3(线程池工作流程)</span><br><span class="line">A.10.1 --&gt; A.10.1.4(自定义线程池)</span><br><span class="line">A.10 --&gt; A.10.2(Quartz)</span><br><span class="line">A.10.2 --&gt; A.10.2.1(starter-Quartz)</span><br><span class="line">A.10.2 --&gt; A.10.2.2(自定义配置)</span><br><span class="line">A.10.2 --&gt; A.10.2.3(任务持久化)</span><br><span class="line">A.10.2 --&gt; A.10.2.4(任务动态维护)</span><br><span class="line">A(SpringBoot)--&gt;A.11(缓存)</span><br><span class="line">A.11 --&gt; A.11.1(缓存支持)</span><br><span class="line">A.11 --&gt; A.11.2(缓存集成)</span><br><span class="line">A.11 --&gt; A.11.3(默认缓存)</span><br><span class="line">A.11 --&gt; A.11.4(starter-Redis)</span><br><span class="line">A(SpringBoot)--&gt;A.12(消息队列)</span><br><span class="line">A.12 --&gt; A.12.1(starter-ActiveMQ)</span><br><span class="line">A.12 --&gt; A.12.2(starter-RabbitMQ)</span><br><span class="line">A.12 --&gt; A.12.3(starter-Kafka)</span><br><span class="line">A(SpringBoot)--&gt;A.13(跟踪调试)</span><br><span class="line">A.13 --&gt; A.13.1(main方法调试)</span><br><span class="line">A.13 --&gt; A.13.2(Maven插件调试)</span><br><span class="line">A(SpringBoot)--&gt;A.14(单元测试)</span><br><span class="line">A.14 --&gt; A.14.1(Mock测试)</span><br><span class="line">A.14 --&gt; A.14.2(技术框架测试)</span><br><span class="line">A(SpringBoot)--&gt;A.15(打包与部署)</span><br><span class="line">A.15 --&gt; A.15.1(应用打包)</span><br><span class="line">A.15.1 --&gt; A.15.1.1(jar)</span><br><span class="line">A.15.1 --&gt; A.15.1.2(war)</span><br><span class="line">A.15 --&gt; A.15.2(运行方式)</span><br><span class="line">A.15.2 --&gt; A.15.2.1(java命令运行)</span><br><span class="line">A.15.2 --&gt; A.15.2.2(直接运行)</span><br><span class="line">A.15.2 --&gt; A.15.2.3(以系统服务运行)</span><br><span class="line">A.15.2 --&gt; A.15.2.4(拆包运行)</span><br><span class="line">A.15 --&gt; A.15.3(部署Docker容器)</span><br><span class="line">A.15 --&gt; A.15.4(生成GraalVM原生镜像)</span><br><span class="line">A(SpringBoot)--&gt;A.16(监管与报警)</span><br><span class="line">A.16 --&gt; A.16.1(Spring Boot Actuator)</span><br><span class="line">A.16 --&gt; A.16.2(Spring Boot Admin)</span><br><span class="line">A.16 --&gt; A.16.3(Prometheus)</span><br><span class="line">A.16 --&gt; A.16.4(Grafana)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-12-MySQL%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/28/2024-01-12-MySQL%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-log-timestamps参数"><a href="#1-log-timestamps参数" class="headerlink" title="1. log_timestamps参数"></a>1. log_timestamps参数</h1><p><code>log_timestamps</code>参数并不影响时区，只会影响某些日志记录的时间。该参数主要是控制 error log、slow log、genera log 日志文件中的显示时间。<code>log_timestamps</code> 该参数全局有效，可以被设置的值有：<code>UTC</code> 和 <code>SYSTEM</code>。默认使用 <code>UTC</code>这样会使得日志中记录的时间比北京时间慢 8 个小时，导致查看日志不方便。可以修改为 <code>SYSTEM</code> 变成使用系统时区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看参数值</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_timestamps&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改参数值</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_timestamps <span class="operator">=</span> <span class="keyword">SYSTEM</span>;</span><br></pre></td></tr></table></figure><h1 id="2-time-zone参数"><a href="#2-time-zone参数" class="headerlink" title="2. time_zone参数"></a>2. time_zone参数</h1><p><code>time_zone</code>参数用来设置每个连接会话的时区，该参数分为全局和会话级别，可以动态修改。默认值为 SYSTEM，此时使用的是全局参数 <code>system_time_zone</code> 的值，而 <code>system_time_zone</code> 默认继承自当前系统的时区，即默认情况下 MySQL 时区和系统时区相同。</p><p>时区设置主要影响时区敏感的时间值的显示和存储。包括一些函数（now()、curtime()）显示的值，以及存储在 TIMESTAMP 类型中的值，但不影响 DATE、TIME 和 DATETIME 列中的值，因为这些数据类型在存取时未进行时区转换，而 TIMESTAMP 类型存入数据库的实际是 UTC 的时间，查询显示时会根据具体的时区来显示不同的时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看MySQL当前时区</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;%time_zone%&#x27;</span>;</span><br><span class="line"><span class="comment">-- 修改时区</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> time_zone<span class="operator">=</span><span class="string">&#x27;+8:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p>如果需要永久生效，还需写入配置文件中。例如将时区改为东八区，则需要在配置文件中增加一行<code>default_time_zone = &#39;+8:00&#39;</code>。</p><h1 id="3-如何避免出现时区问题"><a href="#3-如何避免出现时区问题" class="headerlink" title="3. 如何避免出现时区问题"></a>3. 如何避免出现时区问题</h1><ul><li>首先保证系统时区准确。</li><li>jdbc 连接串中指定时区，并与数据库时区一致。</li><li><code>time_zone</code> 参数建议设置为’+8:00’，不使用容易误解的 CST。</li><li>各环境数据库实例时区参数保持相同。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-22-SpringBoot%E4%B9%8BTomcat/"/>
      <url>/2024/10/28/2024-01-22-SpringBoot%E4%B9%8BTomcat/</url>
      
        <content type="html"><![CDATA[<h1 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h1><p>WEB容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。如果是单线程，那同时只能处理一个用户的请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-14-Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%B1%BB/"/>
      <url>/2024/10/28/2024-01-14-Java%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-String类"><a href="#1-String类" class="headerlink" title="1. String类"></a>1. String类</h1><p>字符串常量是用双引号括起的字符序列</p><p>字符串的字符使用Unicode字符编码，一个字符（不区分字母还是汉字）占两个字节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sss是字符串常量，而str是String类对象</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;sss&quot;</span>;</span><br></pre></td></tr></table></figure><p>String类实现了接口<code>Serializable</code>，意味着String对象可以串行化，支持在网络中传输</p><p>String类实现了接口<code>Comparable</code>，意味着String对象可以比较</p><p>String类是final类，不能被其他类继承 </p><p>String类有属性<code>private final char value[];</code> 用于存放字符串内容，并且该value是final类型，不能修改（是value不能指向新的地址而不是value的值不能修改）</p><h2 id="1-1-String常用构造方法"><a href="#1-1-String常用构造方法" class="headerlink" title="1.1. String常用构造方法"></a>1.1. String常用构造方法</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String()</td><td>创建一个空白字符串对象</td></tr><tr><td>public String(char[] chs)</td><td>根据字符数组的内容，来创建字符串对象</td></tr><tr><td>public String(byte[] bys)</td><td>根据字节数组的内容，来创建字符串对象</td></tr></tbody></table></div><h2 id="1-2-String对象的创建"><a href="#1-2-String对象的创建" class="headerlink" title="1.2. String对象的创建"></a>1.2. String对象的创建</h2><p><strong>直接赋值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure><p>先从常量池查看是否有<code>&quot;123&quot;</code>数据空间，如果有，直接指向。如果没有则重新创建，然后指向。s2最终指向的是常量池的空间地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[栈, s2指向0x99] --&gt; B[常量池, 值123,地址0x99];</span><br></pre></td></tr></table></figure><p><strong>调用构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;123&quot;</span>);</span><br></pre></td></tr></table></figure><p>先在堆中创建空间，里面维护了value属性，指向常量池的<code>&quot;123&quot;</code>空间。如果常量池没有<code>&quot;123&quot;</code>，重新创建。如果有，直接通过value指向。最终指向的是堆中的空间地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[栈, s2指向0x11] --&gt; B[堆, value指向0x99,地址0x11];</span><br><span class="line">B --&gt; C[常量池, 值123, 地址0x99];</span><br></pre></td></tr></table></figure><h2 id="1-3-字符串的特点"><a href="#1-3-字符串的特点" class="headerlink" title="1.3. 字符串的特点"></a>1.3. 字符串的特点</h2><p><strong>字符串对象一旦被分配，其内容不可变</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">s = <span class="string">&quot;456&quot;</span>;</span><br></pre></td></tr></table></figure><p>上面语句创建了两个对象，s对象发生了改变<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[栈, s] --&gt; |先指向| B[池, 123]</span><br><span class="line">A --&gt; |后指向|D[池, 456]</span><br></pre></td></tr></table></figure><br><strong>重要规则：常量相加，看的是池。变量相加，是在堆中</strong></p><p>一共有几个对象：1个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span> + <span class="string">&quot;456&quot;</span>; </span><br></pre></td></tr></table></figure></p><p>编译器会做一个优化，判断创建的常量池对象是否有引用指向 <code>String a = &quot;hello&quot; +&quot;abc&quot;</code> 等价于 <code>String a = &quot;helloabc&quot;</code></p><p>一共有几个对象：3个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;456&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b; </span><br></pre></td></tr></table></figure></p><h2 id="1-4-String类的常见方法"><a href="#1-4-String类的常见方法" class="headerlink" title="1.4. String类的常见方法"></a>1.4. String类的常见方法</h2><p>用的时候查手册就行</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean equals(Object anObject)</td><td>比较字符串的内容，严格区分大小写</td></tr><tr><td>public char charAt(int index)</td><td>返回字符串指定索引处的值</td></tr><tr><td>public int length()</td><td>返回此字符串的长度</td></tr></tbody></table></div><h1 id="2-StringBuffer类"><a href="#2-StringBuffer类" class="headerlink" title="2. StringBuffer类"></a>2. StringBuffer类</h1><p>StringBuffer代表可变的字符序列，可以通过某些方法调用来更改序列的长度和内容</p><p>StringBuffer是个容器</p><p>StringBuffer的直接父类是AbstractStringBuilder</p><p>StringBuffer实现了SerializabLe，即StringBuffer的对象可以串行化</p><p>在父类中AbstractStringBuilder有属性<code>char[ ] value</code>，不是final，该value 数组存放字符串的内容，因此是存放在堆中的</p><p>StringBuffer是一个final类， 不能被继承</p><p><strong>String VS StringBuffer</strong></p><p>String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低，核心原因：<code>private final char value[]</code></p><p>StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高，核心原因：<code>char[] value</code></p><p><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</p><h2 id="2-1-构造方法"><a href="#2-1-构造方法" class="headerlink" title="2.1. 构造方法"></a>2.1. 构造方法</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>public StringBuffer()</td><td>构造一个没有字符的字符串缓冲区，初始容量为16个字符</td></tr><tr><td>public StringBuffer(String str)</td><td>构造一个初始化为指定字符串内容的字符串缓冲区。字符串缓冲区的初始容量为<code>16</code>加上字符串参数的长度</td></tr></tbody></table></div><h2 id="2-2-String与StringBuffer互转"><a href="#2-2-String与StringBuffer互转" class="headerlink" title="2.2. String与StringBuffer互转"></a>2.2. String与StringBuffer互转</h2><h3 id="2-2-1-String转StringBuffer"><a href="#2-2-1-String转StringBuffer" class="headerlink" title="2.2.1. String转StringBuffer"></a>2.2.1. String转StringBuffer</h3><p><strong>方式1 使用构造器</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(str);</span><br></pre></td></tr></table></figure></p><p><strong>方式2 使用的是append方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">stringBuffer1 = stringBuffer1.append(str);</span><br></pre></td></tr></table></figure></p><h3 id="2-2-2-StringBuffer转String"><a href="#2-2-2-StringBuffer转String" class="headerlink" title="2.2.2. StringBuffer转String"></a>2.2.2. StringBuffer转String</h3><p><strong>方式1 使用StringBuffer提供的 toString方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> stringBuffer3.toString();</span><br></pre></td></tr></table></figure></p><p><strong>方式2 使用构造器来搞定</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">stringBuffer3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(stringBuffer3);</span><br></pre></td></tr></table></figure><h2 id="2-3-StringBuffer常见方法"><a href="#2-3-StringBuffer常见方法" class="headerlink" title="2.3. StringBuffer常见方法"></a>2.3. StringBuffer常见方法</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>append</td><td>增</td></tr><tr><td>delete(start,end)</td><td>删，将start到end间的内容删除掉，不含end</td></tr><tr><td>replace(start,end,string)</td><td>改，将start到end间的内容替换掉，不含end</td></tr><tr><td>indexOf</td><td>查，查找子串在字符串第1次出现的索引，如果找不到返回-1</td></tr><tr><td>insert</td><td>插</td></tr><tr><td>length</td><td>获取长度（字符数）</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">sb.append(str);  </span><br><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure><p>最后输出的是null（字符串）</p><h1 id="3-StringBuilder类"><a href="#3-StringBuilder类" class="headerlink" title="3. StringBuilder类"></a>3. StringBuilder类</h1><p>一个可变的字符序列。此类提供一个与<code>StringBuffer</code>兼容的API，但不保证同步。此类被设计用作<code>StringBuffer</code>的简易替换，用在字符串缓冲区被单个线程使用的地方。 在可能的情况下，建议使用这个类别优先于<code>StringBuffer</code> ，因为它在大多数实现中将更快</p><p>在StringBuilder 上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据</p><p>StringBuilder继承AbstractStringBuilder类</p><p>StringBuilder实现了Serializable，说明StringBuilder对象是可以串行化的</p><p>StringBuilder是final类，不能被继承</p><p>StringBuilder对象字符序列仍然是存放在其父类 AbstractStringBuilder的 <code>char[] value</code>，因此，字符序列在堆中</p><p>StringBuilder的方法，没有做互斥的处理，即没有synchronized关键字，因此仅可在单线程的情况下使用StringBuilder</p><p><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的</p><p>StringBuilder的方法使用和StringBuffer一样</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><ul><li>如果字符串存在大量的修改操作，一般使用StringBuffer 或StringBuilder</li><li>如果字符串存在大量的修改操作，并在单线程的情况,使用StringBuilder</li><li>如果字符串存在大量的修改操作，并在多线程的情况,使用StringBuffer</li><li>如果我们字符串很少修改，被多个对象引用，使用String，比如配置信息等</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-24-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96/"/>
      <url>/2024/10/28/2024-01-24-%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>超过 10w+ 的数据量</p><h1 id="2-JDBC环境"><a href="#2-JDBC环境" class="headerlink" title="2. JDBC环境"></a>2. JDBC环境</h1><p>JDBC环境下推荐自己实现批处理方式</p><p><strong>导入依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">!-- MySQL 驱动 --&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>JDBC 批量插入的实现方式：批处理插入方式 + 手动事务提交</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCPlusDemo</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">// url 设置允许重写批量提交 rewriteBatchedStatements=true  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;  </span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;  </span><br><span class="line">        <span class="comment">// sql语句（注意url设置为rewriteBatchedStatements=true时，不允许sql语句带有;号，否则会抛出BatchUpdateException异常）  </span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO fee(`owner`,`fee1`,`fee2`,`fee3`,`fee4`,`fee5`) VALUES (?,?,?,?,?,?)&quot;</span>;  </span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line">        <span class="comment">// 开始时间  </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            Class.forName(driver);  </span><br><span class="line">            conn = DriverManager.getConnection(url, user, password);  </span><br><span class="line">            ps = conn.prepareStatement(sql);  </span><br><span class="line">            <span class="comment">// 关闭自动提交  </span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100000</span>; i++) &#123;  </span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">&quot;o&quot;</span>+i);  </span><br><span class="line">                ps.setBigDecimal(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11111.111&quot;</span>));  </span><br><span class="line">                ps.setBigDecimal(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11111.111&quot;</span>));  </span><br><span class="line">                ps.setBigDecimal(<span class="number">4</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11111.111&quot;</span>));  </span><br><span class="line">                ps.setBigDecimal(<span class="number">5</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11111.111&quot;</span>));  </span><br><span class="line">                ps.setBigDecimal(<span class="number">6</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;11111.111&quot;</span>));  </span><br><span class="line">                <span class="comment">// 加入批处理（将当前sql加入缓存）  </span></span><br><span class="line">                ps.addBatch();  </span><br><span class="line">                <span class="comment">// 以 1000 条数据作为分片  </span></span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">1000</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="comment">// 执行缓存中的sql语句  </span></span><br><span class="line">                    ps.executeBatch();  </span><br><span class="line">                    <span class="comment">// 清空缓存  </span></span><br><span class="line">                    ps.clearBatch();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            ps.executeBatch();  </span><br><span class="line">            ps.clearBatch();  </span><br><span class="line">            <span class="comment">// 事务提交（实际开发中需要判断有插入失败的需要在 finally 中做好事务回滚操作）  </span></span><br><span class="line">            conn.commit();  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;  </span><br><span class="line">            e.printStackTrace();  </span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    conn.close();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;  </span><br><span class="line">                <span class="keyword">try</span> &#123;  </span><br><span class="line">                    ps.close();  </span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;  </span><br><span class="line">                    e.printStackTrace();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 结束时间  </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">&quot;十万条数据插入时间（批处理插入）：&quot;</span> + (end - start) + <span class="string">&quot; ms&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的细节和重点</strong></p><ul><li>需要注意批量处理时的分片操作，分片操作可以避免一次性提交的数据量过大从而导致数据库在处理时出现的性能问题和内存占用过高问题，有效的分片可以减轻数据库的负担</li><li>使用手动事务提交可以提高插入速度，在批量插入大量数据时，手动事务提交相对于自动提交事务来说可以减少磁盘的写入次数，减少锁竞争，从而提高插入的性能</li><li>使用 JDBC 时需要注意插入的 sql 语句结尾不能带 <code>;</code> 号，否则会抛出 <code>BatchUpdateException</code> 异常</li><li>在配置 MySQL 的 url 时需要加上 <code>rewriteBatchedStatements=true</code> 才能达到真正意义上的批处理效果。如果不开启允许重写批量提交，实际上批处理操作和原本的单条语句循环插入的效果一样</li></ul><h1 id="3-MyBatis环境"><a href="#3-MyBatis环境" class="headerlink" title="3. MyBatis环境"></a>3. MyBatis环境</h1><p>foreach 动态拼接插入，当数据量为 10w 条时，测试结果报错，这是因为默认情况下 MySQL 可执行的最大 SQL 语句大小为 4194304 即 4MB，这里使用动态 SQL 拼接后的大小远大于默认值，故报错</p><p><strong>MyBatis环境下推荐在MyBatis中使用JDBC 的批处理插入方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">saveByBatch</span><span class="params">(List&lt;Fee&gt; feeList)</span> &#123;  </span><br><span class="line">    <span class="comment">// 记录结果（影响行数）  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="comment">// 开启批处理模式  </span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(ExecutorType.BATCH);  </span><br><span class="line">    <span class="type">FeeMapper</span> <span class="variable">feeMapper</span> <span class="operator">=</span> sqlSession.getMapper(FeeMapper.class);  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= feeList.size(); i++) &#123;  </span><br><span class="line">        <span class="comment">// 利用mapper的单条插入方法插入  </span></span><br><span class="line">        res += feeMapper.insertByOne(feeList.get(i-<span class="number">1</span>));  </span><br><span class="line">        <span class="comment">// 进行分片类似 JDBC 的批处理  </span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">100000</span> == <span class="number">0</span>) &#123;  </span><br><span class="line">            sqlSession.commit();  </span><br><span class="line">            sqlSession.clearCache();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    sqlSession.commit();  </span><br><span class="line">    sqlSession.clearCache();  </span><br><span class="line">    <span class="keyword">return</span> res;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要注意的细节和重点</strong></p><ul><li>和 JDBC 一样都需要开启允许重写批量处理提交（即在配置文件的数据库配置 url 中加上<code>rewriteBatchedStatements=true</code>）</li><li>代码中需要使用批处理模式（利用 <code>SqlSessionFactory</code> 设置批处理模式并获取对应的 Mapper 接口）</li><li>代码中同样进行了分片操作，目的是为了减轻数据库的负担避免在处理时内存占用过高</li><li>可以在实现方法中加上 <code>@Transactional</code> 注解来起到手动提交事务的效果（好处和 JDBC 一样）</li></ul><h1 id="4-MyBatis-Plus环境"><a href="#4-MyBatis-Plus环境" class="headerlink" title="4. MyBatis Plus环境"></a>4. MyBatis Plus环境</h1><p>使用自带的<code>saveBatch(feeList)</code>方法</p><p><strong>需要注意的细节和重点</strong></p><p>需要开启允许重写批量处理提交（即在配置文件的数据库配置 url 中加上<code>rewriteBatchedStatements=true</code>）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-20-SpringBoot%E6%95%B4%E5%90%88Redis/"/>
      <url>/2024/10/28/2024-01-20-SpringBoot%E6%95%B4%E5%90%88Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-Redis-配置"><a href="#2-Redis-配置" class="headerlink" title="2. Redis 配置"></a>2. Redis 配置</h1><h2 id="2-1-yml"><a href="#2-1-yml" class="headerlink" title="2.1. yml"></a>2.1. yml</h2><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">xxx.xxx.99.232</span> <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">xxx</span> <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br></pre></td></tr></table></figure><h2 id="2-2-Java-configuration"><a href="#2-2-Java-configuration" class="headerlink" title="2.2. Java configuration"></a>2.2. Java configuration</h2><p>首先，使用jedis客户端，定义一个connectionFactory。然后使用jedisConnectionFactory定义一个RedisTemplate。这可以用于自定义存储库查询数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">JedisConnectionFactory <span class="title function_">jedisConnectionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JedisConnectionFactory</span> <span class="variable">jedisConFactory</span></span><br><span class="line">      <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisConnectionFactory</span>();</span><br><span class="line">    jedisConFactory.setHostName(<span class="string">&quot;localhost&quot;</span>);</span><br><span class="line">    jedisConFactory.setPort(<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">return</span> jedisConFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">    template.setConnectionFactory(jedisConnectionFactory());</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-RedisTemplate"><a href="#3-RedisTemplate" class="headerlink" title="3. RedisTemplate"></a>3. RedisTemplate</h1><p>Spring Data Redis 提供的模板类，可以对 Redis 进行操作</p><p>RedisTemplate除了提供 opsForValue 方法来操作字符串之外，还提供了以下方法：</p><ul><li>opsForList：操作 list</li><li>opsForSet：操作 set</li><li>opsForZSet：操作有序 set</li><li>opsForHash：操作 hash</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CodingmoreRedisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        redisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;沉默王二的狗腿子&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;沉默王二&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        System.out.println(stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 删除</span></span><br><span class="line">        stringRedisTemplate.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;沉默王二的狗腿子&quot;</span>);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        System.out.println(stringRedisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Redis-连接池"><a href="#4-Redis-连接池" class="headerlink" title="4. Redis 连接池"></a>4. Redis 连接池</h1><ul><li>Jedis：Spring Boot 1.5.x 版本时默认的 Redis 客户端，实现上是直接连接 Redis Server，如果在多线程环境下是非线程安全的，这时候要使用连接池为每个 jedis 实例增加物理连接</li><li>Lettuce：Spring Boot 2.x 版本后默认的 Redis 客户端，基于 Netty 实现，连接实例可以在多个线程间并发访问，一个连接实例不够的情况下也可以按需要增加连接实例</li></ul><h2 id="4-1-Lettuce"><a href="#4-1-Lettuce" class="headerlink" title="4.1. Lettuce"></a>4.1. Lettuce</h2><p>Lettuce是Spring Boot 2.x 版本后默认的，所以不许单独引入依赖</p><p>修改 application.yml，添加 Lettuce 连接池配置（pool 节点）。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">        <span class="attr">lettuce:</span></span><br><span class="line">          <span class="attr">pool:</span></span><br><span class="line">            <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 连接池最大连接数</span></span><br><span class="line">            <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 连接池最大空闲连接数</span></span><br><span class="line">            <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 连接池最小空闲连接数</span></span><br><span class="line">            <span class="attr">max-wait:</span> <span class="string">-1ms</span> <span class="comment"># 连接池最大阻塞等待时间，负值表示没有限制</span></span><br></pre></td></tr></table></figure><p>在 pom.xml 文件中添加 commons-pool2 依赖，否则会在启动的时候报 ClassNotFoundException 的错。这是因为 Spring Boot 2.x 里默认没启用连接池<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><br>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">GenericObjectPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericObjectPoolConfig</span>();</span><br><span class="line">poolConfig.setMaxTotal(<span class="number">100</span>); <span class="comment">// 设置最大连接数</span></span><br><span class="line"></span><br><span class="line"><span class="type">RedisURI</span> <span class="variable">redisURI</span> <span class="operator">=</span> RedisURI.Builder.redis(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).build();</span><br><span class="line"><span class="type">RedisClient</span> <span class="variable">redisClient</span> <span class="operator">=</span> RedisClient.create(redisURI);</span><br><span class="line">StatefulRedisConnection&lt;String, String&gt; connection = redisClient.connect();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RedisCommands&lt;String, String&gt; commands = connection.sync();</span><br><span class="line">    <span class="comment">// 进行Redis操作</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">        connection.close(); <span class="comment">// 归还连接给连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (redisClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        redisClient.shutdown(); <span class="comment">// 关闭Redis客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-2-Jedis"><a href="#4-2-Jedis" class="headerlink" title="4.2. Jedis"></a>4.2. Jedis</h2><p>在 pom.xml 文件中添加 Jedis 依赖，去除 Lettuce 默认依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.lettuce<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lettuce-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改 application-dev.yml，添加 Jedis 连接池配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">    redis:</span><br><span class="line">        jedis:</span><br><span class="line">          pool:</span><br><span class="line">            max-active: 8 # 连接池最大连接数</span><br><span class="line">            max-idle: 8 # 连接池最大空闲连接数</span><br><span class="line">            min-idle: 0 # 连接池最小空闲连接数</span><br><span class="line">            max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制</span><br></pre></td></tr></table></figure><h1 id="5-Spring-Cache-操作-Redis"><a href="#5-Spring-Cache-操作-Redis" class="headerlink" title="5. Spring Cache 操作 Redis"></a>5. Spring Cache 操作 Redis</h1><p>Spring Cache 是 Spring 提供的一整套的缓存解决方案。虽然它本身并没有提供缓存的实现，但是它提供了一整套的接口和代码规范、配置、注解等，这样它就可以整合各种缓存方案了，比如 Redis、Ehcache，我们也就不用关心操作缓存的细节。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-25-Mybatis%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/28/2024-01-25-Mybatis%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-int变long"><a href="#1-int变long" class="headerlink" title="1. int变long"></a>1. int变long</h1><p>MySQL中id字段存的是unsigned int 类型，MyBatis框架却将其转为了Long</p><p>MyBatis框架使用Long来映射MySQL的int。原因是我们的数据库id字段设置的类型为无符号的Int型</p><p>如果MySQL选择无符号的int类型时，它的取值范围是要超过java的Integer类型的，所以MyBatis框架为了确保能包括MySQL中int的所有取值范围，使用java中的Long映射最为可靠。</p>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-12-%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/10/28/2024-01-12-%E6%97%B6%E9%97%B4%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-时区"><a href="#1-时区" class="headerlink" title="1. 时区"></a>1. 时区</h1><p>在Java中，可以使用<code>LocalDateTime</code>来表示不带时区的日期和时间。在MySQL中，可以使用<code>DATETIME</code>或<code>TIMESTAMP</code>数据类型来存储日期和时间。<code>DATETIME</code>类型存储的是具体的日期和时间值，不受时区影响。<code>TIMESTAMP</code>类型也存储日期和时间值，但会自动转换为UTC时区存储，并且在检索时会自动转换为当前时区（不建议使用<code>TIMESTAMP</code>）。</p><h2 id="1-1-Java处理"><a href="#1-1-Java处理" class="headerlink" title="1.1. Java处理"></a>1.1. Java处理</h2><p>使用<code>LocalDateTime</code>类型的字段存储时间，将时间以一定的格式存入数据库，读取时再将数据库中存储的UTC时间转为指定时区下的时间<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个UTC时间，参数1是UTC日期时间，参数2是UTC偏移量</span></span><br><span class="line"><span class="type">OffsetDateTime</span> <span class="variable">utcDateTime</span> <span class="operator">=</span> OffsetDateTime.of(localDateTime,ZoneOffset.UTC);</span><br><span class="line"><span class="comment">// 将UTC时间转换为特定时区下的时间</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">zoneId</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);</span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> utcDateTime.atZoneSameInstant(zoneId);</span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;UTC时间： &quot;</span> + utcDateTime);</span><br><span class="line">System.out.println(<span class="string">&quot;目标时区时间： &quot;</span> + zonedDateTime);</span><br></pre></td></tr></table></figure><br>在Java中应该使用<code>@JsonFormat</code> 注解指定日期时间字段在 JSON 序列化和反序列化过程中的格式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>  </span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-MySQL处理"><a href="#1-2-MySQL处理" class="headerlink" title="1.2. MySQL处理"></a>1.2. MySQL处理</h2><p>使用<code>DATETIME</code>类型的字段存储时间</p>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-29-sa-token%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2023-12-29-sa-token%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-开启路由拦截器后springdoc无法访问"><a href="#1-开启路由拦截器后springdoc无法访问" class="headerlink" title="1. 开启路由拦截器后springdoc无法访问"></a>1. 开启路由拦截器后springdoc无法访问</h1><p>排除以下路径即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">&quot;/swagger-resources/**&quot;</span>, <span class="string">&quot;/webjars/**&quot;</span>, <span class="string">&quot;/v3/**&quot;</span>, <span class="string">&quot;/swagger-ui.html/**&quot;</span>,<span class="string">&quot;/swagger-ui/**&quot;</span>,<span class="string">&quot;/mgr&quot;</span>,<span class="string">&quot;/mgr/**&quot;</span>,<span class="string">&quot;/h5&quot;</span>,<span class="string">&quot;/h5/**&quot;</span>)        </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> sa-token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-27-%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2024/10/28/2023-12-27-%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-在-Web-应用程序中，始终在服务器上进行散列"><a href="#1-在-Web-应用程序中，始终在服务器上进行散列" class="headerlink" title="1. 在 Web 应用程序中，始终在服务器上进行散列"></a>1. 在 Web 应用程序中，始终在服务器上进行散列</h1><p>密码应该在前端中用JavaScript散列，还是应该将明文密码发送到服务器再进行散列呢？</p><p>即使前端使用JavaScript散列用户密码，也必须在服务器上散列。否则客户端的哈希值逻辑上变成了用户的密码。用户需要做的只是告诉服务器他们密码的散列。如果一个坏人得到了一个用户的散列，他们可以用它来验证服务器，而不需要知道用户的密码！<strong>因此，如果坏人不知何故从这个假想的网站窃取了哈希数据库，他们就可以立即访问每个人的帐户，而不必猜测任何密码</strong>。</p><h1 id="2-用盐做散列"><a href="#2-用盐做散列" class="headerlink" title="2. 用盐做散列"></a>2. 用盐做散列</h1><p>每个用户每个密码的salt必须是唯一的。每次用户创建帐户或更改密码时，都应该使用新的随机salt对密码进行哈希运算。不要重复使用盐。盐也应该足够长, 以保证有足够多的盐用于哈希加密。根据经验，使salt至少与哈希函数的输出一样长。salt应该与hash一起存储在用户账户表中</p><h1 id="3-保存密码"><a href="#3-保存密码" class="headerlink" title="3. 保存密码"></a>3. 保存密码</h1><ul><li>将salt预先混入密码中（通常把盐放在密码之前），并使用标准密码哈希函数（如Argon2、bcrypt、scrypt或PBKDF2）对其进行哈希运算。</li><li>在用户的数据库记录中保存salt和hash。</li></ul><h1 id="4-校验密码"><a href="#4-校验密码" class="headerlink" title="4. 校验密码"></a>4. 校验密码</h1><ul><li>从数据库中检索用户的salt和hash。</li><li>将salt混入用户提交的密码，并使用相同的哈希函数对其进行哈希运算。</li><li>将给定密码的哈希值与数据库中的哈希值进行比较。如果匹配，则密码正确。否则，密码不正确。</li></ul><h1 id="5-要保证对比密码的操作时间相同"><a href="#5-要保证对比密码的操作时间相同" class="headerlink" title="5. 要保证对比密码的操作时间相同"></a>5. 要保证对比密码的操作时间相同</h1><p>我不知道你的密码, 但是密码的每一位肯定是在256个字符串中间的某一个, 假如代码不遵循 ‘操作时间相同’ 原则, 那我试这256次, 耗时最长的那一个肯定是第一位是对的, 然后我试第二个字符, 一直到我试出来密码或者我根据试出来的猜测出密码</p><p>参考：<a href="https://www.cnblogs.com/chnmig/p/14475648.html">https://www.cnblogs.com/chnmig/p/14475648.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-30-node/"/>
      <url>/2024/10/28/2023-12-30-node/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Node-js-Windows解压版下载"><a href="#1-Node-js-Windows解压版下载" class="headerlink" title="1. Node.js Windows解压版下载"></a>1. <a href="https://nodejs.org/en/download/">Node.js</a> Windows解压版下载</h1><p>选择<code>Windows 二进制文件 (.zip)</code> 这个版本进行下载</p><p>新版的<code>Node.js</code>已自带<code>npm</code>，就在解压后的<code>node_modules</code>文件夹中。 <strong><code>npm</code>的作用：是对<code>Node.js</code>依赖的包进行管理，类似<code>maven</code></strong></p><h1 id="2-配置npm安装目录"><a href="#2-配置npm安装目录" class="headerlink" title="2. 配置npm安装目录"></a>2. 配置npm安装目录</h1><p>在解压之后的文件路径下新建<code>node_global</code>和<code>node_cache</code>两个文件夹，注意打开读写权限</p><p>设置缓存文件夹</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set cache &quot;E:\node\node_cache&quot;</span><br></pre></td></tr></table></figure><p>设置全局模块存放路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;E:\node\node_global&quot;</span><br></pre></td></tr></table></figure><p>设置成功后，之后使用命令<code>npm install XXX -g</code> 安装以后模块就在<code>&quot;E:\node\node_global&quot;</code>里</p><h1 id="3-设置环境变量"><a href="#3-设置环境变量" class="headerlink" title="3. 设置环境变量"></a>3. 设置环境变量</h1><p>将<code>node.exe</code>所在目录和<code>node_global</code>加入到环境变量中</p><p>新增变量 <code>NODE_PATH</code>，设置为 <code>E:\node;E:\node\node_global;</code></p><p>Path变量中添加 <code>%NODE_PATH%;</code></p><h1 id="4-检验和测试"><a href="#4-检验和测试" class="headerlink" title="4. 检验和测试"></a>4. 检验和测试</h1><p>到这里就安装完成了，可以在CMD命令行中用 <code>npm -v</code>和 <code>node -v</code>测试一下是否按照成功</p><h1 id="5-设置仓库"><a href="#5-设置仓库" class="headerlink" title="5. 设置仓库"></a>5. 设置仓库</h1><p>独立开发可以设置淘宝仓库，也是为了保证以后的下载速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>使用 <code>npm config ls</code> 查看npm的配置信息</p><h1 id="6-使用pnpm代替npm"><a href="#6-使用pnpm代替npm" class="headerlink" title="6. 使用pnpm代替npm"></a>6. 使用pnpm代替npm</h1><p>pnpm比npm优秀</p><p>使用npm安装pnpm</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g pnpm</span><br></pre></td></tr></table></figure><p>配置pnpm 相关目录</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pnpm config <span class="built_in">set</span> store-<span class="built_in">dir</span> &quot;D:\pnpm\storeDir&quot; # pnpm全局仓库路径(类似 .git 仓库)</span><br><span class="line">pnpm config <span class="built_in">set</span> global-<span class="built_in">dir</span> &quot;D:\pnpm\globalDir&quot; # pnpm全局安装路径</span><br><span class="line">pnpm config <span class="built_in">set</span> global-bin-<span class="built_in">dir</span> &quot;D:\pnpm\globalBinDir&quot; # pnpm全局bin路径</span><br><span class="line">pnpm config <span class="built_in">set</span> state-<span class="built_in">dir</span> &quot;D:\pnpm\state&quot; # pnpm创建pnpm-state.json文件的目录</span><br><span class="line">pnpm config <span class="built_in">set</span> cache-<span class="built_in">dir</span> &quot;D:\pnpm\cache&quot; # pnpm全局缓存路径</span><br></pre></td></tr></table></figure><p>在环境变量中配置pnpm全局bin路径</p><h1 id="7-包管理器辨别"><a href="#7-包管理器辨别" class="headerlink" title="7. 包管理器辨别"></a>7. 包管理器辨别</h1><ul><li><code>npm</code>是一个包管理器，方便开发者分享和下载开源包。经历了许多重大版本的更新，各方面已经和<code>yarn</code>在同一水平。</li><li><code>npx</code>是<code>npm@5.2</code>的产物，<code>npx</code>会把下载的文件放在临时文件中，过一段时间会自动清除，但不会<strong>立即</strong>清除。</li><li><code>cnpm</code>是方便中国开发者下载依赖包而诞生的下载器。</li><li><code>yarn</code>解决了<code>npm@5</code>之前的一些让人诟病的问题，同时拥有一些其它的优点。例如离线安装、失败自动重试安装和并行下载等。</li><li><code>pnpm</code>通过连接的方式，让多个项目的依赖公用同一个包，大大节省了磁盘空间，比<code>yarn</code>和<code>npm</code>下载速度快得多，但是也有连接带来的各种兼容问题。</li></ul><h1 id="8-npm-使用"><a href="#8-npm-使用" class="headerlink" title="8. npm 使用"></a>8. npm 使用</h1><p><strong>npm安装依赖</strong><br>npm install xxx 利用 npm 安装xxx依赖到当前命令行所在目录<br>npm install xxx -g 利用npm安装全局依赖xxx<br>npm install xxx –save 安装并写入package.json的”dependencies”中<br>npm install xxx –save-dev 安装并写入package.json的”devDependencies”中  </p><p><strong>npm删除依赖</strong><br>npm uninstall xxx 删除xxx依赖<br>npm uninstall xxx -g 删除全局依赖xxx</p><h1 id="9-Node-js和npm的关系"><a href="#9-Node-js和npm的关系" class="headerlink" title="9. Node.js和npm的关系"></a>9. Node.js和npm的关系</h1><p><code>Node.js</code>是<code>JavaScript</code>的一种运行环境，是对Google V8引擎进行的封装。是一个服务器端的<code>JavaScript</code>的解释器。</p><p>包含关系，<code>Node.js</code>中含有<code>npm</code>，比如说你安装好<code>Node.js</code>，你打开<code>cmd</code>输入<code>npm -v</code>会发现<code>npm</code>的版本号，说明<code>npm</code>已经安装好。</p><p><code>npm</code>是<code>Node Package Manager</code>的缩写，它是<code>Node.js</code>的包管理和分发工具，用于管理<code>JavaScript</code>的包，包括安装、卸载、管理依赖等</p><p>npm是nodejs的包管理器（package manager）。我们在Node.js上开发时，会用到很多别人已经写好的javaScript代码，如果每当我们需要别人的代码时，都根据名字搜索一下，下载源码，解压，再使用，会非常麻烦。于是就出现了包管理器npm。大家把自己写好的源码上传到npm官网上，如果要用某个或某些个，直接通过npm安装就可以了，不用管那个源码在哪里。并且如果我们要使用模块A，而模块A又依赖模块B，模块B又依赖模块C和D，此时npm会根据依赖关系，把所有依赖的包都下载下来并且管理起来</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-30-%E8%AE%A4%E8%AF%86JSON/"/>
      <url>/2024/10/28/2023-12-30-%E8%AE%A4%E8%AF%86JSON/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，用于在不同的系统之间传输和存储数据。它采用易于理解的文本格式，以键值对的形式表示数据，并使用大括号和方括号进行格式化。JSON最初由JavaScript衍生而来，但已成为一种独立于编程语言的通用数据格式。</p><h1 id="2-数据的格式"><a href="#2-数据的格式" class="headerlink" title="2. 数据的格式"></a>2. 数据的格式</h1><p>JSON采用一种简洁的文本格式来表示数据，其格式规范如下：</p><ul><li>数据由键值对组成，键和值之间使用冒号<code>:</code>进行分隔。</li><li>键必须是字符串，用双引号<code>&quot;</code>括起来。</li><li>值可以是字符串、数字、布尔值、数组、对象或null。</li><li>多个键值对之间使用逗号<code>,</code>进行分隔。</li><li>整个JSON数据包含在大括号<code>&#123;&#125;</code>中，表示一个对象。</li><li>数组由方括号<code>[]</code>表示，其中的值可以是任意类型的数据，多个值之间使用逗号分隔</li></ul><h1 id="3-转义"><a href="#3-转义" class="headerlink" title="3. 转义"></a>3. 转义</h1><p>在JSON中，如果要表示特殊字符或具有特殊含义的字符，需要使用转义符进行转义。JSON中使用的转义符是反斜杠<code>\</code>。以下是JSON中常用的转义字符：</p><ul><li><code>\&quot;</code>：双引号（”）</li><li><code>\\</code>：反斜杠（<code>\</code>）</li><li><code>\/</code>：斜杠（/）</li><li><code>\b</code>：退格（U+0008）</li><li><code>\f</code>：换页（U+000C）</li><li><code>\n</code>：换行（U+000A）</li><li><code>\r</code>：回车（U+000D）</li><li><code>\t</code>：制表符（U+0009）</li><li><code>\uXXXX</code>：表示Unicode字符，其中XXXX是该字符的四位十六进制编码</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-08-UML%E8%AE%BE%E8%AE%A1%E5%9B%BE%E5%BD%A2/"/>
      <url>/2024/10/28/2024-01-08-UML%E8%AE%BE%E8%AE%A1%E5%9B%BE%E5%BD%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A[UML] --&gt; A.1[工具]</span><br><span class="line">    A --&gt; A.3[制图方法]</span><br><span class="line">    A --&gt; A.2[图形分类]</span><br><span class="line">    A.1 --&gt; A.1.1[PlantUML]</span><br><span class="line">A.3 --&gt; A.3.1[C4模型]</span><br><span class="line">A.2 --&gt; A.2.1[泳道图]</span><br><span class="line">A.2 --&gt; A.2.2[时序图]</span><br><span class="line">A.2 --&gt; A.2.3[流程图]</span><br><span class="line">A.2 --&gt; A.2.4[状态图]</span><br><span class="line">A.2 --&gt; A.2.5[协作图]</span><br></pre></td></tr></table></figure><h1 id="2-UML"><a href="#2-UML" class="headerlink" title="2. UML"></a>2. UML</h1><h2 id="2-1-UML简介"><a href="#2-1-UML简介" class="headerlink" title="2.1. UML简介"></a>2.1. UML简介</h2><p>UML（Unified Modeling Language）为面向对象软件设计提供统一的、标准的、可视化的建模语言。适用于描述以用例为驱动，以体系结构为中心的软件设计的全过程。</p><p>UML的定义包括UML语义和UML表示法两个部分</p><ul><li><strong>UML语义</strong>：UML对语义的描述使开发者能在语义上取得一致认识，消除了因人而异的表达方法所造成的影响。</li><li><strong>UML表示法</strong>：UML表示法定义UML符号的表示法，为开发者或开发工具使用这些图形符号和文本语法为系统建模提供了标准。</li></ul><h2 id="2-2-UML模型图的构成"><a href="#2-2-UML模型图的构成" class="headerlink" title="2.2. UML模型图的构成"></a>2.2. UML模型图的构成</h2><ul><li>事物（Things）：UML模型中最基本的构成元素，是具有代表性的成分的抽象</li><li>关系（Relationships）：关系把事物紧密联系在一起</li><li>图（Diagrams）：图是事物和关系的可视化表示</li></ul><h1 id="3-PlantUML"><a href="#3-PlantUML" class="headerlink" title="3. PlantUML"></a>3. PlantUML</h1><p>PlantUML 是一个快速创建 UML 图形的组件或者可以说是语言，通过简单和直观的语言来定义图形。其在学习成本、效率、团队协同以及维护成本上都有比较大的优势，所以推荐使用 PlantUML 来画图。除了 UML 之外，PlantUML 还支持一系列其他图表</p><h1 id="4-画图方法"><a href="#4-画图方法" class="headerlink" title="4. 画图方法"></a>4. 画图方法</h1><p>基于C4模型来绘制软件架构图。</p><p>C4模型是Simon Brown提出的一种软件架构的可视化模型，简单来说，就是如何描述软件架构，如何画架构图。</p><p>C4 模型使用容器（应用程序、数据存储、微服务等）、组件和代码来描述一个软件系统的静态结构。</p><h1 id="5-图的分类"><a href="#5-图的分类" class="headerlink" title="5. 图的分类"></a>5. 图的分类</h1><h2 id="5-1-泳道图"><a href="#5-1-泳道图" class="headerlink" title="5.1. 泳道图"></a>5.1. 泳道图</h2><p>每个泳道代表一个参与者，可以是个人、团队、部门或组织</p><p>主要重点：泳道图的重点在于显示不同参与者之间的关系和协作，强调流程中各个参与者的角色和职责。</p><p>使用场景：</p><ul><li>流程优化和改进：通过可视化不同参与者之间的关系和职责，识别和解决流程中的问题</li><li>项目管理：展示项目中不同团队或部门之间的协作和依赖关系，帮助协调和分配任务</li><li>组织架构和角色定义：展示组织中不同团队、部门或个人之间的关系和职责，帮助澄清工作职责和沟通渠道。</li></ul><h2 id="5-2-时序图"><a href="#5-2-时序图" class="headerlink" title="5.2. 时序图"></a>5.2. 时序图</h2><p>时序图是一种用于描述对象之间交互的图表，强调交互的时间顺序和消息传递</p><p>主要重点：时序图的重点在于显示对象之间的交互顺序和时序，以及它们之间传递的消息。</p><p>使用场景：</p><ul><li>软件系统设计和分析：展示系统中不同对象之间的交互和消息传递，帮助分析系统的行为和设计系统架构。</li><li>软件调试和故障排除：跟踪和分析对象之间的交互，帮助定位和解决软件中的问题。</li><li>通信协议设计：描述通信协议中不同实体之间的消息传递和交互顺序。</li></ul><h2 id="5-3-流程图"><a href="#5-3-流程图" class="headerlink" title="5.3. 流程图"></a>5.3. 流程图</h2><p>流程图是一种用于展示流程或系统中各个步骤、决策和操作的图表。它使用不同的图形符号表示不同类型的步骤和操作，并使用箭头表示流程的方向。</p><p>主要重点：流程图的重点在于展示流程中的步骤、决策和操作，以及它们之间的顺序和关系。</p><p>使用场景：</p><ul><li>流程分析和优化：帮助识别和改进流程中的瓶颈、冗余和错误。</li><li>项目管理和计划：展示项目的执行流程和关键步骤，帮助协调和管理项目。</li><li>程序设计和算法描述：描述算法或程序中的操作步骤和逻辑流程。</li></ul><h2 id="5-4-状态图"><a href="#5-4-状态图" class="headerlink" title="5.4. 状态图"></a>5.4. 状态图</h2><p>状态图是一种描述对象或系统在不同状态之间转换的图表。它展示了对象的不同状态以及在特定条件下状态之间的转换。</p><p>主要重点：状态图的重点在于显示对象或系统的不同状态以及状态之间的转换条件和动作。</p><p>使用场景：</p><ul><li>软件系统建模：描述系统中的对象或组件的状态和状态转换，帮助分析系统行为和设计系统。</li><li>用户界面设计：展示用户界面的不同状态以及用户操作之间的转换和交互。</li><li>系统控制和逻辑描述：描述系统或控制器的不同工作状态和状态转换规则。</li></ul><h2 id="5-5-协作图"><a href="#5-5-协作图" class="headerlink" title="5.5. 协作图"></a>5.5. 协作图</h2><p>协作图，也称为通信图（Communication Diagram）或合作图，用于展示对象之间的交互和消息传递。它强调对象之间的通信和合作关系。</p><p>主要重点：协作图的重点在于显示对象之间的交互消息和合作关系，强调对象之间的通信和协作。</p><p>使用场景：</p><ul><li>软件系统设计和分析：描述系统中不同对象之间的通信和合作，帮助分析系统架构和设计系统组件间的交互。</li><li>系统集成和接口设计：展示不同系统或组件之间的通信和接口，帮助定义和设计系统集成。</li><li>分布式系统和网络通信：描述分布式系统中不同节点之间的通信和消息传递。</li></ul><p>以上所述的图表类型并不是互相排斥的，而是可以结合使用，根据需求选择适合的图表类型来展示信息和解决问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-08-%E5%A6%82%E4%BD%95%E7%94%BB%E5%A5%BD%E5%9B%BE/"/>
      <url>/2024/10/28/2024-01-08-%E5%A6%82%E4%BD%95%E7%94%BB%E5%A5%BD%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-适用范围"><a href="#1-适用范围" class="headerlink" title="1. 适用范围"></a>1. 适用范围</h1><p>架构图/业务图/流程图/用例图，品牌、电商、包装、UI等诸多领域</p><h1 id="2-好图的定义"><a href="#2-好图的定义" class="headerlink" title="2. 好图的定义"></a>2. 好图的定义</h1><p><strong>结构清晰：观点明确、主次分明、内容清楚</strong></p><p>能够让看图人轻易地从图中获取信息/观点/关系/思想，明白作图者想表达的内容</p><p><strong>外表美观：有更多的浏览欲/阅读欲</strong></p><p>能够让看图人更舒适地浏览图的内容，有更多的浏览欲/阅读欲</p><p><strong>内容完整：一张图内容自闭环</strong></p><p>能够让看图人从一张图中获取到这件事的全部内容，而不是缺这缺那</p><h1 id="3-关键点"><a href="#3-关键点" class="headerlink" title="3. 关键点"></a>3. 关键点</h1><p><strong>设计四大原则：让图结构更清晰</strong></p><ul><li>亲密性：实现组织性（让有关系的元素挨在一起，有区别的元素分开） </li><li>对齐：使页面统一而且有条理（元素与元素之间存在一些对齐效果）</li><li>对比：增强页面的效果、有助于信息的组织（元素与元素之间存在一些对比效果）</li><li>重复：更统一，增强视觉效果（让类似的元素存在一样的效果/样式）</li></ul><p>将这些原则应用到图的线、块、面上。</p><p><strong>美感：色轮的运用</strong></p><ul><li>美术三原色：红黄蓝（在三色场景下，应用最多最广泛的颜色）</li><li>互补色：一种作为主色，另一种作为强调（在二色场景下，用互补色）</li><li>等距三色组：会让人愉悦的颜色组合（在三色场景下，使用等距三色组具有愉悦感）</li><li>采用同层级的颜色：具有和谐感的颜色组合（在多色场景下，采用同层级的颜色更具和谐）</li></ul><p><strong>美感：黄金分割构图法</strong></p><ul><li>黄金分割：0.618（图的整体大小采用长1.618宽1的黄金比）</li><li>斐波那契数列：1，1，2，3，5，8，13，21，34，55，89……，当趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618</li></ul><p>较大部分与整体部分的比值等于较小部分与较大部分的比值，其比值约为0.618</p><p><strong>完整感：以终为始的设计</strong></p><ul><li>思考先行：以终为始的设计</li><li>列出所有要素：所有能帮助看图人理解的元素都要有，包括图例标注、箭头顺序、标题、注解</li><li>用户为先：把自己当作看图人，在没有上下文的情况下能获取到图中多少信息</li></ul><p>在作图前我们要想清楚作这张图的目的是什么，是想要表达清楚什么，以及需要哪些元素，最终实现的效果就是通过一张图，就能完整地了解你的意图和目标。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2024/10/28/2024-01-09-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h1><h2 id="1-1-设计原则-vs-设计模式"><a href="#1-1-设计原则-vs-设计模式" class="headerlink" title="1.1. 设计原则 vs 设计模式"></a>1.1. 设计原则 vs 设计模式</h2><p>设计模式是设计原则的具体化形式，是针对于某些特定场景的具体化解决方案</p><p><strong>在你还不能灵活的运用设计原则时，设计模式则是你的垫脚石，让你在具体的问题面前能够写出更好地代码</strong></p><h2 id="1-2-分类"><a href="#1-2-分类" class="headerlink" title="1.2. 分类"></a>1.2. 分类</h2><p>有23种设计模式，按照特点可以将其分为三大类型：<strong>创建型</strong>、<strong>结构型</strong>、<strong>行为型</strong></p><p><strong>创建型模式是用来创建对象的模式，抽象了实例的创建过程，封装了创建逻辑</strong></p><p><strong>结构型模式讨论的是类和对象的结构，继承和组合结构</strong></p><p><strong>行为型设计模式关注的是对象的行为，用来解决对象之间的联系/通信问题</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2024-01-09-SOLID%E4%BA%94%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
      <url>/2024/10/28/2024-01-09-SOLID%E4%BA%94%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SOLID"><a href="#1-SOLID" class="headerlink" title="1. SOLID"></a>1. SOLID</h1><p>SOLID 原则是用来指导软件设计的，它一共分为五条设计原则，分别是：</p><ul><li>单一职责原则（SRP）</li><li>开闭原则（OCP）</li><li>里氏替换原则（LSP）</li><li>接口隔离原则（ISP）</li><li>依赖倒置原则（DIP）</li></ul><h1 id="2-SRP"><a href="#2-SRP" class="headerlink" title="2. SRP"></a>2. SRP</h1><p>单一职责原则（Single Responsibility Principle）简单地说：接口职责应该单一，不要承担过多的职责。单一职责适用于接口、类，同时也适用于方法</p><p>我们在设计一个类的时候，可以先从粗粒度的类开始设计，等到业务发展到一定规模，我们发现这个粗粒度的类方法和属性太多，且经常修改的时候，我们就可以对这个类进行重构了，将这个类拆分成粒度更细的类，这就是所谓的持续重构</p><h1 id="3-OCP"><a href="#3-OCP" class="headerlink" title="3. OCP"></a>3. OCP</h1><p>开闭原则（Open Closed Principle），简单地说：就是当别人要修改软件功能的时候，使得他不能修改我们原有代码，只能新增代码实现软件功能修改的目的。</p><p>比如，一个做饭的处理程序，做不同的饭用到不同的处理方式，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(type == <span class="string">&quot;米饭&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">//deal with 米饭</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;面条&quot;</span>)&#123;</span><br><span class="line">    <span class="comment">//deal with 面条</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ......)&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以后还需要做其他饭，那么就会在后面加上很多 if else 语句，最终会让整个方法变得又臭又长</p><p>如果我们对做饭这件事情做一个抽象，做米饭的过程是一个具体的实现，做面条是一个具体的实现，那么写出的代码会是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DealFood</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dealFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rice</span> implement DealFood&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dealFood</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//deal with Rice</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Noodles</span> implement DealFood&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dealFood</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//deal with Noodles</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DealFoodFactory</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, DealFood&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//init all the Class that implements DealFood interface </span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;Rice&quot;</span>;</span><br><span class="line">    <span class="type">DealFood</span> <span class="variable">dealFood</span> <span class="operator">=</span> DealFoodFactory.getdealFood(type);  <span class="comment">//get RiceDealFoodClass Instance.</span></span><br><span class="line">    dealFood.dealFood();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种实现方式使得别人无法修改我们的代码，为什么？</p><p>因为当需要做米饭的时候，他会发现他只能新增一个类实现 DealFood 接口，而无法再原来的代码上修改。这样就实现了「对拓展开放，对修改封闭」的原则。</p><h1 id="4-LSP"><a href="#4-LSP" class="headerlink" title="4. LSP"></a>4. LSP</h1><p>里氏替换原则（Liskov Substitution Principle），简单地说：所有父类能出现的地方，子类就可以出现，并且替换了也不会出现任何错误。</p><p>重点强调：对使用者来说，能够使用父类的地方，一定可以使用其子类，并且预期结果是一致的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parent</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">等价于</span><br><span class="line"><span class="type">Son</span> <span class="variable">son</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br></pre></td></tr></table></figure><p>这就要求子类重写父类的所有相同方法时，都必须遵循父类的约定，否则当父类替换为子类时就会出错。</p><h1 id="5-ISP"><a href="#5-ISP" class="headerlink" title="5. ISP"></a>5. ISP</h1><p>接口隔离原则（Interface Segregation Principle），简单地说：接口的内容一定要尽可能地小，能有多小就多小。不要将一个大而全的接口扔给使用者，而是将每个使用者关注的接口进行隔离</p><p>比如，我们提供的一个接口中包含1、2、3、4、5个方法，调用方A只调用1、2、3方法，调用方B只调用4、5方法，接口隔离原则的意思是，你应该把 1、2、3 抽离出来作为一个接口，4、5 抽离出来作为一个接口，这样接口之间就隔离开来了。</p><h1 id="6-DIP"><a href="#6-DIP" class="headerlink" title="6. DIP"></a>6. DIP</h1><p>依赖倒置原则（Dependence Inversion Principle），简单地说，就是说我们应该面向接口编程。通过抽象成接口，使各个类的实现彼此独立，实现类之间的松耦合。DIP 提倡使用者依赖一个抽象的服务接口，而不是去依赖一个具体的服务执行者，从依赖具体实现转向到依赖抽象接口。</p><h1 id="7-SOLID的本质"><a href="#7-SOLID的本质" class="headerlink" title="7. SOLID的本质"></a>7. SOLID的本质</h1><p><strong>简单地说：依赖倒置原则告诉我们要面向接口编程。当我们面向接口编程之后，接口隔离原则和单一职责原则又告诉我们要注意职责的划分，不要什么东西都塞在一起。当我们职责捋得差不多的时候，里氏替换原则告诉我们在使用继承的时候，要注意遵守父类的约定。而上面说的这四个原则，它们的最终目标都是为了实现开闭原则</strong></p><p><img src="F:\笔记\博客\文章图片\16108948449641.jpg" alt="16108948449641"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-29-Windows%E5%AE%9A%E5%88%B6/"/>
      <url>/2024/10/28/2023-11-29-Windows%E5%AE%9A%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-系统激活"><a href="#1-系统激活" class="headerlink" title="1. 系统激活"></a>1. 系统激活</h1><p><a href="https://github.com/massgravel/Microsoft-Activation-Scripts">开源激活脚本</a></p><h1 id="2-暂停更新"><a href="#2-暂停更新" class="headerlink" title="2. 暂停更新"></a>2. 暂停更新</h1><p>打开 cmd ，输入以下内容，暂停更新3000天：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\WindowsUpdate\UX\Settings&quot; /v FlightSettingsMaxPauseDays /t reg_dword /d 3000 /f</span><br></pre></td></tr></table></figure><h1 id="3-关闭-defender"><a href="#3-关闭-defender" class="headerlink" title="3. 关闭 defender"></a>3. 关闭 defender</h1><p>使用dControl工具</p><h1 id="4-取消搜索框的信息推送"><a href="#4-取消搜索框的信息推送" class="headerlink" title="4. 取消搜索框的信息推送"></a>4. 取消搜索框的信息推送</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\explorer&quot; /v DisableSearchBoxSuggestions /t reg_dword /d 1 /f</span><br></pre></td></tr></table></figure><h1 id="5-设置系统全局默认编码为utf-8（谨慎使用）"><a href="#5-设置系统全局默认编码为utf-8（谨慎使用）" class="headerlink" title="5. 设置系统全局默认编码为utf-8（谨慎使用）"></a>5. 设置系统全局默认编码为utf-8（谨慎使用）</h1><p><code>Windows设置 --&gt; 时间和语言 --&gt; 语言 --&gt; 右侧管理语言设置 --&gt; 更改系统区域设置 --&gt; 使用Unicode UTF-8</code></p><h1 id="6-系统默认目录迁移"><a href="#6-系统默认目录迁移" class="headerlink" title="6. 系统默认目录迁移"></a>6. 系统默认目录迁移</h1><p>实现将系统数据与用户数据分开</p><p>重装系统时，随意新建一个用户并设置为管理员。进入系统后修改用户目录的配置，然后新建自己的用户名并设置为管理员。重启后最后新建的用户的数据就放在了修改后的目录</p><h2 id="6-1-迁移用户目录"><a href="#6-1-迁移用户目录" class="headerlink" title="6.1. 迁移用户目录"></a>6.1. 迁移用户目录</h2><ul><li>更改此设置时，不支持 Microsoft Store 应用</li><li>使用除系统驱动器之外的驱动器：可将用户配置文件文件夹（通常为 <code>%SYSTEMDRIVE%\Users</code>）移动到其他位置。 目标路径可以位于系统驱动器以外的卷上，前提是它满足以下要求：<ul><li>必须位于 NTFS 卷上。</li><li>不能指向具有不同 Windows 副本的驱动器。</li></ul></li></ul><p>打开注册表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\</span><br></pre></td></tr></table></figure><p>将<code>ProfilesDirectory</code>项改为将要迁移的路径，例如<code>D:\Users</code></p><h2 id="6-2-仅迁移桌面"><a href="#6-2-仅迁移桌面" class="headerlink" title="6.2. 仅迁移桌面"></a>6.2. 仅迁移桌面</h2><p>迁移文档、视频、下载、图片、音乐、桌面，方式一样</p><p><code>打开此电脑-&gt;找到对应文件-&gt; 右键属性-&gt;位置</code></p><h1 id="7-卸载右下角的资讯和新闻功能"><a href="#7-卸载右下角的资讯和新闻功能" class="headerlink" title="7. 卸载右下角的资讯和新闻功能"></a>7. 卸载右下角的资讯和新闻功能</h1><p>其实这个功能是和edge浏览器绑定的，可以直接卸载edge浏览器，从而这个功能也会直接卸载</p><p>powershell执行<code>get-appxpackage *edge*</code> 查找到edge浏览器的安装包名称</p><p><code>remove-appxpackage + 安装包名称</code> 卸载</p><h1 id="8-安装必要的运行库"><a href="#8-安装必要的运行库" class="headerlink" title="8. 安装必要的运行库"></a>8. 安装必要的运行库</h1><p>使用工具 aio-runtimes</p><h1 id="9-任务栏透明度"><a href="#9-任务栏透明度" class="headerlink" title="9. 任务栏透明度"></a>9. 任务栏透明度</h1><p>命名为 <code>TaskbarAcrylicOpacity.bat</code><br><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">reg add &quot;HKCU\Software\Microsoft\Windows\CurrentVersion\Themes\Personalize&quot; /v EnableTransparency /t REG_DWORD /d <span class="number">1</span> /f</span><br><span class="line">reg add &quot;HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Advance&quot; /v TaskbarAcrylicOpacity /t REG_DWORD /d <span class="number">10</span> /f</span><br><span class="line"><span class="built_in">taskkill</span> /f /im explorer.exe</span><br><span class="line"><span class="built_in">start</span> explorer.exe</span><br></pre></td></tr></table></figure></p><h1 id="10-关闭快速启动"><a href="#10-关闭快速启动" class="headerlink" title="10. 关闭快速启动"></a>10. 关闭快速启动</h1><p>方法一：将下面内容保存为bat执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line"></span><br><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Power&quot; /v HiberbootEnabled /t REG_DWORD /d 0 /f</span><br><span class="line"></span><br><span class="line">echo HiberbootEnabled set to 0 successfully.</span><br><span class="line"></span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>方法二：</p><p>在Windows 搜索栏输入<code>[电源和睡眠设置]</code>，然后点击<code>[打开]</code></p><p>点击<code>[其他电源设置]</code></p><p>点击<code>[选择电源按钮的功能]</code></p><p>如果<strong>关机设置</strong>中的快速启动选项显示为灰色，请先点击<code>[更改当前不可用的设置]</code></p><p>取消勾选<code>[启用快速启动]</code>，然后点击<code>[保存修改]</code>即可关闭 Windows 中的快速启动功能</p><h1 id="11-关闭Microsoft-Compatibility-Telemetry进程"><a href="#11-关闭Microsoft-Compatibility-Telemetry进程" class="headerlink" title="11. 关闭Microsoft Compatibility Telemetry进程"></a>11. 关闭Microsoft Compatibility Telemetry进程</h1><p><strong>Microsoft Compatibility Telemetry</strong> 是微软设计的一个官方系统进程，它在后台运行以收集操作系统的性能数据。</p><p><strong>删除 CompatTelRunner.exe 文件</strong></p><ul><li>进入 <code>C: &gt; Windows &gt; System32</code>, 注意此处假设C盘为系统盘</li><li>必须先拥有该文件的所有权，然后才能将其删除。右键单击该文件并打开“属性”页面。</li><li>然后，单击“安全”选项卡中的“高级”选项。</li><li>此处看到文件的当前所有者，即“TrustedInstaller”。单击右侧提供的“更改”选项以更改所有者。</li><li>在这里，可以键入用户名称。为了安全起见，只需在命令提示符下运行“whoami”命令，然后在空格中输入结果。</li><li>选择自己为所有者后，单击“确定”关闭对话框。</li><li>现在就可以更改文件的权限。选择CompatTelRunner.exe并授予该文件的“完全控制权”。</li><li>完成上面的步骤后，就可以直接从计算机中删除 CompatTelRunner.exe 文件了。删除后，重新启动系统以使更改生效。</li></ul><h1 id="12-修改环境变量"><a href="#12-修改环境变量" class="headerlink" title="12. 修改环境变量"></a>12. 修改环境变量</h1><p>系统变量：修改后重启才能生效</p><p>用户变量：修改后，重启相关应用即可生效</p><p>一般建议使用用户变量即可</p><h1 id="13-无视任何限制和权限-强制删除文件夹-文件"><a href="#13-无视任何限制和权限-强制删除文件夹-文件" class="headerlink" title="13. 无视任何限制和权限 强制删除文件夹/文件"></a>13. 无视任何限制和权限 强制删除文件夹/文件</h1><p>win键 + R 输入msconfig</p><p>选择【引导】选项卡，勾选左边的【安全引导】，点击确定</p><p>系统会询问你是否立刻重启 那么你就重新启动电脑 </p><p>重新启动后进入安全模式，则可以删除任意文件夹，无需管理员权限！  </p><p>最后，删除完成后，再次运行cmd。输入msconfig，将【系统配置】的【引导】中的【安全引导】的勾选掉，再次重新重新启动电脑，即可回到正常模式。</p><h1 id="14-关闭文件资源管理器的快速访问"><a href="#14-关闭文件资源管理器的快速访问" class="headerlink" title="14. 关闭文件资源管理器的快速访问"></a>14. 关闭文件资源管理器的快速访问</h1><p>打开文件资源管理器，查看-&gt;选项，设置打开文件资源管理器时默认打开<code>此电脑</code>，取消勾选<code>快速访问</code></p><p>打开 本地组策略（win+r，输入gpedit.msc），选择 用户配置-&gt;管理模板-&gt;开始菜单-&gt; 不保留最近打开文档的历史</p><h1 id="15-解决win10-cmd下运行python弹出windows应用商店"><a href="#15-解决win10-cmd下运行python弹出windows应用商店" class="headerlink" title="15. 解决win10 cmd下运行python弹出windows应用商店"></a>15. 解决win10 cmd下运行python弹出windows应用商店</h1><p>删除微软应用商店的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\...\AppData\Microsoft\WindowsApps</span><br></pre></td></tr></table></figure><h1 id="16-时间自动同步"><a href="#16-时间自动同步" class="headerlink" title="16. 时间自动同步"></a>16. 时间自动同步</h1><p>打开Windows Time服务，启动方式设置为自动</p><h1 id="17-开机时进入安全模式"><a href="#17-开机时进入安全模式" class="headerlink" title="17. 开机时进入安全模式"></a>17. 开机时进入安全模式</h1>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-05-GNUmake/"/>
      <url>/2024/10/28/2023-12-05-GNUmake/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么需要GNU-Make"><a href="#1-为什么需要GNU-Make" class="headerlink" title="1. 为什么需要GNU Make"></a>1. 为什么需要GNU Make</h1><p>写 hello world 程序的时候，在编辑完 <code>helloworld.c</code> 之后，需要用 <code>gcc</code> 编译生成可执行文件，然后再执行。但如果项目由成百上千个 C 源文件组成，并且星罗棋布在各个子目录下，该如何将它们编译链接到一起呢？假如你的项目编译一次需要半个小时（大型项目相当常见），而你只修改了一个分号，是不是还需要再等半个小时呢？</p><p>这时候 GNU Make 就闪亮登场了，它能让你在一个脚本里（即所谓的 <code>Makefile</code>）定义整个编译流程以及各个目标文件与源文件之间的依赖关系，并且只重新编译你的修改会影响到的部分，从而降低编译的时间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-06-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2024/10/28/2023-12-06-%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主从复制"><a href="#1-主从复制" class="headerlink" title="1. 主从复制"></a>1. 主从复制</h1><h2 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1. 优点"></a>1.1. 优点</h2><ul><li>做数据的热备。主数据库故障后，可切换到从数据库继续工作，避免数据丢失</li><li>架构的扩展。业务量增加，单机无法满足，做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能</li><li>读写分离。使数据库能支持更大的并发量</li></ul><h2 id="1-2-原理"><a href="#1-2-原理" class="headerlink" title="1.2. 原理"></a>1.2. 原理</h2><p>主从数据库之间通过binary log进行数据的同步</p><p>binary log有三种模式</p><p><strong>基于SQL语句的复制（STATEMENT）</strong></p><p>MySQL 会将执行的每个更改数据的 SQL 语句（insert、update、delete）记录到二进制日志中，进而同步到从库的relaylog中，被从库的SQL线程取出来，回放执行</p><p>优点：</p><ul><li><strong>效率高</strong>：因为只记录 SQL 语句，所以日志量相对较小。</li><li><strong>易读性</strong>：日志内容是标准的 SQL 语句，便于阅读和调试。</li></ul><p>缺点：</p><ul><li><strong>非确定性语句问题</strong>：同步的SQL语句里如果包含有某些函数、关键字等，在执行时可能会产生不同的结果，例如基于 NOW() 或 RAND() 函数的语句。</li></ul><p><strong>基于行的复制（ROW）</strong></p><p>MySQL 会记录每一行的改变，更新前和更新后的数据，而不是记录 SQL 语句，可以保证主从数据绝对相同</p><p>优点：</p><ul><li><strong>准确性高</strong>：每一行的变化被精确记录，消除了非确定性语句可能带来的问题。</li><li><strong>复制一致性</strong>：适用于复杂的数据修改，如涉及触发器、存储过程等的操作。</li></ul><p>缺点：</p><ul><li><strong>日志量大</strong>：因为记录了每一行的变化，所以日志量可能非常大，尤其是在进行批量操作时。</li><li><strong>可读性差</strong>：日志内容是行数据的变化，不易阅读和调试。</li></ul><p><strong>混合复制</strong></p><p>以上两种模式的混合，MySQL 会根据具体的 SQL 语句类型自动选择使用 STATEMENT 或 ROW 模式。通常，会优先使用 STATEMENT 模式，但在某些情况下（如非确定性语句）会切换到 ROW 模式。</p><h2 id="1-3-同步模式"><a href="#1-3-同步模式" class="headerlink" title="1.3. 同步模式"></a>1.3. 同步模式</h2><p>MySQL主从同步的同步模式</p><p><strong>全同步</strong></p><p>全同步复制确保每一个写操作在所有从数据库都确认接收到更改后，主数据库才返回给客户端。</p><p>优点：最高的数据一致性：确保所有从数据库都接收到更改，完全消除了数据丢失的风险。</p><p>缺点：性能显著降低：主数据库需要等待所有从数据库的确认，写操作的延迟显著增加。</p><p><strong>半同步</strong></p><p>在半同步复制中，主数据库在将更改写入二进制日志后，会等待至少一个从数据库确认接收到该更改，然后才返回给客户端。</p><p>优点：提高数据一致性：在主数据库崩溃时，只有确认至少一个从数据库接收到更改，才返回给客户端，从而减少了数据丢失的风险。</p><p>缺点：性能影响：由于主数据库需要等待从数据库的确认，写操作的延迟增加，可能会影响性能。</p><p><strong>异步</strong></p><p>异步复制是 MySQL 默认的复制模式。在异步复制中，主数据库在将更改写入二进制日志后立即返回给客户端，而不等待从数据库的确认。</p><p>优点：性能高：因为主数据库不需要等待从数据库的确认，所以写操作的延迟很低。</p><p>简单实现：配置和管理相对简单，适用于大多数常见场景。</p><p>缺点：潜在的数据丢失：在主数据库崩溃时，可能会有一些操作还没有被复制到从数据库，从而导致数据丢失。</p><h1 id="2-读写分离"><a href="#2-读写分离" class="headerlink" title="2. 读写分离"></a>2. 读写分离</h1><p>主数据库负责数据的写操作，从数据负责数据的读操作</p><h2 id="2-1-实现"><a href="#2-1-实现" class="headerlink" title="2.1. 实现"></a>2.1. 实现</h2><ul><li><strong>应用层实现</strong>：应用程序代码中区分读写操作，并根据操作类型选择连接主库或从库。</li><li><strong>中间件实现</strong>：如 sharding-jdbc 等中间件，可以自动实现读写分离。</li></ul><h1 id="3-分库分表"><a href="#3-分库分表" class="headerlink" title="3. 分库分表"></a>3. 分库分表</h1><h2 id="3-1-分表（分片）"><a href="#3-1-分表（分片）" class="headerlink" title="3.1. 分表（分片）"></a>3.1. 分表（分片）</h2><p>将一张大表分成若干小表</p><p><strong>垂直切分</strong></p><p>垂直切分是将一张表中的列数据按逻辑关系分散到多个表中，每个表存储部分列的数据。常见的垂直切分策略包括将经常访问的列和不常访问的列分开，将大字段和小字段分开等。</p><p><strong>水平切分</strong></p><p>水平切分是将一张表中的行数据按某种规则分散到多个表中，每个表都有相同的列结构，但存储的是不同范围的数据。常见的水平切分策略包括按范围（Range Sharding）、按哈希（Hash Sharding）等。</p><h2 id="3-2-分库"><a href="#3-2-分库" class="headerlink" title="3.2. 分库"></a>3.2. 分库</h2><p>将多种分类的数据表，分开存在不同的数据库中，如：用户数据，订单数据，商品数据，分别放在不同的数据库中。有利于差异化管理</p><h2 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3. 实现"></a>3.3. 实现</h2><p>在分库分表的同时要解决使用的透明度，在应用程序和数据库集群中增加数据库代理层如：sharding-jdbc ，降低应用程序和数据库间的耦合度</p><h2 id="3-4-分库分表方案产品"><a href="#3-4-分库分表方案产品" class="headerlink" title="3.4. 分库分表方案产品"></a>3.4. 分库分表方案产品</h2><p>目前市面上的分库分表中间件相对较多，其中基于代理方式的有MySQL Proxy和Amoeba， 基于Hibernate框架的是Hibernate Shards，基于jdbc的有当当sharding-jdbc， 基于mybatis的类似maven插件式的有蘑菇街的蘑菇街TSharding， 通过重写spring的ibatis template类的Cobar Client</p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-05-http%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/10/28/2023-12-05-http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-web及网络基础"><a href="#1-web及网络基础" class="headerlink" title="1. web及网络基础"></a>1. web及网络基础</h1><h2 id="1-1-http1-0"><a href="#1-1-http1-0" class="headerlink" title="1.1. http1.0"></a>1.1. http1.0</h2><h2 id="1-2-http1-1"><a href="#1-2-http1-1" class="headerlink" title="1.2. http1.1"></a>1.2. http1.1</h2><h2 id="1-3-TCP-IP协议族"><a href="#1-3-TCP-IP协议族" class="headerlink" title="1.3. TCP/IP协议族"></a>1.3. TCP/IP协议族</h2><h3 id="1-3-1-IP协议"><a href="#1-3-1-IP协议" class="headerlink" title="1.3.1. IP协议"></a>1.3.1. IP协议</h3><p>作用：把各种数据包传送给对方</p><p><strong>IP地址</strong></p><p>指明节点被分配到的地址</p><p><strong>MAC地址</strong></p><ul><li>网卡所属的固定地址</li><li>ARP协议依赖MAC地址进行通信</li></ul><h3 id="1-3-2-TCP协议"><a href="#1-3-2-TCP协议" class="headerlink" title="1.3.2. TCP协议"></a>1.3.2. TCP协议</h3><ul><li>提供字节流服务：将大块数据分割为报文段进行传输</li><li>三次握手</li><li>四次挥手</li></ul><h3 id="1-3-3-DNS服务"><a href="#1-3-3-DNS服务" class="headerlink" title="1.3.3. DNS服务"></a>1.3.3. DNS服务</h3><ul><li>将域名和IP地址相互映射</li><li>对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符</li></ul><h2 id="1-4-URI"><a href="#1-4-URI" class="headerlink" title="1.4. URI"></a>1.4. URI</h2><p>统一资源标识符</p><h3 id="1-4-1-格式"><a href="#1-4-1-格式" class="headerlink" title="1.4.1. 格式"></a>1.4.1. 格式</h3><ul><li>登录信息（）</li><li>服务器地址</li><li>服务器端口号</li><li>带层次的文件路径</li><li>查询字符串</li><li>片段标识符</li></ul><h2 id="1-5-URL"><a href="#1-5-URL" class="headerlink" title="1.5. URL"></a>1.5. URL</h2><p>统一资源定位符</p><p>URL：是URI常用协议的一个子集</p><h3 id="1-5-1-组成"><a href="#1-5-1-组成" class="headerlink" title="1.5.1. 组成"></a>1.5.1. 组成</h3><ul><li>第一部分：协议，如：HTTP、FTP、MHTML等</li><li>第二部分：主机的IP地址，有时也包括端口</li><li>第三部分：资源文件名，通常包含目录在内</li></ul><h1 id="2-简单的HTTP协议1-1"><a href="#2-简单的HTTP协议1-1" class="headerlink" title="2. 简单的HTTP协议1.1"></a>2. 简单的HTTP协议1.1</h1><h2 id="2-1-持久连接问题"><a href="#2-1-持久连接问题" class="headerlink" title="2.1. 持久连接问题"></a>2.1. 持久连接问题</h2><p><strong>HTTP keep-alive</strong></p><p>解决了HTTP1.0每通信一次就断开TCP连接的问题</p><p><strong>管线化</strong></p><p>无需等待响应，可并行发送多个请求</p><h2 id="2-2-无状态协议"><a href="#2-2-无状态协议" class="headerlink" title="2.2. 无状态协议"></a>2.2. 无状态协议</h2><ul><li>每次http通信都需要重新验证用户身份</li><li>解决方法：cookie技术。服务器响应报文中的Set-Cookie通知客户端保存Cookie</li></ul><h2 id="2-3-请求URI"><a href="#2-3-请求URI" class="headerlink" title="2.3. 请求URI"></a>2.3. 请求URI</h2><p>不是访问特定资源而是对服务器本身发起的请求使用 <code>*</code> 代替URI</p><h2 id="2-4-请求与响应的通信"><a href="#2-4-请求与响应的通信" class="headerlink" title="2.4. 请求与响应的通信"></a>2.4. 请求与响应的通信</h2><h3 id="2-4-1-请求方法"><a href="#2-4-1-请求方法" class="headerlink" title="2.4.1. 请求方法"></a>2.4.1. 请求方法</h3><p>报文中起始行的开头</p><p><strong>注：方法名区分大小写</strong></p><ul><li>GET（获取资源）</li></ul><ul><li><p>POST（传输实体主体）</p></li><li><p>PUT（传输文件）：自身不带验证机制</p></li><li><p>HEAD（获得报文首部）：用于确认URI的有效性</p></li><li><p>DELETE（删除资源）：自身不带验证机制</p></li><li><p>OPTIONS（询问支持的方法）</p></li><li><p>TRACE（追踪路径）：确认连接过程中发生的一系列操作</p></li><li><p>CONNECT（要求用隧道协议连接代理）：实现用隧道协议进行TCP通信，CONNECT 代理服务器名 ：端口号 HTTP版本</p><ul><li>TLS协议</li><li>SSL协议</li></ul></li></ul><h1 id="3-HTTP报文"><a href="#3-HTTP报文" class="headerlink" title="3. HTTP报文"></a>3. HTTP报文</h1><h2 id="3-1-概念"><a href="#3-1-概念" class="headerlink" title="3.1. 概念"></a>3.1. 概念</h2><p><strong>报文</strong></p><p>HTTP通信中的基本单位，由8位组字节流组成</p><p>HTTP协议交互的信息</p><ul><li>报文首部</li><li>报文主体</li></ul><p>注：报文首部与报文主体用 CR + LF （回车符+换行符）实现空行，十六进制为 0x0d 和 0x0a</p><p><strong>实体</strong></p><p>作为请求或响应的有效载荷数据被传输</p><ul><li>实体首部</li><li><p>实体主体</p></li><li><p>注：通常，报文主体等于实体主体，只有当传输内容进行编码操作时，二者才会不同。</p></li></ul><h2 id="3-2-编码提升传输速率"><a href="#3-2-编码提升传输速率" class="headerlink" title="3.2. 编码提升传输速率"></a>3.2. 编码提升传输速率</h2><h3 id="3-2-1-内容编码"><a href="#3-2-1-内容编码" class="headerlink" title="3.2.1. 内容编码"></a>3.2.1. 内容编码</h3><p>实体信息原样压缩</p><ul><li>gzip</li><li>deflate（zlib）</li><li>identity（不进行编码）</li></ul><h3 id="3-2-2-分块传输编码"><a href="#3-2-2-分块传输编码" class="headerlink" title="3.2.2. 分块传输编码"></a>3.2.2. 分块传输编码</h3><p>把大量数据分割成块</p><h2 id="3-3-多部分对象集合"><a href="#3-3-多部分对象集合" class="headerlink" title="3.3. 多部分对象集合"></a>3.3. 多部分对象集合</h2><h2 id="3-4-范围请求"><a href="#3-4-范围请求" class="headerlink" title="3.4. 范围请求"></a>3.4. 范围请求</h2><h2 id="3-5-内容协商"><a href="#3-5-内容协商" class="headerlink" title="3.5. 内容协商"></a>3.5. 内容协商</h2><h2 id="3-6-HTTP报文的组成"><a href="#3-6-HTTP报文的组成" class="headerlink" title="3.6. HTTP报文的组成"></a>3.6. HTTP报文的组成</h2><h1 id="4-HTTP状态码"><a href="#4-HTTP状态码" class="headerlink" title="4. HTTP状态码"></a>4. HTTP状态码</h1><p>注：状态码经常与状态不一致</p><p><strong>1xx</strong></p><p>信息性状态码</p><p><strong>2xx</strong></p><p>成功状态码</p><p><strong>3xx</strong></p><p>重定向状态码</p><p><strong>4xx</strong></p><p>客户端错误状态码</p><p><strong>5xx</strong></p><p>服务器错误状态码</p><h1 id="5-与HTTP协作的web服务器"><a href="#5-与HTTP协作的web服务器" class="headerlink" title="5. 与HTTP协作的web服务器"></a>5. 与HTTP协作的web服务器</h1><h2 id="5-1-单个主机托管多个域名"><a href="#5-1-单个主机托管多个域名" class="headerlink" title="5.1. 单个主机托管多个域名"></a>5.1. 单个主机托管多个域名</h2><p>多个域名指向同一ip地址，请求访问时需在Host中指明完整的主机名或域名的URL</p><h2 id="5-2-通信数据转发"><a href="#5-2-通信数据转发" class="headerlink" title="5.2. 通信数据转发"></a>5.2. 通信数据转发</h2><h3 id="5-2-1-代理"><a href="#5-2-1-代理" class="headerlink" title="5.2.1. 代理"></a>5.2.1. 代理</h3><ul><li>不改变请求URL</li><li>通过代理服务器的请求或响应会追加写入Via首部信息</li></ul><p><strong>分类1</strong></p><ul><li>缓存代理（Caching proxy）：将资源副本保存在服务器上</li><li>透明代理（Transparent proxy）：不对报文做任何加工</li></ul><p><strong>分类2</strong></p><ul><li>正向代理<ul><li>目标服务器是不知道真正的客户端是谁</li><li>客户端知道代理服务器和web服务器的存在</li><li>可以隐藏客户端真实IP</li></ul></li><li>反向代理（CDN）<ul><li>客户端是不知道真正的目标服务器是谁</li><li>客户端不知道web服务器的存在</li><li>隐藏服务器真实IP</li></ul></li></ul><h3 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2. 网关"></a>5.2.2. 网关</h3><ul><li>能使通信线路上的服务器提供非HTTP协议服务</li><li>提高通信的安全性</li></ul><h3 id="5-2-3-隧道"><a href="#5-2-3-隧道" class="headerlink" title="5.2.3. 隧道"></a>5.2.3. 隧道</h3><ul><li>实现远距离的安全通信</li><li>SSL加密</li></ul><h1 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6. HTTP首部"></a>6. HTTP首部</h1><h2 id="6-1-请求报文"><a href="#6-1-请求报文" class="headerlink" title="6.1. 请求报文"></a>6.1. 请求报文</h2><ul><li>方法</li><li>URI</li><li>HTTP版本</li><li>HTTP首部字段</li></ul><h2 id="6-2-响应报文"><a href="#6-2-响应报文" class="headerlink" title="6.2. 响应报文"></a>6.2. 响应报文</h2><ul><li>HTTP版本</li><li>状态码</li><li>HTTP首部字段 </li></ul><h2 id="6-3-HTTP首部字段"><a href="#6-3-HTTP首部字段" class="headerlink" title="6.3. HTTP首部字段"></a>6.3. HTTP首部字段</h2><h3 id="6-3-1-实际用途分类"><a href="#6-3-1-实际用途分类" class="headerlink" title="6.3.1. 实际用途分类"></a>6.3.1. 实际用途分类</h3><p><strong>通用首部字段</strong></p><div class="table-container"><table><thead><tr><th>Cache-Control</th><th>控制缓存的行为</th></tr></thead><tbody><tr><td>Connection</td><td>逐挑首部、连接的管理</td></tr><tr><td>Date</td><td>创建报文的日期时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Trailer</td><td>报文末端的首部一览</td></tr><tr><td>Transfer-Encoding</td><td>指定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>升级为其他协议</td></tr><tr><td>Via</td><td>代理服务器的相关信息</td></tr><tr><td>Warning</td><td>错误通知</td></tr></tbody></table></div><p><strong>请求</strong></p><div class="table-container"><table><thead><tr><th>Accept</th><th>用户代理可处理的媒体类型</th></tr></thead><tbody><tr><td>Accept-Charset</td><td>优先的字符集</td></tr><tr><td>Accept-Encoding</td><td>优先的内容编码</td></tr><tr><td>Accept-Language</td><td>优先的语言（自然语言）</td></tr><tr><td>Authorization</td><td>Web认证信息</td></tr><tr><td>Expect</td><td>期待服务器的特定行为</td></tr><tr><td>From</td><td>用户的电子邮箱地址</td></tr><tr><td>Host</td><td>请求资源所在服务器</td></tr><tr><td>If-Match</td><td>比较实体标记（ETag）</td></tr><tr><td>If-Modified-Since</td><td>比较资源的更新时间</td></tr><tr><td>If-None-Match</td><td>比较实体标记（与 If-Macth 相反）</td></tr><tr><td>If-Range</td><td>资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td>If-Unmodified-Since</td><td>比较资源的更新时间(与 If-Modified-Since 相反)</td></tr><tr><td>Max-Forwards</td><td>最大传输逐跳数</td></tr><tr><td>Proxy-Authorization</td><td>代理服务器要求客户端的认证信息</td></tr><tr><td>Range</td><td>实体的字节范围请求</td></tr><tr><td>Referer</td><td>表示从哪儿链接到目前的网页，采用的格式是URL</td></tr><tr><td>TE</td><td>传输编码的优先级</td></tr><tr><td>User-Agent</td><td>HTTP 客户端程序的信息</td></tr></tbody></table></div><p><strong>响应</strong></p><div class="table-container"><table><thead><tr><th>Accept-Ranges</th><th>是否接受字节范围请求</th></tr></thead><tbody><tr><td>Age</td><td>推算资源创建经过时间</td></tr><tr><td>ETag</td><td>资源的匹配信息</td></tr><tr><td>Location</td><td>令客户端重定向至指定 URI</td></tr><tr><td>Proxy-Authenticate</td><td>代理服务器对客户端的认证信息</td></tr><tr><td>Retry-After</td><td>对再次发起请求的时机要求</td></tr><tr><td>Server</td><td>HTTP 服务器的安装信息</td></tr><tr><td>Vary</td><td>代理服务器缓存的管理信息</td></tr><tr><td>WWW-Authenticate</td><td>服务器对客户端的认证信息</td></tr></tbody></table></div><p><strong>实体</strong></p><div class="table-container"><table><thead><tr><th>Allow</th><th>资源可支持的 HTTP 方法</th></tr></thead><tbody><tr><td>Content-Encoding</td><td>实体主体适用的编码方式</td></tr><tr><td>Content-Language</td><td>实体主体的自然语言</td></tr><tr><td>Content-Length</td><td>实体主体的大小（单位：字节）</td></tr><tr><td>Content-Location</td><td>替代对应资源的 URI</td></tr><tr><td>Content-MD5</td><td>实体主体的报文摘要</td></tr><tr><td>Content-Range</td><td>实体主体的位置范围</td></tr><tr><td>Content-Type</td><td>实体主体的媒体类型</td></tr><tr><td>Expires</td><td>实体主体过期的日期时间</td></tr><tr><td>Last-Modified</td><td>资源的最后修改日期时间</td></tr></tbody></table></div><h3 id="6-3-2-缓存代理-非缓存代理"><a href="#6-3-2-缓存代理-非缓存代理" class="headerlink" title="6.3.2. 缓存代理/非缓存代理"></a>6.3.2. 缓存代理/非缓存代理</h3><ul><li>端到端首部（End-to-end Header）<ul><li>此类别中的首部会转发给最终的接收目标，且必须保存在由缓存生成的响应中，另外规定，它必须被转发</li></ul></li><li>逐跳首部（Hop-by-hop Header）<ul><li>只对单次转发有效，会因通过缓存或代理而不再转发<ul><li>Connection</li><li>Keep-Alive</li><li>Proxy-Authenticate</li><li>Proxy-Authorization</li><li>Trailer</li><li>TE</li><li>Transfer-Encoding</li><li>Upgrade</li><li>注：除以上8个，其他都属于端到端</li></ul></li></ul></li></ul><h3 id="6-3-3-为Cookie服务的首部字段"><a href="#6-3-3-为Cookie服务的首部字段" class="headerlink" title="6.3.3. 为Cookie服务的首部字段"></a>6.3.3. 为Cookie服务的首部字段</h3><ul><li><p>Set-Cookie（响应首部字段）</p><p>属性</p><ul><li><p>NAME=VALUE</p><p>Cookie的名称和值</p></li><li><p>expires=DATE</p><p>Cookie的有效期</p></li><li><p>path=PATH</p><p>将服务器上的文件目录作为Cookie的适用对象</p></li><li><p>domain=域名</p><p>作为Cookie适用对象的域名</p></li><li><p>Secure</p><p>仅在HTTPS安全连接时才会发送Cookie</p></li><li><p>HttpOnly</p><p>使Cookie不能被JavaScript脚本访问</p><ul><li>防止XSS跨站脚本攻击</li></ul></li></ul></li><li><p>Cookie（请求首部字段）</p></li></ul><h3 id="6-3-4-其他首部字段"><a href="#6-3-4-其他首部字段" class="headerlink" title="6.3.4. 其他首部字段"></a>6.3.4. 其他首部字段</h3><ul><li><p>X-Frame-Options</p><p>防止点击劫持攻击</p></li><li><p>X-XSS-Protection</p><p>防止XSS跨站攻击</p></li><li><p>DNT</p></li><li><p>P3P</p></li></ul><h1 id="7-HTTPS"><a href="#7-HTTPS" class="headerlink" title="7. HTTPS"></a>7. HTTPS</h1><h2 id="7-1-HTTP缺点"><a href="#7-1-HTTP缺点" class="headerlink" title="7.1. HTTP缺点"></a>7.1. HTTP缺点</h2><ul><li><p>HTTP的防篡改措施</p><ul><li>SHA-1</li><li>MD5</li></ul></li><li><p>明文传输</p></li><li><p>无法验证通信方身份</p><p>接收大量无意义的请求，导致DoS攻击（拒绝服务攻击）</p></li><li><p>无法验证报文的完整性</p><p>报文可能被修改，导致中间人攻击（MITM）</p></li></ul><h2 id="7-2-HTTP-SSL"><a href="#7-2-HTTP-SSL" class="headerlink" title="7.2. HTTP+SSL"></a>7.2. HTTP+SSL</h2><h3 id="7-2-1-加密"><a href="#7-2-1-加密" class="headerlink" title="7.2.1. 加密"></a>7.2.1. 加密</h3><ul><li><p>对称密钥加密（共享密钥加密）</p><p>解密与加密使用同一密钥，所以密钥会发送给解密之人</p></li><li><p>公开密钥加密</p><p>一对非对称密钥</p><ul><li><p>私有密钥</p><p>解密方使用该密钥解密</p></li><li><p>公开密钥</p><p>加密方使用该密钥进行加密</p></li></ul></li><li><p>总结：公开密钥加密解决了共享密钥在传输时被窃取的危险</p></li><li><p>HTTPS的混合加密</p><ul><li>在交换密钥环节使用公开密钥加密，建立通信后，使用共享密钥加密</li></ul></li></ul><h3 id="7-2-2-认证"><a href="#7-2-2-认证" class="headerlink" title="7.2.2. 认证"></a>7.2.2. 认证</h3><ul><li><p>查找证书</p></li><li><p>公钥证书（数字证书）</p><p>解决公钥在传输过程中可能被替换的问题</p></li></ul><h1 id="8-确认用户访问身份的认证"><a href="#8-确认用户访问身份的认证" class="headerlink" title="8. 确认用户访问身份的认证"></a>8. 确认用户访问身份的认证</h1><h2 id="8-1-HTTP的认证方式"><a href="#8-1-HTTP的认证方式" class="headerlink" title="8.1. HTTP的认证方式"></a>8.1. HTTP的认证方式</h2><h3 id="8-1-1-BASIC认证"><a href="#8-1-1-BASIC认证" class="headerlink" title="8.1.1. BASIC认证"></a>8.1.1. BASIC认证</h3><ul><li>发送请求后收到 状态码401，然后客户端将账户密码用 ： 连接，再base64加密后传输给服务器</li></ul><h3 id="8-1-2-DIGEST认证（摘要认证）"><a href="#8-1-2-DIGEST认证（摘要认证）" class="headerlink" title="8.1.2. DIGEST认证（摘要认证）"></a>8.1.2. DIGEST认证（摘要认证）</h3><ul><li>可防止窃听，但不防止用户伪装</li><li>质询/响应的方式</li></ul><h3 id="8-1-3-SSL客户端认证"><a href="#8-1-3-SSL客户端认证" class="headerlink" title="8.1.3. SSL客户端认证"></a>8.1.3. SSL客户端认证</h3><ul><li>客户端证书认证</li><li>双因素认证<ul><li>客户端认证</li><li>表单认证</li></ul></li></ul><h3 id="8-1-4-FormBase认证（基于表单认证）"><a href="#8-1-4-FormBase认证（基于表单认证）" class="headerlink" title="8.1.4. FormBase认证（基于表单认证）"></a>8.1.4. FormBase认证（基于表单认证）</h3><ul><li>Cookie管理Session（会话）<ul><li>Session是指用户从打开浏览器访问服务器到关闭浏览器之间的会话状态,在一个会话期间，服务器会自动分配一个标识SessionId。Session可以存储用户访问服务器的一些传递资料信息</li><li>Session对象和Cookie对象相比的差别在于,Cookie存储在客户端的浏览器中，而Session对象存储在服务器端</li><li>存在XSS攻击</li></ul></li></ul><h1 id="9-基于-HTTP的其他协议"><a href="#9-基于-HTTP的其他协议" class="headerlink" title="9. 基于 HTTP的其他协议"></a>9. 基于 HTTP的其他协议</h1><h2 id="9-1-HTTP缺点"><a href="#9-1-HTTP缺点" class="headerlink" title="9.1. HTTP缺点"></a>9.1. HTTP缺点</h2><p>SNS(社交网络服务)需要实时更新网页内容，导致频繁的从客户端到服务端访问，若没有内容更新，则会浪费资源</p><h2 id="9-2-解决方法"><a href="#9-2-解决方法" class="headerlink" title="9.2. 解决方法"></a>9.2. 解决方法</h2><h3 id="9-2-1-Ajax"><a href="#9-2-1-Ajax" class="headerlink" title="9.2.1. Ajax"></a>9.2.1. Ajax</h3><p>（异步+JavaScript+XML）</p><ul><li>核心：API  : XMLHttpRequest</li><li>通过调用JavaScript脚本与服务器建立通信，从web页面发起请求，更新局部内容</li><li>缺点：产生大量请求</li></ul><h3 id="9-2-2-Comet"><a href="#9-2-2-Comet" class="headerlink" title="9.2.2. Comet"></a>9.2.2. Comet</h3><ul><li>延迟应答<ul><li>接到请求后先将挂起，待服务端有内容更新时，再返回响应</li></ul></li><li>缺点：为了维持连接 ，会消耗较多资源</li></ul><h3 id="9-2-3-SPDY"><a href="#9-2-3-SPDY" class="headerlink" title="9.2.3. SPDY"></a>9.2.3. SPDY</h3><ul><li>以会话层的形式加入</li><li>功能<ul><li>多路复用流</li><li>赋予请求优先级</li><li>压缩HTTP首部</li><li>推送功能</li><li>服务器提示功能</li></ul></li></ul><h3 id="9-2-4-WebSocket"><a href="#9-2-4-WebSocket" class="headerlink" title="9.2.4. WebSocket"></a>9.2.4. WebSocket</h3><h1 id="10-构建web内容的技术"><a href="#10-构建web内容的技术" class="headerlink" title="10. 构建web内容的技术"></a>10. 构建web内容的技术</h1><h2 id="10-1-HTML"><a href="#10-1-HTML" class="headerlink" title="10.1. HTML"></a>10.1. HTML</h2><h2 id="10-2-CSS"><a href="#10-2-CSS" class="headerlink" title="10.2. CSS"></a>10.2. CSS</h2><h2 id="10-3-JavaScript"><a href="#10-3-JavaScript" class="headerlink" title="10.3. JavaScript"></a>10.3. JavaScript</h2><ul><li>动态HTML</li></ul><h2 id="10-4-DOM"><a href="#10-4-DOM" class="headerlink" title="10.4. DOM"></a>10.4. DOM</h2><ul><li>用来操作HTML和XML的API</li></ul><h2 id="10-5-web应用"><a href="#10-5-web应用" class="headerlink" title="10.5. web应用"></a>10.5. web应用</h2><h3 id="10-5-1-内容"><a href="#10-5-1-内容" class="headerlink" title="10.5.1. 内容"></a>10.5.1. 内容</h3><ul><li>静态内容</li><li>动态内容<ul><li>由程序创建</li></ul></li></ul><h3 id="10-5-2-CGI"><a href="#10-5-2-CGI" class="headerlink" title="10.5.2. CGI"></a>10.5.2. CGI</h3><p>（Common Gateway Interface-通用网关接口）</p><ul><li><p>它是网页的表单和你写的程序之间通信的一种协议。可以用任何语言写一个CGI脚本，这些语言只要能接收输入输出信息，读取环境变量</p></li><li><p>CGI脚本的结构</p><ul><li><p>读取用户提交表单的信息</p></li><li><p>处理这些信息（也就是实现业务）</p></li><li><p>输出，返回html响应（返回处理完的数据）</p></li></ul></li></ul><h3 id="10-5-3-Servlet"><a href="#10-5-3-Servlet" class="headerlink" title="10.5.3. Servlet"></a>10.5.3. Servlet</h3><ul><li>运行的环境：Web容器或Servlet容器</li><li>优点：运行在与web服务器相同的进程中，受到的负载小，而CGI每次接受请求都要启动，访问量大时，会导致服务器负载过大</li></ul><h2 id="10-6-数据发布的格式及语言"><a href="#10-6-数据发布的格式及语言" class="headerlink" title="10.6. 数据发布的格式及语言"></a>10.6. 数据发布的格式及语言</h2><ul><li>XML(可拓展标记语言)<ul><li>使数据容易读取</li></ul></li><li>发布更新信息的RSS/Atom</li><li>JSON</li></ul><h1 id="11-web的攻击技术"><a href="#11-web的攻击技术" class="headerlink" title="11. web的攻击技术"></a>11. web的攻击技术</h1><h2 id="11-1-攻击类别"><a href="#11-1-攻击类别" class="headerlink" title="11.1. 攻击类别"></a>11.1. 攻击类别</h2><h3 id="11-1-1-被动攻击（设计陷阱使用户触发，执行攻击代码）"><a href="#11-1-1-被动攻击（设计陷阱使用户触发，执行攻击代码）" class="headerlink" title="11.1.1. 被动攻击（设计陷阱使用户触发，执行攻击代码）"></a>11.1.1. 被动攻击（设计陷阱使用户触发，执行攻击代码）</h3><ul><li>XSS</li><li>HTTP首部注入攻击</li><li>会话固定攻击</li><li>跨站点请求伪造（CSRF）</li></ul><h3 id="11-1-2-主动攻击（直接访问web应用，传入攻击代码）"><a href="#11-1-2-主动攻击（直接访问web应用，传入攻击代码）" class="headerlink" title="11.1.2. 主动攻击（直接访问web应用，传入攻击代码）"></a>11.1.2. 主动攻击（直接访问web应用，传入攻击代码）</h3><ul><li>SQL注入<ul><li>非法查看或篡改数据</li><li>规避认证</li><li>执行相关程序</li></ul></li><li>OS命令注入<ul><li>原理：通过web应用调用shell执行非法的操作系统命令</li></ul></li></ul><h2 id="11-2-因输出值转义不完全导致的漏洞"><a href="#11-2-因输出值转义不完全导致的漏洞" class="headerlink" title="11.2. 因输出值转义不完全导致的漏洞"></a>11.2. 因输出值转义不完全导致的漏洞</h2><h3 id="11-2-1-XSS"><a href="#11-2-1-XSS" class="headerlink" title="11.2.1. XSS"></a>11.2.1. XSS</h3><ul><li>原理：通过web网站的注册用户的浏览器内运行非法HTML标签或JavaScript</li><li>危害<ul><li>利用脚本窃取用户Cookie</li><li>显示伪造的文章/图片</li><li>利用虚假输入表单骗取用户信息</li></ul></li></ul><h3 id="11-2-2-HTTP首部注入攻击"><a href="#11-2-2-HTTP首部注入攻击" class="headerlink" title="11.2.2. HTTP首部注入攻击"></a>11.2.2. HTTP首部注入攻击</h3><ul><li>原理：在响应首部字段内插入换行，添加任意响应首部或主体</li><li>注意：<code>%0D%0A</code> 代表HTTP报文中的换行符</li><li>危害<ul><li>设置任何Cookie信息</li><li>重定向至任何URL</li><li>显示任意的主体（HTTP响应截断攻击）</li></ul></li></ul><h3 id="11-2-3-HTTP响应截断攻击"><a href="#11-2-3-HTTP响应截断攻击" class="headerlink" title="11.2.3. HTTP响应截断攻击"></a>11.2.3. HTTP响应截断攻击</h3><ul><li>注：<code>%0D%0A%0D%0A</code> 两个连续的换行实现HTTP首部与主体分隔所需的空行</li><li>利用插入字符串<code>%0D%0A%0D%0A</code>  可实现伪造主体</li><li><p>危害</p><ul><li>用户浏览器显示伪造的web页面</li></ul></li><li><p>邮件首部注入攻击</p><ul><li>利用web应用中的邮件发送功能</li><li>向邮件首部To或Subject内添加任意非法内容</li></ul></li><li>目录遍历攻击<ul><li>子主题 1</li></ul></li><li>远程文件包含漏洞<ul><li>PHP的include 和 require ，5.2.0版本以后默认无效</li><li>原理：部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，当脚本读取后，就可运行任意脚本</li></ul></li></ul><h2 id="11-3-因设计缺陷导致的漏洞"><a href="#11-3-因设计缺陷导致的漏洞" class="headerlink" title="11.3. 因设计缺陷导致的漏洞"></a>11.3. 因设计缺陷导致的漏洞</h2><h3 id="11-3-1-强制浏览"><a href="#11-3-1-强制浏览" class="headerlink" title="11.3.1. 强制浏览"></a>11.3.1. 强制浏览</h3><ul><li>推测文件名及目录</li><li>浏览由软件自动生成的备份文件</li><li>浏览经认证才可显示的文件</li></ul><h3 id="11-3-2-不正确的错误消息处理"><a href="#11-3-2-不正确的错误消息处理" class="headerlink" title="11.3.2. 不正确的错误消息处理"></a>11.3.2. 不正确的错误消息处理</h3><ul><li>根据错误提示信息，得到其他信息</li></ul><h3 id="11-3-3-开放重定向"><a href="#11-3-3-开放重定向" class="headerlink" title="11.3.3. 开放重定向"></a>11.3.3. 开放重定向</h3><ul><li>URL跳转</li></ul><h2 id="11-4-因会话管理疏忽导致的漏洞"><a href="#11-4-因会话管理疏忽导致的漏洞" class="headerlink" title="11.4. 因会话管理疏忽导致的漏洞"></a>11.4. 因会话管理疏忽导致的漏洞</h2><h3 id="11-4-1-会话劫持"><a href="#11-4-1-会话劫持" class="headerlink" title="11.4.1. 会话劫持"></a>11.4.1. 会话劫持</h3><ul><li>获取用户会话ID</li><li>获取途径<ul><li>推测会话ID</li><li>窃听或XSS攻击盗取</li><li>会话固定攻击强行获取</li></ul></li></ul><h3 id="11-4-2-会话固定攻击"><a href="#11-4-2-会话固定攻击" class="headerlink" title="11.4.2. 会话固定攻击"></a>11.4.2. 会话固定攻击</h3><ul><li>强制用户使用攻击者指定的会话ID</li><li>Session Adoption<ul><li>PHP或ASP.NET能够接受处理未知会话ID的功能</li></ul></li></ul><h3 id="11-4-3-跨站点请求伪造（CSRF）"><a href="#11-4-3-跨站点请求伪造（CSRF）" class="headerlink" title="11.4.3. 跨站点请求伪造（CSRF）"></a>11.4.3. 跨站点请求伪造（CSRF）</h3><ul><li>强制对已完成认证的用户进行非预期的信息更新</li></ul><h2 id="11-5-其他"><a href="#11-5-其他" class="headerlink" title="11.5. 其他"></a>11.5. 其他</h2><h3 id="11-5-1-缓存污染"><a href="#11-5-1-缓存污染" class="headerlink" title="11.5.1. 缓存污染"></a>11.5.1. 缓存污染</h3><h3 id="11-5-2-密码破解"><a href="#11-5-2-密码破解" class="headerlink" title="11.5.2. 密码破解"></a>11.5.2. 密码破解</h3><ul><li>通过网络的密码试错<ul><li>穷举法</li><li>字典攻击</li></ul></li><li>对已加密的密码破解<ul><li>穷举/字典</li><li>彩虹表</li><li>拿到密钥</li><li>加密算法的漏洞</li></ul></li></ul><h3 id="11-5-3-点击劫持"><a href="#11-5-3-点击劫持" class="headerlink" title="11.5.3. 点击劫持"></a>11.5.3. 点击劫持</h3><ul><li>利用透明的按钮或链接，覆盖在web页面上吗，做成陷阱</li></ul><h3 id="11-5-4-DoS攻击"><a href="#11-5-4-DoS攻击" class="headerlink" title="11.5.4. DoS攻击"></a>11.5.4. DoS攻击</h3><ul><li>同时发送大量请求，使服务器停止服务</li></ul><h1 id="12-https"><a href="#12-https" class="headerlink" title="12. https"></a>12. https</h1><p>服务器先给浏览器发送一个公钥。浏览器利用该公钥生成一个加密的密钥并发送给服务器，服务器利用私钥解密得到密钥，之后双方再利用这个密钥进行对称加密传输。整个过程是：先利用非对称加密把密钥传输到服务器上，之后再利用这个密钥进行对称加密的通信</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-10-Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/"/>
      <url>/2024/10/28/2023-12-10-Excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>在项目开发中往往需要使用到数据的导入和导出，导入就是从 Excel 中导入到 DB 中，而导出就是从 DB 中查询数据然后使用 POI 写到 Excel 上。</p><h1 id="1-存在的问题"><a href="#1-存在的问题" class="headerlink" title="1. 存在的问题"></a>1. 存在的问题</h1><p>1、 我遇到的数据量超级大，使用传统的 POI 方式来完成导入导出很明显会内存溢出，并且效率会非常低；</p><p>2、 数据量大直接使用<code>select * from tableName</code>肯定不行，一下子查出来 300w 条数据肯定会很慢；</p><p>3、 300w 数据导出到 Excel 时肯定不能都写在一个 Sheet 中，这样效率会非常低；估计打开都得几分钟；</p><p>4、 300w 数据导出到 Excel 中肯定不能一行一行的导出到 Excel 中。频繁 IO 操作绝对不行；</p><p>5、 导入时 300 万数据存储到 DB 如果循环一条条插入也肯定不行；</p><p>6、导入时 300w 数据如果使用 Mybatis 的批量插入肯定不行，因为 Mybatis 的批量插入其实就是 SQL 的循环；一样很慢。</p><h1 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h1><p>针对 1 ：</p><p>其实问题所在就是内存溢出，我们只要使用对上面介绍的 POI 方式即可，主要问题就是原生的 POI 解决起来相当麻烦。</p><p>经过查阅资料翻看到阿里的一款 POI 封装工具 EasyExcel，上面问题等到解决；</p><p>针对 2：</p><p>不能一次性查询出全部数据，我们可以分批进行查询，只不过时多查询几次的问题，况且市面上分页插件很多。此问题好解决。</p><p>针对 3：</p><p>可以将 300w 条数据写到不同的 Sheet 中，每一个 Sheet 写一百万即可。</p><p>针对 4：</p><p>不能一行一行的写入到 Excel 上，我们可以将分批查询的数据分批写入到 Excel 中。</p><p>针对 5：</p><p>导入到 DB 时我们可以将 Excel 中读取的数据存储到集合中，到了一定数量，直接批量插入到 DB 中。</p><p>针对 6：</p><p>不能使用 Mybatis 的批量插入，我们可以使用 JDBC 的批量插入，配合事务来完成批量插入到 DB。即 Excel 读取分批+JDBC 分批插入+事务。</p><h1 id="3-具体实现"><a href="#3-具体实现" class="headerlink" title="3. 具体实现"></a>3. 具体实现</h1><p><strong>查询大量数据</strong></p><p>在查询数据库层面，需要分批进行查询（我使用的是每次查询 20w）</p><p><strong>插入大量数据</strong></p><p>建立数据库连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, username, password);</span><br><span class="line"><span class="comment">// 设置connection对象为非自动提交</span></span><br><span class="line">connection.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>创建一个PreparedStatement对象，并指定插入语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">insertQuery</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO mytable (column1, column2) VALUES (?, ?)&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(insertQuery);</span><br></pre></td></tr></table></figure><p>循环准备数据并添加到批处理中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; data.size(); i++) &#123;</span><br><span class="line">    statement.setString(<span class="number">1</span>, data.get(i).getColumn1());</span><br><span class="line">    statement.setString(<span class="number">2</span>, data.get(i).getColumn2());</span><br><span class="line">    statement.addBatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行批处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] result = statement.executeBatch();</span><br></pre></td></tr></table></figure><p>提交事务并关闭连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connection.commit();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-21-Java%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%B1%BB/"/>
      <url>/2024/10/28/2023-12-21-Java%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java日期发展"><a href="#1-Java日期发展" class="headerlink" title="1. Java日期发展"></a>1. Java日期发展</h1><h2 id="1-1-第一代Date"><a href="#1-1-第一代Date" class="headerlink" title="1.1. 第一代Date"></a>1.1. 第一代Date</h2><p><strong>Date</strong><br>注意是<code>java.util.Date</code>包下的，不是<code>java.sql</code>包下的<br>精确到秒，代表特定的瞬间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前系统时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过指定毫秒数得到时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">d2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">54646</span>)</span><br></pre></td></tr></table></figure><p><strong>SimpleDateFormat</strong><br>格式化（日期—&gt;文本）和解析日期（文本—&gt;日期）的类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br><span class="line"><span class="comment">// Date日期转字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> sdf.format(Date日期);</span><br><span class="line"><span class="comment">// 字符串转Date日期</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2000年01月01日 10：20：30 星期一&quot;</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> sdf.parse(s)</span><br></pre></td></tr></table></figure><h2 id="1-2-第二代Calendar"><a href="#1-2-第二代Calendar" class="headerlink" title="1.2. 第二代Calendar"></a>1.2. 第二代Calendar</h2><p>Calendar类是一个抽象类，它为操作日历字段，如<code>YEAR、MONTH、DAY_OF _MONTH、HOUR</code>等提供了一些方法</p><p>Calendar类是一个抽象类，不能通过new来实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建日历类对象</span></span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance()</span><br><span class="line"><span class="comment">// 获取日历对象的某个日历字段</span></span><br><span class="line">c.get(Calendar.YEAR)</span><br><span class="line"><span class="comment">// Calendar返回月的时候，是从0开始编号</span></span><br><span class="line">c.get(Calendar.MONTH) +<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>Calender 没有专门的格式化方法，所以需要程序员自己来组合显示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c.get(Calendar.YEAR)+<span class="string">&quot;年&quot;</span>+(c.get(Calendar.MONTH)+<span class="number">1</span>)+<span class="string">&quot;月&quot;</span>+c.get(Calendar.DAY_OF_MONTH)+<span class="string">&quot;日&quot;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="1-3-第三代LocalDateTime（推荐）"><a href="#1-3-第三代LocalDateTime（推荐）" class="headerlink" title="1.3. 第三代LocalDateTime（推荐）"></a>1.3. 第三代LocalDateTime（推荐）</h2><p><strong>前两代</strong></p><ul><li>不能处理闰秒</li><li>线程不安全</li></ul><p><strong>JDK8加入的</strong><br>该类不存储或表示时区</p><ul><li>LocalDate只包含日期，可以获取日期字段</li><li>LocalTime只包含时间，可以获取时间字段</li><li>LocalDateTime包含日期+时间，可以获取日期和时间字段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// now获取当前日期时间对象</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 获取年</span></span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getYear());</span><br><span class="line"><span class="comment">// 获取英文月</span></span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getMonth());</span><br><span class="line"><span class="comment">// 获取数字月</span></span><br><span class="line">System.out.println(<span class="string">&quot;年=&quot;</span> + ldt.getMonthValue());</span><br></pre></td></tr></table></figure><p>还可以对日期时间进行加减</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间  </span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 当前时间减2年</span></span><br><span class="line">System.out.println(localDateTime.minusYears(<span class="number">2</span>));  </span><br><span class="line"><span class="comment">// 当前时间加2年</span></span><br><span class="line">System.out.println(localDateTime.plusYears(<span class="number">2</span>));|</span><br></pre></td></tr></table></figure><p><strong>DateTimeFormatter格式日期类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormat</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(格式)</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> dtf.format(日期对象);</span><br></pre></td></tr></table></figure><p><strong>lnstant时间戳</strong></p><p>类似于Date，提供了和Date类转换的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间戳的对象</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now()</span><br><span class="line"><span class="comment">// 把lnstant时间戳转为Date</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> Date.from(now)</span><br><span class="line"><span class="comment">// 把Date转为lnstant时间戳</span></span><br><span class="line"><span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> date.toInstant</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A(JDK8) --&gt; B(LocalDateTime:LocalDate + LocalTime,无时区属性)</span><br><span class="line">  A --&gt; C(Instant,时间戳,类似Date)</span><br><span class="line">  A --&gt; G(DateTimeFormatter,格式化日期时间,线程安全)</span><br><span class="line">  A --&gt; D(ZonedDateTime:LocalDateTime+ZoneId,表示日期和时间,有时区属性)</span><br><span class="line">  A --&gt; H(ZoneId,时区)</span><br><span class="line">  A --&gt; E(Duration,一段时间)</span><br><span class="line">  A --&gt; F(Period,一段日期)</span><br></pre></td></tr></table></figure><h1 id="2-时区问题"><a href="#2-时区问题" class="headerlink" title="2. 时区问题"></a>2. 时区问题</h1><p>日期时间的初始化、时区、格式化、解析和计算</p><p><strong>初始化日期时间</strong></p><p>处理好时间和时区问题首先就是要正确保存日期时间</p><p>以 UTC（Universal Time Coordinated）保存，保存的时间没有时区属性，是不涉及时区时间差问题的世界统一时间。我们通常说的时间戳就是用的这种方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br></pre></td></tr></table></figure><p><strong>时区问题（重点）</strong></p><p>全球有 24 个时区，同一个时刻不同时区（比如中国上海和美国纽约）的时间是不一样的。对于需要全球化的项目，如果初始化时间时没有提供时区，那就不是一个真正意义上的时间</p><p>要正确处理时区，在于存进去和读出来两方面：存的时候，需要使用正确的当前时区来保存，这样 UTC 时间才会正确；读的时候，也只有正确设置本地时区，才能把 UTC 时间转换为正确的当地时间。</p><p>使用 ZoneId.of 来初始化一个标准的时区，也可以使用 ZoneOffset.ofHours 通过一个 offset，来初始化一个具有指定时间差的自定义时区。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个时区  </span></span><br><span class="line"><span class="comment">// 上海时区</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">timeZoneSH</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);  </span><br><span class="line"><span class="comment">// 纽约时区</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">timeZoneNY</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>获得一个带有时区属性的时间（有效时间）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个时间  </span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="comment">// 指定一个时区</span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">timeZoneNY</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);</span><br><span class="line"><span class="comment">// 获得带有时区的有效时间</span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.of(localDateTime, timeZoneNY);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>使用 DateTimeFormatter 格式化时间</strong></p><p><code>yyyy-MM-dd HH:mm:ss z</code> z 是带时区的，<code>yyyy-MM-dd HH:mm:ss</code> 是不带时区的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化日期时间  </span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss z&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> zonedDateTime.format(dateTimeFormatter);</span><br></pre></td></tr></table></figure></p><p>完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间  </span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();  </span><br><span class="line"><span class="comment">// 初始化一个时区  </span></span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">timeZoneSH</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;Asia/Shanghai&quot;</span>);  </span><br><span class="line"><span class="type">ZoneId</span> <span class="variable">timeZoneNY</span> <span class="operator">=</span> ZoneId.of(<span class="string">&quot;America/New_York&quot;</span>);  </span><br><span class="line"><span class="comment">// 解析格式化后的日期时间，并添加时区信息  </span></span><br><span class="line"><span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> ZonedDateTime.of(localDateTime, timeZoneNY);  </span><br><span class="line"><span class="comment">// 格式化日期时间  </span></span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss z&quot;</span>);  </span><br><span class="line"><span class="type">String</span> <span class="variable">formattedDateTime</span> <span class="operator">=</span> zonedDateTime.format(dateTimeFormatter);  </span><br><span class="line"><span class="comment">// 输出结果  </span></span><br><span class="line">System.out.println(formattedDateTime);</span><br></pre></td></tr></table></figure><h1 id="3-日期时间的计算"><a href="#3-日期时间的计算" class="headerlink" title="3. 日期时间的计算"></a>3. 日期时间的计算</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(localDateTime.plusDays(<span class="number">30</span>));</span><br></pre></td></tr></table></figure><p>计算两个日期差时可能会踩坑：Java 8 中有一个专门的类 Period 定义了日期间隔，通过 Period.between 得到了两个 LocalDate 的差，返回的是两个日期差几年零几月零几天。如果希望得知两个日期之间差几天，直接调用 Period 的 getDays() 方法得到的只是最后的“零几天”，而不是算总的间隔天数。</p><p>比如，计算 2019 年 12 月 12 日和 2019 年 10 月 1 日的日期间隔，很明显日期差是 2 个月零 11 天，但获取 getDays 方法得到的结果只是 11 天，而不是 72 天，可以使用 ChronoUnit.DAYS.between 解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;//计算日期差&quot;</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line"><span class="type">LocalDate</span> <span class="variable">specifyDate</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(Period.between(specifyDate, today).getDays());</span><br><span class="line">System.out.println(Period.between(specifyDate, today));</span><br><span class="line">System.out.println(ChronoUnit.DAYS.between(specifyDate, today));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-27-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/10/28/2023-12-27-%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-权限管理"><a href="#1-权限管理" class="headerlink" title="1. 权限管理"></a>1. 权限管理</h1><h2 id="1-1-RBAC模型"><a href="#1-1-RBAC模型" class="headerlink" title="1.1. RBAC模型"></a>1.1. RBAC模型</h2><p>它有两种解释</p><p><strong>Role-Based Access Control</strong></p><p>基于角色的访问控制，即按角色进行授权。当需要修改角色的权限时就需要修改授权的相关代码，系统可扩展性差</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasRole(<span class="string">&quot;总经理角色&quot;</span>) || 主体.hasRole(<span class="string">&quot;股东角色&quot;</span>))&#123;</span><br><span class="line">     查询运营报表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Resource-Based Access Control</strong></p><p>基于资源的访问控制，即按资源（或权限）进行授权。这样在系统设计时就已经定义好权限标识，即使所需要的角色变化也不需要修改授权代码，系统可扩展性强。该授权方式更加常用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(主体.hasPermission(<span class="string">&quot;查询报表权限&quot;</span>))&#123;</span><br><span class="line">   查询运营报表</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="F:\笔记\博客\文章图片\系统权限设计.drawio.png" alt="系统权限设计.drawio"></p><h2 id="1-2-权限表设计"><a href="#1-2-权限表设计" class="headerlink" title="1.2. 权限表设计"></a>1.2. 权限表设计</h2><p>目前流行的是<code>用户-角色-部门-权限</code>的权限管理模型，下面仅介绍了不含部门的情况</p><p>用户表、角色表、权限表，用户和角色表，角色和权限表</p><p><strong>用户表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users`  (`uid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`uid`) <span class="keyword">USING</span> BTREE ) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">  <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;baizhan&#x27;</span>,<span class="string">&#x27;$2a$10$Eqv9PRMl6bPt5BiwgPr2eucgyl.E.xLENt4b</span></span><br><span class="line"><span class="string">vfDvv7DyS5AVPT.U6&#x27;</span>, <span class="string">&#x27;13812345678&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>角色表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role`  (</span><br><span class="line">  `rid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `roleName` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `roleDesc` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`rid`) <span class="keyword">USING</span> BTREE ) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">4</span></span><br><span class="line"><span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;总经理&#x27;</span>,<span class="string">&#x27;管理整个公司&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role` <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;股东&#x27;</span>,<span class="string">&#x27;参与公司决策&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role` <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;财务&#x27;</span>,<span class="string">&#x27;管理公司资产&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>权限表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permission`  (</span><br><span class="line">  `pid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `permission_name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `url` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`pid`) <span class="keyword">USING</span> BTREE ) ENGINE <span class="operator">=</span> InnoDB </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permission` <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">&#x27;查询报表&#x27;</span>, <span class="string">&#x27;/reportform/find&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permission` <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">&#x27;查询工资&#x27;</span>, <span class="string">&#x27;/salary/find&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `permission` <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="string">&#x27;查询税务&#x27;</span>, <span class="string">&#x27;/tax/find&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>用户和角色表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users_role`  (</span><br><span class="line">  `uid` <span class="type">int</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `rid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`uid`, `rid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  INDEX `rid`(`rid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `users_role_ibfk_1` <span class="keyword">FOREIGN</span> KEY(`uid`) <span class="keyword">REFERENCES</span> `users` (`uid`) <span class="keyword">ON</span> <span class="keyword">DELETE</span></span><br><span class="line">RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `users_role_ibfk_2` <span class="keyword">FOREIGN</span> KEY(`rid`) <span class="keyword">REFERENCES</span> `role` (`rid`) <span class="keyword">ON</span> <span class="keyword">DELETE</span></span><br><span class="line">RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> RESTRICT ) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8</span><br><span class="line"><span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users_role` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `users_role` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><strong>角色和权限表</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `role_permission`  (</span><br><span class="line">  `rid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `pid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">   <span class="keyword">PRIMARY</span> KEY (`rid`, `pid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">   INDEX `pid`(`pid`) <span class="keyword">USING</span> BTREE,</span><br><span class="line">   <span class="keyword">CONSTRAINT</span> `role_permission_ibfk_1` <span class="keyword">FOREIGN</span> KEY (`rid`) <span class="keyword">REFERENCES</span> `role`</span><br><span class="line">(`rid`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line">RESTRICT,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> `role_permission_ibfk_2`</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (`pid`) <span class="keyword">REFERENCES</span> `permission`</span><br><span class="line">(`pid`) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span></span><br><span class="line">RESTRICT</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8</span><br><span class="line"><span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span></span><br><span class="line"><span class="keyword">Dynamic</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `role_permission` <span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="1-3-代码设计"><a href="#1-3-代码设计" class="headerlink" title="1.3. 代码设计"></a>1.3. 代码设计</h2><ul><li>实现验证用户登录信息的拦截器</li><li>实现验证用户权限的拦截器（先从用户角色开始过滤，不符合要求的角色直接在controller层ban掉，之后再根据对资源的操作权限进行过滤，分增、删、改、查权限，不符合要求的角色不能执行相关操作）<br><code>[&quot;user-add&quot;, &quot;user-delete&quot;, &quot;user-get&quot;, &quot;user-update&quot;]</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-12-11-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2024/10/28/2023-12-11-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E7%99%BB%E5%BD%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>基于Vue和Spring Boot实现前后端分离的登录功能，流程分为以下几步</p><ul><li>用户输入用户名和密码并登录（即提交表单）</li><li>后端查询数据库，验证用户名于密码是否匹配，若匹配，返回token给前端</li><li>前端接收token，保存到store中</li><li>前端登录成功，进行页面跳转，进入到主页面</li><li>前端未登录，只允许访问主页面和登录页面，若访问其他页面则强制重定向到登录页（根据store中的token判断）</li><li>登录之后每次请求时请求头中携带token，后端会对token进行检验</li><li>若token无效或者过期，后端返回错误码，如401，前端将页面重定向到登录页重新登录</li><li>用户点击退出登录，后端清空token</li><li>用户不退出登录，前端store保存token</li><li>登录后，前端路由的访问需要进行权限控制</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 业务场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-12-Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CVim/"/>
      <url>/2024/10/28/2023-10-12-Linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8CVim/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文本处理"><a href="#1-文本处理" class="headerlink" title="1. 文本处理"></a>1. 文本处理</h1><h1 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h1><h1 id="3-VIM"><a href="#3-VIM" class="headerlink" title="3. VIM"></a>3. VIM</h1><p>vi: Visual lnterface，文本编辑器文本:ASCll, Unicode<br>文本编辑种类:<br>行编辑器: sed<br>全屏编辑器:nano, vivim - Vilmproved其他编辑器:<br>gedit一个简单的图形编辑器gvim一个Vim编辑器的图形版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-19-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
      <url>/2024/10/28/2023-10-19-%E6%8B%A6%E6%88%AA%E5%99%A8%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-过滤器（Filter）"><a href="#1-过滤器（Filter）" class="headerlink" title="1. 过滤器（Filter）"></a>1. 过滤器（Filter）</h1><p>Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。</p><p><strong>Filter有如下几个用处</strong></p><p>主要的用途是设置字符集、控制权限、控制转向、做一些业务逻辑判断等</p><p>Filter可以认为是Servlet的一种“加强版”，它主要用于在HttpServletRequest到达Servlet之前，拦截客户的请求，对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理</p><p><strong>Filter有如下几个种类</strong></p><ul><li>用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。</li><li>日志Filter：详细记录某些特殊的用户请求。</li><li>负责解码的Filter：包括对非标准编码的请求解码。</li><li>能改变XML内容的XSLT Filter等。</li><li>Filter可以负责拦截多个请求或响应；一个请求或响应也可以被多个Filter拦截。</li></ul><p><strong>创建一个Filter只需两个步骤</strong></p><ul><li>创建Filter处理类（必须实现javax.servlet.Filter接口）</li><li>web.xml文件中配置Filter</li></ul><h1 id="2-拦截器（Interceptor）"><a href="#2-拦截器（Interceptor）" class="headerlink" title="2. 拦截器（Interceptor）"></a>2. 拦截器（Interceptor）</h1><p>拦截器是在 Spring容器内的，是Spring框架支持的。</p><p>用于在某个方法被访问之前，进行拦截，然后在之前或之后加入某些操作。拦截是AOP的一种实现策略。</p><p>在Spring构架的程序中，要优先使用拦截器。几乎所有 Filter 能够做的事情， Interceptor 都能够轻松的实现</p><h1 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h1><div class="table-container"><table><thead><tr><th>Filter</th><th>Interceptor</th><th>Summary</th></tr></thead><tbody><tr><td>Filter在只在 Servlet 前后起作用。Filters 通常将 请求和响应（request/response） 当做黑盒子，Filter 通常不考虑servlet 的实现。</td><td>拦截器能够深入到方法前后、异常抛出前后等，因此拦截器的使用具有更大的弹性。允许用户介入（hook into）请求的生命周期，在请求过程中获取信息，Interceptor 通常和请求更加耦合。</td><td>在Spring构架的程序中，要优先使用拦截器。几乎所有 Filter 能够做的事情， interceptor 都能够轻松的实现<a href="http://einverne.github.io/post/2017/08/spring-interceptor-vs-filter.html#fn:top"> </a></td></tr><tr><td>Filter 是 Servlet 规范规定的。</td><td>而拦截器既可以用于Web程序，也可以用于Application、Swing程序中。</td><td>使用范围不同</td></tr><tr><td>Filter 是在 Servlet 规范中定义的，是 Servlet 容器支持的。</td><td>而拦截器是在 Spring容器内的，是Spring框架支持的。</td><td>规范不同</td></tr><tr><td>Filter 不能够使用 Spring 容器资源</td><td>拦截器是一个Spring的组件，归Spring管理，配置在Spring文件中，因此能使用Spring里的任何资源、对象，例如 Service对象、数据源、事务管理等，通过IoC注入到拦截器即可</td><td>Spring 中使用 interceptor 更容易</td></tr><tr><td>Filter 是被 Server(like Tomcat) 调用</td><td>Interceptor 是被 Spring 调用</td><td>因此 Filter 总是优先于 Interceptor 执行</td></tr></tbody></table></div>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-13-JJWT%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/10/28/2023-10-13-JJWT%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1. 引入依赖"></a>1. 引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt-jackson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> <span class="comment">&lt;!-- or jjwt-gson if Gson is preferred --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.12.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-生成JWT"><a href="#2-生成JWT" class="headerlink" title="2. 生成JWT"></a>2. 生成JWT</h1><p>指定签名算法并生成密钥（signing key）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> Jwts.SIG.HS256.key().build();</span><br></pre></td></tr></table></figure><br>生成JWT，设置完各项参数后，使用<code>.compact()</code>生成JWT<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateToken</span><span class="params">(String username)</span> &#123;  </span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();  </span><br><span class="line">    <span class="type">Date</span> <span class="variable">expiration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(now.getTime() + <span class="number">360000</span>);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()  </span><br><span class="line">            .header()  </span><br><span class="line">                .and()  </span><br><span class="line">            .expiration(expiration)  </span><br><span class="line">            .signWith(key)  </span><br><span class="line">            .subject(username)  </span><br><span class="line">            .compact();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> jwt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="3-配置JWT-header"><a href="#3-配置JWT-header" class="headerlink" title="3. 配置JWT header"></a>3. 配置JWT header</h1><h2 id="3-1-JwtBuilder-header"><a href="#3-1-JwtBuilder-header" class="headerlink" title="3.1. JwtBuilder.header()"></a>3.1. <code>JwtBuilder.header()</code></h2><p><code>JwtBuilder</code> 的<code>header()</code>方法，配置完header后，调用<code>.and()</code> 表明header配置完成，返回到<code>JwtBuilder</code>，再去配置payload等</p><p><code>and</code>相当于结束符，表示结束当前标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">        </span><br><span class="line">    .header()                        <span class="comment">// &lt;----</span></span><br><span class="line">        .keyId(<span class="string">&quot;aKeyId&quot;</span>)</span><br><span class="line">        .x509Url(aUri)</span><br><span class="line">        .add(<span class="string">&quot;someName&quot;</span>, anyValue)</span><br><span class="line">        .add(mapValues)</span><br><span class="line">        <span class="comment">// ... etc ...</span></span><br><span class="line">        .and()                      <span class="comment">// go back to the JwtBuilder</span></span><br><span class="line">        </span><br><span class="line">    .subject(<span class="string">&quot;Joe&quot;</span>)                 <span class="comment">// resume JwtBuilder calls...</span></span><br><span class="line">    <span class="comment">// ... etc ...    </span></span><br><span class="line">    .compact();</span><br></pre></td></tr></table></figure><p>你不需要设置alg、enc或zip标头——JJWT总是会根据需要自动设置它们</p><p><code>JwtBuilder.header()</code>下的<code>.add()</code>方法支持键值对</p><h2 id="3-2-Jwts-header"><a href="#3-2-Jwts-header" class="headerlink" title="3.2. Jwts.header()"></a>3.2. <code>Jwts.header()</code></h2><p>如果你想在使用JwtBuilder的上下文中创建一个独立的header，可以直接使用<code>Jwts.header()</code>，最后使用<code>.build()</code>生成一个Header实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Header</span> <span class="variable">commonHeader</span> <span class="operator">=</span> Jwts.header() </span><br><span class="line"></span><br><span class="line">        .keyId(<span class="string">&quot;aKeyId&quot;</span>)</span><br><span class="line">        .x509Url(aUri)</span><br><span class="line">        .add(<span class="string">&quot;someName&quot;</span>, anyValue)</span><br><span class="line">        .add(mapValues)</span><br><span class="line">        <span class="comment">// ... etc ...</span></span><br><span class="line">        </span><br><span class="line">        .build()  <span class="comment">// &lt;---- not &#x27;and()&#x27;</span></span><br></pre></td></tr></table></figure><p>这种方式适用于需要提取公共header参数的JWT，该公共header可被任意<code>JwtBuilder</code>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"></span><br><span class="line">    .header()</span><br><span class="line">        .add(commonHeader)                   <span class="comment">// 将上面创建的公共header引入</span></span><br><span class="line">        .add(<span class="string">&quot;specificHeader&quot;</span>, specificValue) <span class="comment">// jwt-specific headers...</span></span><br><span class="line"></span><br><span class="line">    .subject(<span class="string">&quot;whatever&quot;</span>)</span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br><span class="line">    .compact();</span><br></pre></td></tr></table></figure><h1 id="4-配置JWT-Payload"><a href="#4-配置JWT-Payload" class="headerlink" title="4. 配置JWT Payload"></a>4. 配置JWT Payload</h1><p>JWT Payload 可以是任何东西——任何可以表示为字节数组的东西，比如文本、图像、文档等等。</p><p><code>JwtBuilder</code> 支持两种不同的JWT Payload选项</p><ul><li><code>content</code> JWT Payload 是任意字节数组</li><li><code>claims</code> JWT Payload 是一个JSON声明对象</li></ul><p>注意：content和claims不能同时使用</p><h2 id="4-1-任意字节数组"><a href="#4-1-任意字节数组" class="headerlink" title="4.1. 任意字节数组"></a>4.1. 任意字节数组</h2><p><code>Jwts.builder()</code>的<code>.content(content, &quot;text/plain&quot;)</code>方法，<code>.content()</code>方法有两个参数，第一个参数是实际的字节数组，第二个参数是媒体类型的字符串标识符</p><p>常见的有</p><ul><li><code>text/html</code> HTML格式</li><li><code>text/plain</code> 纯文本格式</li><li><code>text/ xml</code> XML格式</li><li><code>image/ jpeg</code>  jpg图片格式</li><li><code>image/png</code>  png图片格式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] content = <span class="string">&quot;Hello World&quot;</span>.getBytes(StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">jwt</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"></span><br><span class="line">    .content(content, <span class="string">&quot;text/plain&quot;</span>) <span class="comment">// &lt;---</span></span><br><span class="line">    </span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><h2 id="4-2-JSON声明对象"><a href="#4-2-JSON声明对象" class="headerlink" title="4.2. JSON声明对象"></a>4.2. JSON声明对象</h2><p><strong>标准的（官方提供的7个字段）</strong></p><ul><li><code>issuer</code>: sets the <code>iss</code> (Issuer) Claim</li><li><code>subject</code>: sets the <code>sub</code> (Subject) Claim</li><li><code>audience</code>: sets the <code>aud</code> (Audience) Claim</li><li><code>expiration</code>: sets the <code>exp</code> (Expiration Time) Claim</li><li><code>notBefore</code>: sets the <code>nbf</code> (Not Before) Claim</li><li><code>issuedAt</code>: sets the <code>iat</code> (Issued At) Claim</li><li><code>id</code>: sets the <code>jti</code> (JWT ID) Claim</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"></span><br><span class="line">    .issuer(<span class="string">&quot;me&quot;</span>)</span><br><span class="line">    .subject(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">    .audience(<span class="string">&quot;you&quot;</span>)</span><br><span class="line">    .expiration(expiration) <span class="comment">//a java.util.Date</span></span><br><span class="line">    .notBefore(notBefore) <span class="comment">//a java.util.Date </span></span><br><span class="line">    .issuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>()) <span class="comment">// for example, now</span></span><br><span class="line">    .id(UUID.randomUUID().toString()) <span class="comment">//just an example id</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><p><strong>自定义的</strong></p><p>自定义单个增加字段，调用<code>JwtBuilder</code>的<code>claim</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"></span><br><span class="line">    .claim(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">    .claim(<span class="string">&quot;teacher&quot;</span>, <span class="string">&quot;good&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义批量增加字段，调用<code>JwtBuilder</code> 的<code>claims(Map)</code>方法，<code>claims()</code>方法中的参数是一个map类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line"></span><br><span class="line">    .claims(Map)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ... etc ...</span></span><br></pre></td></tr></table></figure><h1 id="5-为JWT签名"><a href="#5-为JWT签名" class="headerlink" title="5. 为JWT签名"></a>5. 为JWT签名</h1><p>JWT规范确定了13个标准签名算法——3个秘密密钥算法和10个非对称密钥算法</p><p>生成密钥<code>SecretKey</code>，使用<code>Jwts.SIG</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SecretKey</span> <span class="variable">key</span> <span class="operator">=</span> Jwts.SIG.HS256.key().build(); <span class="comment">//or HS384.key() or HS512.key()</span></span><br></pre></td></tr></table></figure><br>使用<code>signWith()</code>签名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jws</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">.subject(<span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">.signWith(key)</span><br><span class="line">.compact();</span><br></pre></td></tr></table></figure></p><h1 id="6-解析JWT"><a href="#6-解析JWT" class="headerlink" title="6. 解析JWT"></a>6. 解析JWT</h1><p>使用<code>Jwts.parser()</code>方法创建一个 <code>JwtParserBuilder</code> ，可以调用<code>.keyLocator()</code>，<code>.verifyWith()</code> ， <code>.decryptWith()</code> 方法去解析JWT中的信息</p><p>需要注意<code>parser()</code>下调用的方法应该放在 <code>try/catch</code>代码块中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getClaimsByToken</span><span class="params">(String token)</span> &#123;  </span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claim</span> <span class="operator">=</span> Jwts.parser()  </span><br><span class="line">                .verifyWith(key)  </span><br><span class="line">                    <span class="comment">// or .keyLocator(keyLocator) dynamically locate signing or encryption keys</span></span><br><span class="line">    <span class="comment">// or .decryptWith(key)   a constant key used to decrypt all encrypted JWTs</span></span><br><span class="line">                .build()  <span class="comment">// 结束 parser</span></span><br><span class="line">                .parseSignedClaims(token)  <span class="comment">// or parseSignedClaims, parseEncryptedClaims, parseSignedContent, parse</span></span><br><span class="line">                .getPayload();  </span><br><span class="line">        <span class="keyword">return</span> claim.toString();  </span><br><span class="line">  </span><br><span class="line">    &#125;<span class="keyword">catch</span> (JwtException e)&#123;  </span><br><span class="line">        System.out.println(e.getStackTrace());  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JJWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-14-Spring%E4%B9%8BValidation%E6%A0%A1%E9%AA%8C%E5%8F%82%E6%95%B0/"/>
      <url>/2024/10/28/2023-10-14-Spring%E4%B9%8BValidation%E6%A0%A1%E9%AA%8C%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念区分"><a href="#1-概念区分" class="headerlink" title="1. 概念区分"></a>1. 概念区分</h1><p><code>@Valid</code>是Java标准的Bean验证注解，而<code>@Validated</code>是Spring框架提供的增强验证注解，具有更多特性，如分组验证。</p><h1 id="2-环境说明"><a href="#2-环境说明" class="headerlink" title="2. 环境说明"></a>2. 环境说明</h1><p>从springboot-2.3开始，校验包被独立成了一个starter组件，所以需要引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-Validator-内置参数校验"><a href="#3-Validator-内置参数校验" class="headerlink" title="3. Validator 内置参数校验"></a>3. Validator 内置参数校验</h1><div class="table-container"><table><thead><tr><th style="text-align:left">注解</th><th style="text-align:left">校验功能</th></tr></thead><tbody><tr><td style="text-align:left">@AssertFalse</td><td style="text-align:left">必须是false</td></tr><tr><td style="text-align:left">@AssertTrue</td><td style="text-align:left">必须是true</td></tr><tr><td style="text-align:left">@DecimalMax</td><td style="text-align:left">小于等于给定的值</td></tr><tr><td style="text-align:left">@DecimalMin</td><td style="text-align:left">大于等于给定的值</td></tr><tr><td style="text-align:left">@Digits</td><td style="text-align:left">可设定最大整数位数和最大小数位数</td></tr><tr><td style="text-align:left">@Email</td><td style="text-align:left">校验是否符合Email格式</td></tr><tr><td style="text-align:left">@Future</td><td style="text-align:left">必须是将来的时间</td></tr><tr><td style="text-align:left">@FutureOrPresent</td><td style="text-align:left">当前或将来时间</td></tr><tr><td style="text-align:left">@Max</td><td style="text-align:left">最大值</td></tr><tr><td style="text-align:left">@Min</td><td style="text-align:left">最小值</td></tr><tr><td style="text-align:left">@Negative</td><td style="text-align:left">负数（不包括0）</td></tr><tr><td style="text-align:left">@NegativeOrZero</td><td style="text-align:left">负数或0</td></tr><tr><td style="text-align:left">@NotBlank</td><td style="text-align:left">不为null并且包含至少一个非空白字符</td></tr><tr><td style="text-align:left">@NotEmpty</td><td style="text-align:left">不为null并且不为空（不能校验数字类型）</td></tr><tr><td style="text-align:left">@NotNull</td><td style="text-align:left">不为null</td></tr><tr><td style="text-align:left">@Null</td><td style="text-align:left">为null</td></tr><tr><td style="text-align:left">@Past</td><td style="text-align:left">必须是过去的时间</td></tr><tr><td style="text-align:left">@PastOrPresent</td><td style="text-align:left">必须是过去的时间，包含现在</td></tr><tr><td style="text-align:left">@PositiveOrZero</td><td style="text-align:left">正数或0</td></tr><tr><td style="text-align:left">@Size</td><td style="text-align:left">校验容器的元素个数</td></tr></tbody></table></div><p>对于String类型，建议使用<code>@NotBlank</code></p><p>对于Integer类型，建议使用<code>@NotNull</code>，因为它的值要么为 <code>null</code>，要么为非 <code>null</code>，无需再进一步限制</p><p>对于Map、List类型 可以使用<code>@NotEmpty</code>，确保不为空</p><h1 id="4-常见的校验方式"><a href="#4-常见的校验方式" class="headerlink" title="4. 常见的校验方式"></a>4. 常见的校验方式</h1><p><strong>业务层校验</strong></p><p>手动在Java的Service层进行数据校验判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(UserVO userVO)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(userVO.getAge() == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;年龄不能为空&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(userVO.getAge() &gt; <span class="number">120</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;年龄不能超过120&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一堆参数校验...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Validator + BindingResult</strong><br>….<br>….<br><strong>Validator + 自动抛出异常（推荐）</strong></p><p>使用全局异常处理代替BindingResult捕获异常</p><h1 id="5-在Controller层用validator做参数校验"><a href="#5-在Controller层用validator做参数校验" class="headerlink" title="5. 在Controller层用validator做参数校验"></a>5. 在Controller层用validator做参数校验</h1><p><strong>Bean字段校验</strong></p><p>Bean字段校验是对Java Bean对象中的字段进行验证。如，验证一个用户对象的姓名是否非空、年龄是否在有效范围内，或者电子邮件地址是否符合规定的格式。</p><p>首先在待校验字段上增加校验规则注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line">    <span class="meta">@NotNull(message = &quot;age 不能为空&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在<code>controller</code>方法中添加<code>@Validated</code>和用于接收错误信息的<code>BindingResult</code>就可以了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@Validated</span> UserVO userVO, BindingResult result)</span> &#123;</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">    <span class="keyword">if</span>(!fieldErrors.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> fieldErrors.get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>单个参数校验</strong></p><p>先在<code>controller</code>类上添加注解<code>@Validated</code></p><p>然后在方法中的待校验参数前增加校验规则注解和用于接收错误信息的<code>BindingResult</code>就可以了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span>&#123;</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">add</span><span class="params">(<span class="meta">@NotNull(message = &quot;不能为空&quot;)</span> String uname, BindingResult result)</span> &#123;</span><br><span class="line">    List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">    <span class="keyword">if</span>(!fieldErrors.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span> fieldErrors.get(<span class="number">0</span>).getDefaultMessage();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-在Controller层之外用validator做参数校验"><a href="#6-在Controller层之外用validator做参数校验" class="headerlink" title="6. 在Controller层之外用validator做参数校验"></a>6. 在Controller层之外用validator做参数校验</h1><p>在controller层参数的注解用<code>@Valid</code>和<code>@Validated</code>都可生效，个人觉得最好还是统一用<code>@Validated</code></p><p>在service层或其他spring管理的bean里使用。在controller之外用的话想让切面生效目前只有一种选择，直接在类上加<code>@Validated</code>注解（虽然这个注解可以加在方法上但是只在方法上加不会走切面逻辑，在方法上加主要是定义组校验逻辑）。加在类上会导致所有public方法在外部被调用时都走一次校验前置处理逻辑，一定程度上来说会造成一些不必要的性能影响，所以如果不是所有方法都需要校验并且对细微的性能影响有要求的话最好还是慎重考虑</p><h1 id="7-全局异常处理"><a href="#7-全局异常处理" class="headerlink" title="7. 全局异常处理"></a>7. 全局异常处理</h1><p>如果每个<code>Controller</code>方法中都写一遍对<code>BindingResult</code>信息的处理，使用起来还是很繁琐。可以通过全局异常处理的方式统一处理校验异常。</p><p>当我们写了<code>@validated</code>注解，不写<code>BindingResult</code>的时候，Spring 就会抛出异常。由此，可以写一个全局异常处理类来统一处理这种校验异常，从而免去重复组织异常信息的代码。</p><p>总结了三种参数校验时可能引发的异常：</p><ul><li>使用form data方式调用接口，校验异常抛出 BindException</li><li>使用 json 请求体调用接口，校验异常抛出 MethodArgumentNotValidException</li><li>单个参数校验异常抛出 ConstraintViolationException</li></ul><p>全局异常处理类可以添加各种需要处理的异常，比如添加一个对<code>Exception.class</code>的异常处理，当所有<code>ExceptionHandler</code>都无法处理时，由其记录异常信息，并返回友好提示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalControllerAdvice</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">BAD_REQUEST_MSG</span> <span class="operator">=</span> <span class="string">&quot;客户端请求参数错误&quot;</span>;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 处理 form data方式调用接口校验失败抛出的异常 </span></span><br><span class="line">    <span class="meta">@ExceptionHandler(BindException.class)</span></span><br><span class="line">    <span class="comment">// ResultInfo是封装的一个结果类</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">bindExceptionHandler</span><span class="params">(BindException e)</span> &#123;</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">        List&lt;String&gt; collect = fieldErrors.stream()</span><br><span class="line">                .map(o -&gt; o.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>().success(HttpStatus.BAD_REQUEST.value(), BAD_REQUEST_MSG, collect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;2&gt; 处理 json 请求体调用接口校验失败抛出的异常 </span></span><br><span class="line">    <span class="meta">@ExceptionHandler(MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">methodArgumentNotValidExceptionHandler</span><span class="params">(MethodArgumentNotValidException e)</span> &#123;</span><br><span class="line">        List&lt;FieldError&gt; fieldErrors = e.getBindingResult().getFieldErrors();</span><br><span class="line">        List&lt;String&gt; collect = fieldErrors.stream()</span><br><span class="line">                .map(o -&gt; o.getDefaultMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>().success(HttpStatus.BAD_REQUEST.value(), BAD_REQUEST_MSG, collect);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;3&gt; 处理单个参数校验失败抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(ConstraintViolationException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResultInfo <span class="title function_">constraintViolationExceptionHandler</span><span class="params">(ConstraintViolationException e)</span> &#123;</span><br><span class="line">        Set&lt;ConstraintViolation&lt;?&gt;&gt; constraintViolations = e.getConstraintViolations();</span><br><span class="line">        List&lt;String&gt; collect = constraintViolations.stream()</span><br><span class="line">                .map(o -&gt; o.getMessage())</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>().success(HttpStatus.BAD_REQUEST.value(), BAD_REQUEST_MSG, collect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-其他校验类型"><a href="#8-其他校验类型" class="headerlink" title="8. 其他校验类型"></a>8. 其他校验类型</h1><h2 id="8-1-分组校验"><a href="#8-1-分组校验" class="headerlink" title="8.1. 分组校验"></a>8.1. 分组校验</h2><p>同一个参数在新增的时候为必填，在更新的时候又非必填。面对这种场景就需要用到分组校验了</p><p><strong>先定义一个分组接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ValidGroup</span> <span class="keyword">extends</span> <span class="title class_">Default</span> &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">Crud</span> <span class="keyword">extends</span> <span class="title class_">ValidGroup</span>&#123;</span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Create</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Update</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Query</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">interface</span> <span class="title class_">Delete</span> <span class="keyword">extends</span> <span class="title class_">Crud</span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个分组接口ValidGroup让其继承<code>javax.validation.groups.Default</code>，再在分组接口中定义出多个不同的操作类型，Create，Update，Query，Delete</p><p><strong>在校验注解上添加<code>groups</code>属性指定分组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;name 不能为空&quot;,groups = ValidGroup.Crud.Update.class)</span></span><br><span class="line">    <span class="meta">@NotNull(message = &quot;name 不能为空&quot;,groups = ValidGroup.Crud.Create.class)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给参数指定分组，对于未指定分组的则使用的是默认分组</p><p><strong><code>Controller</code>方法的<code>@Validated</code>注解添加分组类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;update&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ResultInfo <span class="title function_">update</span><span class="params">(<span class="meta">@Validated(value = ValidGroup.Crud.Update.class)</span> UserVO userVO)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ResultInfo</span>().success(userVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：<code>@validated</code>和Validator 内置的参数校验注解默认都属于<code>Default.class</code>分组</p><h2 id="8-2-递归校验"><a href="#8-2-递归校验" class="headerlink" title="8.2. 递归校验"></a>8.2. 递归校验</h2><p>如果 UserVO 类中增加一个 OrderVO 类的属性，而 OrderVO 中的属性也需要校验，就用到递归校验了，只要在相应属性上增加<code>@Valid</code>注解即可实现（对于集合同样适用）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserVO</span> &#123;</span><br><span class="line">    <span class="meta">@NotBlank(message = &quot;name 不能为空&quot;,groups = Update.class)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//需要递归校验的OrderVO</span></span><br><span class="line">    <span class="meta">@Valid</span></span><br><span class="line">    <span class="keyword">private</span> OrderVO orderVO;</span><br><span class="line">    <span class="comment">// 省略其他代码...</span></span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="8-3-自定义校验"><a href="#8-3-自定义校验" class="headerlink" title="8.3. 自定义校验"></a>8.3. 自定义校验</h2><p>先自定义校验注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint(validatedBy = &#123;HaveNoBlankValidator.class&#125;)</span><span class="comment">// 标明由哪个类执行校验逻辑</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> HaveNoBlank &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 校验出错时默认返回的消息</span></span><br><span class="line">    String <span class="title function_">message</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;字符串中不能含有空格&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Payload</span>&gt;[] payload() <span class="keyword">default</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同一个元素上指定多个该注解时使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Target(&#123; METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE &#125;)</span></span><br><span class="line">    <span class="meta">@Retention(RUNTIME)</span></span><br><span class="line">    <span class="meta">@Documented</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@interface</span> List &#123;</span><br><span class="line">        NotBlank[] value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再编写校验者类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HaveNoBlankValidator</span> <span class="keyword">implements</span> <span class="title class_">ConstraintValidator</span>&lt;HaveNoBlank, String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> &#123;</span><br><span class="line">        <span class="comment">// null 不做检验</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value.contains(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 校验失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 校验成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>自定义校验注解使用起来和内置注解无异，在需要的字段上添加相应注解即可</p><h1 id="9-继承问题"><a href="#9-继承问题" class="headerlink" title="9. 继承问题"></a>9. 继承问题</h1><p>父类中的参数校验，能否被子类继承？</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-18-Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/"/>
      <url>/2024/10/28/2023-11-18-Swagger%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p><strong>OpenAPI</strong></p><p>是一个组织（OpenAPI Initiative），他们指定了一个如何描述HTTP API的规范（OpenAPI Specification）。既然是规范，那么谁想实现都可以，只要符合规范即可。</p><p><strong>Swagger</strong></p><p>它是SmartBear公司的一个开源项目，里面提供了一系列工具，包括著名的 <code>swagger-ui</code>。<code>swagger</code>是早于OpenApi的，某一天<code>swagger</code>将自己的API设计贡献给了OpenApi，然后由其标准化了。</p><p><strong>Springfox</strong></p><p>是Spring生态的一个开源库，是Swagger与OpenApi规范的具体实现。我们使用它就可以在spring中生成API文档。以前基本上是行业标准，目前最新版本可以支持 Swagger2, Swagger3 以及 OpenAPI3 三种格式。但是其从 2020年7月14号就不再更新了，不支持springboot3，所以业界都在不断的转向我们今天要谈论的另一个库Springdoc，新项目就不要用了。</p><p><strong>Springdoc</strong></p><p>算是后起之秀，带着继任Springfox的使命而来。其支持OpenApi3规范，支持Springboot3，我们的新项目都应该使用这个</p><p>下面介绍<strong>Springdoc</strong>的使用</p><h1 id="2-引入依赖"><a href="#2-引入依赖" class="headerlink" title="2. 引入依赖"></a>2. 引入依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springdoc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springdoc-openapi-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>访问地址</strong> <code>http://server:port/context-path/swagger-ui.html</code></p><h1 id="3-配置文档信息"><a href="#3-配置文档信息" class="headerlink" title="3. 配置文档信息"></a>3. 配置文档信息</h1><p>创建一个OpenAPI 的bean，配置文档名称等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.ExternalDocumentation;  </span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.OpenAPI;  </span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Contact;  </span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.Info;  </span><br><span class="line"><span class="keyword">import</span> io.swagger.v3.oas.models.info.License;</span><br><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringDocConfig</span> &#123;  </span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> OpenAPI <span class="title function_">myOpenAPI</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OpenAPI</span>()  </span><br><span class="line">                .info(<span class="keyword">new</span> <span class="title class_">Info</span>()  </span><br><span class="line">                        .title(<span class="string">&quot;考试系统API&quot;</span>)  </span><br><span class="line">                        .version(<span class="string">&quot;v1.0.0&quot;</span>)  </span><br><span class="line">                        .license(<span class="keyword">new</span> <span class="title class_">License</span>()  </span><br><span class="line">                                .name(<span class="string">&quot;许可协议&quot;</span>)  </span><br><span class="line">                                .url(<span class="string">&quot;https://github.com/&quot;</span>))  </span><br><span class="line">                        .contact(<span class="keyword">new</span> <span class="title class_">Contact</span>()  </span><br><span class="line">                                .name(<span class="string">&quot;Me&quot;</span>)  </span><br><span class="line">                                .email(<span class="string">&quot;007@gmail.com&quot;</span>)))  </span><br><span class="line">                .externalDocs(<span class="keyword">new</span> <span class="title class_">ExternalDocumentation</span>()  </span><br><span class="line">                        .description(<span class="string">&quot;007的博客&quot;</span>)  </span><br><span class="line">                        .url(<span class="string">&quot;https://gitbub.com&quot;</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-配置文档分组"><a href="#4-配置文档分组" class="headerlink" title="4. 配置文档分组"></a>4. 配置文档分组</h1><p>通常根据请求地址分组<code>/api/teacher/</code>、<code>/api/user/</code> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> GroupedOpenApi <span class="title function_">adminApi</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> GroupedOpenApi.builder()  </span><br><span class="line">            .group(<span class="string">&quot;question&quot;</span>)  </span><br><span class="line">            .pathsToMatch(<span class="string">&quot;/question/**&quot;</span>)  </span><br><span class="line">            .build();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-常用注解"><a href="#5-常用注解" class="headerlink" title="5. 常用注解"></a>5. 常用注解</h1><div class="table-container"><table><thead><tr><th>注解</th><th>含义</th></tr></thead><tbody><tr><td>@Tag</td><td>用在controller类上，描述此controller的信息</td></tr><tr><td>@Operation</td><td>用在controller的方法里，描述此api的信息</td></tr><tr><td>@Parameter</td><td>用在controller方法里的参数上，描述参数信息</td></tr><tr><td>@Parameters</td><td>用在controller方法里的参数上，批量添加</td></tr><tr><td>@Schema</td><td>用于Entity，以及Entity的属性上</td></tr><tr><td>@ApiResponse</td><td>用在controller方法的返回值上</td></tr><tr><td>@ApiResponses</td><td>用在controller方法的返回值上</td></tr><tr><td>@Hidden</td><td>用在各种地方，用于隐藏其api</td></tr></tbody></table></div><p>同时，Springdoc还支持 Java Bean Validation API 的注解，例如<code>@NotNull</code> 等</p><h1 id="6-认证授权"><a href="#6-认证授权" class="headerlink" title="6. 认证授权"></a>6. 认证授权</h1><p>有时我们的服务需要认证，否则就调用不通，那怎么办</p><p>Springdoc 使用<code>@SecurityScheme</code> 来定义一个安全模式，我们可以定义全局的，也可以针对某个controller定义类级别的</p><h1 id="7-knife4j"><a href="#7-knife4j" class="headerlink" title="7. knife4j"></a>7. knife4j</h1><p>Knife4j是一个基于Swagger UI的增强版UI框架</p><p>Knife4j在OpenAPI3规范中，底层基础框架选择springdoc-openapi项目（所以引入knife4j后就不用再引入springdoc-openapi）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-openapi3-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.yml 配置<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># knife4j的增强配置，不需要增强可以不配  </span></span><br><span class="line"><span class="attr">knife4j:</span>  </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 是否启用knife4j增强,如果只是使用knife4j 的UI ,则可以关闭</span></span><br><span class="line">  <span class="attr">setting:</span>  </span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh_cn</span></span><br></pre></td></tr></table></figure></p><h2 id="7-1-访问地址"><a href="#7-1-访问地址" class="headerlink" title="7.1. 访问地址"></a>7.1. 访问地址</h2><p><strong>knife4j导出接口文档</strong></p><p><code>http://127.0.0.1:8080/doc.html</code></p><p><strong>knife4j UI界面</strong></p><p><code>http://127.0.0.1:8080/doc.html</code></p><p><strong>Swagger UI界面</strong></p><p><code>http://127.0.0.1:8080/swagger-ui/index.html</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-27-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2024/10/28/2023-11-27-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是消息队列"><a href="#1-什么是消息队列" class="headerlink" title="1. 什么是消息队列"></a>1. 什么是消息队列</h1><p>消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：</p><ul><li>Producer：消息生产者，负责产生和发送消息到 Broker；</li><li>Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li><li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li></ul><h1 id="2-消息队列模式"><a href="#2-消息队列模式" class="headerlink" title="2. 消息队列模式"></a>2. 消息队列模式</h1><ul><li>点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。</li><li>发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。</li></ul><h1 id="3-消息队列应用场景"><a href="#3-消息队列应用场景" class="headerlink" title="3. 消息队列应用场景"></a>3. 消息队列应用场景</h1><ul><li><strong>应用解耦</strong>：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li><li><strong>异步处理</strong>：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li><li><strong>流量削锋</strong>：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li><li><strong>日志处理</strong>：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li><li><strong>消息通讯</strong>：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</li><li><strong>消息广播</strong>：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。</li></ul><h1 id="4-常用消息队列"><a href="#4-常用消息队列" class="headerlink" title="4. 常用消息队列"></a>4. 常用消息队列</h1><p>Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据的互联网服务的数据收集业务</strong>，大型公司建议可以选用，<strong>如果有日志采集功能，肯定是首选 kafka。</strong></p><p>RocketMQ：<strong>天生为金融互联网领域而生，对于可靠性要求很高的场景</strong>，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，<strong>如果你的业务有上述并发场景，建议可以选择 RocketMQ。</strong></p><p>RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。<strong>如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-27-Nginx%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/28/2023-11-27-Nginx%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">nginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。</span><br><span class="line">nginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。</span><br><span class="line">nginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。</span><br><span class="line">nginx -s reopen     重新打开日志文件。</span><br><span class="line">nginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。</span><br><span class="line">nginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。</span><br><span class="line">nginx -v            显示 nginx 的版本。</span><br><span class="line">nginx -V            显示 nginx 的版本，编译器版本和配置参数。</span><br></pre></td></tr></table></figure><p>可编写一个批处理文件一键运行nginx</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="attribute">echo</span> <span class="literal">off</span></span><br><span class="line">rem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程</span><br><span class="line">nginx.exe -s stop</span><br><span class="line"></span><br><span class="line">rem 测试配置文件语法正确性</span><br><span class="line">nginx.exe -t -c conf/nginx.conf</span><br><span class="line"></span><br><span class="line">rem 显示版本信息</span><br><span class="line">nginx.exe -v</span><br><span class="line"></span><br><span class="line">rem 按照指定配置去启动nginx</span><br><span class="line">nginx.exe -c conf/nginx.conf</span><br></pre></td></tr></table></figure><h1 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h1><p><code>conf/nginx.conf</code> 是 nginx 的默认配置文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义 nginx 运行的用户和用户组</span></span><br><span class="line"><span class="attribute">user</span> www www;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx 进程数，建议设置为等于 CPU 总核心数。</span></span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx 默认没有开启利用多核 CPU, 通过增加 worker_cpu_affinity 配置参数来充分利用多核 CPU 以下是 8 核的配置参数</span></span><br><span class="line"><span class="attribute">worker_cpu_affinity</span> <span class="number">00000001</span> <span class="number">00000010</span> <span class="number">00000100</span> <span class="number">00001000</span> <span class="number">00010000</span> <span class="number">00100000</span> <span class="number">01000000</span> <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#进程文件</span></span><br><span class="line"><span class="attribute">pid</span> /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个 nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值 ulimit -n）与 nginx 进程数相除，但是 nginx 分配请求并不均匀，所以建议与 ulimit -n 的值保持一致。</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#工作模式与连接数上限</span></span><br><span class="line"><span class="section">events</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll 模型是 Linux 2.6 以上版本内核中的高性能网络 I/O 模型，如果跑在 FreeBSD 上面，就用 kqueue 模型。</span></span><br><span class="line">    <span class="comment">#epoll 是多路复用 IO(I/O Multiplexing) 中的一种方式，但是仅用于 linux2.6 以上内核，可以大大提高 nginx 的性能</span></span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">    <span class="comment">#单个后台 worker process 进程的最大并发链接数</span></span><br><span class="line">    <span class="comment">#事件模块指令，定义 nginx 每个进程最大连接数，默认 1024。最大客户连接数由 worker_processes 和 worker_connections 决定</span></span><br><span class="line">    <span class="comment">#即 max_client=worker_processes*worker_connections, 在作为反向代理时：max_client=worker_processes*worker_connections / 4</span></span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">    <span class="comment">############################################################################</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定 http 服务器</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types; <span class="comment">#文件扩展名与文件类型映射表</span></span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream; <span class="comment">#默认文件类型</span></span><br><span class="line">    <span class="comment">#charset utf-8; #默认编码</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>; <span class="comment">#服务器名字的 hash 表大小</span></span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>; <span class="comment">#上传文件大小限制</span></span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">64k</span>; <span class="comment">#设定请求缓</span></span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>; <span class="comment">#设定请求缓</span></span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>; <span class="comment">#开启高效文件传输模式，sendfile 指令指定 nginx 是否调用 sendfile 函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘 IO 重负载应用，可设置为 off，以平衡磁盘与网络 I/O 处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成 off。</span></span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment">#开启目录列表访问，合适下载服务器，默认关闭。</span></span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>; <span class="comment">#防止网络阻塞</span></span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>; <span class="comment">#防止网络阻塞</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">##连接客户端超时时间各种参数设置##</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">120</span>;          <span class="comment">#单位是秒，客户端连接时时间，超时之后服务器端自动关闭该连接 如果 nginx 守护进程在这个等待的时间里，一直没有收到浏览发过来 http 请求，则关闭这个 http 连接</span></span><br><span class="line">    <span class="attribute">client_header_timeout</span> <span class="number">10</span>;        <span class="comment">#客户端请求头的超时时间</span></span><br><span class="line">    <span class="attribute">client_body_timeout</span> <span class="number">10</span>;          <span class="comment">#客户端请求主体超时时间</span></span><br><span class="line">    <span class="attribute">reset_timedout_connection</span> <span class="literal">on</span>;    <span class="comment">#告诉 nginx 关闭不响应的客户端连接。这将会释放那个客户端所占有的内存空间</span></span><br><span class="line">    <span class="attribute">send_timeout</span> <span class="number">10</span>;                 <span class="comment">#客户端响应超时时间，在两次客户端读取操作之间。如果在这段时间内，客户端没有读取任何数据，nginx 就会关闭连接</span></span><br><span class="line">    <span class="comment">################################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#FastCGI 相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">###作为代理缓存服务器设置#######</span></span><br><span class="line">    <span class="comment">###先写到 temp 再移动到 cache</span></span><br><span class="line">    <span class="comment">#proxy_cache_path /var/tmp/nginx/proxy_cache levels=1:2 keys_zone=cache_one:512m inactive=10m max_size=64m;</span></span><br><span class="line">    <span class="comment">###以上 proxy_temp 和 proxy_cache 需要在同一个分区中</span></span><br><span class="line">    <span class="comment">###levels=1:2 表示缓存级别，表示缓存目录的第一级目录是 1 个字符，第二级目录是 2 个字符 keys_zone=cache_one:128m 缓存空间起名为 cache_one 大小为 512m</span></span><br><span class="line">    <span class="comment">###max_size=64m 表示单个文件超过 128m 就不缓存了  inactive=10m 表示缓存的数据，10 分钟内没有被访问过就删除</span></span><br><span class="line">    <span class="comment">#########end####################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#####对传输文件压缩###########</span></span><br><span class="line">    <span class="comment">#gzip 模块设置</span></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; <span class="comment">#开启 gzip 压缩输出</span></span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>; <span class="comment">#最小压缩文件大小</span></span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>; <span class="comment">#压缩缓冲区</span></span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>; <span class="comment">#压缩版本（默认 1.1，前端如果是 squid2.5 请使用 1.0）</span></span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>; <span class="comment">#压缩等级，gzip 压缩比，1 为最小，处理最快；9 为压缩比最大，处理最慢，传输速度最快，也最消耗 CPU；</span></span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    <span class="comment">#压缩类型，默认就已经包含 text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个 warn。</span></span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">##############################</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#limit_zone crawler $binary_remote_addr 10m; #开启限制 IP 连接数的时候需要使用</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> blog.ha97.com &#123;</span><br><span class="line">        <span class="comment">#upstream 的负载均衡，weight 是权重，可以根据机器配置定义权重。weigth 参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.121:80</span> weight=<span class="number">3</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.122:80</span> weight=<span class="number">2</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">192.168.80.123:80</span> weight=<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#虚拟主机的配置</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#############https##################</span></span><br><span class="line">        <span class="comment">#listen 443 ssl;</span></span><br><span class="line">        <span class="comment">#ssl_certificate /opt/https/xxxxxx.crt;</span></span><br><span class="line">        <span class="comment">#ssl_certificate_key /opt/https/xxxxxx.key;</span></span><br><span class="line">        <span class="comment">#ssl_protocols SSLv3 TLSv1;</span></span><br><span class="line">        <span class="comment">#ssl_ciphers HIGH:!ADH:!EXPORT57:RC4+RSA:+MEDIUM;</span></span><br><span class="line">        <span class="comment">#ssl_prefer_server_ciphers on;</span></span><br><span class="line">        <span class="comment">#ssl_session_cache shared:SSL:2m;</span></span><br><span class="line">        <span class="comment">#ssl_session_timeout 5m;</span></span><br><span class="line">        <span class="comment">####################################end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#域名可以有多个，用空格隔开</span></span><br><span class="line">        <span class="attribute">server_name</span> www.ha97.com ha97.com;</span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.php;</span><br><span class="line">        <span class="attribute">root</span> /data/www/ha97;</span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(php|php5)?$</span> &#123;</span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#图片缓存时间设置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">10d</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#JS 和 CSS 缓存时间设置</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(js|css)?$</span> &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">1h</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#日志格式设定</span></span><br><span class="line">        <span class="attribute">log_format</span> access <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span> <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span> <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; <span class="variable">$http_x_forwarded_for</span>&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#定义本虚拟主机的访问日志</span></span><br><span class="line">        <span class="attribute">access_log</span> /var/log/nginx/ha97access.log access;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#对 &quot;/&quot; 启用反向代理</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:88;</span><br><span class="line">            <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="comment">#后端的 Web 服务器可以通过 X-Forwarded-For 获取用户真实 IP</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="comment">#以下是一些反向代理的配置，可选。</span></span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">client_max_body_size</span> <span class="number">10m</span>; <span class="comment">#允许客户端请求的最大单文件字节数</span></span><br><span class="line">            <span class="attribute">client_body_buffer_size</span> <span class="number">128k</span>; <span class="comment">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">##代理设置 以下设置是 nginx 和后端服务器之间通讯的设置##</span></span><br><span class="line">            <span class="attribute">proxy_connect_timeout</span> <span class="number">90</span>; <span class="comment">#nginx 跟后端服务器连接超时时间（代理连接超时）</span></span><br><span class="line">            <span class="attribute">proxy_send_timeout</span> <span class="number">90</span>; <span class="comment">#后端服务器数据回传时间（代理发送超时）</span></span><br><span class="line">            <span class="attribute">proxy_read_timeout</span> <span class="number">90</span>; <span class="comment">#连接成功后，后端服务器响应时间（代理接收超时）</span></span><br><span class="line">            <span class="attribute">proxy_buffering</span> <span class="literal">on</span>;    <span class="comment">#该指令开启从后端被代理服务器的响应内容缓冲 此参数开启后 proxy_buffers 和 proxy_busy_buffers_size 参数才会起作用</span></span><br><span class="line">            <span class="attribute">proxy_buffer_size</span> <span class="number">4k</span>;  <span class="comment">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class="line">            <span class="attribute">proxy_buffers</span> <span class="number">4</span> <span class="number">32k</span>;   <span class="comment">#proxy_buffers 缓冲区，网页平均在 32k 以下的设置</span></span><br><span class="line">            <span class="attribute">proxy_busy_buffers_size</span> <span class="number">64k</span>; <span class="comment">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class="line">            <span class="attribute">proxy_max_temp_file_size</span> <span class="number">2048m</span>; <span class="comment">#默认 1024m, 该指令用于设置当网页内容大于 proxy_buffers 时，临时文件大小的最大值。如果文件大于这个值，它将从 upstream 服务器同步地传递请求，而不是缓冲到磁盘</span></span><br><span class="line">            <span class="attribute">proxy_temp_file_write_size</span> <span class="number">512k</span>; 这是当被代理服务器的响应过大时 <span class="attribute">nginx</span> 一次性写入临时文件的数据量。</span><br><span class="line">            proxy_temp_path  /var/tmp/nginx/proxy_temp;    <span class="comment">##定义缓冲存储目录，之前必须要先手动创建此目录</span></span><br><span class="line">            <span class="attribute">proxy_headers_hash_max_size</span> <span class="number">51200</span>;</span><br><span class="line">            <span class="attribute">proxy_headers_hash_bucket_size</span> <span class="number">6400</span>;</span><br><span class="line">            <span class="comment">#######################################################</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#设定查看 nginx 状态的地址</span></span><br><span class="line">        <span class="section">location</span> /nginxStatus &#123;</span><br><span class="line">            <span class="attribute">stub_status</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">access_log</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">auth_basic</span> <span class="string">&quot;nginxStatus&quot;</span>;</span><br><span class="line">            <span class="attribute">auth_basic_user_file</span> conf/htpasswd;</span><br><span class="line">            <span class="comment">#htpasswd 文件的内容可以用 apache 提供的 htpasswd 工具来产生。</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#本地动静分离反向代理配置</span></span><br><span class="line">        <span class="comment">#所有 jsp 的页面均交由 tomcat 或 resin 处理</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#所有静态文件由 nginx 直接读取不经过 tomcat 或 resin</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$</span></span><br><span class="line">        &#123; <span class="attribute">expires</span> <span class="number">15d</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ .*.(js|css)?$</span></span><br><span class="line">        &#123; <span class="attribute">expires</span> <span class="number">1h</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-27-Nginx%E5%BA%94%E7%94%A8/"/>
      <url>/2024/10/28/2023-11-27-Nginx%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Nginx-简介"><a href="#1-Nginx-简介" class="headerlink" title="1. Nginx 简介"></a>1. Nginx 简介</h1><p><strong>Nginx (engine x)</strong> 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器</p><h1 id="2-静态站点"><a href="#2-静态站点" class="headerlink" title="2. 静态站点"></a>2. 静态站点</h1><p>需要配置静态站点，即 html 文件和一堆静态资源</p><p>举例来说：如果所有的静态资源都放在了 <code>/app/dist</code> 目录下，我们只需要在 <code>nginx.conf</code> 中指定首页以及这个站点的 host 即可。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml text/javascript application/javascript image/jpeg image/gif image/png;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  static.zp.cn;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">root</span> /app/dist;</span><br><span class="line">            <span class="attribute">index</span> index.html;</span><br><span class="line">            <span class="comment">#转发任何请求到 index.html</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，添加 HOST：</p><p><code>127.0.0.1 static.zp.cn</code></p><p>此时，在本地浏览器访问 static.zp.cn ，就可以访问静态站点了。</p><h1 id="3-网站有多个-webapp-的配置"><a href="#3-网站有多个-webapp-的配置" class="headerlink" title="3. 网站有多个 webapp 的配置"></a>3. 网站有多个 webapp 的配置</h1><p>假如 <code>www.helloworld.com</code>站点有好几个 webapp，product（产品）、admin（用户中心）。访问这些应用的方式通过上下文(context)来进行区分</p><p><code>www.helloworld.com/product/</code></p><p><code>www.helloworld.com/admin/</code></p><p>http 的默认端口号是 80，如果在一台服务器上同时启动这几个 webapp 应用，都用 80 端口，肯定是不成的。所以，这几个应用需要分别绑定不同的端口号。</p><p>那么，问题来了，用户在实际访问 <code>www.helloworld.com</code>站点时，访问不同 webapp，总不会还带着对应的端口号去访问吧。所以，需要用到反向代理来做处理。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#此处省略一些基本配置</span></span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> product_server&#123;</span><br><span class="line">        <span class="attribute">server</span> www.helloworld.com:<span class="number">8081</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> admin_server&#123;</span><br><span class="line">        <span class="attribute">server</span> www.helloworld.com:<span class="number">8082</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">upstream</span> finance_server&#123;</span><br><span class="line">        <span class="attribute">server</span> www.helloworld.com:<span class="number">8083</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment">#此处省略一些基本配置</span></span><br><span class="line">        <span class="comment">#默认指向product的server</span></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://product_server;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /product/&#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://product_server;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /admin/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://admin_server;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> /finance/ &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://finance_server;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-搭建文件服务器"><a href="#4-搭建文件服务器" class="headerlink" title="4. 搭建文件服务器"></a>4. 搭建文件服务器</h1><p>适用于团队需要归档一些数据或资料</p><ul><li>将 autoindex 开启可以显示目录，默认不开启。</li><li>将 autoindex_exact_size 开启可以显示文件的大小。</li><li>将 autoindex_localtime 开启可以显示文件的修改时间。</li><li>root 用来设置开放为文件服务的根路径。</li><li>charset 设置为 <code>charset utf-8;</code>，可以避免中文乱码问题</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">9050</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">9050</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">        <span class="attribute">root</span>         /path/to/your/directory;  <span class="comment"># 修改为你要分享的文件所在的目录的路径</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">autoindex_exact_size</span> <span class="literal">on</span>;</span><br><span class="line">            <span class="attribute">autoindex_localtime</span> <span class="literal">on</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-反向代理"><a href="#5-反向代理" class="headerlink" title="5. 反向代理"></a>5. 反向代理</h1><h2 id="5-1-http反向代理"><a href="#5-1-http反向代理" class="headerlink" title="5.1. http反向代理"></a>5.1. http反向代理</h2><h2 id="5-2-https反向代理"><a href="#5-2-https反向代理" class="headerlink" title="5.2. https反向代理"></a>5.2. https反向代理</h2><p>使用 nginx 配置 https 需要知道几点：</p><ul><li>HTTPS 的固定端口号是 443，不同于 HTTP 的 80 端口</li><li>SSL 标准需要引入安全证书，所以在 nginx.conf 中你需要指定证书和它对应的 key</li></ul><p>其他和 http 反向代理基本一样，只是在 <code>Server</code> 部分配置有些不同。</p><h1 id="6-负载均衡"><a href="#6-负载均衡" class="headerlink" title="6. 负载均衡"></a>6. 负载均衡</h1><p>网站在实际运营过程中，大部分都是以集群的方式运行，这时需要使用负载均衡来分流。</p><p>假设这样一个应用场景：将应用部署在 192.168.1.11:80、192.168.1.12:80、192.168.1.13:80 三台 linux 环境的服务器上。网站域名叫 <code>www.helloworld.com</code>，公网IP 为 192.168.1.11。在公网 IP 所在的服务器上部署 nginx，对所有请求做负载均衡处理</p><h2 id="6-1-轮询"><a href="#6-1-轮询" class="headerlink" title="6.1. 轮询"></a>6.1. 轮询</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  <span class="comment"># 默认所有服务器权重为 1</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-加权轮询"><a href="#6-2-加权轮询" class="headerlink" title="6.2. 加权轮询"></a>6.2. 加权轮询</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span>   weight=<span class="number">3</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span>              <span class="comment"># default weight=1</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span>              <span class="comment"># default weight=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-最少连接"><a href="#6-3-最少连接" class="headerlink" title="6.3. 最少连接"></a>6.3. 最少连接</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  least_conn;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># with default weight for all (weight=1)</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-4-加权最少连接"><a href="#6-4-加权最少连接" class="headerlink" title="6.4. 加权最少连接"></a>6.4. 加权最少连接</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line">  least_conn;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span>   weight=<span class="number">3</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span>              <span class="comment"># default weight=1</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span>              <span class="comment"># default weight=1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-5-IP-Hash"><a href="#6-5-IP-Hash" class="headerlink" title="6.5. IP Hash"></a>6.5. IP Hash</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line"></span><br><span class="line">  ip_hash;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># with default weight for all (weight=1)</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-普通Hash"><a href="#6-6-普通Hash" class="headerlink" title="6.6. 普通Hash"></a>6.6. 普通Hash</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> bck_testing_01 &#123;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># with default weight for all (weight=1)</span></span><br><span class="line">  <span class="attribute">server</span> <span class="number">192.168.250.220:8080</span></span><br><span class="line">  server <span class="number">192.168.250.221:8080</span></span><br><span class="line">  server <span class="number">192.168.250.222:8080</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-11-29-DOS%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/"/>
      <url>/2024/10/28/2023-11-29-DOS%E6%89%B9%E5%A4%84%E7%90%86%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1. 基本语法"></a>1. 基本语法</h1><p><strong>@echo off</strong></p><p>关闭回显功能，也就是屏蔽过程，建议放置在批处理的首行</p><p><strong>pause</strong></p><p>暂停批处理运行</p><p><strong>title</strong></p><p>为批处理脚本设置标题</p><p><strong>set</strong></p><p>设置变量，常用与在脚本中的互动赋值</p><p><strong>:</strong></p><p>定义标签名</p><p><strong>goto</strong></p><p>跳转到指定标签</p><p><strong>exit</strong></p><p>终止当前脚本</p><p><code>exit /b</code> 退出当前批处理脚本，而不是退出Cmd.exe。如果从批处理脚本外部执行，则退出Cmd.exe</p><p><strong>GOTO :EOF</strong> </p><p>立即关闭当前运行的脚本</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-30-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2024/10/28/2023-09-30-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第一章-计算机系统概论"><a href="#1-第一章-计算机系统概论" class="headerlink" title="1. 第一章 计算机系统概论"></a>1. 第一章 计算机系统概论</h1><h1 id="2-第二章-数据的表示和运算"><a href="#2-第二章-数据的表示和运算" class="headerlink" title="2. 第二章 数据的表示和运算"></a>2. 第二章 数据的表示和运算</h1><h1 id="3-第三章-存储系统"><a href="#3-第三章-存储系统" class="headerlink" title="3. 第三章 存储系统"></a>3. 第三章 存储系统</h1><h1 id="4-第四章-指令系统"><a href="#4-第四章-指令系统" class="headerlink" title="4. 第四章 指令系统"></a>4. 第四章 指令系统</h1><h1 id="5-第五章-中央处理器"><a href="#5-第五章-中央处理器" class="headerlink" title="5. 第五章 中央处理器"></a>5. 第五章 中央处理器</h1><h1 id="6-第六章-总线"><a href="#6-第六章-总线" class="headerlink" title="6. 第六章 总线"></a>6. 第六章 总线</h1><h1 id="7-第七章-输入输出系统"><a href="#7-第七章-输入输出系统" class="headerlink" title="7. 第七章 输入输出系统"></a>7. 第七章 输入输出系统</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-11-GitPage%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2024/10/28/2023-10-11-GitPage%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主题市场"><a href="#1-主题市场" class="headerlink" title="1. 主题市场"></a>1. 主题市场</h1><p><a href="http://jekyllthemes.org/">Jekyll Themes</a></p><h1 id="2-本地调试"><a href="#2-本地调试" class="headerlink" title="2. 本地调试"></a>2. 本地调试</h1><p>安装<a href="https://rubyinstaller.org/">Ruby</a></p><p>打开CMD，执行命令安装Jekyll</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem <span class="keyword">install </span><span class="keyword">jekyll</span></span><br></pre></td></tr></table></figure><p>设置镜像源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bundle config mirror.https://rubygems.org https://mirrors.tuna.tsinghua.edu.cn/rubygems</span><br></pre></td></tr></table></figure><p>进入仓库文件夹，执行命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span><span class="keyword">install</span></span><br></pre></td></tr></table></figure><p>启动Jekyll服务</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bundle </span>exec <span class="keyword">jekyll </span>serve</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/sqchen/p/10757927.html">参考</a></p><h1 id="3-功能拓展"><a href="#3-功能拓展" class="headerlink" title="3. 功能拓展"></a>3. 功能拓展</h1><p>想要在markdown笔记中添加思维导图，但又不想使用图片，可以使用mermaid，但是GitPage的Jekyll默认不支持 mermaid，以下是解决方法</p><h2 id="3-1-step1"><a href="#3-1-step1" class="headerlink" title="3.1. step1"></a>3.1. step1</h2><p>先在博客文件中添加<code>mermaid.min.js</code>文件（可以在<a href="https://unpkg.com/browse/mermaid@8.6.0/获取），将`mermaid.min.js`放在js文件夹">https://unpkg.com/browse/mermaid@8.6.0/获取），将`mermaid.min.js`放在js文件夹</a></p><h2 id="3-2-step2"><a href="#3-2-step2" class="headerlink" title="3.2. step2"></a>3.2. step2</h2><p>打开<code>_layouts/default.html</code>文件，添加如下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;/js/mermaid.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> config = &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">startOnLoad</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">theme</span>: <span class="string">&quot;forest&quot;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="attr">flowchart</span>:&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">useMaxWidth</span>: <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="attr">htmlLabels</span>: <span class="literal">true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">mermaid.<span class="title function_">initialize</span>(config);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">window</span>.<span class="property">mermaid</span>.<span class="title function_">init</span>(<span class="literal">undefined</span>, <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;.language-mermaid&#x27;</span>));</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-05-Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/2024/10/28/2023-10-05-Linux%E7%94%A8%E6%88%B7%E5%92%8C%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用户和组配置文件"><a href="#1-用户和组配置文件" class="headerlink" title="1. 用户和组配置文件"></a>1. 用户和组配置文件</h1><p><strong>安全3A</strong></p><ul><li>Authentication  认证（确定验证身份）</li><li>Authorization  授权</li><li>Accounting Audition  审计</li></ul><p><strong>用户user</strong></p><p>令牌 token，identity </p><p>用户账号在登录时会获取令牌</p><p>权限是根据ID号划分的</p><p>Linux 用户：Username，UID</p><ul><li>管理员：root，0</li><li>普通用户：1-60000 自动分配<ul><li>系统用户（对进程的运行进行权限分配）：1-499、1-999 （CentOS7）</li><li>登录用户（交互式登录）：500+、1000+ （CentOS7）</li></ul></li></ul><p>系统用户一般是给应用程序使用的，系统用户没有家目录，给应用程序使用的用户对应的shell类型一般是nologin类型</p><p><strong>组group</strong></p><p>组是多个用户的集合</p><p>Linux中允许用户和组重名（Windows不允许）</p><p>用户和组是多对多的关系</p><p>Linux 组：Groupname，GID</p><ul><li>管理员组：root，0</li><li>系统组：1-499、1-999<ul><li>系统组：1-499、1-99</li><li>普通组：500+、100+</li></ul></li></ul><p><strong>安全上下文</strong></p><p>每个运行中的程序（进程）都有其对应的运行者的身份（用户），进程所能够访问资源的权限取决于进程的运行者的身份</p><p><strong>组的类别</strong></p><p>用户的主要组（primary group）</p><ul><li>用户必须属于一个且只能属于一个主组</li><li>Linux中新建一个用户，系统会自动创建一个同名的组，作为新建用户的主组</li></ul><p>用户的附加组（supplementary group）</p><ul><li>一个用户可以属于零个或多个辅助组</li></ul><p><strong>用户和组的配置文件</strong></p><p><code>/etc/passwd</code>：用户及其属性信息</p><ul><li>格式<code>username:password:UID:GID:GECOS:home_directory:shell</code></li></ul><p><code>/etc/group</code>：组及其属性信息</p><ul><li>格式<code>groupname:password:GID:user_list</code></li></ul><p><code>/etc/shadow</code>：用户密码及其相关属性</p><ul><li>格式<code>username:password:last_password_change:min_days:max_days:warn_days:inactive_days:expire_date:reserved</code></li></ul><p><code>/etc/gshadow</code>：组密码及其相关属性</p><ul><li>格式<code>groupname:password:admin_list:member_list</code></li><li><code>!!</code>表示禁用</li><li><code>!</code>表示锁定</li></ul><p><strong>密码</strong></p><p>生成随机口令 <code>openssl rand -base64 12</code></p><p>密码期限 minday、maxday、warnday、inactiveday</p><h1 id="2-用户管理命令"><a href="#2-用户管理命令" class="headerlink" title="2. 用户管理命令"></a>2. 用户管理命令</h1><p><strong>操作用户和组的配置文件</strong></p><p>vipw（vi etc/passwd）和 vigr（vi etc/group）</p><p>具有编辑文件与语法检查功能</p><p>pwck和 grpck</p><p>检查命令是否正确</p><p><strong>用户管理命令</strong></p><p>用户创建<code>useradd [options]</code> </p><p>默认值设定<code>/etc/default/useradd</code>文件中</p><ul><li><code>-D</code> 显示默认设置</li><li><code>-u</code> UID</li><li><code>-o</code>配合<code>-u</code>选项，不检查UID的唯一性</li><li><code>-g GID</code> 指明用户所属基本组，可为组名，也可以是GID</li><li><code>-c &quot;COMMENT&quot;</code>用户的注释信息</li><li><code>-d HOME_DIR</code> 以指定的路径（不存在）为家目录</li><li><code>-s SHELL</code> 指明用户的默认shell程序，可用的shell在<code>/etc/shells</code>中，通常使用<code>/sbin/nologin</code>或<code>/bin/bash</code></li><li><code>-G GROUP1[,GROUP2.…]</code>为用户指明附加组，组须事先存在</li><li><code>-N</code>不创建私用组做主组，使用users组做主组</li><li><code>-r</code>创建系统用户CentOS 6:lD&lt;500，CentOS 7:lD&lt;1000</li><li><code>-m</code>强制创建家目录，用于系统用户</li><li><code>-M</code>强制不创建家目录，用于非系统用户</li></ul><p>批量创建用户<code>newusers /etc/passwd格式的文件</code></p><p>批量修改口令<code>echo username:password | chpasswd</code></p><p>用户属性修改 <code>usermod [options]</code></p><ul><li><code>-u UID</code>新UID</li><li><code>-g GID</code>新主组</li><li><code>-G GROUP1[,GROUP2..[,GROUPN]]]</code>新附加组，原来的附加组将会被覆盖；若保留原有，则要同时使用<code>-a</code>选项</li><li>-<code>s SHELL</code> 新的默认SHELL</li><li><code>-c &#39;COMMENT&#39;</code>新的注释信息</li><li><code>-d HOME</code>新家目录不会自动创建；若要创建新家目录并移动原家数据，同时使用<code>-m</code>选项</li><li><code>-l login_name</code>新的名字</li><li><code>-L</code> 锁定用户，会在<code>/etc/shadow</code>密码栏增加<code>!</code></li><li><code>-U</code> 解锁用户，会将<code>/etc/shadow</code>密码栏的<code>!</code>拿掉</li><li><code>-e YYYY-MM-DD</code> 指明用户账号过期日期</li><li><code>-f INACTIVE</code> 设定非活动期限</li></ul><p>删除用户 <code>userdel [options]</code></p><ul><li><code>-r</code>删除用户家目录</li><li>正在登录的用户无法直接删除</li></ul><p><strong>查看用户相关的ID信息</strong></p><p><code>id [options]... [USER]</code></p><ul><li><code>-u</code> 显示UID</li><li><code>-g</code> 显示GID</li><li><code>-G</code> 显示用户所属的组的ID</li><li><code>-n</code> 显示名称，需配合u、g、G使用</li></ul><p><strong>切换用户或以其他用户身份执行命令</strong></p><p><code>su [options...] [-] [user [args...]]</code>切换用户的方式</p><ul><li><code>su UserName</code> 非登录式切换，即不会读取目标用户的配置文件，不改变当前工作目录</li><li><code>su - UserName</code>或<code>su -l UserName</code>登录式切换，会读取目标用户的配置文件，切换至家目录，完全切换</li><li>root用户su至其他用户无须密码，非root用户切换时需要密码</li><li>换个身份执行命令 <code>su [-] UserName -c &#39;command&#39;</code></li></ul><p><strong>设置密码</strong></p><p><code>passwd [OPTIONS] UserName</code> 修改指定用户的密码</p><ul><li><code>-d</code>删除指定用户密码</li><li><code>-l</code> 锁定指定用户</li><li><code>-u</code>解锁指定用户</li><li><code>-e</code>强制用户下次登录修改密码</li><li><code>-f</code>强制操作</li><li><code>-n mindays</code>指定最短使用期限</li><li><code>-x maxdays</code>最大使用期限</li><li><code>-w warndays</code>提前多少天开始警告</li><li><code>-i inactivedays</code>非活动期限</li><li><code>--stdin</code> 从标准输入接收用户密码 <code>echo &quot;password&quot; | passwd --stdin username</code></li></ul><p><strong>修改用户密码策略</strong></p><p><code>chage [OPTION]...</code></p><ul><li><code>-d LAST_DAY</code></li><li><code>-E EXPIRE_DATE</code></li><li><code>-I INACTIVE</code></li><li><code>-m</code> MIN_DAYS</li><li><code>-M</code> MAX_DAYS</li><li><code>-W</code> WARN_DAYS</li><li><code>-l</code> 显示密码策略</li></ul><p><strong>用户相关的其他命令</strong></p><p><code>chfn</code>指定个人信息</p><p><code>chsh</code>指定shell</p><h1 id="3-用户和组管理"><a href="#3-用户和组管理" class="headerlink" title="3. 用户和组管理"></a>3. 用户和组管理</h1><p><strong>组的维护命令</strong></p><p>创建组 <code>groupadd [options]</code></p><ul><li><code>-g GID</code>指明GID号</li><li><code>-r</code> 创建系统组 CentOS 6:ID&lt;500，CentOS 7:ID&lt;1000</li></ul><p>修改和删除组 <code>groupmod [options]</code></p><ul><li><code>-n groupname</code> 修改组名</li><li><code>-g GID</code> 修改GID</li></ul><p>组删除 <code>groupdel groupname</code> 附加组可以直接删，主组不能直接删</p><p><strong>更改组密码</strong></p><p><code>gpasswd [options]</code></p><ul><li><code>-a user</code> 添加用户user进某个组 </li><li><code>-d user</code> 从指定组中移除用户user</li><li><code>-A user1,user2...</code> 设置有管理权限的用户列表</li></ul><p><code>newgrp</code> 临时切换主组，如果用户本不属于此组，则需要组密码</p><p><strong>更改和查看组成员</strong></p><p><code>groupmems [options] [action]</code></p><p>options</p><ul><li><code>-g</code> 指定某个组<br>action</li><li><code>-a</code> 指定用户加入组</li><li><code>-d</code> 从组中删除用户</li><li><code>-p</code> 从组中清楚所有成员</li><li><code>-l</code> 显示组成员列表</li></ul><p>查看用户所属组列表 <code>groups [OPTION].[USERNAME]</code> </p><h1 id="4-权限管理"><a href="#4-权限管理" class="headerlink" title="4. 权限管理"></a>4. 权限管理</h1><p>权限所有者：所有者权限、所有组权限、路人权限</p><p>权限类型</p><ul><li>文件：read（看文件内容）、write（修改文件内容）、excute（执行）</li><li>文件夹：read（浏览目录下的文件列表）、write（在目录下创建、删除文件）、excute（访问目录下的文件）</li></ul><p>执行权限为目录的基础权限，没有执行权限则无法进入到目录，无法查看目录内容，无法在目录中创建、修改、删除里面的文件，就是什么也做不了</p><p><strong>文件权限</strong></p><p><code>chown [OPTION]... [OWNER][:[GROUP]] FILE...</code>设置文件的所有者</p><ul><li><code>-R</code>递归</li></ul><p><code>chgrp [OPTION].….GROUP FILE...</code> 设置文件的属组信息</p><ul><li><code>-R</code> 递归</li></ul><p><code>chmod who opt per file</code> 模式法设置文件权限，<code>chmod u-w file</code> 给file文件的所有者减去写权限 </p><ul><li>who：<code>u</code>文件所有者、<code>g</code>文件所有组、<code>o</code>路人、<code>a</code>所有人</li><li>opt：<code>+</code>加权限、<code>-</code>减权限、<code>=</code>重新分权限</li><li>per：<code>r</code>读权限、<code>w</code>写权限、<code>x</code>执行权限</li></ul><p><strong>数字法</strong>（八进制数字）设置文件权限 略…</p><h1 id="5-默认权限umask和特殊权限"><a href="#5-默认权限umask和特殊权限" class="headerlink" title="5. 默认权限umask和特殊权限"></a>5. 默认权限umask和特殊权限</h1><p><strong>默认权限umask</strong></p><p><code>umask</code> 命令在创建新文件和目录时自动应用一些权限限制</p><p><code>umask [options] [mask]</code> 其中，mask 是一个八进制数字，用于设置掩码。如果未提供 mask 参数，则 <code>umask</code> 命令将显示当前的掩码设置。掩码是一个八进制数字，表示要从默认权限中屏蔽的权限位</p><ul><li><code>-S</code>模式方式显示</li><li><code>-p</code>输出可被调用</li></ul><p>非特权用户<code>umask</code>是002</p><p>root的<code>umask</code>是022</p><p>全局设置：<code>/etc/bashrc</code> 用户设置：<code>~/. bashrc</code></p><p><strong>Linux文件系统上的特殊权限</strong></p><p>任何一个可执行程序文件能不能启动为进程:取决发起者对程序文件是否拥有执行权限</p><p>启动为进程之后，其进程的属组为原程序文件的属组</p><p>SUID权限，占据属主的执行权限位，作用于二进制可执行文件，该文件在执行时将具有拥有者的权限</p><ul><li>相应权限位显示<code>s</code>说明属主拥有x权限</li><li>相应权限位显示<code>S</code> 说明属主没有x权限</li></ul><p>SGID权限，占据属组的执行权限位，作用于二进制可执行文件，该文件在执行时将具有所属组的权限。作用于目录上，当用户在此目录新建文件时，此新文件的所属组继承目录的所属组</p><ul><li>相应权限位显示<code>s</code> 说明属组拥有x权限</li><li>相应权限位显示<code>S</code> 说明属组没有x权限</li></ul><p>Sticky权限，占据other的执行权限位，作用于目录上，只有目录的所有者、文件的所有者和 root 用户才能删除或重命名目录中的文件。其他用户只能在目录中创建、修改和访问自己的文件，不能删除其他用户的文件</p><ul><li>相应权限位显示<code>t</code> 说明other拥有x权限</li><li>相应权限位显示<code>T</code> 说明other没有x权限</li></ul><p><strong>设定文件特定属性</strong></p><p>更改文件或目录的属性的命令。它用于设置或清除文件系统级别的特殊属性，以增加文件的安全性或保护文件免受意外修改</p><p><code>lsattr</code> 显示特定属性</p><p><code>chattr +i filename</code> 不能删除，改名，更改</p><p><code>chattr -i filename</code> 清除文件的不可修改属性</p><p><code>chattr +a filename</code> 只能追加内容</p><p><code>chattr -a filename</code> 清除文件的只追加属性</p><h1 id="6-ACL权限管理"><a href="#6-ACL权限管理" class="headerlink" title="6. ACL权限管理"></a>6. ACL权限管理</h1><p>传统权限是根据所有者，所属者和其它人这三种进行设置的，这种设置方法非常不灵活</p><p>如要实现除了wang用户不能访问文件file1外，其他用户都可以访问，则传统的权限管理无法实现</p><p><strong>ACL权限</strong></p><p>Access Control List，实现灵活的权限管理。ACL功能允许对文件和目录进行更精细的权限控制，可以对用户或用户组进行个别授权，实现细粒度的访问控制</p><p>CentOS7默认创建的 xfs 和 ext 文件系统具有ACL功能</p><p>CentOS7之前版本，默认手工创建的ext4文件系统无ACL功能，需手动增加</p><p>ACL生效顺序：所有者，自定义用户，自定义组，其他人</p><p><code>getfacl [option] file/directory</code>命令用于获取ACL权限</p><ul><li><code>-R</code>：递归地获取ACL规则，包括文件夹及其内容</li></ul><p><code>setfacl [option] [permissions] file/directory</code>命令用于设置ACL权限</p><ul><li><code>-m</code>：修改ACL规则。</li><li><code>-x</code>：移除ACL规则。</li><li><code>-R</code>：递归地应用ACL规则到文件夹及其内容。</li></ul><p>常用的命令：</p><ul><li><code>setfacl -m u:wang:rwx file|directory</code></li><li><code>setfacl -Rm g:sales:rwX directory</code></li><li><code>setfacl -M file.acl file|directory</code></li><li><code>setfacl -m g:salesgroup:rw file|directory</code></li><li><code>setfacl -m d:u:wang:rx directory</code></li><li><code>setfacl -x u:wang file|directory</code></li><li><code>setfacl -X file.acl directory</code></li></ul><p>getfacl 可看到特殊权限：flags</p><p>通过ACL赋予目录默认x权限，目录内文件也不会继承x权限base ACL不能删除</p><p><code>setfacl -k dir</code> 删除默认ACL权限<br><code>setfacl -b file1</code>清除所有ACL权限</p><p><strong>mask权限</strong></p><p>对最高权限的限制，超过mask权限的其他权限将失效</p><p>ACL文件上的group权限是mask值（自定义用户，自定义组，拥有组的最大权限），而非传统的组权限</p><p>mask只影响除所有者和other的之外的人和组的最大权限</p><p>Mask需要与用户的权限进行逻辑与运算后，才能变成有限的权限(EffectivePermission)</p><p>用户或组的设置必须存在于mask权限设定范围内才会生效</p><p><strong>备份和恢复ACL</strong></p><p>主要的文件操作命令<code>cp</code>和<code>mv</code>都支持ACL，只是<code>cp</code>命令需要加上<code>-p</code>参数。但是<code>tar</code>等常见的备份工具是不会保留目录和文件的ACL信息</p><p>备份<code>getfacl -R /tmp/dir1 &gt; acl.txt</code></p><p>还原<code>setfacl --restore acl.txt</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-12-JWT%E8%AF%A6%E8%A7%A3/"/>
      <url>/2024/10/28/2023-10-12-JWT%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念区分"><a href="#1-概念区分" class="headerlink" title="1. 概念区分"></a>1. 概念区分</h1><p><strong>JWT</strong><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;none&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p><strong>JWS</strong> a signed JWT</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>JWE</strong> a fully-encrypted JWT</p><p>Signature </p><h1 id="2-JWT-的原理"><a href="#2-JWT-的原理" class="headerlink" title="2. JWT 的原理"></a>2. JWT 的原理</h1><p>客户端发送账号密码到服务器，服务器认证以后，生成一个 JSON 对象，发回给用户</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;姓名&quot;</span><span class="punctuation">:</span> <span class="string">&quot;张三&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;角色&quot;</span><span class="punctuation">:</span> <span class="string">&quot;管理员&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;到期时间&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2018年7月1日0点0分&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止JSON 对象被篡改，服务器在生成这个对象的时候，会加上签名</p><h1 id="3-JWT-的数据结构"><a href="#3-JWT-的数据结构" class="headerlink" title="3. JWT 的数据结构"></a>3. JWT 的数据结构</h1><p><a href="https://jwt.io/">在线JWT解析</a></p><p>JWT 的三个部分依次如下</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Header</span>.<span class="property">Payload</span>.<span class="property">Signature</span></span><br></pre></td></tr></table></figure><p>它是一个很长的字符串，中间用点<code>.</code>分隔成三个部分。注意，JWT 内部是没有换行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure><p><strong>Header</strong></p><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据</p><ul><li><code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）</li><li><code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;alg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HS256&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;typ&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JWT&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串</p><p><strong>Payload</strong></p><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>除了官方字段，你还可以在这个部分定义私有字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1234567890&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;John Doe&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;admin&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串</p><p><strong>Signature</strong></p><p>Signature 部分是对前两部分的签名，防止数据篡改</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”<code>.</code>分隔，就可以返回给用户。</p><p><strong>Base64URL</strong></p><p>Base64URL算法跟 Base64 算法基本类似，但有一些小的不同</p><p>JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 <code>api.example.com/?token=xxx</code>）。Base64 有三个字符<code>+</code>、<code>/</code>、<code>=</code>，在 URL 里面有特殊含义，所以要被替换掉<code>=</code>被省略、<code>+</code>替换成<code>-</code>，<code>/</code>替换成<code>_</code> 。这就是 Base64URL 算法。</p><h1 id="4-JWT-的使用方式"><a href="#4-JWT-的使用方式" class="headerlink" title="4. JWT 的使用方式"></a>4. JWT 的使用方式</h1><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</p><p>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<code>Authorization</code>字段里 <code>Authorization: Bearer &lt;token&gt;</code></p><p>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h1 id="5-JWT-的几个特点"><a href="#5-JWT-的几个特点" class="headerlink" title="5. JWT 的几个特点"></a>5. JWT 的几个特点</h1><ul><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-10-12-Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/28/2023-10-12-Linux%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-无类域间路由CIDR"><a href="#1-无类域间路由CIDR" class="headerlink" title="1. 无类域间路由CIDR"></a>1. 无类域间路由CIDR</h1><p>跨网段通信必须通过路由器（网关）</p><p>有类：A类、B类、C类、D类、E类，主机位数和网络位数是确定的</p><p>无类：主机位数和网络位数是不确定的</p><p>子网掩码（netmask）：因为是无类的，所以需要知道主机位数和网络位数的情况，由此诞生子网掩码</p><p>CIDR 无类域间路由表示法：<code>IP/网络ID位数</code></p><p><strong>常用公式</strong></p><p>网络（网段）数量=2^可变网络ID位数</p><p>一个网络的主机数量=2^主机ID位数-2</p><p>网络ID = IP与子网掩码相与</p><p><strong>判断是否在同一网段下</strong></p><p>A：192.168.1.100/16<br>B：192.168.2.100/24</p><ul><li>从A的角度去判断B是否和A在同一网段：</li></ul><p>192.168.1.100和A的子网掩码16相与，得到192.168.0.0</p><p>192.168.2.100和A的子网掩码16相与，得到192.168.0.0</p><p>在同一网段</p><ul><li>从B的角度去判断A是否和B在同一网段：</li></ul><p>192.168.2.100和B的子网掩码24相与，得到192.168.2.0</p><p>192.168.1.100和B的子网掩码24相与，得到192.168.1.0</p><p>不在同一网段</p><h1 id="2-网络管理"><a href="#2-网络管理" class="headerlink" title="2. 网络管理"></a>2. 网络管理</h1><p><strong>划分子网</strong></p><p>将一个大网络划分成多个小网络</p><p>10.0.0.0/8 划分32个子网给32个省公司使用，则</p><pre><code>新的子网掩码：255.248.0.0新的子网的最小网络和最大网络：10.0.0.0/13、10.248.0.0/13新的子网存放最多的主机数：2^19=52万 </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-22-Linux%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2023-09-22-Linux%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-主机信息配置"><a href="#1-主机信息配置" class="headerlink" title="1. 主机信息配置"></a>1. 主机信息配置</h1><p><strong>主机名</strong></p><p>终端命令窗口中<code>user@主机名</code></p><p><strong>网络设置</strong></p><p>网卡：eth0 （ethernet 以太网）</p><p><strong>时区</strong></p><p>上海时间</p><p><strong>安装过程可以使用的命令</strong></p><p>F1、F2、F3、F4、F5、F6</p><h1 id="2-安装系统"><a href="#2-安装系统" class="headerlink" title="2. 安装系统"></a>2. 安装系统</h1><p><strong>安装系统</strong></p><p>生产环境中一般选择最小安装Minimal</p><p><strong>启动过程</strong></p><p>按下esc键显示详细加载过程</p><p><strong>系统备份</strong></p><p>直接复制整个文件夹</p><p>打开备份的虚拟机时，提示移动还是复制，要选择移动</p><p><strong>用户类型</strong></p><p>普通用户 <code>$</code>，root用户<code>#</code></p><h1 id="3-Linux基本操作"><a href="#3-Linux基本操作" class="headerlink" title="3. Linux基本操作"></a>3. Linux基本操作</h1><p><strong>系统的运行模式</strong></p><ul><li>Linux中图形界面只是个软件，可用可不用，<code>runlevel</code> 查看运行模式</li><li><code>init 3</code> 切换为纯字符模式</li><li><code>init 5</code> 切换为图形模式（需要再登录）</li><li><code>startx</code> 开启图形软件（不需要再登录）</li><li><code>init 0</code> 关机</li><li><code>init 6</code> 重启</li><li><code>Ctrl + Alt + F[1-6]</code> 临时新建终端，可实现多用户登录</li><li><code>Ctrl + Alt + F1</code> 返回图形界面</li><li><code>tty</code> 查看当前所在终端的编号</li></ul><p><strong>网卡</strong></p><p>启动网卡 <code>nmcli connection modifyens33connection.autoconnect yes</code></p><p><strong>用户登录</strong></p><ul><li><p>超级管理员用户（一般是root用户）</p><p>  超级管理员已接近完整的系统控制</p><p>  对系统损害几乎有无限的能力</p><p>  除非必要，不要登录为root</p></li><li><p>普通用户</p><p>  权限有限</p><p>  造成损害的能力比较有限</p><p>  通过 uid 判断用户类型，<code>id -u</code>，超级管理员 uid 为 0</p><p>  切换用户 <code>su 用户名</code></p></li></ul><p><strong>终端terminal</strong></p><ul><li><p>设备终端</p><p>  键盘、鼠标、显示器</p></li><li><p>物理终端（/dev/console ）</p><p>  控制台console</p></li><li><p>虚拟终端（tty：teletypewriters，/dev/tty# <code>#</code>为<code>[1-6]</code>）</p><p>  tty可有n个，<code>Ctrl+Alt+F[1-6]</code></p></li><li><p>图形终端(/dev/tty7 ) startx，xwindows</p><p>  CentOs 6：<code>Ctrl + Alt + F7</code></p><p>  CentOS7：在哪个终端启动，即位于哪个虚拟终端</p></li><li><p>串行终端（/dev/ttyS# )</p><p>  ttyS</p></li><li><p>伪终端（ pty：pseudo-tty，/dev/pts/# )</p><p>  pty，SSH远程连接</p></li><li><p>查看当前的终端设备</p><p>  tty</p></li></ul><p><strong>查看命令行历史</strong></p><p><code>history</code></p><p><strong>交互式接口</strong></p><ul><li><p>GUI：Graphic User Interface</p><p>  x protocol，window manager，desktop</p><p>  Desktop：GNOME（C，图形库gtk），KDE（C++，图形库qt），XFCE（轻量级桌面）</p></li><li><p>CLl：Command Line Interface</p><p>  shell程序：sh（bourn史蒂夫·伯恩） csh tcsh ksh (korn)bash (bournagain shell)GPL zsh</p><p>  查看Linux内核版本<code>uname -r</code></p><p>  查看系统版本<code>cat /etc/centos-release</code></p><p>  查看cpu <code>lscpu</code></p><p>  查看内存 <code>free -h</code></p><p>  查看磁盘 <code>lsblk</code></p><p>  查看网卡<code>mii-tool 网卡名</code></p><p>  查看主机名 <code>hostname</code></p><p>  查看当前终端登录情况<code>who am i</code></p><p>  查看当前系统的登录用户 <code>who</code></p><p>  退出登录用户<code>exit</code> 或<code>logout</code></p></li></ul><p><strong>shell</strong></p><p>Shell是Linux系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行</p><p>shell也被称为LINUX的命令解释器（command interpreter）shell是一种高级程序设计语言</p><p>shell指令是区分大小写的</p><p>将命令转为二进制数据供计算机执行，重点学习bash shell</p><p>查看系统支持的shell类型 <code>cat /etc/shells</code> </p><p>查看系统使用的shell类型 <code>echo $SHELL</code></p><p>清空终端内容<code>clear</code></p><p><strong>命令提示符</strong></p><ul><li><p><code>[root@localhost ~]#</code> </p><p>  管理员<code>#</code>，普通用户<code>$</code></p></li><li><p>显示提示符格式</p><p>  <code>echo $PS1</code></p></li><li><p>修改提示符格式</p><p>  保存到文件中永久生效 <code>nano /etc/profile.d/env.sh</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS1=&quot;\[\e[1;5;41;33m\][\u@\h \W]\\$\[\e[0m\]&quot;</span><br><span class="line"></span><br><span class="line">黄色 PS1=&quot;\[\e[33m\][\u@\h \W]\\$ \[\e[0m\]&quot;</span><br><span class="line"></span><br><span class="line">绿色PS1=&quot;\[\e[32m\][\u@\h \W]\\$ \[\e[0m\]&quot;</span><br><span class="line"></span><br><span class="line">红色PS1=&quot;\[\e[31m\][\u@\h \W]\\$ \[\e[0m\]&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\e \033</span><br><span class="line">\u当前用户</span><br><span class="line">\h主机名简称</span><br><span class="line">\H主机名</span><br><span class="line">lw当前工作目录</span><br><span class="line">\W当前工作目录基名</span><br><span class="line">\t 24小时时间格式</span><br><span class="line">\T 12小时时间格式</span><br><span class="line">\!命令历史数</span><br><span class="line">\#开机后命令历史数</span><br></pre></td></tr></table></figure><p><strong>登录提示</strong></p><p><code>vi /etc/motd</code> 登录后会提示<code>motd</code>文件中的内容</p><h1 id="4-Linux命令执行过程"><a href="#4-Linux命令执行过程" class="headerlink" title="4. Linux命令执行过程"></a>4. Linux命令执行过程</h1><p><strong>执行命令</strong></p><ul><li><p>输入命令后回车</p><p>  提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来</p></li><li><p>在shell中可执行的命令有两类</p><ul><li><p>内部命令：由shell自带的，而且通过某命令形式提供，在磁盘中没有对应文件，不同类型的shell有各自不同的内部命令</p><p>  <code>help</code> 内部命令列表</p><p>  <code>enable cmd</code>启用内部命令</p><p>  <code>enable -n cmd</code>禁用内部命令</p><p>  <code>enable -n</code>查看所有禁用的内部命令</p></li><li><p>外部命令：在文件系统路径下有对应的可执行程序文件</p><p>  查看路径：<code>which</code>、<code>whereis</code></p></li></ul></li><li><p>判断命令是内部或外部命令</p><p>  <code>type [command]</code></p></li><li><p>Hash缓存表</p><p>  系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率</p></li><li><p>hash常见用法</p><p>  <code>hash</code>显示hash缓存</p><p>  <code>hash -l</code>显示hash缓存，可作为输入使用</p><p>  <code>hash -p path name</code>将命令全路径path起别名为name</p><p>  <code>hash -t name</code>打印缓存中name的路径</p><p>  <code>hash -d name</code>清除name缓存</p><p>  <code>hash -r</code> 清除缓存</p></li><li><p>执行时的查找顺序</p><p>  内部命令 -&gt; hash表 -&gt; <code>$PATH</code> -&gt; 命令找不到</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-30-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/10/28/2023-09-30-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-第一章-计算机系统概述"><a href="#1-第一章-计算机系统概述" class="headerlink" title="1. 第一章 计算机系统概述"></a>1. 第一章 计算机系统概述</h1><h1 id="2-第二章-进程与线程"><a href="#2-第二章-进程与线程" class="headerlink" title="2. 第二章 进程与线程"></a>2. 第二章 进程与线程</h1><h1 id="3-第三章-内存管理"><a href="#3-第三章-内存管理" class="headerlink" title="3. 第三章 内存管理"></a>3. 第三章 内存管理</h1><h1 id="4-第四章-文件管理"><a href="#4-第四章-文件管理" class="headerlink" title="4. 第四章 文件管理"></a>4. 第四章 文件管理</h1><h1 id="5-第五章-IO管理"><a href="#5-第五章-IO管理" class="headerlink" title="5. 第五章 IO管理"></a>5. 第五章 IO管理</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-24-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/10/28/2023-09-24-Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Linux基本命令1"><a href="#1-Linux基本命令1" class="headerlink" title="1. Linux基本命令1"></a>1. Linux基本命令1</h1><p><strong>命令别名</strong></p><ul><li><p>显示当前shell进程所有可用的命令别名</p><p>  <code>alias</code></p></li><li><p>定义别名NAME，其相当于执行命令VALUE</p><p>  <code>alias NAME=&#39;VALUE&#39;</code></p></li><li><p>在命令行中定义的别名，仅对当前shell进程有效如果想永久有效，要定义在配置文件中</p><p>  仅对当前用户：<code>~/.bashrc</code></p><p>  对所有用户有效：<code>/etc/bashrc</code></p></li><li><p>bash进程重新读取配置文件</p><p>  <code>source [filename]</code> 通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录</p></li><li><p>撤销别名</p><p>  <code>unalias</code></p></li><li><p>如果别名同原命令重名，如果要执行原命令，可使用</p><p>  <code>\ALIASNAME</code>、<code>&quot;ALIASNAME&quot;</code>、<code>&#39;ALIASNAME&#39;</code></p></li></ul><p><strong>命令格式</strong></p><p><code>command [options.….][argument...]</code></p><ul><li><p>选项</p><p>  用于启用或关闭命令的某个或某些功能</p><p>  长格式选项 <code>--all</code></p><p>  短格式选项 <code>-a</code></p></li><li><p>参数</p><p>  命令的作用对象，比如文件名，用户名等</p></li></ul><p><strong>注意</strong></p><ul><li>多个选项以及多参数和命令之间使用空白字符分隔</li><li>取消和结束命令执行：Ctrl+c，Ctrl+d</li><li>多个命令可以用<code>;</code>符号分开</li><li>较长的命令可以使用 <code>\</code>拼接换行写</li></ul><p><strong>日期和时间</strong></p><p>非常重要可以清楚系统什么时间发生了什么事</p><ul><li><p>Linux的两种时钟</p><p>  系统时钟：由Linux内核通过CPU的工作频率进行的</p><p>  硬件时钟：主板</p></li><li><p>date 显示和设置系统时间</p><p>  <code>date -d</code></p><p>  <code>hwclock</code>、<code>clock</code> 显示硬件时钟</p><p>  <code>-s</code>，<code>--hctosys</code> 以硬件时钟为准，校正系统时钟</p><p>  <code>-w</code>，<code>--systohc</code> 以系统时钟为准，校正硬件时钟</p><p>  查看当前时区<code>ll /etc/localtime</code></p><p>  查看所有时区<code>timedatectl list-timezones</code></p><p>  设置时区<code>timedatectl set-timezone Asia/Shanghai</code></p><p>  显示日历 <code>cal -y</code></p><p>  远程同步系统时钟<code>ntpdate ipaddress</code></p></li></ul><p><strong>简单命令</strong></p><ul><li>关机：<code>halt</code>，<code>poweroff</code></li><li>重启：<code>reboot</code><br><code>-f</code>：强制，不调用<code>shutdown</code><br><code>-p</code>：切断电源</li><li><p>关机或重启：<code>shutdown</code></p><p>  <code>shutdown [OPTION].…. [TIME] [MESSAGE]</code></p><p>  <code>-r：reboot</code></p><p>  <code>-h：halt</code></p><p>  <code>-c：cancel</code></p><p>  <code>TIME</code>：无指定，默认相当于+1 （CentOS7）</p><p>  <code>now</code>：立刻，相当于+0</p><p>  <code>+m</code>：相对时间表示法，几分钟之后例如＋3</p><p>  <code>hh:mm</code>：绝对时间表示，指明具体时间</p></li></ul><p><strong>用户登录信息查看命令</strong></p><p><code>whoami</code>：显示当前登录有效用户</p><p><code>who</code>：系统当前所有的登录会话</p><p><code>w</code>：系统当前所有的登录会话及所做的操作</p><p><code>nano</code>文本编辑</p><p><strong>screen命令</strong></p><p>创建新screen会话<code>screen -S [SESSION]</code></p><p>加入screen会话<code>screen -x [SESSION]</code></p><p>退出并关闭screen会话 <code>exit</code></p><p>剥离当前screen会话 <code>Ctrl+a+d</code></p><p>恢复某screen会话<code>screen -r [SESSION]</code></p><p>显示所有已经打开的screen会话<code>screen -ls</code></p><p>使用场景：</p><ul><li>多人加入同一终端会话，共同工作</li><li>在断网或重启之后重新恢复之前的终端工作状态</li></ul><p>连上远程主机后，先不要急于运行你的指令，而是先创建一个screen，然后在screen的虚拟终端里面运行你的指令，要断开连接之前先把screen挂起，下次连进来的时候你只需要重新连接你的screen，你会发现你的指令已经乖乖地执行完毕或者正在执行而不是被迫中断了</p><h1 id="2-Linux基本命令2"><a href="#2-Linux基本命令2" class="headerlink" title="2. Linux基本命令2"></a>2. Linux基本命令2</h1><p><strong>echo命令</strong></p><ul><li>功能：显示字符</li><li>说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开，并在最后加上换行号</li><li>选项：<br>  <code>-E</code>（默认）不支持<code>\</code>解释功能<br>  <code>-n</code>不自动换行<br>  <code>-e</code>启用<code>\</code>字符的解释功能</li><li>`  ` 可以识别命令</li><li>显示变量<br><code>echo &quot;$VAR_NAME&quot;</code>变量会替换，弱引用<br><code>echo &#39;$VAR_NAME&#39;</code>变量不会替换，强引用</li><li><p><code>-e</code></p><p>  启用命令选项<code>-e</code>，若字符串中出现以下字符，则特别加以处理，而不会将它当成—般文字输出</p><p>  <code>\a</code>发出警告声</p><p>  <code>\b</code> 退格键</p><p>  <code>\c</code>最后不加上换行符号</p><p>  <code>\n</code>换行且光标移至行首</p><p>  <code>\r</code>回车，即光标移至该行首，但不换行</p><p>  <code>\t</code>插入tab</p><p>  <code>\\</code>插入<code>\</code>字符</p><p>  <code>\0nnn</code>插入nnn（八进制）所代表的ASCIl字符</p><p>  <code>\xnnn</code>插入nnn（十六进制）所代表的ASCII数字</p></li></ul><p><strong>字符集和编码</strong></p><p>查看当前系统编码 <code>echo $LANG</code></p><ul><li><p>ASCII码：计算机内部，所有信息最终都是一个二进制值。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。ASCIl码一共规定了128个字符的编码，占用了一个字节的后面7位，最前面的一位统一规定为0</p></li><li><p>Unicode：用于表示世界上所有语言中的所有字符。每一个符号都给予一个独一无二的编码数字，Unicode是一个很大的集合，现在的规模可以容纳100多万个符号。Unicode仅仅只是一个字符集，规定了每个字符对应的二进制代码至于这个二进制代码如何存储则没有规定</p></li><li><p>Unicode编码方案：</p><p>  UTF-8：变长，1到4个字节</p><p>  UTF-16：变长，2或4个字节</p><p>  UTF-32：固定长度，4个字节</p></li></ul><p>UTF-8是目前互联网上使用最广泛的一种Unicode编码方式，可变长存储。使用1-4个字节表示一个字符，根据字符的不同变换长度。</p><p>编码规则如下：对于单个字节的字符，第一位设为0，后面的7位对应这个字符的 Unicode码。因此，对于英文中的0 - 127号字符，与ASCIl码完全相同。这意味着ASCII码的文档可用UTF-8编码打开。对于需要使用N个字节来表示的字符（N&gt;1），第一个字节的前N位都设为1，第N＋1位设为0，剩余的N-1个字节的前两位都设为10，剩下的二进制位则使用这个字符的Unicode码来填充</p><p><strong>命令行扩展、被括起来的集合（重点）</strong></p><ul><li><p>命令行扩展：<code>$()</code>或``</p><p>  把一个命令的输出打印给另一个命令的参数</p></li><li><p>括号扩展：<code>&#123;&#125;</code></p><p>  打印重复字符串的简化形式</p><p>  <code>echo file&#123;1,3,5&#125;</code> 结果为：<code>file1 file3 file5rm -f file&#123;1,3,5&#125;</code></p><p>  <code>echo &#123;000..20..2&#125;</code></p></li></ul><h1 id="3-Linux基本命令3"><a href="#3-Linux基本命令3" class="headerlink" title="3. Linux基本命令3"></a>3. Linux基本命令3</h1><p><strong>tab键</strong></p><ul><li><p>命令补全</p><p>  用户给定的字符串只有一条唯一对应的命令直接补全，否则再次Tab会给出列表</p><p>  内部命令：</p><p>  外部命令：bash根据<code>$PATH</code>环境变量定义的路径，自左而右在每个路径搜寻以给定命令命名的文件，第一次找到的命令即为要执行的命令</p></li><li><p>路径补全</p><p>  把用户给出的字符串当做路径开头，并在其指定上级目录下搜索以指定的字符串开头的文件名</p><p>  如果唯一：则直接补全</p><p>  否则：再次Tab给出列表</p></li></ul><p><strong>获得帮助</strong></p><ul><li><code>whatis command</code> 显示命令的简短描述</li><li><code>command --help</code> </li><li><code>man</code> 或 <code>info</code></li><li><code>/usr/share/doc/</code></li></ul><p><strong>命令帮助（重点）</strong></p><ul><li><p>内部命令：</p><p>  <code>help COMMAND</code> 或 <code>man bash</code></p></li><li><p>外部命令：</p><p>  <code>COMMAND --help</code>、<code>COMMAND -h</code></p><p>  使用手册（manual）</p><pre><code>  `man COMMAND`</code></pre><p>  信息页</p><pre><code>  `info COMMAND`</code></pre></li></ul><p><strong>命令历史</strong></p><p><code>history</code></p><p>终端的命令历史记录在内存中，当用户正常退出时，会保存在该用户目录下的<code>.bash_history</code>文件中</p><p>查看记录命令的最大数量<code>echo $HISTSIZE</code></p><p><code>-c</code>：清空命令历史<br><code>-d offset</code>：删除历史中指定的第offset个命令<br><code>n</code>：显示最近的n条历史<br><code>-a</code>：追加本次会话新执行的命令历史列表至历史文件<br><code>-r</code>：读历史文件附加到历史列表<br><code>-w</code>：保存历史列表到指定的历史文件<br><code>-n</code>：读历史文件中未读过的行到历史列表<br><code>-p</code>：展开历史参数成多行，但不存在历史列表中<br><code>-s</code>：展开历史参数成一行，附加在历史列表后</p><p><strong>命令行历史</strong></p><p>重复前一个命令，有4种方法</p><ul><li>重复前一个命令使用上方向键，并回车执行</li><li>按<code>!!</code>并回车执行</li><li>输入<code>!-1</code>并回车执行</li><li>按<code>Ctrl+p</code>并回车执行</li><li><code>!:0</code>执行前一条命令（去除参数）</li><li>Ctrl + n显示当前历史中的下一条命令，但不执行</li><li>Ctrl + j执行当前命令</li><li><code>!n</code>执行history命令输出对应序号n的命令</li><li><code>!-n</code>执行history历史中倒数第n个命令</li></ul><ul><li><code>!string</code>重复前一个以“string”开头的命令</li><li><code>!?string</code>重复前一个包含string的命令</li><li><code>!string:p</code> 仅打印命令历史，而不执行</li><li><code>!$:p</code>打印输出<code>!$</code>（上一条命令的最后一个参数）的内容</li><li><code>!*:p</code>打印输出<code>!*</code>（上一条命令的所有参数）的内容</li><li><code>^string</code>删除上一条命令中的第一个string</li><li><code>^string1^string2</code>将上一条命令中的第一个string1替换为string2</li><li><code>!:gs/string1/string2</code>将上一条命令中所有的string1都替换为string2</li></ul><p><strong>调用历史参数</strong></p><ul><li><code>command !^</code>利用上一个命令的第一个参数做cmd的参数</li><li><code>command !$</code>利用上一个命令的最后一个参数做cmd的参数</li><li><code>command !*</code>利用上一个命令的全部参数做cmd的参数</li><li><code>command !:n</code>利用上一个命令的第n个参数做cmd的参数</li><li><code>command !n:^</code>调用第n条命令的第一个参数</li><li><code>command !n:$</code>调用第n条命令的最后一个参数</li><li><code>command !n:m</code>调用第n条命令的第m个参数</li><li><code>command !n:*</code>调用第n条命令的所有参数</li></ul><p><strong>命令历史相关环境变量</strong></p><ul><li><code>HISTSIZE</code>：命令历史记录的条数</li><li><code>HISTFILE</code>：指定历史文件，默认为<code>~/.bash_history</code></li><li><code>HISTFILESIZE</code>：命令历史文件记录历史的条数</li><li><code>HISTTIMEFORMAT=&quot;%F %T&quot;</code>显示时间</li><li><code>HISTIGNORE=&quot;str1:str2*:...&quot;</code>忽略str1命令，str2开头的历史</li><li>控制命令历史的记录方式：</li></ul><p>环境变量：<code>HISTCONTROL</code></p><p><code>ignoredups</code> 默认，忽略重复的命令，连续且相同为”重复”</p><p><code>ignorespace</code> 忽略所有以空白开头的命令</p><p><code>ignoreboth</code> 相当于<code>ignoredups</code>和 <code>ignorespace</code>的组合</p><p><code>erasedups</code>删除重复命令</p><ul><li><code>export变量名=&quot;值&quot;</code></li><li>存放在<code>/etc/profile</code>或<code>~/.bash_profile</code></li></ul><h1 id="4-Linux基本命令4"><a href="#4-Linux基本命令4" class="headerlink" title="4. Linux基本命令4"></a>4. Linux基本命令4</h1><p><strong>man命令</strong></p><ul><li>提供命令帮助的文件</li><li>手册页存放在<code>/usr/share/man</code></li><li><p>man页面分组为不同的”章节”</p><p>  1：用户命令</p><p>  2：系统调用</p><p>  3：C库调用</p><p>  4：设备文件及特殊文件</p><p>  5:配置文件格式</p><p>  6：游戏</p><p>  7：杂项</p><p>  8：管理类的命令</p><p>  9：Linux内核API</p></li><li><p>man命令的配置文件：<code>/etc/man.config 、 man_db.conf</code></p></li><li><code>MANPATH /PATH/TO/SOMEWHERE</code>：指明man文件搜索位置</li><li><code>man -M /PATH/TO/SOMEWHERE COMMAND</code>：到指定位置下搜索COMMAND命令的手册页并显示</li><li>中文man需安装包<code>man-pages-zh-CN</code></li><li>帮助手册中的段落说明：</li></ul><p><strong>man帮助段落说明（重点）</strong></p><p>SYNOPSIS用法格式说明：</p><pre><code>`[]`可选内容`&lt;&gt;`必选内容`a|b`二选一`&#123; &#125;`分组`...`同一内容可出现多次</code></pre><p><strong>man帮助</strong></p><ul><li>查看man手册页<br>  <code>man [章节] keyword</code></li><li>列出所有帮助<br>  <code>man -a keyword</code></li><li><p>搜索man手册<br>  <code>man -k keyword</code> 列出所有匹配的页面</p><p>  使用<code>whatis</code>数据库</p></li><li>相当于whatis<br>  <code>man -f keyword</code></li><li>打印man帮助文件的路径<br>  <code>man -w [章节] keyword</code></li></ul><p><strong>man搜索</strong></p><ul><li><p><code>/KEYWORD</code>：<br>  以KEYWORD指定的字符串为关键字，从当前位置向文件尾部搜索，不区分字符大小写</p><p>  n：下一个</p><p>  N：上一个</p></li><li><p><code>?KEYWORD</code>：<br>  以KEYWORD指定的字符串为关键字，从当前位置向文件首部搜索，不区分字符大小写</p><p>  n：跟搜索命令同方向，下一个</p><p>  N：跟搜索命令反方向，上一个</p></li></ul><p><strong>info</strong></p><ul><li>man常用于命令参考，GNU工具info适合通用文档参考</li><li>没有参数列出所有的页面</li><li>info页面的结构就像一个网站</li><li>每一页分为“节点”</li><li>链接节点之前<code>*</code></li><li><code>info[命令]</code></li></ul><p><strong>导航info页</strong></p><ul><li>方向键，PgUp，PgDn导航</li><li>Tab键移动到下一个链接</li><li>d显示主题目录</li><li>Home显示主题首部</li><li>Enter进入选定链接</li><li><code>n/p/u/l</code>进入下/前/上一层/最后一个链接</li><li>s文字文本搜索</li><li>q退出info</li></ul><p><strong>通过本地文档获取帮助</strong></p><p><code>/usr/share/doc</code>目录</p><p>多数安装了的软件包的子目录，包括了这些软件的相关原理说明</p><p>常见文档：README INSTALL CHANGES</p><h1 id="5-Linux基本命令5"><a href="#5-Linux基本命令5" class="headerlink" title="5. Linux基本命令5"></a>5. Linux基本命令5</h1><p><strong>bash的快捷键</strong></p><ul><li>Ctrl+l清屏，相当于clear命令</li><li>Ctrl + o 执行当前命令，并重新显示本命令</li><li>Ctrl + s阻止屏幕输出，锁定</li><li>Ctrl + q允许屏幕输出</li><li>Ctrl + c终止命令</li><li>Ctrl +z挂起命令</li><li>Ctrl + a光标移到命令行首，相当于Home</li><li>Ctrl + e光标移到命令行尾，相当于End</li><li>Ctrl + f光标向右移动一个字符</li><li>Ctrl + b光标向左移动一个字符</li><li>Alt + f光标向右移动一个单词尾</li><li>Alt + b光标向左移动一个单词首</li><li>Ctrl + xx光标在命令行首和光标之间移动</li><li>Ctrl + u从光标处删除至命令行首</li><li>Ctrl + k从光标处删除至命令行尾</li><li>Alt +r删除当前整行</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-26-Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/10/28/2023-09-26-Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-文件目录结构"><a href="#1-文件目录结构" class="headerlink" title="1. 文件目录结构"></a>1. 文件目录结构</h1><p><strong>标准目录结构</strong></p><p>以下结构几乎适用于所有Linux系统</p><ul><li><code>boot</code> 文件中存放的是和启动相关的内容</li><li><code>dev</code> 文件存放的是设备相关内容，如硬盘、光盘、null 等</li><li><code>etc</code> 文件是用来存放一些重要的配置文件，它的作用基本等价于 windows 系统中注册表的作用。因此管理 linux 主要就是在改 etc 中的各种设置</li><li><code>home</code> 文件存放的是用户的数据</li><li><code>run</code> 文件存放的是运行中生成的相关数据</li><li><code>bin（binary）</code> 文件存放的是用户可执行的二进制文件，而 <code>sbin</code> 文件存放的是系统管理员常用的工具</li><li><code>tmp</code> 文件是用来存放临时数据</li><li><code>usr</code> 文件存放的是大型的数据</li><li><code>var</code> 文件存放的是可变的内容，如日志、缓存数据等 </li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131043258.jpg" alt="QQ图片20240825131138"></p><p><strong>文件系统</strong></p><ul><li>文件和目录被组织成一个单根倒置树结构</li><li>文件系统从根目录下开始，用<code>/</code>表示</li><li>根文件系统（rootfs）：root filesystem</li><li>文件名称区分大小写（由文件系统决定的）。当文件系统是标准 Linux 文件系统时（Ext4、XFS），文件名大小写敏感。如果是 windows 文件系统（FAT），则文件名大小写不敏感</li><li>以<code>.</code>开头的文件为隐藏文件（使用<code>ll</code>命令的<code>-a</code>参数才能列出）</li><li>路径分隔用<code>/</code></li><li>文件有两类数据<ul><li>元数据（文件属性）：metadata</li><li>数据（文件内容）：data</li></ul></li><li>文件系统分层结构：LSB Linux Standard Base</li><li>FHS：（Filesystem Hierarchy Standard文件的分层结构标准）<a href="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/</a></li></ul><p>总之，文件的存放是有规则的而不可以随意存放，可以参照以上的标准目录存放对应的文件。</p><p><strong>文件名规则</strong></p><p><code>touch</code> 新建文件</p><ul><li>文件名最长255个字节</li><li>包括路径在内文件名称最长4095个字节</li><li><code>蓝色--&gt;目录；绿色--&gt;可执行文件；红色--&gt;打包文件；浅蓝色--&gt;链接文件（软链接）；灰色--&gt;其他文件</code>（需要注意的是，有时候文件后缀也会影响文件名的颜色，这在<code>/etc/DIR_COLORS</code>中都有定义）</li><li>除了斜杠和 NUL 所有字符都有效，但使用特殊字符的目录名和文件不推荐使用，有些字符需要用引号来引用它们</li></ul><p><strong>Linux上的应用程序的组成部分</strong></p><ul><li>二进制程序： <code>/bin, /sbin, /usr/bin, /usr/sbin, /usr/local/bin, /usr/local/sbin</code></li><li>库文件：<code>/lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64</code></li><li>配置文件：<code>/etc, /etc/DIRECTORY, /usr/local/etc</code></li><li>帮助文件：<code>/usr/share/man, /usr/share/doc, /usr/local/share/man,/usr/local/share/doc</code></li></ul><p><strong>Linux下的文件类型</strong></p><ul><li><code>-</code>普通文件</li><li><code>d</code>目录文件</li><li><code>b</code>块设备</li><li><code>c</code>字符设备</li><li><code>l</code>符号链接文件</li><li><code>p</code>管道文件pipe</li><li><code>s</code>套接字文件socket</li></ul><h1 id="2-文件目录命令"><a href="#2-文件目录命令" class="headerlink" title="2. 文件目录命令"></a>2. 文件目录命令</h1><p><strong>显示当前工作目录</strong></p><ul><li>每个 shell 和系统进程都有一个当前的工作目录 CWD（current work directory）</li><li><p>显示当前 shell CWD 的绝对路径 <code>pwd</code> （printing working directory）<br>  <code>-P</code> 显示真实物理路径</p><p>  <code>-L</code> 显示链接路径（默认）</p></li></ul><p><strong>绝对和相对路径</strong></p><ul><li><p>绝对路径</p><p>  以正斜杠开始<code>/</code></p><p>  完整的文件的位置路径</p></li><li><p>相对路径</p><p>  指定相对于当前工作目录或某目录的位置</p><p>  <code>.</code> 表示当前目录</p><p>  <code>..</code> 表示上一级目录</p></li><li><p>基名（文件本身的名字）：<code>basename</code> 取基名</p></li><li>目录名（文件所在文件夹的名字）：<code>dirname</code>取目录名</li></ul><p><strong>更改目录</strong></p><p><code>cd</code>（change directory）改变目录</p><ul><li>切换至当前用户的主目录（home） <code>cd</code></li><li>切换至以前的工作目录 <code>cd-</code></li><li>选项 <code>-P</code></li><li><p>相关的环境变量</p><p>  <code>$PWD</code> 当前目录路径</p><p>  <code>$OLDPWD</code> 上一次目录路径</p></li></ul><p><strong>列出目录内容</strong></p><p><code>ls [options] [files or dirs]</code> 列出当前目录的内容或指定目录</p><ul><li><code>-a</code> 包含隐藏文件</li><li><code>-l</code>  显示额外的信息</li><li><code>-R</code> 目录递归遍历</li><li><code>-ld</code> 目录和符链接信息</li><li><code>-1</code> 文件分行显示</li><li><code>-S</code> 按从大到小排序</li><li><code>-Sr</code> 按从小到大排序</li><li><code>-r</code> 倒序排</li><li><code>-t</code> 按 mtime（modify time 修改时间）排序</li><li><code>-u</code> 配合<code>-t</code> 选项，显示并按 atime（access time 访问时间）从新到旧排序</li><li><code>-U</code> 按目录存放顺序显示</li><li><code>-x</code> 按文件后缀排序</li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131043579.jpg" alt="QQ图片20240825130630"></p><p><strong>文件的三个时间</strong></p><p><code>stat [filename]</code> 查看文件的三个时间</p><ul><li><p>ctime 变化时间</p><p>  最后一次改变文件（属性或权限）或者目录（属性或权限）的时间</p></li><li><p>mtime 修改时间</p><p>  最后一次修改文件（内容）或者目录（内容）的时间</p></li><li><p>atime 访问时间</p><p>  最后一次访问文件（读取或执行）的时间</p></li></ul><p>这些信息都记录在文件中，所以每发生一次读事件就会发生一次写事件，通常可以关闭该信息的记录，以提高系统性能</p><h1 id="3-文件通配符"><a href="#3-文件通配符" class="headerlink" title="3. 文件通配符"></a>3. 文件通配符</h1><p>文件通配符解决的是文件名匹配的问题</p><ul><li><code>*</code> 匹配零个或多个字符</li><li><code>?</code> 匹配任何单个字符</li><li><code>~</code>当前用户家目录</li><li><code>~username</code> 某用户的家目录</li><li><code>[0-9]</code> 匹配数字范围</li><li><code>[a-z]</code> 字母</li><li><code>[A-Z]</code> 字母</li><li><code>[wang]</code> 匹配列表中的任何一个字符</li><li><code>[^wang]</code> 匹配除列表中字符以外的其他所有字符</li></ul><p><strong>预定义的字符类</strong></p><ul><li><code>[:digit:]:</code>任意数字，相当于<code>0-9</code></li><li><code>[:lower:]:</code>任意小写字母</li><li><code>[:upper:]:</code>任意大写字母</li><li><code>[:alpha:]:</code>任意大小写字母</li><li><code>[:alnum:]:</code>任意数字或字母</li><li><code>[:blank:]:</code>水平空白字符</li><li><code>[:space:]:</code>水平或垂直空白字符</li><li><code>[:punct:]:</code>标点符号</li><li><code>[:print:]:</code>可打印字符</li><li><code>[:cntrl:]:</code>控制（非打印）字符</li><li><code>[:graph:]:</code>图形字符</li><li><code>[:xdigit:]:</code> 十六进制字符</li></ul><p><strong>创建空文件和刷新时间</strong></p><p><code>touch 命令</code> </p><ul><li><p>格式：<code>touch [OPTION]... FILE...</code></p><p>  <code>-a</code> 仅改变 atime 和 ctime</p><p>  <code>-m</code> 仅改变 mtime 和 ctime</p></li></ul><h1 id="4-文件管理命令"><a href="#4-文件管理命令" class="headerlink" title="4. 文件管理命令"></a>4. 文件管理命令</h1><p><strong>复制文件和目录</strong></p><p>cp 命令只适合复制普通的文件，无法复制特殊文件（如硬盘文件等）</p><ul><li><code>cp [OPTION] SRC DEST</code></li></ul><p>cp常用选项</p><ul><li><code>-i</code>：覆盖前提示 </li><li><code>-n</code>：不覆盖</li><li><code>-r、-R</code>：递归复制目录及内部的所有内容</li><li><code>-a</code>：归档（备份），相当于<code>-dR --preserv=all</code>，复制文件的所有属性</li><li><code>-d</code>：<code>--no-dereference --preserv=links</code>不复制原文件，只复制链接名</li><li><p><code>--preserv[=ATTR_LIST]</code><br>  mode：权限</p><p>  ownership：属主属组</p><p>  timestamp:</p><p>  links</p><p>  xattr</p><p>  context</p><p>  all</p></li><li><code>-p</code>：等同<code>--preserv=mode,ownership,timestamp</code></li><li><code>-v</code>： <code>--verbose</code> 显示执行过程</li><li><code>-f</code>：<code>--force</code></li><li><code>-u</code>：<code>--update</code>只复制源比目标更新的文件或目标不存在的文件</li><li><code>-b</code>：目标存在，覆盖前先备份</li><li><code>--backup=numbered</code>目标存在，覆盖前先备份加数字后缀</li></ul><p><strong>移动和重命名文件</strong></p><ul><li><code>mv [OPTION] SRC DEST</code></li></ul><p>改名：<code>mv f1 f2</code></p><p>移动：<code>mv f1 /path/</code></p><p>边移动边改名：<code>mv /root/f2 /data/f3</code></p><p>常用选项</p><ul><li><code>-i</code>：交互式</li><li><code>-f</code>：强制</li><li><code>-b</code>：目标存在，覆盖前先备份</li></ul><p><strong>删除</strong></p><p>生产环境下使用mv命令代替rm命令，删除某个文件时，可以把某文件移动到回收文件夹下</p><p>删除文件，必须对文件所在目录有执行和写权限才能删除文件</p><p><code>rm [OPTION]... FILE...</code> 无论文件是否正在被使用都将被删除</p><p>常用选项</p><ul><li><code>-i</code> 交互式</li><li><code>-f</code>  强制删除</li><li><code>-r</code> 递归，rm 不能直接删文件夹，用<code>-r</code>就可以</li><li><code>--no-preserve-root</code> 删除/根目录</li></ul><p><strong>释放空间</strong></p><p>正在被使用的文件被删除后不会释放空间</p><p>查看已删除但是没有释放空间的文件 <code>lsof |grep deleted</code></p><p>对于正在被使用的文件的删除，应先清空文件<code>&gt; filename</code>，再删除<code>rm filename</code></p><p><strong>&gt;的用法</strong></p><p><code>&gt; filename</code> 可以创建一个空文件，如果文件名存在则会覆盖并清空此文件</p><p> <code>&gt;&gt; filename</code> 如果文件名不存在，则创建一个新的空文件；如果文件名存在，原封不动，相较于<code>&gt; filename</code> 更加安全</p><p><strong>文件备份</strong></p><p><code>cp file&#123;,.bak&#125;</code> 等价于 <code>cp file file.bak</code>，前者比后者的好处在于当文件名很长时，前者更节省时间</p><p><strong>文件改名命令</strong></p><p><code>rename</code> 命令可以批量改名</p><p><strong>以- ～开头的文件</strong></p><p>创建并删除以<code>-</code>开头的文件</p><ul><li><code>touch -- -a</code></li><li><code>rm -- -a</code></li></ul><p>创建并删除以<code>～</code>开头的文件</p><ul><li><code>touch &#39;~wang&#39;</code> </li><li><code>rm &#39;~wang&#39;</code></li></ul><p><strong>目录操作</strong></p><p><code>mkdir</code> 创建目录</p><ul><li><code>-p</code>：存在于不报错，且可自动创建所需的各目录</li><li><code>-v</code>：显示详细信息</li><li><code>-m MODE</code>：创建目录时直接指定权限</li></ul><p><code>rmdir</code> 删除空目录</p><ul><li><code>-p</code>：递归删除父空目录</li><li><code>-v</code>：显示详细信息</li></ul><p><code>rmdir</code> 只能删除空目录</p><h1 id="5-节点表结构"><a href="#5-节点表结构" class="headerlink" title="5. 节点表结构"></a>5. 节点表结构</h1><p><strong>索引节点</strong></p><p>inode（index node）包含一个文件的元数据，详细请看《操作系统》</p><p>inode是相对于分区而言的，同一分区下，inode编号是唯一的</p><p>查看文件的节点编号<code>ll -i</code></p><p>空间不足的两种情况：</p><ul><li>索引节点编号用完了</li><li>磁盘空间用完了</li></ul><p>rm命令本质是释放inode编号，使编号可以被重用，并把数据块放在空闲列表中，删除目录项，数据实际上不会马上被删除，但当另一个文件使用数据块时将被覆盖</p><h1 id="6-软链接和硬链接"><a href="#6-软链接和硬链接" class="headerlink" title="6. 软链接和硬链接"></a>6. 软链接和硬链接</h1><p><strong>硬链接</strong></p><ul><li>本质是对一个文件，起多个名字 <code>ln filename1 filename2</code></li><li>硬链接不能跨分区</li><li>inode 是同一个</li><li>只支持文件</li></ul><p><strong>软链接</strong></p><ul><li>本质是一个指针 <code>ln -s filename1 filename2</code></li><li>inode 不同</li><li>支持文件和文件夹</li><li>支持跨分区</li><li>原始文件一般路径用相对路径，相对路径一定相对于软链接文件的路径</li></ul><p><strong>重置</strong></p><p><code>reset</code> 当终端窗口乱码后执行</p><p><strong>file命令</strong></p><p><code>file [options] &lt;filename&gt; ...</code>查看文件类型，使用<code>cat</code>命令查看前，检查一下文件是什么类型的，直接查看非文本文件可能导致终端乱码</p><ul><li><code>-b</code>列出文件辨识结果时，不显示文件名称</li><li><code>-f</code> filelist列出文件filelist中文件名的文件类型</li><li><code>-F</code>使用指定分隔符号替换输出文件名后默认的<code>:</code>分隔符</li><li><code>-L</code>查看对应软链接对应文件的文件类型</li><li><code>--help</code> 显示命令在线帮助</li></ul><h1 id="7-I-O重定向"><a href="#7-I-O重定向" class="headerlink" title="7. I/O重定向"></a>7. I/O重定向</h1><p><strong>Linux 默认给程序提供三种 I/O 设备</strong></p><ul><li>标准输入（STDIN） 0 ，默认接受来自键盘的输入</li><li>标准输出（STDOUT） 1 ，默认输出到终端窗口</li><li>标准错误（STDERR） 2 ，默认输出到终端窗口</li></ul><p>在 Linux 中通常将键盘作为输入设备，而输出通常在终端窗口实现。</p><p>输入、输出、错误也都有对应的文件来表示。这里的错误指的是当我们执行一个错误指令，程序通过终端窗口弹出的错误信息。</p><p>对每一个在Linux里面打开的文件，系统都会分配一个数字，这个数字被称为文件描述符。这个数字代表着打开的文件，而我们用来输入的设备也是一个打开的文件，用0来表示。输出的设备用1来表示，输出的错误用2来表示。</p><p><strong>打开的文件都有一个fd（file descriptor文件描述符）</strong></p><p>若想查看文件或进程对应的数字，可以进入 proc 目录下对应数字的目录，目录中的fd代表了文件描述符</p><p><strong>把标准输出重新定向到文件</strong></p><p><code>1&gt;</code> 文件内容会被覆盖</p><p><code>set +C</code> 允许覆盖</p><p><code>set -C</code> 禁止将内容覆盖已有文件，但可追加</p><p><code>1&gt;|</code> 文件内容会被强制覆盖</p><p><code>1&gt;&gt;</code> 原有内容基础上，追加内容</p><p><strong>把标准错误重新定向到文件</strong></p><p><code>2&gt;</code> 文件内容会被覆盖</p><p><code>2&gt;|</code> 文件内容会被强制覆盖</p><p><code>2&gt;&gt;</code> 原有内容基础上，追加内容</p><p><strong>把标准输出和错误重新定向到文件</strong></p><p><code>&amp;&gt;</code>把标准输出和错误重定向到文件</p><p>要隐藏（）标准输出和标准错误信息，可以重定向到 <code>/dev/null</code></p><p>多条命令的重定向 <code>(command1;command2) &gt; file.log</code></p><p><strong>把标准输入重定向到文件</strong></p><p><code>&lt;</code> 单行重定向</p><p><code>&lt;&lt;</code> 多行重定向，<code>&lt;&lt;EOF</code> 通常以EOF（end of file）作为多行重定向的开始和结束的标志</p><p><strong>转换和删除字符</strong></p><p><code>tr [OPTION].. SET1 [SET2]</code> 默认从标准输入获取数据</p><ul><li><code>-c</code> 取字符集的补集</li><li><code>-d</code> 删除所有属于第一字符集的字符</li><li><code>-s</code>把连续重复的字符以单独一个字符表示</li></ul><p>小写转大写<code>tr &#39;a-z&#39; &#39;A-Z&#39;</code></p><h1 id="8-重定向和管道"><a href="#8-重定向和管道" class="headerlink" title="8. 重定向和管道"></a>8. 重定向和管道</h1><p><strong>管道</strong></p><p><code>command1 | command2 | command3 ...</code>  <code>|</code>左边命令的输出作为<code>|</code>右边命令的输入</p><ul><li>最后一个命令会在当前 shell 进程的子 shell 进程中执行用来</li><li>计算1+2+3+..+99+100的总和 <code>echo &#123;1..100&#125; | tr &#39; &#39; + | bc</code></li><li>标准错误默认不能通过管道转发，可利用<code>command1 2&gt;&amp;1 | command2</code>或<code>command1 |&amp; command2</code>实现</li></ul><p><strong>分页查看</strong></p><p><code>less</code> 分页查看文件内容</p><p><strong>重定向同时执行标准I/O</strong></p><p><code>tee [-a]</code> </p><ul><li><code>-a</code> 追加而不是覆盖</li><li><code>ls | tee -a ls.log</code><h1 id="9-文件查找和压缩"><a href="#9-文件查找和压缩" class="headerlink" title="9. 文件查找和压缩"></a>9. 文件查找和压缩</h1></li></ul><p><strong>locate</strong></p><p><code>locate</code> 搜文件依赖于 locate 数据库，把之前的文件建立在数据库中，基于数据库搜索，搜索速度快。当文件增加或删除后，数据库不会立即更新，所以会找不到。<code>updatedb</code> 更新数据库</p><p><code>locate [参数] 文件名</code></p><ul><li><code>-i</code>不区分大小写的搜索</li><li><code>-n N</code>只列举前N个匹配项目</li><li><code>-r</code>使用正则表达式</li></ul><p><strong>find</strong></p><p>实时查找工具，通过遍历指定路径完成文件查找，查找速度略慢</p><p>可能只搜索用户具备读取和执行权限的目录</p><p><code>find [path] [expression]</code></p><ul><li><code>-maxdepth level</code> 最大搜索目录深度</li><li><code>-mindepth level</code> 最小搜索目录深度。</li><li><code>-depth</code>先处理目录内的文件，再处理目录</li><li><code>-name &quot;文件名称&quot;</code> 根据文件名查找，支持使用通配符</li><li><code>-iname &quot;文件名称&quot;</code> 根据文件名查找不区分大小写</li><li><code>-inum 编号</code>根据 inode 查找</li><li><code>-samefile 编号</code> 相同inode号的文件</li><li><code>-links n</code> 链接数为n的文件</li><li><code>-regex &quot;PATTERN&quot;</code> 以PATTERN匹配整个文件路径，而非文件名称</li></ul><p>根据属主、属组查找：</p><ul><li><code>-user USERNAME</code> 查找属主为指定用户（UID) 的文件</li><li><code>-group GRPNAME</code>查找属组为指定组（GID) 的文件</li><li><code>-uid UserlD</code> 查找属主为指定的 UID 号的文件</li><li><code>-gid GrouplD</code> 查找属组为指定的 GID 号的文件</li><li><code>-nouser</code> 查找没有属主的文件</li><li><code>-nogroup</code>查找没有属组的文件</li></ul><p>根据文件类型查找<code>-type TYPE</code></p><ul><li><code>f</code>普通文件</li><li><code>d</code>目录文件</li><li><code>l</code>符号链接文件</li><li><code>s</code>套接字文件</li><li><code>b</code>块设备文件</li><li><code>c</code>字符设备文件</li><li><code>p</code>管道文件</li></ul><p>空文件或空目录<code>-empty</code></p><p>组合条件</p><ul><li>与 <code>-a</code></li><li>或 <code>-o</code></li><li>非 <code>-not</code>、<code>!</code></li></ul><p>根据文件大小来查找</p><p><code>-size[+-]#UNIT</code>  常用单位：k、M、G、c （byte）</p><p><strong>tar打包</strong></p><p>tar命令可以记录Linux文件权限位字段以及符号链接。可以将多个文件或目录打包成一个单独的文件，通常以 .tar 扩展名结尾</p><ul><li><code>-c</code>：创建新的归档文件。</li><li><code>-x</code>：从归档文件中提取文件。</li><li><code>-v</code>：显示详细的操作信息。</li><li><code>-f</code>：指定归档文件的名称。</li><li><code>-z</code>：使用 gzip 压缩算法进行压缩。生成的打包文件将具有 <code>.tar.gz</code> 扩展名</li><li><code>-p</code>：保留原来的文件权限与属性  </li></ul><p><code>tar -cvf archive.tar file1 file2</code> 创建一个名为<code>archive.tar</code>的归档文件，包含<code>file1</code>和<code>file2</code></p><p><code>tar -czvf archive.tar.gz file1 file2</code>  创建一个名为 <code>archive.tar.gz</code> 的压缩文件，其中包含 <code>file1</code> 和 <code>file2</code></p><p><strong>gzip压缩</strong></p><p>对单个文件进行压缩，并生成<code>.gz</code>格式的压缩文件。<code>gzip</code>命令通常与<code>tar</code>命令结合使用，以实现对文件和目录的打包和压缩操作。</p><ul><li><code>-c</code>：将压缩后的数据输出到标准输出，而不修改原始文件。</li><li><code>-d</code>：解压缩文件。</li><li><code>-v</code>：显示详细的操作信息。</li></ul><p><code>gzip file1</code> 对文件<code>file1</code>进行压缩，生成<code>file1.gz</code></p><p><strong>zip打包和压缩</strong></p><p>对于在Linux中传递的压缩文件，不要使用<code>zip</code>打包和压缩，因为 7z 和 zip 压缩格式都不能保留 unix 风格的文件权限，比如解压出一个可执行文件，需要重新 <code>chmod chown</code>才能恢复正常。</p><p>zip可以创建包含多个文件和目录的压缩文件。常见的zip命令选项如下：</p><ul><li><code>-r</code>：递归地压缩目录及其子目录中的文件。</li><li><code>-q</code>：静默模式，不显示压缩过程的输出信息。</li><li><code>-9</code>：最高压缩级别，生成更小的压缩文件。</li><li><code>-d</code>：从压缩文件中删除指定的文件。</li><li><code>-u</code>：更新压缩文件中已存在的文件。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-11-RabbitMQ/"/>
      <url>/2024/10/28/2023-09-11-RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="1-RabbitMQ-是什么"><a href="#1-RabbitMQ-是什么" class="headerlink" title="1. RabbitMQ 是什么"></a>1. RabbitMQ 是什么</h1><p>消息队列就是一个使用队列来通信的组件</p><p>RabbitMQ 是一个在 AMQP（Advanced Message Queuing Protocol ）基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持高并发，支持可扩展。它支持 AJAX，持久化，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p><h1 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h1><ol><li><p>异步通信：RabbitMQ 可以用作分布式系统之间的异步通信机制。当一个系统需要向另一个系统发送消息并且不需要等待即时响应时，可以使用 RabbitMQ 来发送消息并继续处理其他任务。</p></li><li><p>解耦系统组件：在大型分布式系统中，各个组件之间可能存在依赖关系。通过使用 RabbitMQ，可以将这些组件解耦，使它们能够独立地进行工作。一个组件可以将消息发送到 RabbitMQ，而不需要知道哪些组件将接收这些消息。</p></li><li><p>负载均衡：当多个消费者订阅同一个队列时，RabbitMQ 可以根据一定的策略将消息均匀地分发给这些消费者，从而实现负载均衡。这对于需要处理大量消息的应用程序特别有用，可以提高系统的吞吐量和并发性能。</p></li><li><p>日志收集和分发：RabbitMQ 可以用作日志消息的收集和分发中心。应用程序可以将日志消息发送到 RabbitMQ，然后由日志处理系统订阅和处理这些消息。这种方式可以实现集中式的日志管理和分发，方便进行日志分析和故障排查。</p></li><li><p>任务队列：RabbitMQ 可以用作任务队列，用于处理异步任务。应用程序可以将需要处理的任务封装成消息发送到队列中，然后由消费者进行处理。这种方式可以提高任务的并发处理能力，同时保证任务的可靠性和可恢复性。</p></li><li><p>分布式系统集成：当多个分布式系统之间需要进行数据交换和通信时，RabbitMQ 可以作为它们之间的消息中间件。通过定义消息的格式和协议，各个系统可以通过 RabbitMQ 进行数据的传递和交换，实现系统之间的集成和协作。</p></li></ol><h1 id="3-RabbitMQ-核心概念"><a href="#3-RabbitMQ-核心概念" class="headerlink" title="3. RabbitMQ 核心概念"></a>3. RabbitMQ 核心概念</h1><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。</p><h2 id="3-1-Producer（生产者）-和-Consumer（消费者）"><a href="#3-1-Producer（生产者）-和-Consumer（消费者）" class="headerlink" title="3.1. Producer（生产者） 和 Consumer（消费者）"></a>3.1. Producer（生产者） 和 Consumer（消费者）</h2><p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p><h2 id="3-2-Exchange（交换器）"><a href="#3-2-Exchange（交换器）" class="headerlink" title="3.2. Exchange（交换器）"></a>3.2. Exchange（交换器）</h2><p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉。<br><strong>RabbitMQ 的 Exchange(交换器) 有 4 种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)</strong>，<strong>fanout</strong>，<strong>topic</strong>和 <strong>headers</strong>，不同类型的 Exchange 转发消息的策略有所区别。</p><p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong>，这样 RabbitMQ 就知道如何正确将消息路由到队列了。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系</p><h2 id="3-3-Queue（消息队列）"><a href="#3-3-Queue（消息队列）" class="headerlink" title="3.3. Queue（消息队列）"></a>3.3. Queue（消息队列）</h2><p>它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p><p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免消息被重复消费</p><p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p><h2 id="3-4-Broker（消息中间件的服务节点）"><a href="#3-4-Broker（消息中间件的服务节点）" class="headerlink" title="3.4. Broker（消息中间件的服务节点）"></a>3.4. Broker（消息中间件的服务节点）</h2><p>大多数情况下可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器或者 RabbitMQ 服务实例</p><h1 id="4-AMQP"><a href="#4-AMQP" class="headerlink" title="4. AMQP"></a>4. AMQP</h1><p>AMQP是高级消息队列协议（Advanced Message Queuing Protocol）的缩写。它是一种开放的标准应用层协议，用于不同软件系统之间可靠和高效的通信。AMQP使应用程序和服务之间可以交换消息，提供了一种标准化的方式来确保消息的传递、路由和排队。</p><h1 id="5-RabbitMQ-的工作模式"><a href="#5-RabbitMQ-的工作模式" class="headerlink" title="5. RabbitMQ 的工作模式"></a>5. RabbitMQ 的工作模式</h1><ul><li>简单模式</li><li>work 工作模式</li><li>pub/sub 发布订阅模式</li><li>Routing 路由模式</li><li>Topic 主题模式</li></ul><h1 id="6-RabbitMQ-消息的传输"><a href="#6-RabbitMQ-消息的传输" class="headerlink" title="6. RabbitMQ 消息的传输"></a>6. RabbitMQ 消息的传输</h1><p>由于 TCP 链接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈，所以 RabbitMQ 使用信道的方式来传输数据。信道（Channel）是生产者、消费者与 RabbitMQ 通信的渠道，信道是建立在 TCP 链接上的虚拟链接，且每条 TCP 链接上的信道数量没有限制。就是说 RabbitMQ 在一条 TCP 链接上建立成百上千个信道来达到多个线程处理，这个 TCP 被多个线程共享，每个信道在 RabbitMQ 都有唯一的 ID，保证了信道私有性，每个信道对应一个线程使用</p><h1 id="7-如何保证消息的可靠性"><a href="#7-如何保证消息的可靠性" class="headerlink" title="7. 如何保证消息的可靠性"></a>7. 如何保证消息的可靠性</h1><p>消息到 MQ 的过程中搞丢，MQ 自己搞丢，MQ 到消费过程中搞丢。</p><ul><li>生产者到 RabbitMQ：事务机制和 Confirm 机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。</li><li>RabbitMQ 自身：持久化、集群、普通模式、镜像模式。</li><li>RabbitMQ 到消费者：basicAck 机制、死信队列、消息补偿机制</li></ul><h1 id="8-如何保证-RabbitMQ-消息的顺序性"><a href="#8-如何保证-RabbitMQ-消息的顺序性" class="headerlink" title="8. 如何保证 RabbitMQ 消息的顺序性"></a>8. 如何保证 RabbitMQ 消息的顺序性</h1><p>一个 queue（消息队列）但是对应一个 consumer（消费者），然后这个 consumer（消费者）内部用内存队列做排队，然后分发给底层不同的 worker 来处理</p><h1 id="9-如何保证-RabbitMQ-高可用的"><a href="#9-如何保证-RabbitMQ-高可用的" class="headerlink" title="9. 如何保证 RabbitMQ 高可用的"></a>9. 如何保证 RabbitMQ 高可用的</h1><p>RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式</p><h2 id="9-1-单机模式"><a href="#9-1-单机模式" class="headerlink" title="9.1. 单机模式"></a>9.1. 单机模式</h2><p>Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式。</p><h2 id="9-2-普通集群模式"><a href="#9-2-普通集群模式" class="headerlink" title="9.2. 普通集群模式"></a>9.2. 普通集群模式</h2><p>意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的 queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。</p><p>你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作</p><h2 id="9-3-镜像集群模式"><a href="#9-3-镜像集群模式" class="headerlink" title="9.3. 镜像集群模式"></a>9.3. 镜像集群模式</h2><p>这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思</p><p>这样的好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据</p><h1 id="10-如何解决消息队列的延时以及过期失效问题"><a href="#10-如何解决消息队列的延时以及过期失效问题" class="headerlink" title="10. 如何解决消息队列的延时以及过期失效问题"></a>10. 如何解决消息队列的延时以及过期失效问题</h1><p>RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。我们可以采取一个方案，就是批量重导。你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-12-SpringBoot%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/"/>
      <url>/2024/10/28/2023-09-12-SpringBoot%E5%90%8E%E7%AB%AF%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>一个后端接口大致分为四个部分组成：<strong>接口地址（url）、接口请求方式（get、post等）、请求数据（request）、响应数据（response）</strong>。</p><h1 id="2-参数校验"><a href="#2-参数校验" class="headerlink" title="2. 参数校验"></a>2. 参数校验</h1><p>一个接口一般对参数（请求数据）都会进行安全校验</p><p>一般来说有三种常见的校验方式</p><ul><li>业务层校验</li><li>Validator + BindingResult</li><li>Validator + 自动抛出异常（推荐）</li></ul><h1 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3. 全局异常处理"></a>3. 全局异常处理</h1><p>参数校验失败会自动引发异常，我们当然不可能再去手动捕捉异常进行处理。但又要对这个异常进行处理，那正好使用SpringBoot全局异常处理来达到一劳永逸的效果</p><h1 id="4-数据统一响应"><a href="#4-数据统一响应" class="headerlink" title="4. 数据统一响应"></a>4. 数据统一响应</h1><p>统一数据响应是我们自己自定义一个响应体类，无论后台是运行正常还是发生异常，响应给前端的数据格式是不变的，一般都是按照<code>code，msg，data</code>的格式返回的</p><p>自定义响应体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; &#123;  </span><br><span class="line">    <span class="comment">/**      * 状态码      */</span>  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">    <span class="comment">/**      * 响应信息，用来说明响应情况      */</span>  </span><br><span class="line">    <span class="keyword">private</span> String msg;  </span><br><span class="line">    <span class="comment">/**      * 响应的具体数据      */</span>  </span><br><span class="line">    <span class="keyword">private</span> T data;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 只传data，默认是成功  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(T data)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>(ResultCode.SUCCESS, <span class="string">&quot;操作成功&quot;</span>, data);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(ResultCode resultCode, String message, T data)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.code = resultCode.getCode();  </span><br><span class="line">        <span class="built_in">this</span>.msg = message;  </span><br><span class="line">        <span class="built_in">this</span>.data = data;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义响应代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ResultCode</span> &#123;  </span><br><span class="line">    SUCCESS(<span class="number">2000</span>),  </span><br><span class="line">    FAILED(<span class="number">2001</span>),  </span><br><span class="line">    VALIDATE_FAILED(<span class="number">2002</span>),  </span><br><span class="line">    ERROR(<span class="number">5000</span>);  </span><br><span class="line">    ResultCode(<span class="type">int</span> code) &#123;  </span><br><span class="line">        <span class="built_in">this</span>.code = code;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCode</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> code;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;code&quot;</span>: <span class="string">&quot;999&quot;</span>,</span><br><span class="line"> <span class="string">&quot;message&quot;</span>: <span class="string">&quot;操作成功&quot;</span>,</span><br><span class="line"> <span class="string">&quot;data&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-接口版本控制"><a href="#5-接口版本控制" class="headerlink" title="5. 接口版本控制"></a>5. 接口版本控制</h1><p>在spring boot项目中，如果要进行restful接口的版本控制一般有以下几个方向：</p><ul><li>基于path的版本控制</li><li>基于header的版本控制</li></ul><p>在spring MVC下，url映射到哪个method是由<code>RequestMappingHandlerMapping</code>来控制的，那么我们也是通过 <code>RequestMappingHandlerMapping</code>来做版本控制的。</p><h1 id="6-API接口安全"><a href="#6-API接口安全" class="headerlink" title="6. API接口安全"></a>6. API接口安全</h1><p>一般的解决方案有以下几点：</p><ul><li>Token授权认证，防止未授权用户获取数据；</li><li>时间戳超时机制；</li><li>URL签名，防止请求参数被篡改；</li><li>防重放，防止接口被第二次请求，防采集；</li><li>采用HTTPS通信协议，防止数据明文传输；</li></ul><h1 id="7-接口幂等性"><a href="#7-接口幂等性" class="headerlink" title="7. 接口幂等性"></a>7. 接口幂等性</h1><p>接口是需要考虑幂等性的，尤其抢红包、转账这些重要接口。最直观的业务场景，就是<strong>用户连着点击两次</strong>，你的接口有没有<strong>hold住</strong>。或者消息队列出现重复消费的情况，你的业务逻辑怎么控制？</p><p><strong>防重和幂等设计其实是有区别的</strong>。防重主要为了避免产生重复数据，把重复请求拦截下来即可。而幂等设计除了拦截重复的请求，还要求每次相同的请求都返回一样的效果。不过呢，很多时候，它们的处理流程、方案是类似的</p><p>接口幂等实现方案主要有8种：</p><ul><li><p>select+insert+主键/唯一索引冲突</p></li><li><p>直接insert + 主键/唯一索引冲突</p></li><li><p>状态机幂等</p></li><li><p>抽取防重表</p></li><li><p>token令牌</p></li><li><p>悲观锁</p></li><li><p>乐观锁</p></li><li><p>分布式锁</p></li></ul><h1 id="8-接口防重处理"><a href="#8-接口防重处理" class="headerlink" title="8. 接口防重处理"></a>8. 接口防重处理</h1><p>前端重复请求。如果是查询类的请求，其实不用防重。如果是更新修改类的话，尤其金融转账类的，就要过滤重复请求了。简单点，你可以使用Redis防重复请求，同样的请求方，一定时间间隔内的相同请求，考虑是否过滤。并发不高的话，<strong>推荐使用数据库防重表</strong>，以<strong>唯一流水号作为主键或者唯一索引</strong>。</p><p>接口幂等性和防重处理是相互关联的，需要同时考虑和实现，以确保系统的稳定性、数据的一致性和操作的正确性</p>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-14-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
      <url>/2024/10/28/2023-09-14-%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/</url>
      
        <content type="html"><![CDATA[<p>只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code>+1</code> 就可以了。</p><p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p><p>消息推送无非是推（push）和拉（pull）两种形式</p><h1 id="1-SSE方式"><a href="#1-SSE方式" class="headerlink" title="1. SSE方式"></a>1. SSE方式</h1><p>服务器发送事件，Server-Sent Events</p><p>这是一种服务器端到客户端（浏览器）的单向消息推送</p><p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错</p><h1 id="2-WebSocket方式"><a href="#2-WebSocket方式" class="headerlink" title="2. WebSocket方式"></a>2. WebSocket方式</h1><p>WebSocket是一种在Web应用程序中提供双向通信的协议。它建立在HTTP协议之上，通过在客户端和服务器之间建立持久连接，实现实时数据传输。</p><p>WebSocket在初始握手阶段使用HTTP协议，然后在建立连接后切换到WebSocket协议。与传统的HTTP请求-响应模型不同，WebSocket允许服务器主动向客户端推送数据，而不需要客户端显式发送请求。这种双向通信模式使得WebSocket非常适用于实时应用程序，例如聊天应用、实时数据监控等。</p><p>WebSocket在浏览器端使用JavaScript的WebSocket对象进行编程。它提供了与服务器进行连接、发送和接收数据的函数。在服务器端，需要使用相应的WebSocket库或框架来处理WebSocket连接和数据传输。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 消息推送 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-15-SpringCloud/"/>
      <url>/2024/10/28/2023-09-15-SpringCloud/</url>
      
        <content type="html"><![CDATA[<h1 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1. 微服务"></a>1. 微服务</h1><p><strong>分布式系统开发一定会遇到的四个问题</strong></p><ul><li>这么多服务，客户端如何访问</li><li>这么多服务，服务之间如何通信</li><li>这么多服务，如何治理</li><li>服务挂了，怎么办?</li></ul><p>根本原因：网络是不可靠的</p><p><strong>解决方案</strong></p><ul><li>SpringCloud Netflix</li><li>Apache Dubbo Zookeeper</li><li>SpringCloud Alibaba </li></ul><p>SpringCloud 是一种生态，不是框架</p><p><strong>如何解决</strong></p><ul><li>API 网关，服务路由</li><li>HTTP、RPC、异步调用</li><li>服务注册与发现-&gt;高可用</li><li>熔断、限流、服务降级</li></ul><h1 id="2-SpringCloud-Alibaba最佳实践"><a href="#2-SpringCloud-Alibaba最佳实践" class="headerlink" title="2. SpringCloud Alibaba最佳实践"></a>2. SpringCloud Alibaba最佳实践</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. Spring Cloud Gateway：网关</span><br><span class="line">2. Nacos：服务注册和配置中心</span><br><span class="line">3. Sentinel：熔断限流</span><br><span class="line">4. Seata：分布式事务</span><br><span class="line">5. RocketMQ：消息队列，削峰填谷</span><br><span class="line">6. Docker：使用Docker进行容器化部署</span><br><span class="line">7. Kubernetes：使用k8s进行容器化部署</span><br></pre></td></tr></table></figure><p><strong>异步非阻塞通信</strong></p><ul><li>消息队列</li></ul><p><strong>同步通信</strong></p><ul><li>Netty -&gt; NIO、A工O</li><li>HTTP -&gt; 应用层，跨防火墙，在不同的局域网之间通信</li><li>RPC-&gt; 远程过程调用，TCP，第四层，传输层，优点：速度快，缺点：不能跨防火墙，仅支持局域网通信</li></ul><p>对内RPC，对外REST</p><h1 id="3-概述"><a href="#3-概述" class="headerlink" title="3. 概述"></a>3. 概述</h1><p>Spring Cloud Alibaba项目都是基于Spring Cloud，而Spring Cloud项目又是基于Spring Boot进行开发，并且都是使用Maven做项目管理工具。在实际开发中，我们一般都会创建一个依赖管理项目作为Maven的 Parent项目使用，这样做可以极大的方便我们对Jar包版本的统一管理。</p><h1 id="4-项目结构"><a href="#4-项目结构" class="headerlink" title="4. 项目结构"></a>4. 项目结构</h1><ul><li>dependencies管理</li><li>生产者</li><li>消费者</li><li>网关</li></ul><p>单拎出来每个项目都是spring boot项目</p><h1 id="5-Nacos"><a href="#5-Nacos" class="headerlink" title="5. Nacos"></a>5. Nacos</h1><p>Nacos 致力于帮助发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><h2 id="5-1-服务注册与发现"><a href="#5-1-服务注册与发现" class="headerlink" title="5.1. 服务注册与发现"></a>5.1. 服务注册与发现</h2><p>服务注册和发现是微服务治理的根基，服务注册和发现组件是整个微服务系统的灵魂</p><h2 id="5-2-服务提供者"><a href="#5-2-服务提供者" class="headerlink" title="5.2. 服务提供者"></a>5.2. 服务提供者</h2><p>Restful风格的服务</p><h2 id="5-3-服务消费者"><a href="#5-3-服务消费者" class="headerlink" title="5.3. 服务消费者"></a>5.3. 服务消费者</h2><p>Feign默认集成了Ribbon，Nacos 也很好的兼容了Feign，默认实现了负载均衡的效果</p><ul><li>Feign采用的是基于接口的注解</li><li>Feign整合了ribbon</li></ul><h1 id="6-Sentinel"><a href="#6-Sentinel" class="headerlink" title="6. Sentinel"></a>6. Sentinel</h1><p>在微服务架构中，为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的<strong>雪崩效应</strong>。为了解决这个问题，业界提出了熔断器模型。</p><h2 id="6-1-熔断器防止雪崩"><a href="#6-1-熔断器防止雪崩" class="headerlink" title="6.1. 熔断器防止雪崩"></a>6.1. 熔断器防止雪崩</h2><p>随着微服务的流行，服务和服务之间的稳定性变得越来越重要。Sentinel以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><h2 id="6-2-熔断器仪表盘"><a href="#6-2-熔断器仪表盘" class="headerlink" title="6.2. 熔断器仪表盘"></a>6.2. 熔断器仪表盘</h2><h1 id="7-Gateway"><a href="#7-Gateway" class="headerlink" title="7. Gateway"></a>7. Gateway</h1><h2 id="7-1-Gateway-API网关"><a href="#7-1-Gateway-API网关" class="headerlink" title="7.1. Gateway-API网关"></a>7.1. Gateway-API网关</h2><p>Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式</p><h2 id="7-2-Gateway-全局过滤器"><a href="#7-2-Gateway-全局过滤器" class="headerlink" title="7.2. Gateway-全局过滤器"></a>7.2. Gateway-全局过滤器</h2><p>全局过滤器作用于所有的路由，不需要单独配置，我们可以用它来实现很多统一化处理的业务需求，比如权限认证，IP访问限制等等。</p><h1 id="8-Nacos-分布式配置中心"><a href="#8-Nacos-分布式配置中心" class="headerlink" title="8. Nacos-分布式配置中心"></a>8. Nacos-分布式配置中心</h1><h1 id="9-SkyWalking"><a href="#9-SkyWalking" class="headerlink" title="9. SkyWalking"></a>9. SkyWalking</h1><h2 id="9-1-SkyWalking-链路追踪"><a href="#9-1-SkyWalking-链路追踪" class="headerlink" title="9.1. SkyWalking-链路追踪"></a>9.1. SkyWalking-链路追踪</h2><p><strong>什么是链路追踪</strong></p><p>微服务架构是通过业务来划分服务的，使用REST调用。对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p><p>面对以上情况，我们就需要一些可以帮助理解系统行为、用于分析性能问题的工具，以便发生故障的时候，能够快速定位和解决问题，这就是所谓的APM（应用性能管理）。</p><h2 id="9-2-SkyWalking-服务端配置"><a href="#9-2-SkyWalking-服务端配置" class="headerlink" title="9.2. SkyWalking-服务端配置"></a>9.2. SkyWalking-服务端配置</h2><h2 id="9-3-SkyWalking-客户端配置"><a href="#9-3-SkyWalking-客户端配置" class="headerlink" title="9.3. SkyWalking-客户端配置"></a>9.3. SkyWalking-客户端配置</h2><p><strong>Java Agent服务器探针</strong></p><p><strong>什么是探针</strong></p><p>探针是用来探测语言版本情况、服务器运行状况用的，探针可以实时查看服务器硬盘资源、内存占用、网卡流量、系统负载、服务器时间等信息。</p><h2 id="9-4-SkyWalking-Assembly插件"><a href="#9-4-SkyWalking-Assembly插件" class="headerlink" title="9.4. SkyWalking-Assembly插件"></a>9.4. SkyWalking-Assembly插件</h2><p>Assembly插件目的是提供一个把工程依赖元素、模块、网站文档等其他文件存放到单个归档文件里。</p><h1 id="10-RocketMQ"><a href="#10-RocketMQ" class="headerlink" title="10. RocketMQ"></a>10. RocketMQ</h1><p>主要用来实现异步通信</p><p>消息队列作为高并发系统的核心组件之一，能够帮助业务系统解构提升开发效率和系统稳定性。主要具有以下优势：</p><ul><li>削峰填谷：主要解决瞬时写压力大于应用服务能力导致消息丢失、系统奔溃等问题·</li><li>系统解耦：解决不同重要程度、不同能力级别系统之间依赖导致一死全死</li><li>提升性能：当存在一对多调用时，可以发一条消息给消息系统，让消息系统通知相关系统</li><li>蓄流压测：线上有些链路不好压测，可以通过堆积一定量消息再放开来压测</li></ul><h2 id="10-1-RocketMQ-生产者"><a href="#10-1-RocketMQ-生产者" class="headerlink" title="10.1. RocketMQ-生产者"></a>10.1. RocketMQ-生产者</h2><h2 id="10-2-RocketMQ-消费者"><a href="#10-2-RocketMQ-消费者" class="headerlink" title="10.2. RocketMQ-消费者"></a>10.2. RocketMQ-消费者</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-17-Github%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/"/>
      <url>/2024/10/28/2023-09-17-Github%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">a(他人修改源码后是否可以闭源)</span><br><span class="line">a--&gt;a.1(No)</span><br><span class="line">a--&gt;a.2(Yes)</span><br><span class="line">a.1--&gt;a.1.1(新增代码是否采用同样许可证)</span><br><span class="line">a.2--&gt;a.2.1(每个修改过的文件是否都必须放置版权说明)</span><br><span class="line">a.1.1--&gt;a.1.1.1(No)</span><br><span class="line">a.1.1.1--&gt;a.1.1.1.1(是否需要对源代码的修改之处提供说明文档)</span><br><span class="line">a.1.1.1.1--&gt;a.1.1.1.1.1(No)</span><br><span class="line">a.1.1.1.1.1--&gt;a.1.1.1.1.1.1(LGPL许可证)</span><br><span class="line">a.1.1.1.1--&gt;a.1.1.1.1.2(Yes)</span><br><span class="line">a.1.1.1.1.2--&gt;a.1.1.1.1.1.2(Mozilla许可证)</span><br><span class="line">a.1.1--&gt;a.1.1.2(Yes)</span><br><span class="line">a.1.1.2--&gt;a.1.1.2.1(GPL许可证)</span><br><span class="line">a.2.1--&gt;a.2.1.1(No)</span><br><span class="line">a.2.1--&gt;a.2.1.2(Yes)</span><br><span class="line">a.2.1.1--&gt;a.2.1.1.1(衍生软件的广告是否可以用你的名字促销)</span><br><span class="line">a.2.1.1.1--&gt;a.2.1.1.1.1(No)</span><br><span class="line">a.2.1.1.1--&gt;a.2.1.1.1.2(Yes)</span><br><span class="line">a.2.1.1.1.1--&gt;a.2.1.1.1.1.1(BSD许可证)</span><br><span class="line">a.2.1.1.1.2--&gt;a.2.1.1.1.1.2(MIT许可证)</span><br><span class="line">a.2.1.2--&gt;a.2.1.2.1(Apache许可证)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E8%BF%B0/"/>
      <url>/2024/10/28/2023-09-21-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-1-以太网（Ethernet）"><a href="#1-1-以太网（Ethernet）" class="headerlink" title="1.1. 以太网（Ethernet）"></a>1.1. 以太网（Ethernet）</h2><p><strong>定义</strong></p><p>以太网是一种计算机网络技术，用于在局域网（LAN）内实现设备之间的数据通信。它定义了 <strong>物理层和数据链路层</strong> 的标准，允许设备通过有线连接交换数据。</p><p><strong>特点</strong></p><p>数据传输速率：以太网技术支持多种速率，从最初的10 Mbps（百万比特每秒）到如今常见的千兆以太网（1 Gbps）和万兆以太网（10 Gbps），甚至更高。</p><p>拓扑结构：以太网通常采用星型、总线型或树型拓扑结构，其中交换机或集线器充当中心节点。</p><p>介质访问控制：以太网使用介质访问控制协议（MAC），如CSMA/CD（载波侦听多路访问/碰撞检测）来管理设备对共享通信介质的访问。</p><p>帧格式：以太网数据在链路层被封装成帧，每个帧包含源地址、目的地址、数据和校验信息。</p><p><strong>使用场景</strong></p><p>办公室和家庭的局域网（LAN）连接</p><p>数据中心内的高速数据传输</p><p>组织内部的网络互联</p><p><strong>设备</strong></p><p>交换机（Switch）：用于连接多个以太网设备，转发数据帧到正确的目的地。</p><p>集线器（Hub）：提供简单的信号转发功能，但不具备数据帧的智能转发能力（已逐渐被交换机取代）。</p><p>网卡（NIC）：计算机或设备上的网络接口卡，用于连接到以太网。</p><h2 id="1-2-互联网（Internet）"><a href="#1-2-互联网（Internet）" class="headerlink" title="1.2. 互联网（Internet）"></a>1.2. 互联网（Internet）</h2><p><strong>定义</strong></p><p>互联网是全球范围内互连的计算机网络系统，它采用通用的通信协议（TCP/IP）进行数据交换。互联网由无数的局域网（LAN）、城域网（MAN）和广域网（WAN）互连而成，组成一个覆盖全球的信息网络。</p><p><strong>特点</strong></p><p>全球性：互联网覆盖全球，连接了数十亿台设备，使其成为一个巨大的网络。</p><p>多样性：互联网支持多种服务和应用，包括网页浏览（HTTP/HTTPS）、电子邮件（SMTP/IMAP/POP3）、文件传输（FTP）、即时通信和视频流等。</p><p>开放性：互联网的开放标准和协议允许不同类型和品牌的设备互相通信。</p><p>扩展性：互联网的结构允许随时添加新的网络和设备，具有高度的扩展性。</p><p><strong>使用场景</strong></p><p>访问和共享全球信息资源</p><p>电子商务和在线交易</p><p>社交网络和沟通</p><p>远程教育和在线学习</p><p>云计算和远程存储</p><p><strong>设备</strong></p><p>路由器（Router）：在多个网络之间转发数据包，选择最佳路径。</p><p>调制解调器（Modem）：将数字信号转换为模拟信号，以便通过电话线或电缆传输。</p><p>服务器（Server）：提供各种服务和资源，如网页服务器、电子邮件服务器、数据库服务器等。</p><p><strong>关系</strong></p><p>层次关系：以太网是构建局域网的技术，而互联网则是由无数个局域网通过广域网连接而成的全球网络。</p><p>协议关系：以太网主要涉及物理层和数据链路层协议，而互联网使用的是TCP/IP协议栈，涵盖传输层和网络层。</p><h1 id="2-网络体系结构"><a href="#2-网络体系结构" class="headerlink" title="2. 网络体系结构"></a>2. 网络体系结构</h1><h2 id="2-1-网络模型"><a href="#2-1-网络模型" class="headerlink" title="2.1. 网络模型"></a>2.1. 网络模型</h2><p><strong>开放式系统互联模型</strong>（ <em>open system interconnection model</em> ），简称 <strong>OSI模型</strong> 。</p><p>OSI模型是一种概念模型，用于指导通信系统设计，并实现标准化。</p><p>事实上，我们比较常见，也比较实用的是四层模型，即 TCP/IP 网络模型，Linux 系统正是按照这套网络模型来实现网络协议栈的。</p><p>TCP/IP 网络参考模型共有4层，其中需要我们熟练掌握的是应用层、传输层和网络层，至于网络接口层（数据链路层和物理层）我们只需要做简单的了解就可以了。</p><p>对于应用层，当然重点要熟悉最常见的HTTP 和 HTTPS，传输层 TCP 和 UDP 都要熟悉，网络层要熟悉IPv4，IPv6 可以做简单点了解。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130852870.png" alt="网络模型图"></p><h2 id="2-2-数据封装"><a href="#2-2-数据封装" class="headerlink" title="2.2. 数据封装"></a>2.2. 数据封装</h2><p>每一层都把上层的协议包当成数据部分，再加上自己的协议头部，组成自己的协议包。这些头部信息的主要作用是用来帮助中间传输系统将数据传输到一个正确的目的地，它不是为了给接收方看的。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409141446121.png" alt="image.png"></p><h2 id="2-3-各层的数据单元和设备"><a href="#2-3-各层的数据单元和设备" class="headerlink" title="2.3. 各层的数据单元和设备"></a>2.3. 各层的数据单元和设备</h2><p><strong>应用层: (典型设备:应用程序，如FTP，SMTP ，HTTP)</strong></p><p><strong>传输层: (典型设备: 进程和端口) 数据单元：数据段 （Segment）</strong></p><p><strong>网络层: (典型设备:路由器，防火墙、多层交换机) 数据单元：数据包（Packet ）</strong></p><p><strong>数据链路层: (典型设备: 网卡，网桥，交换机) 数据单元：帧 （Frame）</strong></p><p><strong>物理层:(典型设备：中继器，集线器、网线、HUB) 数据单元：比特 （Bit）</strong></p><h2 id="2-4-各层的协议"><a href="#2-4-各层的协议" class="headerlink" title="2.4. 各层的协议"></a>2.4. 各层的协议</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409141613485.jpg" alt="网络协议图.jpg"></p><h1 id="3-冲突域和广播域"><a href="#3-冲突域和广播域" class="headerlink" title="3. 冲突域和广播域"></a>3. 冲突域和广播域</h1><p><strong>一般来说，一个网段就是一个冲突域，一个局域网就是一个广播域</strong></p><h2 id="3-1-冲突域（碰撞域）"><a href="#3-1-冲突域（碰撞域）" class="headerlink" title="3.1. 冲突域（碰撞域）"></a>3.1. 冲突域（碰撞域）</h2><p>连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合</p><p>在网络中，这意味着一个冲突域内的设备共享同一个通信通道，同一时间只有一个设备可以发送数据，否则会发生数据碰撞</p><p>第二层设备能划分冲突域。即交换机的每一个端口就是一个冲突域</p><p><strong>形成冲突域的主要原因有</strong></p><p>1 . 共享式网络拓扑：比如早期的集线器(Hub)连接的网络环境，所有设备共享同一个网段<br>2 . 同一个交换机端口上连接多个设备</p><p>解决冲突域的主要方法是使用交换机(Switch)替代集线器(Hub)，因为交换机可以隔离不同端口之间的冲突域，从而提高网络性能。</p><p>此外，划分VLAN、配置网络拓扑结构优化、调整网络接入控制策略等方法也可以帮助减少和管理冲突域</p><h2 id="3-2-广播域"><a href="#3-2-广播域" class="headerlink" title="3.2. 广播域"></a>3.2. 广播域</h2><p>接收同样广播消息的节点的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><p>在网络中，广播域是指一个网络中所有设备都能接收到广播消息的范围。</p><p>在一个广播域内，任何设备发送的广播消息（如ARP请求）都会被域内所有其他设备接收</p><p>第三层设备能划分广播域。即路由器的每一个端口就是一个广播域</p><h2 id="3-3-比较"><a href="#3-3-比较" class="headerlink" title="3.3. 比较"></a>3.3. 比较</h2><p>冲突域：房间里的人讲话会互相打断，需要轮流讲话，类似于老式集线器网络中的设备。</p><p>广播域：房间里一个人用麦克风讲话，所有人都能听到，类似于一个网络中所有设备都接收广播消息。</p><h2 id="3-4-例子"><a href="#3-4-例子" class="headerlink" title="3.4. 例子"></a>3.4. 例子</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130854097.png" alt="img"></p><p>分析：没有路由器等第三层设备，所以只有一个广播域；第二层设备交换机，4个端口直连，有4个冲突域。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130854709.png" alt="img"></p><p>分析：路由器的3个端口连接3个Bub,3个广播域；每个Hub下面的所有主机组成一个冲突域</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409130854099.png" alt="img"></p><p>分析：路由器3个端口，3个广播域；每个交换机3个端口连接3太主机共6个冲突域，Hub下面所有主机组成一个冲突域。</p><p>关键：路由器到交换机之间还是存在冲突域的，所以到两个交换机分别有2个冲突域。（6+1+2）</p><h2 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5. 总结"></a>3.5. 总结</h2><p>  （1）第二层设备只能隔离冲突域，第三层设备只能隔离广播域</p><p>  （2）路由器不但能隔离广播域，还能隔离冲突域</p><p>  （3）路由器直连交换机，则路由器到交换机之间也是存在冲突域的</p><h1 id="4-各设备的作用"><a href="#4-各设备的作用" class="headerlink" title="4. 各设备的作用"></a>4. 各设备的作用</h1><h2 id="4-1-网关（Gateway）"><a href="#4-1-网关（Gateway）" class="headerlink" title="4.1. 网关（Gateway）"></a>4.1. 网关（Gateway）</h2><p>按照不同的分类标准，网关也有很多种。TCP/IP协议里的网关是最常用的，日常我们所讲的“网关”均指TCP/IP协议下的网关。</p><p>网关（Gateway）是一种网络设备或软件系统，它充当不同网络之间的桥梁，允许它们进行通信，即使它们使用不同的协议或体系结构</p><p>网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的</p><p>只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）</p><p><strong>视频监控网关（RTSP到HTTP）</strong></p><p>视频监控系统中，摄像头使用RTSP协议传输视频流，而用户通过浏览器（HTTP协议）访问视频流。</p><ul><li><strong>摄像头</strong>：使用RTSP协议传输实时视频流。</li><li><strong>视频监控网关</strong>：将RTSP协议的视频流转换为HTTP协议。</li><li><strong>用户浏览器</strong>：通过HTTP协议访问视频流。</li></ul><h2 id="4-2-交换机（Switch）"><a href="#4-2-交换机（Switch）" class="headerlink" title="4.2. 交换机（Switch）"></a>4.2. 交换机（Switch）</h2><p>交换机是局域网中非常重要的网络设备,它的主要功能是在网络中转发数据包。</p><p>交换机：用于在局域网（LAN）中转发数据帧，交换机会维护一个MAC地址表，根据MAC地址，将数据包从一个接口转发到另一个接口，实现主机之间的直接通信</p><p>交换机的工作原理如下:</p><p>交换机有多个端口,当数据包进入交换机时,交换机会记录下数据包的源MAC地址和进入的端口信息,建立一个MAC地址表。</p><p>当下一个数据包进入交换机时,交换机会查看目的MAC地址,并将数据包转发到对应的端口。如果目的MAC地址不在MAC地址表中,交换机会将数据包广播到所有端口。</p><p>交换机会不断地更新MAC地址表,以提高转发效率。</p><p>交换机的主要特点包括:</p><p>提高网络效率:交换机可以隔离网段,减少网络冲突,提高整体网络吞吐量。</p><p>支持VLAN:交换机可以将物理端口划分成多个逻辑VLAN,实现网络的逻辑隔离。</p><p>支持QoS:交换机可以根据数据流的优先级对其进行调度和管理,提高关键业务的网络性能。</p><p>广泛兼容性:交换机支持多种网络协议和接口标准,可以灵活地应用在不同网络环境中</p><h2 id="4-3-网桥（Bridge）"><a href="#4-3-网桥（Bridge）" class="headerlink" title="4.3. 网桥（Bridge）"></a>4.3. 网桥（Bridge）</h2><p>网桥的主要功能是将网络分割成多个碰撞域，当一个数据帧到达网桥时，网桥会检查数据帧中的源MAC地址，并将该地址添加到网桥的转发表中。然后，网桥会查找目标MAC地址在转发表中的条目，如果找到匹配项，则将数据帧转发到相应的接口，从而使数据帧只在目标网络段中传输，而不会被广播到整个网络中，当网桥接收到一个未知的目标MAC地址时，它会将数据帧广播到所有的接口，以便学习到该地址所在的网络段，并将该地址添加到转发表中，以后的数据帧可以直接转发到目标网络段。</p><p>网桥(Bridge)和交换机(Switch)作为局域网中常见的网络设备,它们之间确实存在一些区别,主要体现在以下几个方面:</p><p>工作层次不同:</p><p>网桥工作在数据链路层(第2层),主要根据MAC地址进行数据转发。</p><p>交换机也工作在数据链路层,但功能更加强大,能够进行基于VLAN、QoS等更高层次的处理。</p><p>端口数量不同:</p><p>网桥通常拥有较少的端口数量,一般在2-4个端口。</p><p>交换机则拥有更多的端口数量,从几个端口到上百个端口不等。</p><p>性能和功能不同:</p><p>网桥的性能相对较低,转发能力较弱。</p><p>交换机具有更高的转发性能,支持更多的网络功能和管理特性。</p><p>应用场景不同:</p><p>网桥主要用于小型网络环境,如连接不同网段或连接不同网络技术。</p><p>交换机适用于中大型网络环境,能够实现更复杂的网络管理和优化。</p><p>发展历程不同:</p><p>网桥是较早出现的网络设备,用于解决早期局域网的连接问题。</p><p>交换机是相对较新的网络设备,逐步替代了网桥成为主流的局域网连接设备。</p><h2 id="4-4-网络接口卡（NIC）"><a href="#4-4-网络接口卡（NIC）" class="headerlink" title="4.4. 网络接口卡（NIC）"></a>4.4. 网络接口卡（NIC）</h2><p>网络接口卡是安装在计算机上的硬件设备，用于实现计算机与网络的物理连接。NIC可以提供网络连接所需的物理层和数据链路层功能，例如信号传输、数据转换等。常见的NIC类型包括以太网卡、无线网卡等。</p><h2 id="4-5-集线器（Hub）"><a href="#4-5-集线器（Hub）" class="headerlink" title="4.5. 集线器（Hub）"></a>4.5. 集线器（Hub）</h2><p>集线器是一种简单的网络设备，它可以将多个节点连接到一个局域网中。集线器的工作原理是将接收到的信号进行放大和再生，并将其发送到所有端口上。集线器适用于连接距离较近的节点，但在现代网络中已经逐渐被交换机所取代。</p><h2 id="4-6-调制解调器（Modem）"><a href="#4-6-调制解调器（Modem）" class="headerlink" title="4.6. 调制解调器（Modem）"></a>4.6. 调制解调器（Modem）</h2><p>调制解调器是一种将数字信号转换为模拟信号或将模拟信号转换为数字信号的设备。它通常用于拨号上网或宽带接入中，将计算机产生的数字信号转换为电话线上的模拟信号，或者将电话线上的模拟信号转换为数字信号传送到计算机上。</p><h2 id="4-7-总结"><a href="#4-7-总结" class="headerlink" title="4.7. 总结"></a>4.7. 总结</h2><p>路由器用于连接不同局域网之间的计算机，而交换机用于同一个局域网内的计算机互联</p><p>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</p><p>路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-07-SpringBoot%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2023-09-07-SpringBoot%E6%97%A5%E5%BF%97%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-为什么要使用日志框架"><a href="#1-为什么要使用日志框架" class="headerlink" title="1. 为什么要使用日志框架"></a>1. 为什么要使用日志框架</h1><p>使用 <code>System.out.println()</code>来打印信息耗费系统资源，不方便排查问题</p><h1 id="2-日志的发展"><a href="#2-日志的发展" class="headerlink" title="2. 日志的发展"></a>2. 日志的发展</h1><p><strong>日志发展到今天，被抽象成了三层：接口层、实现层、适配层</strong></p><p>接口层：或者叫日志门面（facade），只定义接口，等着别人实现</p><p>实现层：真正干活的、能够把日志内容记录下来的工具。但请注意它不是上边接口实现，因为它不感知也不直接实现接口，仅仅是独立的实现</p><p>适配层：它才是上边接口的implements。因为接口层和实现层并非都出自一家之手，它们之间无法直接匹配。但是可以通过增加一个中间层来解决，所以就有了适配层</p><p>适配层又可以分为绑定（Binding）和桥接（Bridging）两种能力：</p><ul><li>绑定：将接口层绑定到某个实现层（实现一个接口层，并调用实现层的方法）</li><li>桥接：将接口层桥接到另一个接口层（实现一个接口层，并调用另一个接口层的接口），主要作用是方便用户低成本的在各接口层和适配层之间迁移</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">4k6jcmr4jtgn2k05mm9ka22q3h[&quot;应用&quot;] --&gt; 4rfu0p7qvvcs4gesajj86h44bv[&quot;接口层(日志门面)：SLF4j、JCL&quot;]</span><br><span class="line">4rfu0p7qvvcs4gesajj86h44bv --&gt; 0va5j947asq6p5abpc7mql1v5v[&quot;适配1&quot;]</span><br><span class="line">0va5j947asq6p5abpc7mql1v5v --绑定--&gt; 2p7lqmaetqrbhl0sa277ddpumc[&quot;实现1：Log4j、JUL、Log4j2、Logback&quot;]</span><br><span class="line">4rfu0p7qvvcs4gesajj86h44bv --&gt; 7qpfa3uqv2c74kev1r93cts3le[&quot;适配2&quot;]</span><br><span class="line">7qpfa3uqv2c74kev1r93cts3le --绑定--&gt; 259327g23vh7termfbande7ulj[&quot;实现2：Log4j、JUL、Log4j2、Logback&quot;]</span><br><span class="line">0va5j947asq6p5abpc7mql1v5v --桥接--&gt; 7qpfa3uqv2c74kev1r93cts3le</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>日志门面（日志的抽象层）</th><th>日志实现</th></tr></thead><tbody><tr><td>JCL（Jakarta Commons Logging）、SLF4j</td><td>Log4j、JUL（java.util.logging）、Log4j2、Logback</td></tr></tbody></table></div><p>推荐搭配：SLF4j + Logback</p><p>Spring框架默认是用JCL</p><p>SpringBoot默认是SLF4j搭配Logback</p><h1 id="3-Slf4j"><a href="#3-Slf4j" class="headerlink" title="3. Slf4j"></a>3. Slf4j</h1><p>Slf4j的两种桥接层：一种是让在使用Slf4j的用户迁移到别的接口层上，如 slf4j-jcl：让在使用Slf4j的用户方便的迁移到JCL上、。另一种是让使用其他接口层的用户方便的迁移到Slf4j 上来，如 jcl-over-slf4j：作用是让已经在使用JCL的用户方便的迁移到Slf4j 上来</p><p>Slf4j通过推出各种适配层，基本满足了用户的所有场景，我们来看一下它的全家桶：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">4k6jcmr4jtgn2k05mm9ka22q3h[&quot;Slf4j</span><br><span class="line">slf4j-api&quot;] --Slf4j迁移到JCL--&gt; 4rfu0p7qvvcs4gesajj86h44bv[&quot;slf4j-jcl&quot;]</span><br><span class="line">4rfu0p7qvvcs4gesajj86h44bv --Slf4j迁移到JCL--&gt; 0va5j947asq6p5abpc7mql1v5v[&quot;JCL&quot;]</span><br><span class="line">0va5j947asq6p5abpc7mql1v5v --JCL迁移到Slf4j--&gt; 05unqgmvbedmfq1gpmahs1qfv9</span><br><span class="line">05unqgmvbedmfq1gpmahs1qfv9[&quot;jcl-over-slf4j&quot;] --JCL迁移到Slf4j--&gt; 4k6jcmr4jtgn2k05mm9ka22q3h</span><br><span class="line">4k6jcmr4jtgn2k05mm9ka22q3h --Slf4j迁移到Log4j--&gt; 041lbr2k15cjiupanig0e7tsuv[&quot;slf4j-log4j12&quot;]</span><br><span class="line">041lbr2k15cjiupanig0e7tsuv --Slf4j迁移到Log4j--&gt; 25mhvv725q6l4bp06v5adqabdi[&quot;Log4j&quot;]</span><br><span class="line">25mhvv725q6l4bp06v5adqabdi --Log4j迁移到Slf4j--&gt; 6sfn042hg96tn2c954s09ukpot</span><br><span class="line">6sfn042hg96tn2c954s09ukpot[&quot;log4j-over-slf4j&quot;] --Log4j迁移到Slf4j--&gt; 4k6jcmr4jtgn2k05mm9ka22q3h</span><br><span class="line">4k6jcmr4jtgn2k05mm9ka22q3h --Slf4j迁移到JUL--&gt; 50o4ko2q2j3j87h3c7am7kklcj[&quot;slf4j-jdk14&quot;]</span><br><span class="line">50o4ko2q2j3j87h3c7am7kklcj --Slf4j迁移到JUL--&gt; 55aml9qs4o7k1176pnbh8i0c2u[&quot;JUL&quot;]</span><br><span class="line">55aml9qs4o7k1176pnbh8i0c2u --JUL迁移到Slf4j--&gt; 59nosjp9f0ream3541ih843995</span><br><span class="line">59nosjp9f0ream3541ih843995[&quot;jul-to-slf4j&quot;] --JUL迁移到Slf4j--&gt; 4k6jcmr4jtgn2k05mm9ka22q3h</span><br></pre></td></tr></table></figure><p><strong>工厂函数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传 Class，一般都是传当前的 Class</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(ExampleService.class);</span><br></pre></td></tr></table></figure><p><strong>@Slf4j注解</strong></p><p>Lombok也提供了针对各种日志系统的支持，比如你只需要<code>@lombok.extern.slf4j.Slf4j</code>注解就可以得到一个静态的log字段，不用再手动调用工厂函数。默认的LoggerName 即是被注解的Class；同时也支持字符串格式的topic字段指定LoggerName</p><h1 id="4-Logback"><a href="#4-Logback" class="headerlink" title="4. Logback"></a>4. Logback</h1><p>Logback主要由三部分组成：</p><ul><li>logback-core：记录/输出日志的核心实现</li><li>logback-classic：适配层，完整实现了Slf4j接口</li><li>logback-access：用于将Logback集成到Servlet容器（Tomcat、Jetty）中，让这些容器的HTTP访问日志也可以经由强大的Logback输出</li></ul><h1 id="5-Slf4j-Logback-整合及排包"><a href="#5-Slf4j-Logback-整合及排包" class="headerlink" title="5. Slf4j+Logback 整合及排包"></a>5. Slf4j+Logback 整合及排包</h1><h2 id="5-1-基础依赖项"><a href="#5-1-基础依赖项" class="headerlink" title="5.1. 基础依赖项"></a>5.1. 基础依赖项</h2><p>以下三个包是必须的：</p><ul><li>Slf4j是基本的日志门面，它的核心API在<code>org.slf4j:slf4j-api</code>中；</li><li>Logback的核心实现层在<code>ch.qos.logback:logback-core</code>中；</li><li>Logback针对Slf4j的适配层在<code>ch.qos.logback:logback-classic</code>中；</li></ul><p>其中logback-classic会直接依赖另外两项，而且它依赖的一定是它能够支持的最合适版本，所以为了避免歧义，我们可以在项目中仅显式依赖logback-classic即可</p><p><strong>兼容性</strong></p><p>Slf4j和Logback的版本并不完全向前兼容，它们之间也有对应关系</p><div class="table-container"><table><thead><tr><th>Slf4j 版本</th><th>JDK 版本</th><th>备注</th></tr></thead><tbody><tr><td>Slf4j 1.7.x</td><td>&gt;= JDK 1.5</td><td></td></tr><tr><td>Slf4j 2.0.x</td><td>&gt;= JDK 8</td><td></td></tr><tr><td>Slf4j 2.1.x</td><td>很可能 &gt;= JDK 11</td><td>Ceki正在征求大家的意见[5]</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>Logback 版本</th><th>Slf4j 版本</th><th>JDK 版本</th><th>备注</th></tr></thead><tbody><tr><td>Logback 1.2.x</td><td>Slf4j 1.7.x</td><td>&gt;= JDK 1.5</td><td></td></tr><tr><td>Logback 1.3.x</td><td>Slf4j 2.0.x</td><td>&gt;= JDK 8</td><td></td></tr><tr><td>Logback 1.4.x</td><td>Slf4j 2.0.x</td><td>&gt;= JDK 11</td><td></td></tr><tr><td>Logback 1.5.x</td><td>&gt;=Slf4j 2.0.12</td><td>&gt;= JDK 11</td><td>1.5.x 用于替代 1.4.x</td></tr></tbody></table></div><p><strong>总结</strong></p><ul><li>如果使用JDK 8，建议选择Slf4j 2.0 + Logback 1.3；</li><li>如果使用JDK 11及以上，建议选择Slf4j 2.0 + Logback 1.5；</li></ul><p>但还没完，Spring Boot的日志系统对Slf4j和Logback又有额外的版本要求</p><h2 id="5-2-适配-Spring-Boot"><a href="#5-2-适配-Spring-Boot" class="headerlink" title="5.2. 适配 Spring Boot"></a>5.2. 适配 Spring Boot</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">graph LR </span><br><span class="line">A[spring-boot-starter-web] --&gt; B[spring-boot-starter] </span><br><span class="line">B --&gt; C[spring-boot-starter-logging] </span><br><span class="line">C --&gt; C.1[logback-classic]</span><br><span class="line">C --&gt; C.2[logback-over-slf4j]</span><br><span class="line">C --&gt; C.3[jul-to-slf4j]</span><br><span class="line">C --&gt; C.4[jcl-over-slf4j]</span><br><span class="line">C.1 --&gt; E[logback-core]</span><br><span class="line">C.1 --&gt; D[slf4j-api]</span><br><span class="line">C.2 --&gt; D[slf4j-api]</span><br><span class="line">C.3 --&gt; D[slf4j-api]</span><br><span class="line">C.4 --&gt; D[slf4j-api]</span><br></pre></td></tr></table></figure><p>Spring Boot通过spring-boot-starter-logging包直接依赖了Logback（然后再间接依赖了 Slf4j），它通过<code>org.springframework.boot.logging.LoggingSystem[10]</code>查找日志接口并自动适配，<strong>所以我们使用Spring Boot时一般并不需要关心日志依赖，只管使用即可</strong>。但因为Slf4j 2.0.x与Slf4j 1.7.x实现不一致，导致Spring Boot也会挑版本：</p><div class="table-container"><table><thead><tr><th>Spring Boot 版本</th><th>Slf4j 版本</th><th>Logback 版本</th><th>JDK 版本</th></tr></thead><tbody><tr><td>Spring Boot 1.5</td><td>Slf4j 1.7.x</td><td>Logback 1.1.x</td><td>&gt;= JDK 7</td></tr><tr><td>Spring Boot 2.x</td><td>Slf4j 1.7.x</td><td>Logback 1.2.x</td><td>&gt;= JDK 8</td></tr><tr><td>Spring Boot 3.x</td><td>Slf4j 2.0.x</td><td>Logback 1.4.x</td><td>&gt;= JDK 17</td></tr></tbody></table></div><p>根据这个表格，以及前一节总结的版本兼容关系，最终可以得到以下结论：</p><ul><li>如果使用Spring Boot 2及以下，建议选择Slf4j 1.7.x + Logback 1.2.x；</li><li>如果使用Spring Boot 3，建议选择Slf4j 2.0.x + Logback 1.4.x</li></ul><h2 id="5-3-桥接其他实现层"><a href="#5-3-桥接其他实现层" class="headerlink" title="5.3. 桥接其他实现层"></a>5.3. 桥接其他实现层</h2><p>我们还要保证项目中依赖的二方、三方包能够正常打印出日志，而它们可能依赖的是 JCL/Log4j/Log4j2/JUL，我们可以统一引入适配层做好桥接</p><ul><li>通过<code>org.slf4j:jcl-over-slf4j</code> 将JCL桥接到Slf4j 上；</li><li>通过<code>org.slf4j:log4j-over-slf4j</code> 将Log4j桥接到Slf4j 上；</li><li>通过<code>org.slf4j:jul-to-slf4j</code> 将JUL桥接到Slf4j上；</li><li>通过<code>org.apache.logging.log4j:log4j-to-slf4j</code> 将Log4j 2桥接到Slf4j上；</li></ul><p>注意，所有<code>org.slf4j</code>的包版本要完全一致，所以如果引入这些桥接包，要保证它们的版本与前边选择的slf4j-api版本对应。为此Slf4j从2.0.8开始提供了bom包，省去了维护每个包版本的烦恼</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-去除无用依赖"><a href="#5-4-去除无用依赖" class="headerlink" title="5.4. 去除无用依赖"></a>5.4. 去除无用依赖</h2><p>桥接层使用与被桥接包一样的包结构，再暗渡陈仓将调用转到另一个接口上。所以如果同时引入桥接层以及被桥接的包，大概率会引起包冲突。</p><p>由于很多工具会在不经意间引入日志接口层/实现层，所以我们有必要从整个应用级别着眼，把那些无用的接口层/实现层排除掉，包括JCL、Log4j和Log4j 2：</p><ul><li>排掉JCL：<code>commons-logging:commons-logging</code></li><li>排掉Log4j：<code>log4j:log4j</code></li><li>排掉Log4j 2：<code>org.apache.logging.log4j:log4j-core</code></li></ul><p>以及，如果项目间接引入了其他的桥接包，也可能会引起冲突，需要排掉</p><p><strong>Maven 统一排包方案</strong></p><p>使用maven-enforcer-plugin插件标识哪些包是要被排掉的，它只是一个校验，实际上你仍然需要在每个引入了错误包的依赖中进行排除</p><h2 id="5-5-最终依赖"><a href="#5-5-最终依赖" class="headerlink" title="5.5. 最终依赖"></a>5.5. 最终依赖</h2><p><strong>JDK 8/11 + Spring Boot 1.5/2</strong></p><ul><li><p>基础</p><ul><li><code>org.slf4j:slf4j-api:1.7.36</code></li><li><code>ch.qos.logback:logback-core:1.2.13</code></li><li><code>ch.qos.logback:logback-classic:1.2.13</code></li></ul></li><li><p>桥接包</p><ul><li><code>org.slf4j:jcl-over-slf4j:1.7.36</code></li><li><code>org.slf4j:log4j-over-slf4j:1.7.36</code></li><li><code>org.slf4j:jul-to-slf4j:1.7.36</code></li><li><code>org.apache.logging.log4j:log4j-to-slf4j:2.23.1</code></li></ul></li><li>排包<ul><li><code>commons-logging:commons-logging:99.0-does-not-exist</code></li><li><code>log4j:log4j:99.0-does-not-exist</code></li><li><code>org.apache.logging.log4j:log4j-core:99.0-does-not-exist</code></li></ul></li></ul><p><strong>JDK 17/21 + Spring Boot 3</strong></p><ul><li><p>基础</p><ul><li><code>org.slf4j:slf4j-bom:2.0.12</code> 通过 BOM 包统一管理依赖</li><li><code>ch.qos.logback:logback-core:1.4.14</code></li><li><code>ch.qos.logback:logback-classic:1.4.14</code></li></ul></li><li><p>桥接包</p><ul><li><code>org.slf4j:jcl-over-slf4j</code> </li><li><code>org.slf4j:log4j-over-slf4j</code> </li><li><code>org.slf4j:jul-to-slf4j</code> </li><li><code>org.apache.logging.log4j:log4j-to-slf4j:2.23.1</code></li></ul></li><li><p>排包</p><ul><li><code>commons-logging:commons-logging:99.0-does-not-exist</code></li><li><code>log4j:log4j:99.0-does-not-exist</code></li><li><code>org.apache.logging.log4j:log4j-core:99.0-does-not-exist</code></li></ul></li></ul><h2 id="5-6-注意事项"><a href="#5-6-注意事项" class="headerlink" title="5.6. 注意事项"></a>5.6. 注意事项</h2><p>根据前边的介绍，我们在实际项目中将主要做两类事情：</p><ul><li>引入期望的包，并指定版本；</li><li>排除一些包（指定空版本）；</li></ul><h1 id="6-SpringBoot中日志的具体配置"><a href="#6-SpringBoot中日志的具体配置" class="headerlink" title="6. SpringBoot中日志的具体配置"></a>6. SpringBoot中日志的具体配置</h1><h2 id="6-1-日志级别"><a href="#6-1-日志级别" class="headerlink" title="6.1. 日志级别"></a>6.1. 日志级别</h2><p>SpringBoot默认的日志级别是info</p><p>可以使用<code>logging.level</code> 调整某个包、类输出的日志级别</p><p>一共有五个等级，按优先级从低到高依次为：</p><ul><li><p>TRACE：一般用于记录调用链路，比如方法进入时打印xxx start；</p></li><li><p>DEBUG：个人觉得它和 trace 等级可以合并，如果一定要区分，可以用来打印方法的出入参；</p></li><li><p>INFO：默认级别，一般用于记录代码执行时的关键信息；</p></li><li><p>WARN：当代码执行遇到预期外场景，但它不影响后续执行时，可以使用；</p></li><li><p>ERROR：出现异常，以及代码无法兜底时使用；</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExampleService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RpcService rpcService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">querySomething</span><span class="params">(String request)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 trace 标识这个方法调用情况</span></span><br><span class="line">        log.trace(<span class="string">&quot;querySomething start&quot;</span>);</span><br><span class="line">        <span class="comment">// 使用 debug 记录出入参</span></span><br><span class="line">        log.debug(<span class="string">&quot;querySomething request=&#123;&#125;&quot;</span>, request);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RpcResult</span> <span class="variable">rpcResult</span> <span class="operator">=</span> rpcService.call(a);</span><br><span class="line">            <span class="keyword">if</span> (rpcResult.isSuccess()) &#123;</span><br><span class="line">                response = rpcResult.getData();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用 info 标识重要节点</span></span><br><span class="line">                log.info(<span class="string">&quot;querySomething rpcService.call succeed, request=&#123;&#125;, rpcResult=&#123;&#125;&quot;</span>, request, rpcResult);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 使用 warn 标识程序调用有预期外错误，但这个错误在可控范围内</span></span><br><span class="line">                log.warn(<span class="string">&quot;querySomething rpcService.call failed, request=&#123;&#125;, rpcResult=&#123;&#125;&quot;</span>, request, rpcResult);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 使用 error 记录程序的异常信息</span></span><br><span class="line">            log.error(<span class="string">&quot;querySomething rpcService.call abnormal, request=&#123;&#125;, exception=&#123;&#125;&quot;</span>, request, e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 debug 记录出入参</span></span><br><span class="line">        log.debug(<span class="string">&quot;querySomething response=&#123;&#125;&quot;</span>, response);</span><br><span class="line">        <span class="comment">// 使用 trace 标识这个方法调用情况</span></span><br><span class="line">        log.trace(<span class="string">&quot;querySomething end&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-Logback配置文件"><a href="#6-2-Logback配置文件" class="headerlink" title="6.2. Logback配置文件"></a>6.2. Logback配置文件</h2><p>每一个日志的实现框架都有自己的配置文件。使用SLF4J以后，日志配置文件还是日志实现框架的配置文件</p><p>将Logback配置文件<code>logback.xml</code>或<code>logback-spring.xml</code>放在resource目录下，<code>logback.xml</code> 会直接被日志框架解析，而<code>logback-spring.xml</code>是由SpringBoot解析</p><p>推荐使用<code>logback-spring.xml</code>配置，这样可以使用SpringBoot中的特性<code>springProfile</code>标签（指定某段配置只在某个环境下生效）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;staging&quot;</span> &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- configuration to be enabled when the &quot;staging&quot; profile is active --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;LOGS&quot;</span> <span class="attr">value</span>=<span class="string">&quot;./logs&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;Console&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span></span><br><span class="line">                %black(%d&#123;ISO8601&#125;)==%highlight(%-5level)==[%blue(%t)]==%yellow(%C&#123;1.&#125;): %msg%n%throwable</span><br><span class="line">            <span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;RollingFile&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;LOGS&#125;/spring-boot-logger.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.encoder.PatternLayoutEncoder&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Pattern</span>&gt;</span>%d==%p==%C&#123;1.&#125;==[%t]==%m%n<span class="tag">&lt;/<span class="name">Pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- rollover daily and when the file reaches 10 MegaBytes --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;LOGS&#125;/archived/spring-boot-logger-%d&#123;yyyy-MM-dd&#125;.%i.log</span><br><span class="line">            <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span></span></span><br><span class="line"><span class="tag">                <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- LOG everything at INFO level --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- LOG &quot;com.baeldung*&quot; at TRACE level --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.baeldung&quot;</span> <span class="attr">level</span>=<span class="string">&quot;trace&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;RollingFile&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;Console&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="6-3-打印哪些日志"><a href="#6-3-打印哪些日志" class="headerlink" title="6.3. 打印哪些日志"></a>6.3. 打印哪些日志</h2><p>可以使用 <code>&lt;logger&gt;</code> 元素为特定的包或类定义日志记录规则，以控制它们的日志输出行为，<code>name</code> 属性值可以是一个包的名称，也可以是一个具体类的全限定名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置项... --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.package1&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.example.package2&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 其他配置项... --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对于 <code>com.example.package1</code>，我们将日志级别设置为 DEBUG，这意味着日志记录器将输出 DEBUG 及以上级别的日志。</p><p><strong>Myibatis log</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis log configure --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;com.apache.ibatis&quot;</span> <span class="attr">level</span>=<span class="string">&quot;TRACE&quot;</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- JDBC日志 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.Connection&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.Statement&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;java.sql.PreparedStatement&quot;</span> <span class="attr">level</span>=<span class="string">&quot;DEBUG&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-05-24-Java%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/"/>
      <url>/2024/10/28/2023-05-24-Java%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MyExcel"><a href="#1-MyExcel" class="headerlink" title="1. MyExcel"></a>1. MyExcel</h1><p>功能全面的 Excel 处理工具，内存占用低</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.liaochong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.0.RC4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-EasyExcel"><a href="#2-EasyExcel" class="headerlink" title="2. EasyExcel"></a>2. EasyExcel</h1><p>阿里的一款 POI 封装工具</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>easyexcel<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-x-easypdf-快速生成-PDF-文档"><a href="#3-x-easypdf-快速生成-PDF-文档" class="headerlink" title="3. x-easypdf 快速生成 PDF 文档"></a>3. x-easypdf 快速生成 PDF 文档</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>wiki.xsx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>x-easypdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-IdGenerator-唯一-ID-生成器"><a href="#4-IdGenerator-唯一-ID-生成器" class="headerlink" title="4. IdGenerator 唯一 ID 生成器"></a>4. IdGenerator 唯一 ID 生成器</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.yitter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yitter-idgenerator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="5-OSHI"><a href="#5-OSHI" class="headerlink" title="5. OSHI"></a>5. OSHI</h1><p>一款为 Java 语言提供的基于 <strong>JNA</strong> 的（本机）操作系统和硬件信息库</p><p>通过 OSHI ，我们不需要安装任何其他本机库，就能查看内存和 CPU 使用率、磁盘和分区使用情况、设备、传感器等信息</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.oshi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>oshi-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-JsonPath"><a href="#6-JsonPath" class="headerlink" title="6. JsonPath"></a>6. JsonPath</h1><p>读取 JSON 的 Java DSL。JsonPath 一种面向 JSON 结构的查询语言。相当于 XPATH 对于 XML、SQL 对于关系型数据库，它们都是比较通用的 DSL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7-Caffeine"><a href="#7-Caffeine" class="headerlink" title="7. Caffeine"></a>7. Caffeine</h1><p>强大的本地缓存。除了基本的缓存功能之外，Caffeine 还提供了过期、异步加载等功能。Caffeine是Guava Cache的改进版</p><p>Java 11 及以上版本使用 <code>3.x</code> ，否则使用<code>2.x</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.ben-manes.caffeine<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>caffeine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-JSON处理相关"><a href="#8-JSON处理相关" class="headerlink" title="8. JSON处理相关"></a>8. JSON处理相关</h1><p><strong>Jackson（推荐）</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>FastJson（不推荐）</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.62<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>Gson（不推荐）</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.gson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- 替换为最新版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="9-jave-all-deps音视频解析"><a href="#9-jave-all-deps音视频解析" class="headerlink" title="9. jave-all-deps音视频解析"></a>9. jave-all-deps音视频解析</h1><p>可以根据自己平台选择不同的依赖库，这种方式需要首先添加 java-core</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ws.schild<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jave-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后再根据自己使用的不同平台，继续添加不同依赖库</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ws.schild<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jave-nativebin-win64<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="10-HTTP工具"><a href="#10-HTTP工具" class="headerlink" title="10. HTTP工具"></a>10. HTTP工具</h1><p><strong>OkHttp3</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>okhttp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>WebClient</strong></p><p>从 Spring Framework 5 开始推荐使用的http请求工具</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="11-工具类"><a href="#11-工具类" class="headerlink" title="11. 工具类"></a>11. 工具类</h1><h2 id="11-1-Guava"><a href="#11-1-Guava" class="headerlink" title="11.1. Guava"></a>11.1. Guava</h2><p>Google公司开发的一款Java类库扩展工具包，内含了丰富的API，涵盖了集合、缓存、并发、I/O等多个方面。使用这些API一方面可以简化我们代码，使代码更为优雅，另一方面它补充了很多jdk中没有的功能</p><p>Guava的工具类都在<code>com.google.common.*</code>下 </p><p><a href="https://guava.dev/releases/snapshot-jre/api/docs/">文档地址</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>30.1.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="11-2-Apache-Commons"><a href="#11-2-Apache-Commons" class="headerlink" title="11.2. Apache Commons"></a>11.2. Apache Commons</h2><div class="table-container"><table><thead><tr><th><strong>组件</strong></th><th><strong>功能介绍</strong></th></tr></thead><tbody><tr><td>commons-beanutils</td><td>提供了对于JavaBean进行各种操作，克隆对象,属性等等.</td></tr><tr><td>commons-betwixt</td><td>XML与Java对象之间相互转换.</td></tr><tr><td>commons-codec</td><td>处理常用的编码方法的工具类包 例如DES、SHA1、MD5、Base64等.</td></tr><tr><td>commons-collections</td><td>java集合框架操作.</td></tr><tr><td>commons-compress</td><td>java提供文件打包 压缩类库.</td></tr><tr><td>commons-configuration</td><td>一个java应用程序的配置管理类库.</td></tr><tr><td>commons-dbcp</td><td>提供数据库连接池服务.</td></tr><tr><td>commons-dbutils</td><td>提供对jdbc 的操作封装来简化数据查询和记录读取操作.</td></tr><tr><td>commons-email</td><td>java发送邮件 对javamail的封装.</td></tr><tr><td>commons-fileupload</td><td>提供文件上传功能.</td></tr><tr><td>commons-httpclient</td><td>提供HTTP客户端与服务器的各种通讯操作. 现在已改成HttpComponents</td></tr><tr><td>commons-io</td><td>io工具的封装.</td></tr><tr><td>commons-lang</td><td>Java基本对象方法的工具类包 如：StringUtils,ArrayUtils,DateUtils,DateFormatUtils等等.</td></tr><tr><td>commons-logging</td><td>提供的是一个Java 的日志接口.</td></tr><tr><td>commons-validator</td><td>提供了客户端和服务器端的数据验证框架.</td></tr></tbody></table></div><h2 id="11-3-Spring-自带的工具类"><a href="#11-3-Spring-自带的工具类" class="headerlink" title="11.3. Spring 自带的工具类"></a>11.3. Spring 自带的工具类</h2><p>Spring的工具类都是以Utils结尾，<code>org.springframework.util</code>，所以要查看这些工具类，只需要在API文档中查询所有<code>*Utils</code>即可</p><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/package-summary.html">文档地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-04-30-%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2024/10/28/2023-04-30-%E7%BD%91%E7%AB%99%E6%9E%B6%E6%9E%84%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>网站架构是如何一步步演变为今天的分布式架构的，以及为什么需要分布式架构</p><h1 id="1-架构设计演变过程"><a href="#1-架构设计演变过程" class="headerlink" title="1. 架构设计演变过程"></a>1. 架构设计演变过程</h1><p>核心：业务驱动着技术的发展</p><p>架构设计的目标：高并发、高可用、可伸缩、可扩展、够安全</p><p>几个影响因素：用户量、业务量、数据量、请求量</p><h2 id="1-1-应用与数据一体模式"><a href="#1-1-应用与数据一体模式" class="headerlink" title="1.1. 应用与数据一体模式"></a>1.1. 应用与数据一体模式</h2><p>一整个业务应用和数据部分只部署在同一个服务器上</p><h2 id="1-2-应用与数据分离模式"><a href="#1-2-应用与数据分离模式" class="headerlink" title="1.2. 应用与数据分离模式"></a>1.2. 应用与数据分离模式</h2><p>实现了硬件层面的分离：业务应用和数据库分别部署在两台不同的服务器上</p><p>应用服务器处理大量请求，需要CPU和内存</p><p>数据服务器处理存储和IO操作，需要磁盘性能</p><h2 id="1-3-缓存与性能提升"><a href="#1-3-缓存与性能提升" class="headerlink" title="1.3. 缓存与性能提升"></a>1.3. 缓存与性能提升</h2><p>用户对某些数据访问量特别大时，数据库成为了性能瓶颈，于是使用了缓存技术</p><p><strong>客户端浏览器缓存</strong></p><p>客户端将每次http请求的内容缓存下来，以减小应用服务器压力</p><p><strong>应用服务器缓存</strong></p><p>是进程内缓存，又称托管堆缓存。如 Java中这种缓存存在JVM的托管堆上</p><p><strong>缓存服务器缓存</strong></p><p>专门的缓存服务器，对内存有要求</p><p>所以用户请求访问数据的顺序变为：客户端浏览器缓存—&gt; 应用服务器缓存—&gt; 缓存服务器缓存—&gt; 数据库</p><p>缓存技术的加入提高了响应请求的速度，在可用性方面也有改善，即当数据库暂时出现问题时，缓存服务器中保存的热点数据依然可以满足用户的暂时访问</p><p>总结：以上发展，都是解决访问数据量大的问题</p><h2 id="1-4-服务器集群处理并发"><a href="#1-4-服务器集群处理并发" class="headerlink" title="1.4. 服务器集群处理并发"></a>1.4. 服务器集群处理并发</h2><p>将同一个应用复制到多个服务器上，解决多个用户同时请求的问题</p><p>增加应用服务器的个数，形成服务器集群，在用户请求与应用服务器之间加入负载均衡器以便将用户请求路由到对应的服务器</p><p>采用负载均衡器后，重点关注：负载均衡器的均衡算法，要保证用户请求均匀的分布在不同服务器上、属于同一会话的所有请求都在同一个服务器上处理、能针对不同应用服务器的性能优劣进行动态调整流量</p><p>负载均衡器位于互联网与应用服务器之间，负责用户流量的接入，因此可以对用户的流量进行监控，同时对提出访问请求的用户进行身份和权限验证</p><h2 id="1-5-数据库读写分离"><a href="#1-5-数据库读写分离" class="headerlink" title="1.5. 数据库读写分离"></a>1.5. 数据库读写分离</h2><p>从读写层面对数据库资源进行分配</p><p>缓存的大小有限，非热点数据的读取仍然要在数据库中读取。数据库对于读、写操作的性能是不一样的。写数据时，会造成锁行、锁表，并发写操作会出现排队现象。而读操作可以通过索引、数据库缓存等加快读取速度。所以出现了数据库读写分离</p><p>负责写的数据库需要向负责读的数据库进行数据同步。涉及到的问题：数据同步技术（同步复制技术、异步复制技术、半同步复制技术）、可靠性问题（如果主库挂了，从库如何接替工作，之后主库恢复了，是继续当主库还是当从库，以及主从库如何同步数据）</p><h2 id="1-6-反向代理和CDN"><a href="#1-6-反向代理和CDN" class="headerlink" title="1.6. 反向代理和CDN"></a>1.6. 反向代理和CDN</h2><h3 id="1-6-1-反向代理"><a href="#1-6-1-反向代理" class="headerlink" title="1.6.1. 反向代理"></a>1.6.1. 反向代理</h3><p>相当于外网与内网间的缓冲</p><p>反向代理服务器接收用户请求，然后再将请求转发到内网的应用服务器，全程只对请求进行转发，自身不运行任何应用</p><p>提高了应用服务器的安全性、还可以在互联网与内网间起适配和网速转换的作用</p><h3 id="1-6-2-CDN"><a href="#1-6-2-CDN" class="headerlink" title="1.6.2. CDN"></a>1.6.2. CDN</h3><p>Content Delivery Network，内容分发网络</p><p>用户的请求需要跳转多个互联网中的节点，才能到达应用服务器获取资源，在离用户客户端最近的节点中存放信息，可以减少跳转次数，提高访问速度</p><p>CDN技术减轻了应用服务器的压力、提高了访问速度</p><p>但是CDN只对静态资源有效，且需要定期更新CDN服务器上的资源</p><h2 id="1-7-分布式数据库与分表分库"><a href="#1-7-分布式数据库与分表分库" class="headerlink" title="1.7. 分布式数据库与分表分库"></a>1.7. 分布式数据库与分表分库</h2><p>从业务和数据层面对数据库进行分配</p><h3 id="1-7-1-分布式数据库"><a href="#1-7-1-分布式数据库" class="headerlink" title="1.7.1. 分布式数据库"></a>1.7.1. 分布式数据库</h3><p>将数据库资源分别放在不同的数据库服务器中</p><p>由于数据存储在不同的表、库、服务器上，所以需要引入数据库中间件来实现数据同步，从而消除不同存储载体间的差异</p><p>从软件工程的角度看，数据库中间件的最佳实践：MyCat、Sharding JDBC。此外从数据治理的角度看，需要考虑数据扩容和数据治理的问题</p><h3 id="1-7-2-分表分库"><a href="#1-7-2-分表分库" class="headerlink" title="1.7.2. 分表分库"></a>1.7.2. 分表分库</h3><p><strong>分表</strong></p><p>一个1000万数据的表拆为两个500万的表或者按业务逻辑进行列的拆分，然后通过外键关联到主表，注意被拆分出去的列一定是不常访问的列</p><p><strong>分库</strong></p><p>每个数据库能承受的最大连接数和连接池是有限的。可以让不同业务访问不同数据库</p><h2 id="1-8-业务拆分"><a href="#1-8-业务拆分" class="headerlink" title="1.8. 业务拆分"></a>1.8. 业务拆分</h2><p>将一个应用拆分成多个部署在不同的服务器上，拆分后的各个应用间存在互相调用、通信、协调问题，因此引入队列、服务注册发现、消息中心等中间件</p><p>业务拆分后会形成一个个应用服务，既有基于业务的服务，如 商品服务、订单服务。也有基础服务，如 消息推送、权限验证</p><h2 id="1-9-分布式与微服务"><a href="#1-9-分布式与微服务" class="headerlink" title="1.9. 分布式与微服务"></a>1.9. 分布式与微服务</h2><h3 id="1-9-1-微服务"><a href="#1-9-1-微服务" class="headerlink" title="1.9.1. 微服务"></a>1.9.1. 微服务</h3><p>更小的业务模块、模块间高内聚低耦合、每个模块可以用自己特有的技术实现、模块通过容器部署运行、各模块通过接口和协议实现调用、可以对热点模块进行水平扩展以提高性能</p><h3 id="1-9-2-微服务与分布式架构的区别"><a href="#1-9-2-微服务与分布式架构的区别" class="headerlink" title="1.9.2. 微服务与分布式架构的区别"></a>1.9.2. 微服务与分布式架构的区别</h3><p><strong>拆分目的不同</strong></p><p>分布式是为了解决单体资源有限的问题，将一个应用拆分部署到不同服务器上，以分担高并发的压力</p><p>微服务是对服务组件精细化，目的是更好的解耦，让各个服务间实现高性能、高可用、可伸缩、可扩展</p><p><strong>拆分方式不同</strong></p><p>分布式架构按照业务和技术分类进行拆分，目的是让拆分后的服务负载原来单一服务的业务</p><p>微服务是在分布式的基础上进行更加细致的拆分，将服务拆分为更小的模块，且每个模块可以独立运行</p><p><strong>部署方式不同</strong></p><p>分布式架构通常会把拆分后的各部分部署到不同服务器上</p><p>微服务既可以将不同服务模块部署在不同服务器上，也可以在同一台服务器上部署多个微服务或者同一个微服务的多个水平扩展</p><p>都是基于分布式架构的思想构建的，微服务是分布式架构的进化版，是分布式架构的子集</p><h1 id="2-分布式架构"><a href="#2-分布式架构" class="headerlink" title="2. 分布式架构"></a>2. 分布式架构</h1><h2 id="2-1-分布式架构的组成"><a href="#2-1-分布式架构的组成" class="headerlink" title="2.1. 分布式架构的组成"></a>2.1. 分布式架构的组成</h2><h3 id="2-1-1-客户端"><a href="#2-1-1-客户端" class="headerlink" title="2.1.1. 客户端"></a>2.1.1. 客户端</h3><p>客户端与CDN，涉及客户端对http请求资源的缓存（常见的缓存方式：强制缓存、对比缓存）、CDN的缓存</p><h3 id="2-1-2-负载均衡器（接入层）"><a href="#2-1-2-负载均衡器（接入层）" class="headerlink" title="2.1.2. 负载均衡器（接入层）"></a>2.1.2. 负载均衡器（接入层）</h3><p>客户端请求服务器的过程：</p><ul><li>客户端向DNS服务器发出URL请求</li><li>DNS服务器向客户端返回<strong>应用服务器入口的IP地址</strong>（并非应用服务器本身的IP地址，而是反向代理服务器的IP地址）</li><li>客户端向服务器发送请求</li><li>负载均衡器接收请求后，根据负载均衡算法找到对应的服务器，并将请求转发给服务器</li></ul><h3 id="2-1-3-应用服务器（应用层）"><a href="#2-1-3-应用服务器（应用层）" class="headerlink" title="2.1.3. 应用服务器（应用层）"></a>2.1.3. 应用服务器（应用层）</h3><p>该层包含具体的业务应用服务</p><p><strong>API网关</strong></p><p>API网关和负载均衡器在原理上是相同的，区别是API网关更多是在服务器内部服务之间实现，而负载均衡更多是在互联网与服务器之间实现</p><ul><li><p>路由请求：API网关可以根据请求的URL、HTTP方法、请求头等信息，将请求路由到相应的后端服务上。</p></li><li><p>协议转换：API网关可以将客户端发送的请求转换成后端服务所支持的协议，从而使得不同协议的服务可以无缝地协同工作。</p></li><li><p>负载均衡：API网关可以将请求分发到多个后端服务上，从而实现负载均衡，提高系统的可用性和性能。</p></li><li><p>安全控制：API网关可以对请求进行验证、鉴权、加密等处理，从而保障系统的安全性。</p></li><li><p>监控和日志：API网关可以对请求进行监控、统计和日志记录，从而实现对系统的监控和管理。</p></li><li><p>缓存：API网关可以对请求结果进行缓存，从而减少后端服务的负载，提高系统的性能。</p></li></ul><p><strong>服务协同与通信</strong></p><p>各个服务如 订单服务和支付服务，可能在不同的进程、容器、服务器中，它们之间如何发现对方并通信</p><p>之前的调用模式：一个模块调用另一个模块，需要在代码中耦合，在代码中描述调用条件，并调用对应的方法或模块。属于<strong>进程内调用</strong></p><p>分布式的调用模式：引入注册中心，被调用服务先在注册中心注册自己，调用模块在注册中心获取可用服务列表，找到要调用的模块，进行RPC调用</p><p><strong>分布式互斥</strong></p><p>多个节点同时对共享资源进行访问时，需要保证资源的互斥访问，避免数据的冲突和重复操作</p><p>通过引入Zookeeper的DataNode保证两个进程的访问顺序</p><p><strong>分布式事务</strong></p><p>一个事务要完成的操作，跨越了多个不同的应用（服务器）</p><p>引入事务协调器</p><h3 id="2-1-4-数据服务器（存储层）"><a href="#2-1-4-数据服务器（存储层）" class="headerlink" title="2.1.4. 数据服务器（存储层）"></a>2.1.4. 数据服务器（存储层）</h3><p>分布式存储会将数据存放在不同的数据表、数据库、服务器上面，单体应用是直接访问数据库获取数据，但是分布式数据库获取数据的方式就要复杂一些</p><p><strong>分布式存储</strong></p><p>如 1000万条商品信息，可能分为两张500万条数据表存储。这两个表可能不在同一个数据库、不在同一个服务器。所以需要在代码中建立对两个数据库的连接，分别做两次查询，这样效率低下</p><p>引入数据库中间件MyCat 解决由数据分片带来的数据路由、SQL解析等问题</p><p><strong>读写分离与主从同步</strong></p><h2 id="2-2-分布式架构的特征"><a href="#2-2-分布式架构的特征" class="headerlink" title="2.2. 分布式架构的特征"></a>2.2. 分布式架构的特征</h2><p><strong>分布性</strong></p><p>拆分部署，将服务拆分，并部署在不同的硬件资源上，这些硬件资源可能分布在不同的网络中</p><p>如 电商系统针对客户浏览商品信息并下单这个过程拆分为：商品服务、订单服务、库存服务、支付服务</p><p><strong>自治性</strong></p><p>每个应用服务都有管理和支配自身任务和资源的能力。对内它可以采用自己的技术实现，并不受其他业务的影响</p><p><strong>并行性</strong></p><p>当某个业务是热门业务时，可将该应用进行水平拓展，该应用与拓展出的应用完成的功能相同，它们并行处理大量请求</p><p><strong>全局性</strong></p><p>分散的资源要共同完成一件事，需要沟通和协作</p><h2 id="2-3-分布式架构的问题"><a href="#2-3-分布式架构的问题" class="headerlink" title="2.3. 分布式架构的问题"></a>2.3. 分布式架构的问题</h2><h3 id="2-3-1-应用服务拆分"><a href="#2-3-1-应用服务拆分" class="headerlink" title="2.3.1. 应用服务拆分"></a>2.3.1. 应用服务拆分</h3><p>先划分业务，再针对划分后的业务进行技术实现</p><p>利用领域驱动设计（Domain-Driven Design，DDD）的方法定义领域模型（Domain Model），确定业务和应用服务的边界</p><ul><li>领域驱动设计的模型结构</li><li>分析业务需求形成应用服务</li><li>领域驱动设计分层架构</li></ul><h3 id="2-3-2-分布式调用"><a href="#2-3-2-分布式调用" class="headerlink" title="2.3.2. 分布式调用"></a>2.3.2. 分布式调用</h3><p>分布式调用可总结为两部分：</p><p>第一部分：感知对方，包括负载均衡、API网关、服务注册与发现、消息队列</p><p>第二部分：信息传递，包括RPC、RMI、NIO通信</p><ul><li>负载均衡分类</li><li>API网关</li><li>服务注册与发现</li><li>服务间的远程调用</li></ul><h3 id="2-3-3-分布式协同"><a href="#2-3-3-分布式协同" class="headerlink" title="2.3.3. 分布式协同"></a>2.3.3. 分布式协同</h3><ul><li>分布式系统的特性与互斥问题</li><li>分布式锁</li><li>分布式事务</li><li>分布式选举</li><li>分布式系统的实践</li></ul><h3 id="2-3-4-分布式计算"><a href="#2-3-4-分布式计算" class="headerlink" title="2.3.4. 分布式计算"></a>2.3.4. 分布式计算</h3><p>分布式架构通常采用水平拓展的方式应对海量数据的计算，不同计算场景下的计算方式可分为两种：针对批量静态数据计算的MapReduce 模式、针对动态数据流进行计算的Stream 模式</p><ul><li>MapReduce 模式</li><li>Stream 模式</li></ul><h3 id="2-3-5-分布式存储"><a href="#2-3-5-分布式存储" class="headerlink" title="2.3.5. 分布式存储"></a>2.3.5. 分布式存储</h3><p>从数据类型划分：结构化数据、非结构化数据</p><p>一个好的数据存储方案，需要关注数据均匀性、数据稳定性、节点异构性、故障隔离</p><ul><li>数据存储面临的问题和解决方案</li><li>分布式存储概念</li><li>分布式关系数据库</li><li>分布式缓存</li></ul><h3 id="2-3-6-分布式资源管理与调度"><a href="#2-3-6-分布式资源管理与调度" class="headerlink" title="2.3.6. 分布式资源管理与调度"></a>2.3.6. 分布式资源管理与调度</h3><p>将任务（用户请求）与资源进行匹配</p><ul><li>分布式调度的由来与过程</li><li>资源的划分和调度策略</li><li>分布式调度架构</li><li>资源调度的实践：Kubernetes 的最佳实践</li></ul><h3 id="2-3-7-高性能与可用性"><a href="#2-3-7-高性能与可用性" class="headerlink" title="2.3.7. 高性能与可用性"></a>2.3.7. 高性能与可用性</h3><ul><li>缓存的应用：HTTP缓存、CDN缓存、负载均衡缓存、进程内缓存、分布式缓存</li><li>可用性的策略：请求限流、服务降级、服务熔断</li></ul><h3 id="2-3-8-指标与监控"><a href="#2-3-8-指标与监控" class="headerlink" title="2.3.8. 指标与监控"></a>2.3.8. 指标与监控</h3><ul><li>性能指标：延迟、流量、错误、饱和度</li><li>分布式监控系统</li><li>流行监控系统的最佳实践：Zabbix、Prometheus</li></ul><h1 id="3-架构设计思路和要点"><a href="#3-架构设计思路和要点" class="headerlink" title="3. 架构设计思路和要点"></a>3. 架构设计思路和要点</h1><h2 id="3-1-架构设计思维方式"><a href="#3-1-架构设计思维方式" class="headerlink" title="3.1. 架构设计思维方式"></a>3.1. 架构设计思维方式</h2><h3 id="3-1-1-过程设计模式"><a href="#3-1-1-过程设计模式" class="headerlink" title="3.1.1. 过程设计模式"></a>3.1.1. 过程设计模式</h3><h3 id="3-1-2-协作式设计模式"><a href="#3-1-2-协作式设计模式" class="headerlink" title="3.1.2. 协作式设计模式"></a>3.1.2. 协作式设计模式</h3><h3 id="3-1-3-扩展立方设计模式"><a href="#3-1-3-扩展立方设计模式" class="headerlink" title="3.1.3. 扩展立方设计模式"></a>3.1.3. 扩展立方设计模式</h3><h2 id="3-2-重构"><a href="#3-2-重构" class="headerlink" title="3.2. 重构"></a>3.2. 重构</h2><h3 id="3-2-1-何时重构"><a href="#3-2-1-何时重构" class="headerlink" title="3.2.1. 何时重构"></a>3.2.1. 何时重构</h3><p>频繁使用的组件</p><p>添加功能时</p><p>修复bug时</p><p>审核代码时</p><h3 id="3-2-2-重构难题"><a href="#3-2-2-重构难题" class="headerlink" title="3.2.2. 重构难题"></a>3.2.2. 重构难题</h3><p>数据库重构（在数据库和业务层之间加入一个中间层Mapper，保证业务层的数据结构发生变化时，无需修改数据库的结构）</p><p>接口与实现</p><p>重构不如重写</p><h2 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3. 测试"></a>3.3. 测试</h2><p><strong>性能测试</strong></p><p>为了得到系统的基准线</p><p><strong>压力测试</strong></p><p>为了得到系统的高压线</p><h1 id="4-职业发展"><a href="#4-职业发展" class="headerlink" title="4. 职业发展"></a>4. 职业发展</h1><h2 id="4-1-技术路线"><a href="#4-1-技术路线" class="headerlink" title="4.1. 技术路线"></a>4.1. 技术路线</h2><p>初级程序员—&gt;中级—&gt;高级—&gt;技术经理</p><h2 id="4-2-管理路线"><a href="#4-2-管理路线" class="headerlink" title="4.2. 管理路线"></a>4.2. 管理路线</h2><p>程序员—&gt;中级工程师—&gt;系统架构师—&gt;项目经理</p><h2 id="4-3-产品路线"><a href="#4-3-产品路线" class="headerlink" title="4.3. 产品路线"></a>4.3. 产品路线</h2><p>程序员—&gt;产品助理—&gt;产品设计师—&gt;产品经理</p><p><strong>参考 《分布式架构原理与实践》崔皓</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-06-03-Terminal%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/28/2023-06-03-Terminal%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认启动为Git Bash</span></span><br><span class="line"><span class="attr">&quot;defaultProfile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;5D1F95DF-36E8-56AD-C203-EA75CE06422C&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can add more global application settings here.</span></span><br><span class="line"><span class="comment">// To learn more about global settings, visit https://aka.ms/terminal-global-settings</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If enabled, selections are automatically copied to your clipboard.</span></span><br><span class="line"><span class="attr">&quot;copyOnSelect&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// If enabled, formatted data is also copied to your clipboard</span></span><br><span class="line"><span class="attr">&quot;copyFormatting&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 黑色主题</span></span><br><span class="line"><span class="attr">&quot;theme&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dark&quot;</span><span class="punctuation">,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A profile specifies a command to execute paired with information about how it should look and feel.</span></span><br><span class="line"><span class="comment">// Each one of them will appear in the &#x27;New Tab&#x27; dropdown,</span></span><br><span class="line"><span class="comment">//   and can be invoked from the commandline with `wt.exe -p xxx`</span></span><br><span class="line"><span class="comment">// To learn more about profiles, visit https://aka.ms/terminal-profile-settings</span></span><br><span class="line"><span class="attr">&quot;profiles&quot;</span><span class="punctuation">:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;defaults&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="comment">// Put settings here that you want to apply to all profiles.</span></span><br><span class="line">        <span class="comment">// 自定义字体</span></span><br><span class="line">        <span class="comment">// &quot;fontFace&quot; : &quot;Fira Code&quot;,</span></span><br><span class="line">        <span class="comment">// 自定义字体大小</span></span><br><span class="line">        <span class="comment">// &quot;fontSize&quot;: 11,</span></span><br><span class="line">        <span class="comment">// 是否启用亚克力效果</span></span><br><span class="line">        <span class="comment">// &quot;useAcrylic&quot; : true,</span></span><br><span class="line">        <span class="comment">// 亚克力效果的透明度</span></span><br><span class="line">        <span class="comment">// &quot;acrylicOpacity&quot; : 0.8,</span></span><br><span class="line">        <span class="comment">// 自带的半黑色配色方案，其他自带配色方案：https://docs.microsoft.com/en-us/windows/terminal/customize-settings/color-schemes</span></span><br><span class="line">        <span class="attr">&quot;colorScheme&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;One Half Dark&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 启动目录</span></span><br><span class="line">        <span class="attr">&quot;startingDirectory&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;%USERPROFILE%\\Desktop&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 输入的时候，窗口自动滚到最下方</span></span><br><span class="line">        <span class="attr">&quot;snapOnInput&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="comment">// 关闭的时候退出</span></span><br><span class="line">        <span class="attr">&quot;closeOnExit&quot;</span> <span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;list&quot;</span><span class="punctuation">:</span></span><br><span class="line">    <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;&#123;5D1F95DF-36E8-56AD-C203-EA75CE06422C&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;Git Bash&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;E:\\Git\\bin\\bash.exe --login -i&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;icon&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;F:\\Pictures\\git-bash.png&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// Make changes here to the cmd.exe profile.</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;命令提示符&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cmd.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// Make changes here to the powershell.exe profile.</span></span><br><span class="line">            <span class="attr">&quot;guid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Windows PowerShell&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;powershell.exe&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-06-03-cmd%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
      <url>/2024/10/28/2023-06-03-cmd%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>首先需要查看代理软件的代理端口，比如我这里的代理端口是7890</p><p>设置http代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>设置socks5代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=socks5://127.0.0.1:7890</span><br><span class="line">set https_proxy=socks5://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>取消代理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br></pre></td></tr></table></figure><p>代理测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.google.com（不可以用ping测试）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-07-26-CentOS%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
      <url>/2024/10/28/2023-07-26-CentOS%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p><strong>注：Centos7 Linux 内核：3.10</strong> </p><h1 id="1-网络"><a href="#1-网络" class="headerlink" title="1. 网络"></a>1. 网络</h1><p><code>/etc/sysconfig/network-scripts/ifcfg-ens33</code> 是一个网络配置文件，通常在Linux系统中用于配置网络接口。在这个特定的文件中，<code>ONBOOT</code> 项用于指定网络接口是否在系统引导时自动启动。如果将其设置为 <code>ONBOOT=yes</code>，那么该网络接口将在系统引导时自动启动。如果设置为 <code>ONBOOT=no</code>，则该网络接口将不会在系统引导时自动启动，需要手动启动。</p><h1 id="2-Yum源"><a href="#2-Yum源" class="headerlink" title="2. Yum源"></a>2. Yum源</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 1 安装 </span><br><span class="line">yum install package  // 安装指定的安装包package </span><br><span class="line"></span><br><span class="line">// 2 更新和升级 </span><br><span class="line">yum update  // 全部更新 </span><br><span class="line">yum update package  // 更新指定程序包package</span><br><span class="line">yum check-update  // 检查可更新的程序 </span><br><span class="line">yum upgrade package  // 升级指定程序包package </span><br><span class="line"></span><br><span class="line">// 3 查找和显示 </span><br><span class="line">yum info // 列出所有可以安装或更新的包的信息</span><br><span class="line">yum info package //显示安装包信息package </span><br><span class="line">yum list // 显示所有已经安装和可以安装的程序包 </span><br><span class="line">yum list package  // 显示指定程序包安装情况package</span><br><span class="line">yum search package // 搜索匹配特定字符的package的详细信息</span><br><span class="line"></span><br><span class="line">// 4 删除程序 </span><br><span class="line">yum remove | erase package  // 删除程序包package</span><br><span class="line">yum deplist package  // 查看程序package依赖情况</span><br><span class="line"></span><br><span class="line">// 5 清除缓存 </span><br><span class="line">yum clean packages  // 清除缓存目录下的软件包 </span><br><span class="line">yum clean headers // 清除缓存目录下的 headers </span><br><span class="line">yum clean oldheaders // 清除缓存目录下旧的 headers </span><br><span class="line">yum clean, yum clean all  // (= yum clean packages; yum clean oldheaders) 清除缓存目录下的软件包及旧的headers</span><br></pre></td></tr></table></figure><h1 id="3-连接网络"><a href="#3-连接网络" class="headerlink" title="3. 连接网络"></a>3. 连接网络</h1><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-enp33（每个机器enp不一样）</span><br></pre></td></tr></table></figure><p>配置子网、网关</p><p>安装网络工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install net-tools</span><br></pre></td></tr></table></figure><h1 id="4-开启SSH"><a href="#4-开启SSH" class="headerlink" title="4. 开启SSH"></a>4. 开启SSH</h1><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#切换到root</span><br><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">PermitRootLogin         yes    #是否允许root用户登录</span><br><span class="line">PermitEmptyPasswords    no            #是否允许空密码</span><br><span class="line">PasswordAuthentication  yes            #是否允许密码验证</span><br><span class="line">AllowUsers              xxxxx    #允许xxxxx用户登录</span><br></pre></td></tr></table></figure><p>防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=22/tcp --permanent#向防火墙中添加端口--permanent 永久生效</span><br><span class="line">firewall-cmd --reload                       #使防火墙规则生效  </span><br><span class="line">firewall-cmd --zone=public --query-port=22/tcp#查看端口是否添加成功: </span><br><span class="line">firewall-cmd --list-ports    #查看防火墙开放的端口</span><br></pre></td></tr></table></figure><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart         #重启ssh服务</span><br></pre></td></tr></table></figure><p>开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable sshd        #开机启动sshd服务</span><br><span class="line">systemctl list-unit-files |grep ssh                #检查是否开机启动</span><br><span class="line">systemctl stop sshd#停止sshd服务</span><br><span class="line">systemctl disable sshd        #禁用开机启动sshd服务</span><br></pre></td></tr></table></figure><h1 id="5-安装Redis"><a href="#5-安装Redis" class="headerlink" title="5. 安装Redis"></a>5. 安装Redis</h1><p>安装或更新EPEL包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br></pre></td></tr></table></figure><p>安装Redis</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install redis -y </span><br></pre></td></tr></table></figure><p>添加到系统服务并设置开机启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start redis.service</span><br><span class="line">sudo systemctl enable redis</span><br></pre></td></tr></table></figure><p>查看状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status redis.service</span><br></pre></td></tr></table></figure><p>配置Redis密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/redis.conf</span><br></pre></td></tr></table></figure><p>找到SECURITY部分，查找<code># requirepass foobared</code>，去掉前面的注释，并将foobared修改为自己的密码，如<code>requirepass 123456</code></p><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart redis.service </span><br></pre></td></tr></table></figure><p>访问 redis-cli命令，测试安装效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></table></figure><p>配置redis允许远程连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置redis.conf </span><br><span class="line">将 bind 127.0.0.1 ，改为0.0.0.0</span><br><span class="line">将 protected-mode yes 改为 protected-mode no（3.2之后加入的新特性，目的是禁止公网访问redis cache，增强redis的安全性）</span><br><span class="line">设置防火墙 firewall-cmd --zone=public --add-port=6379/tcp --permanent</span><br></pre></td></tr></table></figure><h1 id="6-安装docker"><a href="#6-安装docker" class="headerlink" title="6. 安装docker"></a>6. 安装docker</h1><p>Centos7 Linux 内核：官方建议 3.10 以上</p><p>查看当前的内核版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -r</span><br></pre></td></tr></table></figure><p>卸载旧版本 docker</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker.*</span><br></pre></td></tr></table></figure><p>具体步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 2. step 1: 安装必要的一些系统工具</span><br><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line"># 3. Step 2: 添加软件源信息</span><br><span class="line">sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 4. Step 3</span><br><span class="line">sudo sed -i &#x27;s+download.docker.com+mirrors.aliyun.com/docker-ce+&#x27; /etc/yum.repos.d/docker-ce.repo</span><br><span class="line"></span><br><span class="line"># 5. Step 4: 更新并安装Docker-CE</span><br><span class="line">sudo yum makecache fast</span><br><span class="line">sudo yum -y install docker-ce</span><br><span class="line"></span><br><span class="line"># 6. Step : 开启Docker服务</span><br><span class="line">sudo service docker start</span><br></pre></td></tr></table></figure><p>启动 Docker 并设置开机自启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>测试docker是否安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><p>添加阿里云镜像</p><p>编辑配置文件<code>/etc/docker/daemon.json</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123; &quot;registry-mirrors&quot;: [ &quot;https://hub-mirror.c.163.com&quot;, &quot;https://mirror.baidubce.com&quot; ] &#125;</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>检查加速器是否生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><h1 id="7-firewall"><a href="#7-firewall" class="headerlink" title="7. firewall"></a>7. firewall</h1><p>开启防火墙：<br>systemctl start firewalld.service</p><p>关闭防火墙：<br>systemctl stop firewalld.service</p><p>查看防火墙是否开启：<br>systemctl status firewalld</p><p>查看所有开启的端口：<br>firewall-cmd —list-ports</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state ##查看防火墙状态，是否是running</span><br><span class="line">firewall-cmd --reload ##重新载入配置，比如添加规则之后，需要执行此命令</span><br><span class="line">firewall-cmd --get-zones ##列出支持的zone</span><br><span class="line">firewall-cmd --get-services ##列出支持的服务，在列表中的服务是放行的</span><br><span class="line">firewall-cmd --query-service ftp ##查看ftp服务是否支持，返回yes或者no</span><br><span class="line">firewall-cmd --add-service=ftp ##临时开放ftp服务</span><br><span class="line">firewall-cmd --add-service=ftp --permanent ##永久开放ftp服务</span><br><span class="line">firewall-cmd --remove-service=ftp --permanent ##永久移除ftp服务</span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent ##永久添加80端口</span><br><span class="line">iptables -L -n ##查看规则，这个命令是和iptables的相同的</span><br></pre></td></tr></table></figure><h1 id="8-Centos8"><a href="#8-Centos8" class="headerlink" title="8. Centos8"></a>8. Centos8</h1><p>CentOS 8已于2021年12月31日停止维护</p><p><strong>错误：为 repo ‘appstream’ 下载元数据失败解决办法</strong></p><p>可以在/etc/yum.repos.d中更新一下源。使用vault.centos.org代替mirror.centos.org。 解决方法, 执行一下两行代码进行修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo sed -i -e <span class="string">&quot;s|mirrorlist=|#mirrorlist=|g&quot;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">sudo sed -i -e <span class="string">&quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot;</span> /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure><p>修改之后清缓存，制作元数据缓存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除所有缓存文件</span></span><br><span class="line">yum clean <span class="built_in">all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 制作元数据缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-07-Git%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/10/28/2023-09-07-Git%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">git config -e [--global]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置代理（具体端口号需要查看本机的代理端口） </span></span><br><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config [--global] --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config [--global] --<span class="built_in">unset</span> https.proxy </span><br></pre></td></tr></table></figure><p><strong>为Github账户设置SSH key</strong></p><p>首先检查是否已生成密钥 <code>cd ~/.ssh</code>，ls如果有2个文件，则密钥已经生成，<code>id_rsa.pub</code>就是公钥</p><p>如果没有生成，那么通过 命令 来生成</p><p><code>ssh-keygen -t rsa -C &quot;...@qq.com&quot;</code></p><p>生成后，去对应目录<code>C:\Users\Y\ .ssh</code>里（Y为电脑用户名，每个人不同）用记事本打开<code>id_rsa.pub</code>，得到ssh key公钥</p><p>切换到github，展开个人头像的小三角，点击settings</p><p>然后打开SSH keys菜单， 点击Add SSH key新增密钥，填上标题，跟仓库名保持一致吧，好区分。</p><p>接着将<code>id_rsa.pub</code>文件中key粘贴到此，最后Add key生成密钥。到此，github账号的SSH keys配置完成。</p><h1 id="2-仓库"><a href="#2-仓库" class="headerlink" title="2. 仓库"></a>2. 仓库</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">git init [project-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure><h1 id="3-增加-删除文件"><a href="#3-增加-删除文件" class="headerlink" title="3. 增加/删除文件"></a>3. 增加/删除文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">git add -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure><h1 id="4-代码提交"><a href="#4-代码提交" class="headerlink" title="4. 代码提交"></a>4. 代码提交</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">git commit -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><h1 id="5-分支"><a href="#5-分支" class="headerlink" title="5. 分支"></a>5. 分支</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">git checkout -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin --delete [branch-name]</span><br><span class="line">git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h1 id="6-标签"><a href="#6-标签" class="headerlink" title="6. 标签"></a>6. 标签</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">git tag [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">git tag -d [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">git show [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">git push [remote] --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h1 id="7-查看信息"><a href="#7-查看信息" class="headerlink" title="7. 查看信息"></a>7. 查看信息</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">git <span class="built_in">log</span> --follow [file]</span><br><span class="line">git whatchanged [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">git <span class="built_in">log</span> -p [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">git shortlog -sn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">git blame [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">git diff --cached [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">git show [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h1 id="8-远程同步"><a href="#8-远程同步" class="headerlink" title="8. 远程同步"></a>8. 远程同步</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">git fetch [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">git remote show [remote]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">git push [remote] --force</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">git push [remote] --all</span><br></pre></td></tr></table></figure><h1 id="9-撤销"><a href="#9-撤销" class="headerlink" title="9. 撤销"></a>9. 撤销</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">git checkout [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">git checkout .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">git reset [file]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">git reset --hard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">git reset [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">git revert [commit]</span><br><span class="line"></span><br><span class="line">暂时将未提交的变化移除，稍后再移入</span><br><span class="line">git stash</span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-06-26-How%20To%20Ask%20Questions%20The%20Smart%20Way/"/>
      <url>/2024/10/28/2023-06-26-How%20To%20Ask%20Questions%20The%20Smart%20Way/</url>
      
        <content type="html"><![CDATA[<h1 id="1-提问的智慧"><a href="#1-提问的智慧" class="headerlink" title="1. 提问的智慧"></a>1. 提问的智慧</h1><p><strong>How To Ask Questions The Smart Way</strong></p><p>Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen</p><p>本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。</p><p>原文网址：<a href="http://www.catb.org/~esr/faqs/smart-questions.html">http://www.catb.org/~esr/faqs/smart-questions.html</a></p><p>Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu</p><p>本中文指南是基于原文 3.10 版以及 2010 年由 <a href="https://github.com/gasolin">Gasolin</a> 所翻译版本的最新翻译；</p><h2 id="1-1-目录"><a href="#1-1-目录" class="headerlink" title="1.1. 目录"></a>1.1. 目录</h2><ul><li><a href="#声明">声明</a></li><li><a href="#简介">简介</a></li><li><a href="#在提问之前">在提问之前</a></li><li><a href="#当你提问时">当你提问时</a><ul><li><a href="#慎选提问的论坛">慎选提问的论坛</a></li><li><a href="#stack-overflow">Stack Overflow</a></li><li><a href="#网站和-irc-论坛">网站和 IRC 论坛</a></li><li><a href="#第二步使用项目邮件列表">第二步，使用项目邮件列表</a></li><li><a href="#使用有意义且描述明确的标题">使用有意义且描述明确的标题</a></li><li><a href="#使问题容易回复">使问题容易回复</a></li><li><a href="#使用清晰、正确、精准且合乎语法的语句">使用清晰、正确、精准且合乎语法的语句</a></li><li><a href="#使用易于读取且标准的文件格式发送问题">使用易于读取且标准的文件格式发送问题</a></li><li><a href="#精确地描述问题并言之有物">精确地描述问题并言之有物</a></li><li><a href="#话不在多而在精">话不在多而在精</a></li><li><a href="#别动辄声称找到-bug">别动辄声称找到 Bug</a></li><li><a href="#低声下气不能代替你的功课">低声下气不能代替你的功课</a></li><li><a href="#描述问题症状而非你的猜测">描述问题症状而非你的猜测</a></li><li><a href="#按发生时间先后列出问题症状">按发生时间先后列出问题症状</a></li><li><a href="#描述目标而不是过程">描述目标而不是过程</a></li><li><a href="#别要求使用私人电邮回复">别要求使用私人电邮回复</a></li><li><a href="#清楚明确的表达你的问题以及需求">清楚明确的表达你的问题以及需求</a></li><li><a href="#询问有关代码的问题时">询问有关代码的问题时</a></li><li><a href="#别把自己家庭作业的问题贴上来">别把自己家庭作业的问题贴上来</a></li><li><a href="#去掉无意义的提问句">去掉无意义的提问句</a></li><li><a href="#即使你很急也不要在标题写紧急">即使你很急也不要在标题写<code>紧急</code></a></li><li><a href="#礼多人不怪而且有时还很有帮助">礼多人不怪，而且有时还很有帮助</a></li><li><a href="#问题解决后加个简短的补充说明">问题解决后，加个简短的补充说明</a></li></ul></li><li><a href="#如何解读答案">如何解读答案</a><ul><li><a href="#rtfm-和-stfw如何知道你已完全搞砸了">RTFM 和 STFW：如何知道你已完全搞砸了</a></li><li><a href="#如果还是搞不懂">如果还是搞不懂</a></li><li><a href="#处理无礼的回应">处理无礼的回应</a></li></ul></li><li><a href="#如何避免扮演失败者">如何避免扮演失败者</a></li><li><a href="#不该问的问题">不该问的问题</a></li><li><a href="#好问题与蠢问题">好问题与蠢问题</a></li><li><a href="#如果得不到回答">如果得不到回答</a></li><li><a href="#如何更好地回答问题">如何更好地回答问题</a></li><li><a href="#相关资源">相关资源</a></li><li><a href="#鸣谢">鸣谢</a></li></ul><h2 id="1-2-声明"><a href="#1-2-声明" class="headerlink" title="1.2. 声明"></a>1.2. 声明</h2><p>许多项目在他们网站的帮助文档中链接了本指南。这很好，这正是我们想要的用途。但如果你是该项目管理员并试图创建指向本指南的超链接，请在超链接附近的显著位置注明：</p><p><strong>本指南不提供此项目的实际支持服务！</strong></p><p>我们已经深刻领教到缺少上述声明所带来的痛苦：我们将不停地被那些认为发布这本指南就意味着有责任解决世上所有技术问题的傻瓜苦苦纠缠。</p><p>如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些傻瓜之一。别问我们问题，我们只会忽略你。我们在这本指南中想教你如何从那些真正懂得你所遇到的软件或硬件问题的人处取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。</p><h2 id="1-3-简介"><a href="#1-3-简介" class="headerlink" title="1.3. 简介"></a>1.3. 简介</h2><p>在<a href="http://www.catb.org/~esr/faqs/hacker-howto.html">黑客</a>的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确地提问以获得你满意的答案。</p><p>现在开源（Open Source）软件已经相当盛行，您通常可以从其他更有经验的用户那里获得与黑客一样好的答案，这是件<strong>好事</strong>；和黑客相比，用户们往往对那些新手常遇到的问题更宽容一些。尽管如此，以我们在此推荐的方式对待这些有经验的用户通常也是从他们那里获得有用答案的最有效方式。</p><p>首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，“好问题！”是诚挚的大力称赞。</p><p>尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。</p><p>我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 <code>失败者（撸瑟）</code> （由于历史原因，我们有时把它拼作 <code>lusers</code>）。</p><p>我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们认可这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们只为那些真正有兴趣并愿意积极参与问题解决的人调整回答问题的风格。这点不会变，也不该变：否则，我们就是在最擅长的事情上降低效率。</p><p>我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情地滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效地利用时间来回答<code>赢家（winner）</code>的问题。</p><p>如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。</p><p>所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。</p><p>如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。</p><p>（欢迎对本指南提出改进意见。你可以把你的建议发送至 <a href="esr@thyrsus.com">esr@thyrsus.com</a> 或 <a href="respond-auto@linuxmafia.com">respond-auto@linuxmafia.com</a>。然而请注意，本文并非<a href="http://www.ietf.org/rfc/rfc1855.txt">网络礼节</a>的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。</p><h2 id="1-4-在提问之前"><a href="#1-4-在提问之前" class="headerlink" title="1.4. 在提问之前"></a>1.4. 在提问之前</h2><p>在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情：</p><pre><code>1. 尝试在你准备提问的论坛的旧文章中搜索答案。2. 尝试上网搜索以找到答案。3. 尝试阅读手册以找到答案。4. 尝试阅读常见问题文件（FAQ）以找到答案。5. 尝试自己检查或试验以找到答案。6. 向你身边的强者朋友打听以找到答案。7. 如果你是程序开发者，请尝试阅读源代码以找到答案。</code></pre><p>当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所<strong>学到</strong>的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。</p><p>运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 <a href="http://groups.google.com/">Google 论坛</a>和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 <code>我在 Google 中搜过下列句子但没有找到什么有用的东西</code> 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。</p><p>别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐得舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。</p><p>准备好你的问题，再将问题仔细地思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。</p><p>小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着<code>蠢问题…</code>，一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。</p><p>绝不要自以为<strong>够格</strong>得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去<strong>挣到</strong>一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动地从他人处索取知识。</p><p>另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。<code>谁能给点提示？</code>、<code>我的这个例子里缺了什么？</code>以及<code>我应该检查什么地方</code>比<code>请把我需要的确切的过程贴出来</code>更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。</p><h2 id="1-5-当你提问时"><a href="#1-5-当你提问时" class="headerlink" title="1.5. 当你提问时"></a>1.5. 当你提问时</h2><h3 id="1-5-1-慎选提问的论坛"><a href="#1-5-1-慎选提问的论坛" class="headerlink" title="1.5.1. 慎选提问的论坛"></a>1.5.1. 慎选提问的论坛</h3><p>小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者：</p><ul><li>在与主题不合的论坛上贴出你的问题。</li><li>在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。</li><li>在太多的不同新闻群组上重复转贴同样的问题（cross-post）。</li><li>向既非熟人也没有义务解决你问题的人发送私人电邮。</li></ul><p>黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。</p><p>因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括<strong>阅读</strong> FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。</p><p>向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。</p><p>在选择论坛、新闻群组或邮件列表时，别太相信它的名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。</p><p>别像机关枪似的一次“扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。</p><p>搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。</p><p>一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。</p><p>可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者由于涌入其私人邮箱的大量不堪忍受的无用邮件而不再提供支持。</p><h3 id="1-5-2-Stack-Overflow"><a href="#1-5-2-Stack-Overflow" class="headerlink" title="1.5.2. Stack Overflow"></a>1.5.2. Stack Overflow</h3><p>搜索，<em>然后</em>在 Stack Exchange 问。</p><p>近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。</p><p>因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的几率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。</p><p>如果你还是找不到任何对你的问题有用的内容，请把你的问题发在与它最相关的网站上。提问的时候请善用格式化工具，尤其注意为代码添加格式，并且添加相关的标签（特别是编程语言、操作系统或库/包的名称）。当有人要求你提供更多相关信息时，请编辑你的贴子来补充它们[译注：而不是发一个回帖或回答！]。如果你觉得一个答案对你有帮助，点击向上的箭头来为它投票；如果一个答案提供了问题的正确解决方案，点击投票按钮下方的对勾来将它标记为正解。</p><p>Stack Exchange 已经成长到<a href="https://stackexchange.com/sites">超过一百个网站</a>，以下是最常用的几个站：</p><ul><li>Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。</li><li>Stack Overflow 是问写程序有关的问题。</li><li>Server Fault 是问服务器和网管相关的问题。</li></ul><h3 id="1-5-3-网站和-IRC-论坛"><a href="#1-5-3-网站和-IRC-论坛" class="headerlink" title="1.5.3. 网站和 IRC 论坛"></a>1.5.3. 网站和 IRC 论坛</h3><p>本地的用户群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表），这些都是开始提问的好地方，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。</p><p>事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复“使用<strong>我们的</strong>版本”。</p><p>在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。</p><p>通过论坛或 IRC 频道来提供用户支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。</p><p>在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。</p><h3 id="1-5-4-第二步，使用项目邮件列表"><a href="#1-5-4-第二步，使用项目邮件列表" class="headerlink" title="1.5.4. 第二步，使用项目邮件列表"></a>1.5.4. 第二步，使用项目邮件列表</h3><p>当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法：</p><ul><li>任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，那这也不能成为骚扰个别开发者的理由。</li><li>向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。</li><li>大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其他人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。</li><li>如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。</li></ul><p>如果一个项目既有“用户”也有“开发者”（或“黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。</p><p>然而，如果你<strong>确信</strong>你的问题很特别，而且在“用户”列表或论坛中几天都没有回复，可以试试前往“开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意）</p><p>如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。</p><h3 id="1-5-5-使用有意义且描述明确的标题"><a href="#1-5-5-使用有意义且描述明确的标题" class="headerlink" title="1.5.5. 使用有意义且描述明确的标题"></a>1.5.5. 使用有意义且描述明确的标题</h3><p>在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的<code>帮帮忙</code>、<code>跪求</code>、<code>急</code>（更别说<code>救命啊！！！！</code>这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。</p><p>一个好标题范例是<code>目标 —— 差异</code>式的描述，许多技术支持组织就是这样做的。在<code>目标</code>部分指出是哪一个或哪一组东西有问题，在<code>差异</code>部分则描述与期望的行为不一致的地方。</p><blockquote><p>蠢问题：救命啊！我的笔记本电脑不能正常显示了！</p><p>聪明问题：X.org 6.8.1 的鼠标指针会变形，某牌显卡 MV1005 芯片组。</p><p>更聪明问题：X.org 6.8.1 的鼠标指针，在某牌显卡 MV1005 芯片组环境下 - 会变形。</p></blockquote><p>编写<code>目标 —— 差异</code> 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标指针或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境<strong>和</strong>你遇到的问题。</p><p>总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。</p><p>如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 <code>Re: 测试</code> 或者 <code>Re: 新 bug</code> 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。</p><p>对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许用户按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。</p><p>仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。</p><p>在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你<strong>只想</strong>在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。</p><h3 id="1-5-6-使问题容易回复"><a href="#1-5-6-使问题容易回复" class="headerlink" title="1.5.6. 使问题容易回复"></a>1.5.6. 使问题容易回复</h3><p>以<code>请将你的回复发送到……</code>来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，<a href="http://linuxmafia.com/faq/Mail/muas.html">换个好点的</a>；如果是操作系统不支持这种邮件程序，也换个好点的。</p><p>在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如<code>追踪此讨论串</code>、<code>有回复时发送邮件提醒</code>等功能。</p><h3 id="1-5-7-使用清晰、正确、精准且合乎语法的语句"><a href="#1-5-7-使用清晰、正确、精准且合乎语法的语句" class="headerlink" title="1.5.7. 使用清晰、正确、精准且合乎语法的语句"></a>1.5.7. <a name="使用清晰、正确、精准且合乎语法的语句">使用清晰、正确、精准且合乎语法的语句</a></h3><p>我们从经验中发现，粗心的提问者通常也会粗心地写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。</p><p>正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它<strong>必须很</strong>准确，而且有迹象表明你是在思考和关注问题。</p><p>正确地拼写、使用标点和大小写，不要将<code>its</code>混淆为<code>it&#39;s</code>，<code>loose</code>搞成<code>lose</code>或者将<code>discrete</code>弄成<code>discreet</code>。不要<strong>全部用大写</strong>，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。<a href="http://en.wikipedia.org/wiki/Alan_Cox">Alan Cox</a> 也许可以这样做，但你不行）。</p><p>更白话的说，如果你写得像是个半文盲[译注：<a href="http://zh.wikipedia.org/wiki/小白">小白</a>]，那多半得不到理睬。也不要使用即时通信中的简写或<a href="http://zh.wikipedia.org/wiki/火星文">火星文</a>，如将<code>的</code>简化为<code>d</code>会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。</p><p>如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂的语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。</p><p>如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：<br>[译注：以下附上原文以供使用]</p><blockquote><p>English is not my native language; please excuse typing errors.</p></blockquote><ul><li>英文不是我的母语，请原谅我的错字或语法。</li></ul><blockquote><p>If you speak $LANGUAGE, please email/PM me;<br>I may need assistance translating my question.</p></blockquote><ul><li>如果你说<strong>某语言</strong>，请向我发电邮/私信；</li><li>我需要有人协助我翻译我的问题。</li></ul><blockquote><p>I am familiar with the technical terms,<br>but some slang expressions and idioms are difficult for me.</p></blockquote><ul><li>我对技术名词很熟悉，但对于俗语或是特别用法不甚了解。</li></ul><blockquote><p>I’ve posted my question in $LANGUAGE and English.<br>I’ll be glad to translate responses, if you only use one or the other.</p></blockquote><ul><li>我把我的问题用<strong>某语言</strong>和英文写出来。</li><li>如果你只用其中的一种语言回答，我会乐意将回复翻译成为你使用的语言。</li></ul><h3 id="1-5-8-使用易于读取且标准的文件格式发送问题"><a href="#1-5-8-使用易于读取且标准的文件格式发送问题" class="headerlink" title="1.5.8. 使用易于读取且标准的文件格式发送问题"></a>1.5.8. 使用易于读取且标准的文件格式发送问题</h3><p>如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以：</p><ul><li>使用纯文字而不是 HTML (<a href="http://archive.birdhouse.org/etc/evilmail.html">关闭 HTML</a> 并不难）。</li><li>使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。</li><li>不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。</li><li>但是，对一些特殊的文件<strong>不要</strong>设置固定宽度（譬如日志文件拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。</li><li>在英语论坛中，不要使用<code>Quoted-Printable</code> MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的<code>=20</code>符号既难看也分散注意力，甚至有可能破坏内容的语意。</li><li>绝对，<strong>永远</strong>不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。</li><li>如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的<code>智能引号</code>功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉<code>智能引号</code>单选框），以免在你的邮件中到处散布垃圾字符。</li><li>在论坛，勿滥用<code>表情符号</code>和<code>HTML</code>功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。</li></ul><p>如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的<code>查看源代码</code>命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。</p><h3 id="1-5-9-精确地描述问题并言之有物"><a href="#1-5-9-精确地描述问题并言之有物" class="headerlink" title="1.5.9. 精确地描述问题并言之有物"></a>1.5.9. 精确地描述问题并言之有物</h3><ul><li>仔细、清楚地描述你的问题或 Bug 的症状。</li><li>描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：<code>Fedora Core 4</code>、<code>Slackware 9.1</code>等）。</li><li>描述在提问前你是怎样去研究和理解这个问题的。</li><li>描述在提问前为确定问题而采取的诊断步骤。</li><li>描述最近做过什么可能相关的硬件或软件变更。</li><li>尽可能地提供一个可以<code>重现这个问题的可控环境</code>的方法。</li></ul><p>尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能提出的问题回答一遍。</p><p>以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。</p><p><a href="http://www.chiark.greenend.org.uk/~sgtatham/">Simon Tatham</a> 写过一篇名为《<a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html">如何有效的报告 Bug</a>》的出色文章。强力推荐你也读一读。</p><h3 id="1-5-10-话不在多而在精"><a href="#1-5-10-话不在多而在精" class="headerlink" title="1.5.10. 话不在多而在精"></a>1.5.10. 话不在多而在精</h3><p>你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。</p><p>这样做的用处至少有三点。<br>第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；<br>第二，简化问题使你更有可能得到<strong>有用</strong>的答案；<br>第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。</p><h3 id="1-5-11-别动辄声称找到-Bug"><a href="#1-5-11-别动辄声称找到-Bug" class="headerlink" title="1.5.11. 别动辄声称找到 Bug"></a>1.5.11. 别动辄声称找到 Bug</h3><p>当你在使用软件中遇到问题，除非你非常、<strong>非常</strong>的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的<code>Bug</code>，你应该能提供相应位置的修正或替代文件。</p><p>请记得，还有其他许多用户没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前<a href="#在提问之前">已经做了这些，是吧</a>？）。这也意味着很有可能是你弄错了而不是软件本身有问题。</p><p>编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有<code>Bug</code>时，这尤其严重。</p><p>提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是<strong>你</strong>做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。</p><h3 id="1-5-12-低声下气不能代替你的功课"><a href="#1-5-12-低声下气不能代替你的功课" class="headerlink" title="1.5.12. 低声下气不能代替你的功课"></a>1.5.12. 低声下气不能代替你的功课</h3><p>有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：<code>我知道我只是个可悲的新手，一个撸瑟，但...</code>。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。</p><p>别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。</p><p>有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。</p><h3 id="1-5-13-描述问题症状而非你的猜测"><a href="#1-5-13-描述问题症状而非你的猜测" class="headerlink" title="1.5.13. 描述问题症状而非你的猜测"></a>1.5.13. 描述问题症状而非你的猜测</h3><p>告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。</p><p><strong>蠢问题</strong></p><blockquote><p>我在编译内核时接连遇到 SIG11 错误，<br>我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组），<br>256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误，<br>但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。<br>所有内存都换过了，没有效果。相关部分的标准编译记录如下…</p></blockquote><p>由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：<code>所有的诊断专家都来自密苏里州。</code> 美国国务院的官方座右铭则是：<code>让我看看</code>（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：<code>我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。</code>） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方地展示给我们看吧！</p><h3 id="1-5-14-按发生时间先后列出问题症状"><a href="#1-5-14-按发生时间先后列出问题症状" class="headerlink" title="1.5.14. 按发生时间先后列出问题症状"></a>1.5.14. 按发生时间先后列出问题症状</h3><p>问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。</p><p>如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，<code>多</code>不等于<code>好</code>。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。</p><p>如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。</p><h3 id="1-5-15-描述目标而不是过程"><a href="#1-5-15-描述目标而不是过程" class="headerlink" title="1.5.15. 描述目标而不是过程"></a>1.5.15. 描述目标而不是过程</h3><p>如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。</p><p>经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。</p><p><strong>蠢问题</strong></p><blockquote><p>我怎样才能从某绘图程序的颜色选择器中取得十六进制的 RGB 值？</p></blockquote><p><strong>聪明问题</strong></p><blockquote><p>我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot），<br>但却无法从某绘图程序的颜色选择器取得十六进制的 RGB 值。</p></blockquote><p>第二种提问法比较聪明，你可能得到像是<code>建议采用另一个更合适的工具</code>的回复。</p><h3 id="1-5-16-别要求使用私人电邮回复"><a href="#1-5-16-别要求使用私人电邮回复" class="headerlink" title="1.5.16. 别要求使用私人电邮回复"></a>1.5.16. 别要求使用私人电邮回复</h3><p>黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。</p><p>当你要求私下回复时，这个过程和奖励都被中止。别这样做，让<strong>回复者</strong>来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于不可能使其他人产生兴趣。</p><p>这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是<code>向我发电邮，我将为论坛归纳这些回复</code>。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。</p><h3 id="1-5-17-清楚明确地表达你的问题以及需求"><a href="#1-5-17-清楚明确地表达你的问题以及需求" class="headerlink" title="1.5.17. 清楚明确地表达你的问题以及需求"></a>1.5.17. 清楚明确地表达你的问题以及需求</h3><p>漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。</p><p>如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。</p><p>要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。</p><p>所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你获得有用的答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问<code>我想更好地理解 X，可否指点一下哪有好一点说明？</code>通常比问<code>你能解释一下 X 吗？</code>更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。</p><h3 id="1-5-18-询问有关代码的问题时"><a href="#1-5-18-询问有关代码的问题时" class="headerlink" title="1.5.18. 询问有关代码的问题时"></a>1.5.18. 询问有关代码的问题时</h3><p>如果没有提示别人应该从何入手，别要求他人帮你调试有问题的代码。张贴几百行的代码，然后说一声：<code>它不能工作</code>会让你完全被忽略。只贴几十行代码，然后说一句：<code>在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;</code>比较有可能让你得到回应。</p><p>最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能<strong>刚好</strong>展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看<a href="#话不在多而在精">话不在多而在精</a>一节）。</p><p>一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做是一个好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。</p><p>如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。</p><h3 id="1-5-19-别把自己家庭作业的问题贴上来"><a href="#1-5-19-别把自己家庭作业的问题贴上来" class="headerlink" title="1.5.19. 别把自己家庭作业的问题贴上来"></a>1.5.19. 别把自己家庭作业的问题贴上来</h3><p>黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由<strong>你</strong>来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。</p><p>如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户群组，论坛或（最后一招）在项目的<strong>用户</strong>邮件列表或论坛中提问。尽管黑客们<strong>会</strong>看出来，但一些有经验的用户也许仍会给你一些提示。</p><h3 id="1-5-20-去掉无意义的提问句"><a href="#1-5-20-去掉无意义的提问句" class="headerlink" title="1.5.20. 去掉无意义的提问句"></a>1.5.20. 去掉无意义的提问句</h3><p>避免用无意义的话结束提问，例如<code>有人能帮我吗？</code>或者<code>这有答案吗？</code>。</p><p>首先：如果你对问题的描述不是很好，这样问更是画蛇添足。</p><p>其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：<code>没错，有人能帮你</code>或者<code>不，没答案</code>。</p><p>一般来说，避免用 <code>是或否</code>、<code>对或错</code>、<code>有或没有</code>类型的问句，除非你想得到<a href="https://strcat.de/questions-with-yes-or-no-answers.html">是或否类型的回答</a>。</p><h3 id="1-5-21-即使你很急也不要在标题写紧急"><a href="#1-5-21-即使你很急也不要在标题写紧急" class="headerlink" title="1.5.21. 即使你很急也不要在标题写紧急"></a>1.5.21. 即使你很急也不要在标题写<code>紧急</code></h3><p>这是你的问题，不是我们的。宣称<code>紧急</code>极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，<code>紧急</code>这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。</p><p>有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。</p><p>当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如<code>紧急：帮我救救这个毛茸茸的小海豹！</code>肯定让你被黑客忽略或惹恼他们，即使他们认为毛茸茸的小海豹很重要。</p><p>如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。</p><h3 id="1-5-22-礼多人不怪，而且有时还很有帮助"><a href="#1-5-22-礼多人不怪，而且有时还很有帮助" class="headerlink" title="1.5.22. 礼多人不怪，而且有时还很有帮助"></a>1.5.22. 礼多人不怪，而且有时还很有帮助</h3><p>彬彬有礼，多用<code>请</code>和<code>谢谢您的关注</code>，或<code>谢谢你的关照</code>。让大家都知道你对他们花时间免费提供帮助心存感激。</p><p>坦白说，这一点并没有比使用清晰、正确、精准且合乎语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的）</p><p>然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。</p><p>（我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得<code>先谢了</code>意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说<code>先谢了</code>，<strong>然后</strong>事后再对回复者表示感谢，或者换种方式表达感激，譬如用<code>谢谢你的关注</code>或<code>谢谢你的关照</code>。）</p><h3 id="1-5-23-问题解决后，加个简短的补充说明"><a href="#1-5-23-问题解决后，加个简短的补充说明" class="headerlink" title="1.5.23. 问题解决后，加个简短的补充说明"></a>1.5.23. 问题解决后，加个简短的补充说明</h3><p>问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。</p><p>最理想的方式是向最初提问的话题回复此消息，并在标题中包含<code>已修正</code>，<code>已解决</code>或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串<code>问题 X</code>和<code>问题 X - 已解决</code>的潜在回复者就明白不用再浪费时间了（除非他个人觉得<code>问题 X</code>有趣），因此可以利用此时间去解决其它问题。</p><p>补充说明不必很长或是很深入；简单的一句<code>你好，原来是网线出了问题！谢谢大家 – Bill</code>比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。</p><p>对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此<strong>之后</strong>才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。</p><p>除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。</p><p>至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。</p><p>思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。</p><p>在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。</p><h2 id="1-6-如何解读答案"><a href="#1-6-如何解读答案" class="headerlink" title="1.6. 如何解读答案"></a>1.6. 如何解读答案</h2><p><a id="rtfm"></a></p><h3 id="1-6-1-RTFM-和-STFW：如何知道你已完全搞砸了"><a href="#1-6-1-RTFM-和-STFW：如何知道你已完全搞砸了" class="headerlink" title="1.6.1. RTFM 和 STFW：如何知道你已完全搞砸了"></a>1.6.1. RTFM 和 STFW：如何知道你已完全搞砸了</h3><p>有一个古老而神圣的传统：如果你收到<code>RTFM（Read The Fucking Manual）</code>的回应，回答者认为你<strong>应该去读他妈的手册</strong>。当然，基本上他是对的，你应该去读一读。</p><p>RTFM 有一个年轻的亲戚。如果你收到<code>STFW（Search The Fucking Web）</code>的回应，回答者认为你<strong>应该到他妈的网上搜索</strong>。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 <strong><a href="http://lmgtfy.com/">Google 是你的朋友</a></strong>！）</p><p>在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。</p><p>通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为：</p><ul><li><strong>你需要的信息非常容易获得</strong>；</li><li><strong>你自己去搜索这些信息比灌给你，能让你学到更多</strong>。</li></ul><p>你不应该因此不爽；<strong>依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见</strong>。你应该对他祖母般的慈祥表示感谢。</p><h3 id="1-6-2-如果还是搞不懂"><a href="#1-6-2-如果还是搞不懂" class="headerlink" title="1.6.2. 如果还是搞不懂"></a>1.6.2. 如果还是搞不懂</h3><p>如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。</p><p>比方说，如果我回答你：<code>看来似乎是 zentry 卡住了；你应该先清除它。</code>，然后，这是一个<strong>很糟的</strong>后续问题回应：<code>zentry 是什么？</code> <strong>好</strong>的问法应该是这样：<code>哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？</code></p><h3 id="1-6-3-处理无礼的回应"><a href="#1-6-3-处理无礼的回应" class="headerlink" title="1.6.3. 处理无礼的回应"></a>1.6.3. 处理无礼的回应</h3><p>很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直截了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。</p><p>如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这<strong>没有</strong>发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而<strong>你</strong>将被视为有错的一方，这将伤害到你获取信息或帮助的机会。</p><p>另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。</p><p>（有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会<strong>正常</strong>交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们<strong>喜欢</strong>我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。）</p><p>Jeff Bigler 的观察总结和这个相关也值得一读 (<strong><a href="http://www.mit.edu/~jcb/tact.html">tact filters</a></strong>)。</p><p>在下一节，我们会谈到另一个问题，当<strong>你</strong>行为不当时所会受到的<code>冒犯</code>。</p><h2 id="1-7-如何避免扮演失败者"><a href="#1-7-如何避免扮演失败者" class="headerlink" title="1.7. 如何避免扮演失败者"></a>1.7. 如何避免扮演失败者</h2><p>在黑客社区的论坛中，你以本指南所描述的或类似的方式，可能会有那么几次搞砸了。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。</p><p>这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被言语攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、不去关马桶盖等等。相反地，你该这么做：</p><p>熬过去，这很正常。事实上，它是有益健康且合理的。</p><p>社区的标准不会自行维持，它们是通过参与者积极而<strong>公开地</strong>执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。</p><p>也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称<code>如果你不想帮助用户就闭嘴。</code> 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。</p><p>夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。</p><p>记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心<strong>你</strong>和<strong>他的社区</strong>而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。</p><p>有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是<strong>真的</strong>会把问题搞砸。</p><p>这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。</p><p>也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。</p><h2 id="1-8-不该问的问题"><a href="#1-8-不该问的问题" class="headerlink" title="1.8. 不该问的问题"></a>1.8. 不该问的问题</h2><p>以下是几个经典蠢问题，以及黑客没回答时心中所想的：</p><p>问题：<a href="#q1">我能在哪找到 X 程序或 X 资源？</a></p><p>问题：<a href="#q2">我怎样用 X 做 Y？</a></p><p>问题：<a href="#q3">如何设定我的 shell 提示？</a></p><p>问题：<a href="#q4">我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</a></p><p>问题：<a href="#q5">我的程序/设定/SQL 语句没有用</a></p><p>问题：<a href="#q6">我的 Windows 电脑有问题，你能帮我吗？</a></p><p>问题：<a href="#q7">我的程序不会动了，我认为系统工具 X 有问题</a></p><p>问题：<a href="#q8">我在安装 Linux（或者 X ）时有问题，你能帮我吗？</a></p><p>问题：<a href="#q9">我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</a></p><hr><p><a id="q1"></a></p><blockquote><p>问题：我能在哪找到 X 程序或 X 资源？</p></blockquote><p>回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 <a href="https://www.google.com">Google</a> 吗？</p><p><a id="q2"></a></p><blockquote><p>问题：我怎样用 X 做 Y？</p></blockquote><p>回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。</p><p><a id="q3"></a></p><blockquote><p>问题：如何设定我的 shell 提示？？</p></blockquote><p>回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 <a href="#RTFM">RTFM</a>，然后自己去找出来。</p><p><a id="q4"></a></p><blockquote><p>问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文件转换为 TeX 格式吗？</p></blockquote><p>回答：试试看就知道了。如果你试过，你就知道了答案，就不用浪费我的时间了。</p><p><a id="q5"></a></p><blockquote><p>问题：我的{程序/设定/SQL 语句}没有用</p></blockquote><p>回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种</p><ul><li>你还有什么要补充的吗？</li><li>真糟糕，希望你能搞定。</li><li>这关我屁事？</li></ul><p><a id="q6"></a></p><blockquote><p>问题：我的 Windows 电脑有问题，你能帮我吗？</p></blockquote><p>回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。</p><p>注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你<strong>可以</strong>问与 Windows 相关的问题，只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。</p><p><a id="q7"></a></p><blockquote><p>问题：我的程序不会动了，我认为系统工具 X 有问题</p></blockquote><p>回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。</p><p><a id="q8"></a></p><blockquote><p>问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？</p></blockquote><p>回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在<a href="http://www.linux.org/groups/index.html">这儿</a>找到用户群组的清单）。</p><p>注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地用户群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 <code>Linux</code> 和<strong>所有</strong>被怀疑的硬件作关键词仔细搜索。</p><p><a id="q9"></a></p><blockquote><p>问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？</p></blockquote><p>回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！</p><h2 id="1-9-好问题与蠢问题"><a href="#1-9-好问题与蠢问题" class="headerlink" title="1.9. 好问题与蠢问题"></a>1.9. 好问题与蠢问题</h2><p>最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我可以在哪儿找到关于 Foonly Flurbamatic 的资料？</p></blockquote><p>这种问法无非想得到 <a href="#RTFM">STFW</a> 这样的回答。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我用 Google 搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？</p></blockquote><p>这个问题已经 STFW 过了，看起来他真的遇到了麻烦。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我从 foo 项目找来的源码没法编译。它怎么这么烂？</p></blockquote><p>他觉得都是别人的错，这个傲慢自大的提问者。</p><p><strong>聪明问题</strong>：</p><blockquote><p>foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？</p></blockquote><p>提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。</p><p><strong>蠢问题</strong>：</p><blockquote><p>我的主机板有问题了，谁来帮我？</p></blockquote><p>某黑客对这类问题的回答通常是：<code>好的，还要帮你拍拍背和换尿布吗？</code>，然后按下删除键。</p><p><strong>聪明问题</strong>：</p><blockquote><p>我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？</p></blockquote><p>这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。</p><p>在最后一个问题中，注意<code>告诉我答案</code>和<code>给我启示，指出我还应该做什么诊断工作</code>之间微妙而又重要的区别。</p><p>事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。</p><p>通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。</p><p>事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候，一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的<strong>名</strong>人，而是因为我用了正确的方式来提问。</p><p>黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我<strong>像</strong>个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。</p><h2 id="1-10-如果得不到回答"><a href="#1-10-如果得不到回答" class="headerlink" title="1.10. 如果得不到回答"></a>1.10. 如果得不到回答</h2><p>如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。</p><p>总的来说，简单地重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。</p><p>你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。</p><p>有许多网上的以及本地的用户群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。</p><p>另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。</p><p>对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名用户。根本不可能由一个人来处理来自上万名用户的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。</p><h2 id="1-11-如何更好地回答问题"><a href="#1-11-如何更好地回答问题" class="headerlink" title="1.11. 如何更好地回答问题"></a>1.11. 如何更好地回答问题</h2><p><strong>态度和善一点。</strong> 问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。</p><p><strong>对初犯者私下回复。</strong> 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。</p><p><strong>如果你不确定，一定要说出来！</strong> 一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。</p><p><strong>如果帮不了忙，也别妨碍他。</strong> 不要在实际步骤上开玩笑，那样也许会毁了提问者的设置 —— 有些可怜的呆瓜会把它当成真的指令。</p><p><strong>试探性的反问以引出更多的细节。</strong> 如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。</p><p>尽管对那些懒虫抱怨一声 RTFM 是正当的，但能给出文档的链接（即使只是建议个 Google 搜索关键词）会更好。</p><p><strong>如果你决定回答，就请给出好的答案。</strong> 当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。</p><p><strong>正面地回答问题！</strong> 如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 <code>试试看 A 或是 B</code> 或者 <code>试试 X 、 Y 、 Z 、 A 、 B 、 C</code> 并附上一个链接一点用都没有。</p><p><strong>帮助你的社区从问题中学习。</strong> 当回复一个好问题时，问问自己<code>如何修改相关文件或常见问题文件以免再次解答同样的问题？</code>，接着再向文件维护者发一份补丁。</p><p>如果你在研究一番后才作出了回答，<strong>展现你的技巧而不是直接端出结果</strong>。毕竟<code>授人以鱼不如授人以渔</code>。</p><h2 id="1-12-相关资源"><a href="#1-12-相关资源" class="headerlink" title="1.12. 相关资源"></a>1.12. 相关资源</h2><p>如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 <a href="http://en.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO/">Unix 系统和网络基本原理</a>。</p><p>当你发布软件或补丁时，试着按<a href="http://en.tldp.org/HOWTO/Software-Release-Practice-HOWTO/index.html">软件发布实践</a>操作。</p><h2 id="1-13-鸣谢"><a href="#1-13-鸣谢" class="headerlink" title="1.13. 鸣谢"></a>1.13. 鸣谢</h2><p>Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写<code>如何更好地回答问题</code>这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 提问的智慧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-09-07-Redis%E9%85%8D%E7%BD%AE/"/>
      <url>/2024/10/28/2023-09-07-Redis%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h1><p><code>redis.windows-service.conf</code> 和 <code>redis.windows.conf</code> 任选一个做为配置文件即可，只需在做成 service 服务时对应好即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"># 指定 Redis 监听的 IP 地址</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 指定 Redis 监听的端口号</span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"># 指定 TCP 连接的等待队列的长度</span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"># 指定 TCP 连接的 keepalive 选项，0 表示禁用</span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"># 指定 Redis 日志的级别，这里设置为 notice，表示只记录重要的日志信息</span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"># 指定 Redis 日志输出的文件名，这里设置为 &quot;server_log.txt&quot;</span><br><span class="line">logfile &quot;server_log.txt&quot;</span><br><span class="line"></span><br><span class="line"># 指定是否将日志发送到系统的 syslog</span><br><span class="line">syslog-enabled no</span><br><span class="line"></span><br><span class="line"># 指定发送到 syslog 的标识符</span><br><span class="line">syslog-ident redis</span><br><span class="line"></span><br><span class="line"># 指定 Redis 支持的数据库数量</span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"># 指定在多长时间内，有多少个修改操作就将数据集快照保存到磁盘上</span><br><span class="line"># 在 900 秒（15 分钟）内，如果至少有 1 个修改操作，则保存快照</span><br><span class="line">save 900 1 </span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 指定当进行后台保存快照操作时发生错误时，是否停止接受写入操作</span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"># 指定是否对快照进行压缩</span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"># 指定是否对快照进行校验和检查</span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"># 指定快照文件的文件名</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 指定快照和日志文件的保存路径</span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"># 指定当 Redis 作为从服务器（slave）时，是否允许返回过期的数据</span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"># 指定当 Redis 作为从服务器（slave）时，是否只允许读取操作</span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"># 指定是否使用无盘同步（diskless sync）进行复制</span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"># 指定无盘同步的延迟时间</span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"># 指定是否禁用 TCP_NODELAY 选项</span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"># 指定 Redis 从服务器的优先级</span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"># 指定连接 Redis 时需要使用的密码</span><br><span class="line">requirepass 123456</span><br><span class="line"></span><br><span class="line"># 指定是否开启 AOF模式</span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"># 指定 AOF 文件的文件名</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># 指定 AOF 数据同步到磁盘的频率，这里设置为每秒钟同步一次</span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"># 指定是否在 AOF 重写时禁用 AOF 数据同步</span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"># 指定触发 AOF 重写的条件</span><br><span class="line"># 指定 AOF 文件大小相对于上次重写时的大小的增长百分比</span><br><span class="line">auto-aof-rewrite-percentage 100 </span><br><span class="line"># 指定 AOF 文件的最小大小</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 指定在 AOF 文件加载时，如果文件被截断（truncated），是否仍然尝试加载</span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"># 指定执行 Lua 脚本的时间限制（毫秒）</span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"># 指定慢查询日志的阈值，单位为微秒。当执行时间超过该阈值时，将记录慢查询日志</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 指定慢查询日志的最大长度，即最多记录多少条慢查询日志</span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"># 指定是否启用延迟监控，0 表示禁用</span><br><span class="line">latency-monitor-threshold 0</span><br><span class="line"></span><br><span class="line"># 指定要通知的键空间事件类型。这里设置为空字符串，表示不通知任何键空间事件</span><br><span class="line">notify-keyspace-events &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 指定压缩列表（ziplist）中哈希数据结构的最大条目数和最大值大小</span><br><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 指定整数集合（intset）中的最大条目数</span><br><span class="line">set-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"># 指定压缩列表（ziplist）中有序集合数据结构的最大条目数和最大值大小</span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"># 指定 HyperLogLog 数据结构的最大稀疏表示字节数</span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"># 指定是否在运行时对哈希表进行重新哈希</span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"># 指定客户端输出缓冲区的限制。分别设置了三个限制，针对普通连接、从服务器连接和发布/订阅连接</span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"># 指定服务器的时间事件执行频率（每秒调用的次数）</span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"># 指定是否在 AOF 重写过程中使用增量的 fsync() 操作</span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h1 id="2-做成-service-服务"><a href="#2-做成-service-服务" class="headerlink" title="2. 做成 service 服务"></a>2. 做成 service 服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server.exe --service-install redis.windows-service.conf</span><br></pre></td></tr></table></figure><h1 id="3-删除服务"><a href="#3-删除服务" class="headerlink" title="3. 删除服务"></a>3. 删除服务</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc delete &quot;服务名&quot;  (如果服务名中间有空格，就需要前后加引号）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-07-26-Docker%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2023-07-26-Docker%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-部署mongo"><a href="#1-部署mongo" class="headerlink" title="1. 部署mongo"></a>1. 部署mongo</h1><ul><li>数据卷</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 存数据</span><br><span class="line">docker volume create yt-mongo_data</span><br><span class="line"># 存配置文件</span><br><span class="line">docker volume create yt-mongo_config</span><br><span class="line"># 存日志</span><br><span class="line">docker volume create yt-mongo_log</span><br></pre></td></tr></table></figure><ul><li>部署命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">  -d \</span><br><span class="line">  -p 27017:27017 \</span><br><span class="line">  --name yt-mongo \</span><br><span class="line">  --restart=always \</span><br><span class="line">  -v yt-mongo_data:/data/db \</span><br><span class="line">  -v yt-mongo_config:/etc \   (这条命令加上去就会出问题)</span><br><span class="line">  -v yt-mongo_log:/var/log/mongodb \</span><br><span class="line">  mongo</span><br></pre></td></tr></table></figure><ul><li>Using a custom MongoDB configuration file（未掌握）</li></ul><p>Linux下的默认配置文件位置<code>/etc/mongod.conf</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-d mongo:latest --config /etc/mongod.conf</span><br></pre></td></tr></table></figure><p>configuration file content</p><p>注：配置文件中只需要规定 log文件的存放位置即可，数据库的存放位置默认为<code>/data/db</code>，只需要挂载到数据卷即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">   destination: file</span><br><span class="line">   path: &quot;/var/log/mongodb/mongod.log&quot;</span><br><span class="line">   logAppend: true</span><br><span class="line">storage:</span><br><span class="line">   journal:</span><br><span class="line">      enabled: true</span><br><span class="line">processManagement:</span><br><span class="line">   fork: true</span><br><span class="line">net:</span><br><span class="line">   bindIp: 0.0.0.0</span><br><span class="line">   port: 27017</span><br><span class="line">setParameter:</span><br><span class="line">   enableLocalhostAuthBypass: true</span><br><span class="line">security:</span><br><span class="line">   authorization: disable // endable 开启 disable 关闭</span><br></pre></td></tr></table></figure><ul><li>Where to Store Data</li></ul><p>Linux默认<code>/data/db</code>存数据库数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v yt-mongo_data:/data/db</span><br></pre></td></tr></table></figure><p><code>/data/configdb</code> 处理分片集群时需要使用</p><ul><li>进入mongo容器，using the <code>mongosh</code> cli</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it yt-mongo mongosh</span><br></pre></td></tr></table></figure><ul><li>创建数据库用户</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use test</span><br><span class="line">db.createUser(&#123; user:&quot;root&quot;, pwd:&quot;root&quot;, roles:[&quot;readWrite&quot;, &quot;dbAdmin&quot;] &#125;)</span><br></pre></td></tr></table></figure><ul><li>Setting wiredTiger cache size limits</li></ul><p>you will want to set the cache size to something appropriate, taking into account any other processes you may be running in the container which would also utilize memory</p><p>eg： you can configure the cache size to use 1.5GB as:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some-mongo -d mongo --wiredTigerCacheSizeGB 1.5</span><br></pre></td></tr></table></figure><h1 id="2-部署redis"><a href="#2-部署redis" class="headerlink" title="2. 部署redis"></a>2. 部署redis</h1><ul><li>数据卷</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 存放持久化数据</span><br><span class="line">docker volume create yt-redis_data</span><br><span class="line"># 存放日志</span><br><span class="line">docker volume create yt-redis_log</span><br><span class="line"># 存放配置</span><br><span class="line">docker volume create yt-redis_config</span><br></pre></td></tr></table></figure><ul><li>部署命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">--name yt-redis \</span><br><span class="line">-d \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">-v yt-redis_config:/usr/local/etc/redis \</span><br><span class="line">-v yt-redis_data:/data \</span><br><span class="line">redis \</span><br><span class="line">redis-server /usr/local/etc/redis/redis.conf --save 180 1 --loglevel warning</span><br></pre></td></tr></table></figure><ul><li>start with persistent storage</li></ul><p>持久化后的存放地址<code>/data</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v yt-redis_data:/data</span><br></pre></td></tr></table></figure><ul><li>use your own redis.conf</li></ul><p>Where <code>/myredis/conf/</code> is a local directory containing your <code>redis.conf</code> file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /myredis/conf:/usr/local/etc/redis --name myredis redis redis-server /usr/local/etc/redis/redis.conf</span><br></pre></td></tr></table></figure><p>config content<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind 0.0.0.0</span><br><span class="line">port 6379</span><br></pre></td></tr></table></figure></p><ul><li>进入redis容器，使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it yt-redis redis-cli</span><br></pre></td></tr></table></figure><h1 id="3-部署MySQL"><a href="#3-部署MySQL" class="headerlink" title="3. 部署MySQL"></a>3. 部署MySQL</h1><ul><li>数据卷</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 存放持久化数据</span><br><span class="line">docker volume create yt-mysql_data</span><br><span class="line"># 存放日志</span><br><span class="line">docker volume create yt-mysql_log</span><br><span class="line"># 存放配置</span><br><span class="line">docker volume create yt-mysql_config</span><br></pre></td></tr></table></figure><ul><li>部署命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">--name yt-mysql \</span><br><span class="line"># 初始化root用户的密码</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=root \</span><br><span class="line">-v yt-mysql_data:/var/lib/mysql \</span><br><span class="line">-v yt-mysql_config:/etc/mysql/conf.d \</span><br><span class="line">-v yt-mysql_log:/var/log/mysql \</span><br><span class="line">mysql</span><br></pre></td></tr></table></figure><ul><li>Using a custom MySQL configuration file</li></ul><p>The default configuration for MySQL can be found in <code>/etc/mysql/conf.d</code> </p><p><code>yt-mysql_config/config-file.cnf</code> is the path and name of your custom configuration file</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v yt-mysql_config:/etc/mysql/conf.d \</span><br></pre></td></tr></table></figure><p>config content</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># Custom config should go here</span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">#　设置监听的IP地址和端口</span><br><span class="line">bind-address = 0.0.0.0</span><br><span class="line">port=3306</span><br><span class="line"># 设置 MySQL 数据库的字符集</span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line"># 设置数据库数据的存放位置</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line"># 设置 MySQL 数据库的默认引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line"># 设置 MySQL 数据库的最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"></span><br><span class="line"># 设置 MySQL 数据库的日志位置</span><br><span class="line">log_error=/var/log/mysql/error.log</span><br><span class="line"></span><br><span class="line"># 设置 MySQL 数据库的临时文件夹位置</span><br><span class="line">tmpdir=/tmp</span><br><span class="line"></span><br><span class="line"># 设置 MySQL 数据库的缓存大小</span><br><span class="line">key_buffer_size=32M</span><br><span class="line">query_cache_size=64M</span><br><span class="line">thread_cache_size=32</span><br><span class="line">table_open_cache=2048</span><br><span class="line">table_definition_cache=4096</span><br><span class="line">sort_buffer_size=2M</span><br><span class="line">read_buffer_size=2M</span><br><span class="line">read_rnd_buffer_size=4M</span><br><span class="line">join_buffer_size=8M</span><br><span class="line">innodb_buffer_pool_size=2G</span><br><span class="line">innodb_log_file_size=512M</span><br><span class="line">innodb_flush_log_at_trx_commit=2</span><br></pre></td></tr></table></figure><ul><li>where to dbData</li></ul><p>By default, MySQL stores database files in<code>/var/lib/mysql</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v yt-mysql_data:/var/lib/mysql \</span><br></pre></td></tr></table></figure><ul><li>where to log</li></ul><p>Log files are usually located at <code>/var/log/mysql</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v yt-mysql_log:/var/log/mysql \</span><br></pre></td></tr></table></figure><ul><li>进入MySQL容器，使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it yt-mysql mysql -u root -p</span><br></pre></td></tr></table></figure><ul><li>创建用户并允许远程连接</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br></pre></td></tr></table></figure><h1 id="4-部署flask"><a href="#4-部署flask" class="headerlink" title="4. 部署flask"></a>4. 部署flask</h1><p>只涉及一个容器不需要使用Docker Compose</p><p>在服务器中创建一个code目录</p><p>从GitHub上克隆项目到code目录</p><p>打开项目文件夹，在该目录下创建文本文件 dockerfile，内容如下<br><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM python:3.8.10</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 将项目下的requirements.txt文件复制到 /app目录</span><br><span class="line">COPY ./requirements.txt .</span><br><span class="line"># 执行命令pip install --no-cache-dir -r requirements.txt 安装项目依赖</span><br><span class="line">RUN pip install --no-cache-dir -r requirements.txt</span><br><span class="line"># 将Flask 项目复制到容器中的 /app 目录</span><br><span class="line">COPY . .</span><br><span class="line"># 容器向外暴露5000端口</span><br><span class="line">EXPOSE 5000</span><br><span class="line"># 在容器启动时运行 app.py 脚本</span><br><span class="line">CMD [ &quot;python&quot;, &quot;app.py&quot; ]</span><br></pre></td></tr></table></figure></p><p>在dockerfile所在目录下，使用命令<code>docker build -t webshell_ids .</code>构建镜像</p><p>到此镜像定制完毕，之后运行该镜像即可启动项目</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-13-RESTful-API%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2023-03-13-RESTful-API%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是REST"><a href="#1-什么是REST" class="headerlink" title="1. 什么是REST"></a>1. 什么是REST</h1><p>官网：<a href="https://restfulapi.cn/">https://restfulapi.cn/</a></p><p>REST 是一种基于超媒体构建分布式系统的架构风格。 REST 独立于任何基础协议，并且不一定绑定到 HTTP</p><h1 id="2-REST设计原则"><a href="#2-REST设计原则" class="headerlink" title="2. REST设计原则"></a>2. REST设计原则</h1><p>REST API 围绕资源设计，资源是可访问的任何类型的对象、数据或服务。资源应基于名词（资源）而不是动词（对资源执行的操作）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/customers/123/orders</span><br></pre></td></tr></table></figure><p>在 URI 中采用一致的命名约定。对引用集合的 URI 使用复数名词。将集合和子项的 URI 组织成层次结构。 例如，<code>/customers</code> 是客户集合的路径，<code>/customers/5</code> 是 ID 为 5 的客户的路径。</p><p>避免请求复杂度超过 <code>集合/子项目/集合</code>的资源 URI</p><p>资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询</p><p>使用 JSON 作为交换格式，将参数信息都封装在 JSON中</p><p>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都包含必需的信息</p><p>传统风格：通过携带不同的参数来实现不同的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/add?a=1&amp;b=2</span><br></pre></td></tr></table></figure><p>RESTful操作资源：可以通过不同的请求方式来实现不同的效果，即请求地址一样，但是可以实现不同功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1/item/1 查询,GET</span><br><span class="line">http://127.0.0.1/item 新增,POST</span><br><span class="line">http://127.0.0.1/item 更新,PUT</span><br><span class="line">http://127.0.0.1/item/1 删除,DELETE</span><br></pre></td></tr></table></figure><p>常见的HTTP方法及其在RESTful风格下的使用：</p><div class="table-container"><table><thead><tr><th>HTTP方法</th><th>操作</th><th>返回值</th><th>特定返回值</th></tr></thead><tbody><tr><td>POST</td><td>Create</td><td>201</td><td>404 or 409</td></tr><tr><td>GET</td><td>Read</td><td>200</td><td>200 or 404</td></tr><tr><td>PUT</td><td>Update</td><td>200 or 204</td><td>404 or 405</td></tr><tr><td>PATCH</td><td>Update</td><td>200 or 204</td><td>404</td></tr><tr><td>DELETE</td><td>Delete</td><td>200</td><td>404 or 405</td></tr></tbody></table></div><h1 id="3-REST-API最佳实践"><a href="#3-REST-API最佳实践" class="headerlink" title="3. REST API最佳实践"></a>3. REST API最佳实践</h1><p>仅使用get、post方法实现增删改查，put和delete方法可能不被服务器或防火墙支持</p><h2 id="3-1-查-GET"><a href="#3-1-查-GET" class="headerlink" title="3.1. 查-GET"></a>3.1. 查-GET</h2><p><strong>查询列表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: /一级资源/二级资源/list</span><br><span class="line">method: get</span><br><span class="line">param: param</span><br></pre></td></tr></table></figure><p>筛选条件相关的常见参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?pageNum=1 第几页</span><br><span class="line">?pageSize=10 每页几条数据</span><br><span class="line">?offset=10：指定返回记录的开始位置。</span><br><span class="line">?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</span><br><span class="line">?type=1：其他筛选条件</span><br></pre></td></tr></table></figure><p><strong>查询主键</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: /一级资源/二级资源/&#123;id&#125;</span><br><span class="line">method: get</span><br><span class="line">param: param</span><br></pre></td></tr></table></figure><h2 id="3-2-增-POST"><a href="#3-2-增-POST" class="headerlink" title="3.2. 增-POST"></a>3.2. 增-POST</h2><p><strong>增加单个</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: /一级资源/二级资源</span><br><span class="line">method: post</span><br><span class="line">data: data</span><br></pre></td></tr></table></figure><p><strong>批量增加</strong></p><p>…</p><h2 id="3-3-改-POST"><a href="#3-3-改-POST" class="headerlink" title="3.3. 改-POST"></a>3.3. 改-POST</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url: /一级资源/二级资源/edit</span><br><span class="line">method: post</span><br><span class="line">data: data</span><br></pre></td></tr></table></figure><h2 id="3-4-删-GET"><a href="#3-4-删-GET" class="headerlink" title="3.4. 删-GET"></a>3.4. 删-GET</h2><p><strong>删除单个</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: /一级资源/二级资源/delete/&#123;roomIds&#125;</span><br><span class="line">method: get</span><br></pre></td></tr></table></figure><p><strong>批量删除</strong></p><p>roomIds是一个List，当其中只有一个值时，是删除单个，当其中有多个值时是批量删除</p>]]></content>
      
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-12-Spring/"/>
      <url>/2024/10/28/2023-03-12-Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring"><a href="#1-Spring" class="headerlink" title="1. Spring"></a>1. Spring</h1><h2 id="1-1-核心"><a href="#1-1-核心" class="headerlink" title="1.1. 核心"></a>1.1. 核心</h2><p>Spring 的设计思路，<strong>永远都是作为 Bean 的容器，去管理好 Bean</strong> ，这是它永恒不变的地方。</p><p>官网：<a href="https://spring.io/projects/spring-framework#overview">https://spring.io/projects/spring-framework#overview</a></p><h2 id="1-2-两大特性"><a href="#1-2-两大特性" class="headerlink" title="1.2. 两大特性"></a>1.2. 两大特性</h2><p><strong>IOC 控制反转</strong></p><p>Inversion of Control。当一个类中想要调用另外一个类的对象时，不需要再通过new 关键字来创建，而是由Spring框架来负责：创建、分配和管理，从而降低了程序中的耦合性</p><p><strong>AOP</strong></p><p>Aspect Oriented Programming。可以用来做一些日志的打印和输出，用于提示程序执行过程中的一些具体信息等</p><h2 id="1-3-包含的模块"><a href="#1-3-包含的模块" class="headerlink" title="1.3. 包含的模块"></a>1.3. 包含的模块</h2><h3 id="1-3-1-Spring-Core"><a href="#1-3-1-Spring-Core" class="headerlink" title="1.3.1. Spring Core"></a>1.3.1. Spring Core</h3><p>Spring 核心模块提供了依赖注入（DI）和面向切面编程（AOP）等基础功能，这些功能是 Spring 框架的核心，也是 Spring 其他模块的基础。</p><h3 id="1-3-2-Spring-Web"><a href="#1-3-2-Spring-Web" class="headerlink" title="1.3.2. Spring Web"></a>1.3.2. Spring Web</h3><p>Spring Web 模块包括 Spring MVC 和 Spring WebFlux 两个子模块，提供了开发 Web 应用程序所需的基本功能，如控制器、视图解析器、表单处理、文件上传等。</p><h3 id="1-3-3-Spring-Data"><a href="#1-3-3-Spring-Data" class="headerlink" title="1.3.3. Spring Data"></a>1.3.3. Spring Data</h3><p>Spring Data 模块为各种数据访问技术（如关系型数据库、NoSQL 数据库、搜索引擎等）提供了统一的 API，简化了数据访问层的开发。</p><h3 id="1-3-4-Spring-Security"><a href="#1-3-4-Spring-Security" class="headerlink" title="1.3.4. Spring Security"></a>1.3.4. Spring Security</h3><p>Spring Security 模块提供了一套完整的安全性解决方案，包括认证、授权、加密、访问控制等功能，可以帮助开发人员轻松地实现应用程序的安全性管理。</p><h3 id="1-3-5-Spring-Integration"><a href="#1-3-5-Spring-Integration" class="headerlink" title="1.3.5. Spring Integration"></a>1.3.5. Spring Integration</h3><p>Spring Integration 模块提供了一套基于消息的集成框架，可以帮助开发人员轻松地实现不同系统之间的协作和集成。</p><h3 id="1-3-6-Spring-Testing"><a href="#1-3-6-Spring-Testing" class="headerlink" title="1.3.6. Spring Testing"></a>1.3.6. Spring Testing</h3><p>Spring 框架提供了一套完整的测试框架，包括单元测试、集成测试和端到端测试等，可以帮助开发人员实现高质量的测试覆盖。</p><h1 id="2-IOC思想"><a href="#2-IOC思想" class="headerlink" title="2. IOC思想"></a>2. IOC思想</h1><p>从前对象的创建与对象间的依赖关系完全写死在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方使用者</p><p>测试代码的逻辑：</p><ol><li><p>UserServiceImpl调用 UserMapper（接口）</p></li><li><p>UserMapper（接口）有两种实现UserMapperMysqlImpl()和UserMapperOracleImpl()</p></li></ol><p>即在service层使用了set注入后，程序不再具有主动性，而是变成了被动的接受对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利川set进行动态实现值的注入!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserMapper</span><span class="params">(UserMapper userMapper)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getUser</span><span class="params">()</span> &#123;</span><br><span class="line">        userMapper.getUser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中调用时，由使用者决定传入的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line">    <span class="comment">// 实现反转</span></span><br><span class="line">    userService.setUserMapper(<span class="keyword">new</span> <span class="title class_">UserMapperOracleImpl</span>());</span><br><span class="line">    或</span><br><span class="line">    userService.setUserMapper(<span class="keyword">new</span> <span class="title class_">UserMapperMysqlImpl</span>());</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    userService.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-搭建Spring项目"><a href="#3-搭建Spring项目" class="headerlink" title="3. 搭建Spring项目"></a>3. 搭建Spring项目</h1><p>用IDEA创建Spring项目</p><p>在src/main/resources目录下新建 applicationContext.xml 配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--相当于new了一个 UserMapperMysqlImpl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mysqlImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.mapper.UserMapperMysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;oracle&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.mapper.UserMapperOracleImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    ref：引用类型数据的注入</span></span><br><span class="line"><span class="comment">    value：基本数据类型数据的注入</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.service.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在main方法中，使用 <strong>ClassPathXmlApplicationContext(“applicationContext.xml”)</strong>获取Spring容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取ApplicationContext，拿到Spring的容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">UserServiceImpl</span> <span class="variable">userServiceImpl</span> <span class="operator">=</span> (UserServiceImpl) context.getBean(<span class="string">&quot;UserServiceImpl&quot;</span>);</span><br><span class="line"></span><br><span class="line">    userServiceImpl.getUser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-1-Spring-IOC"><a href="#3-1-Spring-IOC" class="headerlink" title="3.1. Spring IOC"></a>3.1. Spring IOC</h2><p>控制反转：就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理</p><p>控制：使用Spring后，对象是由Spring来创建的</p><p>反转：控制权交给外部环境（Spring 框架、IoC 容器）</p><p>在Spring中实现控制反转的是IOC容器，其实现方法是依赖注入（Dependency Injection，DI）</p><p>依赖注入：利用set方法、有参构造来进行注入</p><p>从代码上讲：一个Spring的IOC容器就是某个实现了<strong>ApplicationContext</strong>接口的类的实例</p><p>在 Spring 中， IOC 容器是 Spring 用来实现 IOC 的载体， IOC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象</p><p>可以通过<strong>ClassPathXmlApplicationContext</strong>去浏览底层源码</p><h2 id="3-2-Spring-Bean"><a href="#3-2-Spring-Bean" class="headerlink" title="3.2. Spring Bean"></a>3.2. Spring Bean</h2><p>Bean 代指的就是那些被 IOC 容器所管理的对象</p><p>我们需要告诉 IOC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类</p><h2 id="3-3-Spring配置说明"><a href="#3-3-Spring配置说明" class="headerlink" title="3.3. Spring配置说明"></a>3.3. Spring配置说明</h2><p>可以有多个xml文件，但是只能有一个被命名为applicationContext.xml，可以在applicationContext.xml中import导入其他xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;引入其他bean xml配置文件&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bean标识&quot;</span> <span class="attr">class</span>=<span class="string">&quot;类型名称&quot;</span>/&gt;</span></span><br><span class="line">    id : bean的唯一标识符，也就是相当于对象名</span><br><span class="line">    class : bean 对象所对应的全限定名，即包名+类型</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;mysqlImpl&quot;</span>/&gt;</span></span><br><span class="line">        ref：引用类型数据的注入</span><br><span class="line">        value：基本数据类型数据的注入</span><br><span class="line"><span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&quot;bean标识&quot;</span> <span class="attr">alias</span>=<span class="string">&quot;别名&quot;</span> /&gt;</span></span><br><span class="line">name :是别名，而且name可以同时取多个别名</span><br></pre></td></tr></table></figure><h1 id="4-Spring-IOC创建对象"><a href="#4-Spring-IOC创建对象" class="headerlink" title="4. Spring IOC创建对象"></a>4. Spring IOC创建对象</h1><p>默认使用无参构造</p><p>有参构造：创建的同时，进行注入</p><ul><li>下标赋值</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是参数1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是参数2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>通过类型创建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--不建议使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">value</span>=<span class="string">&quot;7500000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>直接使用参数名设置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--推荐使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是名字&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;42&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：在 xml中配置Bean的时候，容器中管理的对象就已经初始化了</p><h1 id="5-依赖注入"><a href="#5-依赖注入" class="headerlink" title="5. 依赖注入"></a>5. 依赖注入</h1><p>依赖：bean对象的创建依赖于容器（IOC容器）</p><p>注入：就是让属性有值</p><h2 id="5-1-构造器注入"><a href="#5-1-构造器注入" class="headerlink" title="5.1. 构造器注入"></a>5.1. 构造器注入</h2><p>通过有参构造方法实现注入</p><h2 id="5-2-Set方式注入（重点）"><a href="#5-2-Set方式注入（重点）" class="headerlink" title="5.2. Set方式注入（重点）"></a>5.2. Set方式注入（重点）</h2><p>由容器来注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    ref：引用类型数据的注入</span></span><br><span class="line"><span class="comment">    value：基本数据类型数据的注入</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--基本数据类型的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是名字&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用数据类型的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;student&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;books&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>三国演义<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>红楼梦<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--List的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;friends&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>赵四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Map的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;card&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;身份证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;213654456&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;学生证&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2454545454&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Set的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>LOL<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CF<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>PUBG<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--null的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;couple&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Properties的注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br></pre></td></tr></table></figure><h2 id="5-3-其他注入方式"><a href="#5-3-其他注入方式" class="headerlink" title="5.3. 其他注入方式"></a>5.3. 其他注入方式</h2><p>c命名和p命名空间注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">beans中需要引入xml约束</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:c</span>=<span class="string">&quot;http://www.springframework.org/schema/c&quot;</span></span></span><br><span class="line"><span class="tag">       &gt;</span></span><br></pre></td></tr></table></figure><p>c（constructor）命名，原理是通过构造器注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span> <span class="attr">c:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;名字&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>p（property）命名，原理是通过set注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span> <span class="attr">c:name</span>=<span class="string">&quot;名字&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-Bean的自动装配（重点）"><a href="#6-Bean的自动装配（重点）" class="headerlink" title="6. Bean的自动装配（重点）"></a>6. Bean的自动装配（重点）</h1><p>在Spring中有三种装配的方式</p><ol><li>在xml中显式装配（即set方法注入和构造方法注入）</li><li>在Java中显式装配（Java config）</li><li>隐式bean的自动装配和发现机制（重要）</li></ol><p>一般在注入内容较为简单时，可使用注解直接进行开发，当注入内容比较复杂，如map、list等时，仍然使用xml配置文件开发</p><h2 id="6-1-什么是装配"><a href="#6-1-什么是装配" class="headerlink" title="6.1. 什么是装配"></a>6.1. 什么是装配</h2><p>将一个bean中所关联的其他bean装配进去</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 有以下两个实体类，Teacher类，Student类，分别代表老师、学生，其中Teacher类的属性中包含Student类</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>           <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>           <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建了2个实体类，并给teacher Bean手动装配了与之关联的student Bean，这就是装配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.Student&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;student&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;student&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="6-2-通过xml文件实现自动装配"><a href="#6-2-通过xml文件实现自动装配" class="headerlink" title="6.2. 通过xml文件实现自动装配"></a>6.2. 通过xml文件实现自动装配</h2><p>用autowire属性实现自动装配bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--两种方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.User&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置autowire属性为byName，则Spring会根据class属性的值找到实体类，然后查询实体类中所有setter方法的名字，根据setter方法后面的名字（例如SetStudent，则setter方法后面的名字为student）再到xml配置文件中寻找一个与该名字相同id的bean，注入进来，所以需要保证所有bean的id唯一</p><p>设置autowire属性为byType，则Spring会自动寻找一个与class属性的类型相同的bean，注入进来，必须保证配置文件中所有bean的class属性的值是唯一的，否则就会报错</p><h2 id="6-3-通过注解实现自动装配"><a href="#6-3-通过注解实现自动装配" class="headerlink" title="6.3. 通过注解实现自动装配"></a>6.3. 通过注解实现自动装配</h2><p>用@Autowired 注解实现自动装配</p><p>先导入约束</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解功能--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后在实体类的对应属性上添加@Autowired注解（也可以把注解放到对应属性的setter上），如 Teacher类中依赖Student类。所以在Teacher类中的student属性上要加上@Autowired，实现自动装配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>@Autowired 注解方法装配属性的过程：Spring会默认优先根据（被注解修饰的）属性类型去容器中找对应的组件（bean），找到就赋值。若找到多个相同类型的组件，再将属性的名称作为组件（bean）的id去容器中查找</p><p>@Qualifier(value=”xx” ) 用来指定需要装配的bean的id，配合@Autowired的使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired()</span></span><br><span class="line"><span class="meta">@Qualifier(value=&quot;student1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> Student student;</span><br></pre></td></tr></table></figure><p>在默认情况下使用 @Autowired 注释进行自动注入时，Spring 容器中匹配的候选 bean 数目必须有且仅有一个。当找不到一个匹配的 bean 时，Spring 容器将抛出 BeanCreationException 异常，这时可以显式定义Autowired的required属性为false，告诉 Spring在找不到匹配 bean 时也不报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired(required = false)</span></span><br></pre></td></tr></table></figure><h2 id="6-4-总结：可以注入-Bean-的注解"><a href="#6-4-总结：可以注入-Bean-的注解" class="headerlink" title="6.4. 总结：可以注入 Bean 的注解"></a>6.4. 总结：可以注入 Bean 的注解</h2><p>@Resource、@Autowired</p><p>Java自带的@Resource和Spring的@Autowired的区别：</p><ol><li>都是用来自动装配的，都可以放在属性字段上</li><li>@Autowired默认通过byType，如果查找失败，则通过byName的方式实现</li><li>@Resource默认通过byName的方式实现，如果找不到名字，则通过byType实现</li><li>当一个接口存在多个实现类的情况下，@Autowired 和@Resource 都需要通过名称才能正确匹配到对应的 Bean。Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource 可以通过 name 属性来显式指定名称</li></ol><h1 id="7-隐式bean的发现机制（重点）"><a href="#7-隐式bean的发现机制（重点）" class="headerlink" title="7. 隐式bean的发现机制（重点）"></a>7. 隐式bean的发现机制（重点）</h1><p>在xml配置文件中开启自动扫描注解功能</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定要扫描的包，这个包下的注解就会生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hy.entity&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启注解功能--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:annotation-config</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>或者在JavaConfig中使用@ComponentScan 注解定义要扫描的路径，从中找出被@Component注解的 bean，自动装配到 Spring 的 bean 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hy.entity&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">student</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-1-Component"><a href="#7-1-Component" class="headerlink" title="7.1. @Component"></a>7.1. @Component</h2><p>注册该组件到Spring IOC容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性注入 @Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;我是学生&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> name;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相当于property</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.entity.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;我是学生&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="7-2-总结：可以将一个类声明为-Bean-的注解"><a href="#7-2-总结：可以将一个类声明为-Bean-的注解" class="headerlink" title="7.2. 总结：可以将一个类声明为 Bean 的注解"></a>7.2. 总结：可以将一个类声明为 Bean 的注解</h2><p>@Component以及@Component衍生的注解</p><p>以下注解功能一致，只是命名不同</p><p>在web开发中，按照MVC三层架构分层</p><ol><li>DAO（Mapper）层使用 @Repository</li><li>service层使用 @Service</li><li>controller层使用  @Controller</li></ol><h2 id="7-3-Component-和-Bean-的区别"><a href="#7-3-Component-和-Bean-的区别" class="headerlink" title="7.3. @Component 和 @Bean 的区别"></a>7.3. @Component 和 @Bean 的区别</h2><p>@Component注解作用于类，而@Bean注解作用于方法</p><p>@Component 一般是通过类路径扫描来自动侦测、自动装配到 Spring 容器中（可以使用 @ComponentScan 注解定义要扫描的路径，从中找出被@Component注解的 bean，自动装配到 Spring 的 bean 容器中）</p><p>@Bean 作用在方法上，表示将这个方法的返回值装配到 lOC容器中</p><p>下面这个例子是通过 @Component 无法实现的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-Bean的作用域"><a href="#8-Bean的作用域" class="headerlink" title="8. Bean的作用域"></a>8. Bean的作用域</h1><h2 id="8-1-xml文件实现"><a href="#8-1-xml文件实现" class="headerlink" title="8.1. xml文件实现"></a>8.1. xml文件实现</h2><p>单例模式：Spring默认机制，每次从容器中get的时候，共享同一个对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--scope--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.service.UserServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原型模式：每次从容器中get的时候，都会产生一个新对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--scope--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;UserServiceImpl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.service.UserServiceImpl&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其余的request、session、application这些作用域只能在web开发中使用</p><h2 id="8-2-注解实现"><a href="#8-2-注解实现" class="headerlink" title="8.2. 注解实现"></a>8.2. 注解实现</h2><p>@Scope</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-Bean-的生命周期"><a href="#9-Bean-的生命周期" class="headerlink" title="9. Bean 的生命周期"></a>9. Bean 的生命周期</h1><h2 id="9-1-完整版"><a href="#9-1-完整版" class="headerlink" title="9.1. 完整版"></a>9.1. 完整版</h2><p>Bean 容器找到配置文件中 Spring Bean 的定义</p><p>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例</p><p>如果涉及到一些属性值 利用 set()方法设置一些属性值</p><p>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入 Bean 的名字</p><p>如果 Bean 实现了 BeanClassLoaderAware接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例</p><p>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory()方法，传入 BeanFactory对象的实例</p><p>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法</p><p>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法</p><p>如果 Bean 实现了InitializingBean接口，执行afterPropertiesSet()方法</p><p>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法</p><p>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization()方法</p><p>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法</p><p>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法</p><p><img src="F:\笔记\博客\文章图片\bean的生命周期.jpg" alt="bean的生命周期"></p><h2 id="9-2-简化版"><a href="#9-2-简化版" class="headerlink" title="9.2. 简化版"></a>9.2. 简化版</h2><p>实例化：当Spring容器接收到创建Bean的请求时，会根据配置文件或注解等方式创建Bean的实例</p><p>属性赋值：在Bean实例化后，Spring容器会将配置文件或注解中的属性值注入到Bean实例中</p><p>初始化：在属性赋值完成后，Spring容器会调用Bean的初始化方法，可以通过实现InitializingBean接口或在配置文件中指定init-method方法来实现</p><p>使用：初始化完成后，Bean实例可以被应用程序使用</p><p>销毁：当应用程序关闭时，Spring容器会调用Bean的销毁方法，可以通过实现DisposableBean接口或在配置文件中指定destroy-method方法来实现</p><h1 id="10-JavaConfig-实现装配"><a href="#10-JavaConfig-实现装配" class="headerlink" title="10. JavaConfig 实现装配"></a>10. JavaConfig 实现装配</h1><p>不使用xml来配置，由Java全权实现配置功能即配置类</p><p>在配置类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">// @Configuration代表这是一个配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.hy.entity&quot;)</span><span class="comment">// 扫描该包下的被@Component注解的bean</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span><span class="comment">// 注册一个bean，相当于 xml文件中的bean标签</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">student</span><span class="params">()</span>&#123;<span class="comment">//方法名相当于bean标签中的id属性</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Student</span>();<span class="comment">//方法的返回值相当于bean标签中的class属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中使用  AnnotationConfig 获取容器，通过配置类的class对象加载</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取ApplicationContext，拿到Spring的容器</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(UserConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student&quot;</span>);</span><br><span class="line">    System.out.println(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-代理模式"><a href="#11-代理模式" class="headerlink" title="11. 代理模式"></a>11. 代理模式</h1><p>角色分析：</p><p>经典场景：房源（某种功能）、房东（被代理的角色）、中介（代理真实角色的人）、我（客户）</p><ul><li>抽象角色：某种功能，一般会使用接口或者抽象类来解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出租房子的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>真实角色：被代理的角色，被代理类，实现接口或抽象类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 房东实现出租房子的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Host</span> <span class="keyword">implements</span> <span class="title class_">Rent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房东出租房子&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代理角色：代理真实角色的，代理类，代理真实角色后，一般会做一些附属操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中介调用出租房子的接口，同时可以实现其他附加功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">Rent</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Proxy</span><span class="params">(Host host)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rent</span><span class="params">()</span>&#123;</span><br><span class="line">        host.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户：访问代理角色的人</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 真实角色</span></span><br><span class="line">    <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">    <span class="comment">// 中介</span></span><br><span class="line">    <span class="type">Proxy</span> <span class="variable">proxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(host);</span><br><span class="line">    proxy.rent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理模式的优点：</p><ol><li>可以使真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候，方便集中管理</li></ol><p>缺点：一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率会变低</p><h2 id="11-1-静态代理"><a href="#11-1-静态代理" class="headerlink" title="11.1. 静态代理"></a>11.1. 静态代理</h2><p>静态代理，代理类和被代理的类实现了同样的接口，代理类同时持有被代理类的引用，这样，当我们需要调用被代理类的方法时，可以通过调用代理类的方法来做到</p><p>常规开发是纵向开发，业务拓展则是横向开发，这时需要用到代理的思想</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">DAO--&gt;service</span><br><span class="line">service--&gt;controller</span><br><span class="line">controller--&gt;前端</span><br></pre></td></tr></table></figure><h2 id="11-2-动态代理"><a href="#11-2-动态代理" class="headerlink" title="11.2. 动态代理"></a>11.2. 动态代理</h2><p>底层原理：反射</p><p>动态代理的代理类是动态生成的，不是直接写好的</p><p>动态代理分为两大类：基于接口的动态代理（JDK动态代理）、基于类的动态代理（cglib）</p><p>JDK 动态代理：利用反射机制生成一个实现代理接口的类，在调用具体方法前调用InvokeHandler来处理</p><p>CGlib 动态代理：利用ASM（开源的Java字节码编辑库，操作字节码）开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理</p><p>区别：JDK代理只能对实现接口的类生成代理；CGlib是针对类实现代理，对指定的类生成一个子类，并覆盖其中的方法，这种通过继承类的实现方式，不能代理final修饰的类</p><p><strong>InvocationHandler</strong></p><p>需要了解两个类：Proxy 生成动态代理实例、InvocationHandler  调用处理程序并返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个代理类实现 InvocationHandler 接口，并实现 invoke 方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="comment">// 被代理的接口</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过 Proxy.newProxyInstance() 方法创建代理对象</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),target.getClass().getInterfaces(), <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理代理实例，并返回结果</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 动态代理的本质，就是使用反射机制实现</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        拓展功能可在此处调用</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">functions</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//拓展功能的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户代码中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 真实角色</span></span><br><span class="line">        <span class="type">Host</span> <span class="variable">host</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Host</span>();</span><br><span class="line">        <span class="comment">// 代理角色</span></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        <span class="comment">// 设置要代理的真实对象</span></span><br><span class="line">        pih.setTarget(host);</span><br><span class="line">        <span class="comment">// 动态生成代理类</span></span><br><span class="line">        <span class="type">Rent</span> <span class="variable">proxy</span> <span class="operator">=</span> (Rent) pih.getProxy();</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：一个动态代理类代理的是一个接口，一般就是对应的一类业务</p><h1 id="12-AOP-面向切面编程"><a href="#12-AOP-面向切面编程" class="headerlink" title="12. AOP 面向切面编程"></a>12. AOP 面向切面编程</h1><h2 id="12-1-为什么需要AOP"><a href="#12-1-为什么需要AOP" class="headerlink" title="12.1. 为什么需要AOP"></a>12.1. 为什么需要AOP</h2><p>AOP 能够将那些与主要业务无关，却被各业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性</p><p><strong>AOP 的本质是由 AOP 框架修改业务组件的多个方法的源代码</strong>，AOP是代理模式的典型应用</p><p>横切关注点：与我们主线业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志、安全、缓存、事务等</p><h2 id="12-2-AOP实现方式"><a href="#12-2-AOP实现方式" class="headerlink" title="12.2. AOP实现方式"></a>12.2. AOP实现方式</h2><p>静态 AOP 实现， AOP 框架在编译阶段对程序源代码进行修改，生成了静态的 AOP 代理类（生成的 *.class 文件已经被改掉了，需要使用特定的编译器），比如 AspectJ</p><p>动态 AOP 实现， AOP 框架在运行阶段对动态生成代理对象（在内存中以 JDK 动态代理，或 CGlib 动态地生成 AOP 代理类），如 SpringAOP。如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理</p><h2 id="12-3-AOP术语"><a href="#12-3-AOP术语" class="headerlink" title="12.3. AOP术语"></a>12.3. AOP术语</h2><p>切面（ASPECT）：横切关注点的实现类</p><p>通知（Advice）：切面必须要完成的工作。通常是切面实现类中的一个方法</p><p>目标（Target）：被通知对象</p><p>代理（Proxy）：向目标对象应用通知之后创建的对象</p><p>切入点（PointCut）：切面通知执行的地点的定义，通常是一个方法</p><p>连接点（JointPoint）：与切入点匹配的执行点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用</p><h2 id="12-4-Spring-AOP-和-AspectJ-AOP-的区别"><a href="#12-4-Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="12.4. Spring AOP 和 AspectJ AOP 的区别"></a>12.4. Spring AOP 和 AspectJ AOP 的区别</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ 。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多</p><h2 id="12-5-AspectJ-定义的几种通知类型"><a href="#12-5-AspectJ-定义的几种通知类型" class="headerlink" title="12.5. AspectJ 定义的几种通知类型"></a>12.5. AspectJ 定义的几种通知类型</h2><p>Before（前置通知）：目标对象的方法调用之前触发</p><p>After （后置通知）：目标对象的方法调用之后触发</p><p>AfterReturning（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p><p>AfterThrowing（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发</p><p>AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值</p><p>Around （环绕通知）：通知方法会将目标方法封装起来</p><h2 id="12-6-如何控制多个切面的执行顺序"><a href="#12-6-如何控制多个切面的执行顺序" class="headerlink" title="12.6. 如何控制多个切面的执行顺序"></a>12.6. 如何控制多个切面的执行顺序</h2><p>用@Order 注解直接定义切面顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-7-SpringAOP的注解实现（重点）"><a href="#12-7-SpringAOP的注解实现（重点）" class="headerlink" title="12.7. SpringAOP的注解实现（重点）"></a>12.7. SpringAOP的注解实现（重点）</h2><p>Spring AOP 不能拦截对对象字段的修改，也不支持构造器连接点，我们无法在 Bean 创建时应用通知</p><p>在pom.xml中导入依赖包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在application.xml配置文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hy&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启aop注解方式,这样java类中的aop注解才会生效 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>定义一个切面类</p><p>使用注解 @Aspect 表示它是一个切面。类中的方法分别可以使用 @Before、@After、@Around 注解</p><p>参数 (“execution(<em> com.hy.service.UserServiceImpl.</em>(..))”)  声明了切点，表明在该切面的切点是 com.hy.service.UserServiceImpl这个接口实现类中的所有方法。注：execution是指示器</p><p>注意： @Around修饰的环绕通知类型，是将整个目标方法封装起来了，在使用时，我们需要传入 ProceedingJoinPoint类型的参数，这个对象是必须要有的，并且需要调用 ProceedingJoinPoint的 proceed() 方法。 如果没有调用该方法，则原目标方法将被阻塞而不调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">//表明它将作为一个Spring Bean 被装配</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这个类是一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cut</span> &#123;</span><br><span class="line">    <span class="comment">// 方法执行前的切入点</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.hy.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法执行后的切入点</span></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.hy.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环绕（将目标方法封装）</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.hy.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pj)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Around aaa ...&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用proceed()</span></span><br><span class="line">        pj.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;Around bbb ...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在配置文件中启用AOP切面功能</p><p>@EnableAspectJAutoProxy注解，启用了 AOP 功能，参数proxyTargetClass的值设为了 true ，默认值是 false。proxyTargetClass 参数决定了代理的机制。当这个参数为 false 时，通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类。反之，proxyTargetClass为 true，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被final修饰时，无法进行织入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackageClasses = &#123;com.hy.service.UserService.class&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类中测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;application.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userservice</span> <span class="operator">=</span> ac.getBean(<span class="string">&quot;UserServiceImpl&quot;</span>,UserServiceImpl.class);</span><br><span class="line">        userservice.AopTest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过注解声明切点表达式</strong></p><p>多个通知使用了相同的切点表达式，对于像这样频繁出现的相同的表达式，我们可以使用 @Pointcut注解声明切点表达式，然后使用表达式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">//标注这个类是一个切面</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">//表明它将作为一个Spring Bean 被装配</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Log</span> &#123;</span><br><span class="line">    <span class="comment">// 声明切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.hy.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">point</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 方法执行前的切入点</span></span><br><span class="line">    <span class="meta">@Before(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法执行后的切入点</span></span><br><span class="line">    <span class="meta">@After(&quot;point()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-8-SpringAOP的xml实现"><a href="#12-8-SpringAOP的xml实现" class="headerlink" title="12.8. SpringAOP的xml实现"></a>12.8. SpringAOP的xml实现</h2><p><strong>方法一：使用原生Spring API接口</strong></p><p>com.hy.log.Log</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// method：要执行的目标对象的方法</span></span><br><span class="line"><span class="comment">// args：参数</span></span><br><span class="line"><span class="comment">// target：目标对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(Method method, Object[] args, Object target)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    System.out.println(target.getClass().getName() + <span class="string">&quot;的&quot;</span>+method.getName()+<span class="string">&quot;被执行了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现切入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.service.UserServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;log&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.log.Log&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.log.AfterLog&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  切入点 pointcut</span></span><br><span class="line"><span class="comment">  expression：execution（要切入的位置）</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hy.service.UserServiceImpl.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--执行环绕增强 advisor--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;log&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;afterLog&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>main方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 动态代理代理的是接口</span></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">    userService.delete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二：自定义类实现AOP（主要是切面定义）</strong></p><p>推荐使用</p><p>com.hy.log.PointCut</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PointCut</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行前&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法执行后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;cut&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.log.PointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义切面 ref要引用的类，即实现功能拓展的类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;cut&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--切入点，即要为哪个业务类拓展功能--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;point&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hy.log.PointCut.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--通知，具体拓展的是拓展类中的哪个方法，以及拓展位置是方法前还是方法后--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;point&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;after&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;point&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="13-Spring-事务"><a href="#13-Spring-事务" class="headerlink" title="13. Spring 事务"></a>13. Spring 事务</h1><p>事务原本是数据库中的概念，用于数据访问层。但<strong>一般情况下，需要将事务提升到业务层，即Service层</strong>。这样做是为了能够使用事务的特性来管理具体的业务。</p><p>数据库中事务能否生效在于数据库引擎是否支持事务。比如常用的 MySQL 数据库默认使用支持事务的 innodb引擎。但是如果把数据库引擎变为 myisam，那么数据库也就不再支持事务了</p><p>对于普通JDBC，只有一种方法（<code>setAutocommit(false)</code>）来管理事务，而Spring提供了许多不同的、更方便的方法来实现相同的目的。</p><h2 id="13-1-事务的属性"><a href="#13-1-事务的属性" class="headerlink" title="13.1. 事务的属性"></a>13.1. 事务的属性</h2><p><strong>隔离级别</strong></p><p><strong>传播行为</strong>：指在一个事务方法内部调用另一个事务方法时，这两个方法之间事务的传播方式。在使用事务时，可能会遇到多个事务方法相互调用的情况，此时就需要考虑事务的传播行为</p><p><strong>回滚规则</strong></p><p><strong>是否只读</strong>：指的是事务在执行期间是否会修改数据库中的数据。如果事务只读，则事务期间只能进行查询操作，不能进行插入、更新、删除等修改操作</p><p><strong>事务超时</strong></p><h2 id="13-2-Spring-中事务实现的方式"><a href="#13-2-Spring-中事务实现的方式" class="headerlink" title="13.2. Spring 中事务实现的方式"></a>13.2. Spring 中事务实现的方式</h2><h3 id="13-2-1-声明式事务管理（推荐使用）"><a href="#13-2-1-声明式事务管理（推荐使用）" class="headerlink" title="13.2.1. 声明式事务管理（推荐使用）"></a>13.2.1. 声明式事务管理（推荐使用）</h3><p>由Spring框架提供的AOP支撑实现</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式一：在配置文件（xml）中做相关的事务规则声明</strong></p><p>在resources目录下编写 spring-context.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务通知; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>= <span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--给那些方法配置事务--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的传播特性: new propagation= --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot; add&quot;</span> <span class="attr">propagation</span>= <span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>= <span class="string">&quot;query&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>= <span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务切入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointCut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.hy.mapper.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointCut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式二：基于@Transactional 注解的方式（推荐）</strong></p><p><code>@Transactional</code>注解可以应用在类或方法上。如果应用在类上，整个类中的所有方法都将被视为一个事务单元。</p><p>使用<code>@Transactional</code> 注解需要具备以下条件：</p><ul><li>确保Spring项目中开启 <code>@EnableTransactionManagement</code>（在SpringBoot项目中会自动开启）</li><li>在Spring配置中指定事务管理器</li><li>@Transactional 只被加到 public方法上才会生效</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">txManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> yourTxManager; <span class="comment">// 指定事务管理器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口，会使用 CGLIB 动态代理</p><h3 id="13-2-2-编程式事务管理（不建议使用）"><a href="#13-2-2-编程式事务管理（不建议使用）" class="headerlink" title="13.2.2. 编程式事务管理（不建议使用）"></a>13.2.2. 编程式事务管理（不建议使用）</h3><p>在代码中进行事务的管理。通过 TransactionTemplate、TransactionManager手动管理事务</p><p><strong>TransactionTemplate实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// ....  业务代码</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                    <span class="comment">//回滚</span></span><br><span class="line">                    transactionStatus.setRollbackOnly();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>TransactionManager实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTransaction</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> transactionManager.getTransaction(<span class="keyword">new</span> <span class="title class_">DefaultTransactionDefinition</span>());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// ....  业务代码</span></span><br><span class="line">              transactionManager.commit(status);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              transactionManager.rollback(status);</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-Spring-事务管理API"><a href="#13-3-Spring-事务管理API" class="headerlink" title="13.3. Spring 事务管理API"></a>13.3. Spring 事务管理API</h2><p>使用Spring事务管理主要用到的接口</p><p><strong>事务管理器接口</strong></p><p><code>PlatformTransactionManager</code>：Spring 事务策略的核心，通过这个接口，Spring为各个平台如：JDBC、JPA、Hibernate提供对应的事务管理器</p><p>该接口定义了3个事务方法：</p><ul><li>void commit(TransactionStatus status)：事务的提交</li><li>TransactionStatus getTransaction(TransactionDefinition definition)：获取事务的状态</li><li>void rollback(TransactionStatus status)：事务的回滚</li></ul><p><code>PlatformTransactionManager</code>接口常用的两个实现类（具体的事务管理器）：</p><ul><li>DataSourceTransactionManager：使佣JDBC或MyBatis进行持久化数据时使用。（因为MyBatis最后调用的还是JDBC所以可以通用）</li><li>HibernateTransactionManager：使用Hibernate进行持久化数据时使用。</li></ul><p><strong>事务定义接口</strong></p><p><code>TransactionDefinition</code>：定义的信息包含事务隔离级别、传播行为、超时、只读、回滚规则</p><p><code>PlatformTransactionManager</code>会根据 <code>TransactionDefinition</code>的定义，比如事务超时时间、隔离级别、传播行为等，来进行事务管理 </p><p><strong>事务运行状态</strong></p><p><code>TransactionStatus</code>：提供了一些方法来获取事务相应的状态，比如是否新事务、是否可以回滚等等</p><h2 id="13-4-Spring-事务的传播行为"><a href="#13-4-Spring-事务的传播行为" class="headerlink" title="13.4. Spring 事务的传播行为"></a>13.4. Spring 事务的传播行为</h2><p>事务传播行为是指如果在开始当前事务之前，一个事务上下文已经存在，此时有若干选项可以指定一个事务性方法的执行行为</p><p>处于不同事务中的方法在相互调用时，事务的处理方式。如，A事务中的方法a() 调用B事务中的方法b()，在调用执行期间事务的维护情况就称为事务传播行为。事务传播行为是加在方法上的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>TransactionDefinition.PROPAGATION_REQUIRED</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。这是默认值</li><li><code>TransactionDefinition.PROPAGATION_REQUIRES_NEW</code>：创建一个新的事务，如果当前存在事务，则把当前事务挂起</li><li><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</li><li><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起</li><li><code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常</li><li><code>TransactionDefinition.PROPAGATION_MANDATORY</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</li><li><code>TransactionDefinition.PROPAGATION_NESTED</code>：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>，嵌套事务可以独立于外部事务进行提交或回滚</li></ul><h2 id="13-5-Spring-事务的隔离级别"><a href="#13-5-Spring-事务的隔离级别" class="headerlink" title="13.5. Spring 事务的隔离级别"></a>13.5. Spring 事务的隔离级别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(isolation = Isolation.READ_COMMITTED)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DEFAULT：默认的隔离级别，由底层数据库自行决定隔离级别</li><li>READ_UNCOMMITTED：最低的隔离级别，事务可以读取到未提交的数据，可能会出现脏读、不可重复读、幻读等问题</li><li>READ_COMMITTED：事务只能读取已经提交的数据，避免了脏读问题，但可能会出现不可重复读和幻读问题</li><li>REPEATABLE_READ：事务可以重复读取相同的数据，避免了不可重复读问题，但可能会出现幻读问题</li><li>SERIALIZABLE：最高的隔离级别，事务串行执行，避免了所有并发问题，但会对性能产生影响。</li></ul><p>MYSQL：默认为REPEATABLE_READ</p><p>SQLSERVER：默认为READ_COMMITTED</p><p>ORACLE：默认为READ COMMITTED</p><h2 id="13-6-Spring-事务的超时"><a href="#13-6-Spring-事务的超时" class="headerlink" title="13.6. Spring 事务的超时"></a>13.6. Spring 事务的超时</h2><p>默认即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(timeout=30)</span> <span class="comment">//默认是30秒</span></span><br></pre></td></tr></table></figure><h2 id="13-7-Spring-事务的回滚机制"><a href="#13-7-Spring-事务的回滚机制" class="headerlink" title="13.7. Spring 事务的回滚机制"></a>13.7. Spring 事务的回滚机制</h2><p>默认情况下，Spring 只会对 <code>unchecked exception</code>进行回滚，而对 checked 异常不会回滚。可以通过在 @Transactional 注解上设置 <code>rollbackFor</code> 属性来指定需要回滚的异常类型</p><p>在 @Transactional 注解中如果不配置rollbackFor 属性，那么事务只会在遇到RuntimeException的时候才会回滚，加上 rollbackFor=Exception.class，可以让事务在遇到非运行时异常时也回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br></pre></td></tr></table></figure><p>在声明式事务中，当事务方法调用其他事务方法时，如果其中一个方法出现异常并回滚了事务，其他方法也会回滚事务，除非其他方法使用了 <code>REQUIRES_NEW</code> 传播行为。</p><p>在编程式事务中，通过调用 <code>TransactionStatus.setRollbackOnly()</code>方法来设置事务回滚标志，从而回滚事务</p><h2 id="13-8-事务失效"><a href="#13-8-事务失效" class="headerlink" title="13.8. 事务失效"></a>13.8. 事务失效</h2><p><strong>事务失效的场景1</strong>：如果你在方法中有<code>try&#123;&#125;catch(Exception e)&#123;&#125;</code>处理，那么try里面的代码块就脱离了事务的管理，若要事务生效需要在catch中<code>throw new RuntimeException (&quot;xxxxxx&quot;);</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-04-02-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2024/10/28/2023-04-02-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h1><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，下面仅学习JDK 1.8的</p><h2 id="1-1-Java-文件是如何被运行的"><a href="#1-1-Java-文件是如何被运行的" class="headerlink" title="1.1. Java 文件是如何被运行的"></a>1.1. Java 文件是如何被运行的</h2><p>Java 文件经过编译后变成 .class 字节码文件</p><p>（虚拟机主要的 5 大块）</p><p><strong>类加载器</strong></p><p>字节码文件通过 类加载器 被搬运到 JVM 虚拟机中</p><p><strong>方法区</strong></p><p>类加载器将 .class 文件搬过来先丢到这一块上</p><p>对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法</p><p><strong>堆</strong></p><p>主要放一些存储的数据，比如对象实例，数组···等</p><p><strong>栈</strong></p><p>是代码运行空间，每一个方法都会放到 栈 里面运行</p><p>栈存储的是基本数据类型和对象的引用。当一个方法被调用时，Java会在栈上为该方法分配一块内存区域，称为栈帧。栈帧包含方法的参数、局部变量和返回值。当方法返回时，栈帧被弹出，栈上的内存被释放</p><p><strong>计数器</strong></p><p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码</p><p> JVM 的调优主要就是围绕堆，栈两大块进行</p><h2 id="1-2-Java内存管理"><a href="#1-2-Java内存管理" class="headerlink" title="1.2. Java内存管理"></a>1.2. Java内存管理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(JVM运行时数据区域)</span><br><span class="line">A--&gt;A.1(堆)</span><br><span class="line">A--&gt;A.2(栈)</span><br><span class="line">A--&gt;A.3(方法区)</span><br><span class="line">A.1--&gt;A.1.1(所有线程共享的一块内存区域,在虚拟机启动时创建)</span><br><span class="line">A.1--&gt;A.1.2(存放new出的对象实例以及数组)</span><br><span class="line">A.2--&gt;A.2.1(栈是线程私有的内存区域)</span><br><span class="line">A.2--&gt;A.2.2(存储的是基本数据类型和对象的引用)</span><br><span class="line">A.3--&gt;A.3.1(是运行时数据区域的一块逻辑区域,是各个线程共享的内存区域)</span><br><span class="line">A.3--&gt;A.3.2(存放类信息,常量,静态变量,编译后的代码等)</span><br></pre></td></tr></table></figure><h2 id="1-3-运行时常量池（是方法区的一部分）"><a href="#1-3-运行时常量池（是方法区的一部分）" class="headerlink" title="1.3. 运行时常量池（是方法区的一部分）"></a>1.3. 运行时常量池（是方法区的一部分）</h2><p>存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表(Constant Pool Table)</strong> </p><p>字面量是源代码中的固定值的表示法。字面量包括整数、浮点数和字符串字面量</p><p>常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号</p><h2 id="1-4-字符串常量池"><a href="#1-4-字符串常量池" class="headerlink" title="1.4. 字符串常量池"></a>1.4. 字符串常量池</h2><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建</p><p>HotSpot 虚拟机中字符串常量池的实现是 StringTable，StringTable 本质上就是一个<code>HashSet&lt;String&gt;</code>，StringTable 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象</p><h1 id="2-HotSpot-虚拟机对象"><a href="#2-HotSpot-虚拟机对象" class="headerlink" title="2. HotSpot 虚拟机对象"></a>2. HotSpot 虚拟机对象</h1><h2 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1. 对象的创建"></a>2.1. 对象的创建</h2><h2 id="2-2-分析"><a href="#2-2-分析" class="headerlink" title="2.2. 分析"></a>2.2. 分析</h2><p> <strong>String s1 = new String(“abc”) 这句话创建了几个字符串对象？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Java中的字符串是不可变的，这意味着每次对字符串进行更改时，都会创建一个新的字符串对象。</span><br><span class="line">因此，<span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>)创建了两个字符串对象。</span><br><span class="line"></span><br><span class="line">第一个字符串对象是字面值<span class="string">&quot;abc&quot;</span>，它存储在字符串常量池中。第二个字符串对象是通过<span class="keyword">new</span>关键字创建的，它存储在堆中。s1是对第二个字符串对象的引用。</span><br><span class="line"></span><br><span class="line">需要注意的是，如果使用字面值创建字符串对象，只会创建一个字符串对象。例如，<span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>只会创建一个字符串对象，因为<span class="string">&quot;abc&quot;</span>已经存在于字符串常量池中。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-26-MySQL%E5%8E%9F%E7%90%86/"/>
      <url>/2024/10/28/2023-03-26-MySQL%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h2 id="1-1-关系型数据库"><a href="#1-1-关系型数据库" class="headerlink" title="1.1. 关系型数据库"></a>1.1. 关系型数据库</h2><h2 id="1-2-SQL"><a href="#1-2-SQL" class="headerlink" title="1.2. SQL"></a>1.2. SQL</h2><h2 id="1-3-MySQL"><a href="#1-3-MySQL" class="headerlink" title="1.3. MySQL"></a>1.3. MySQL</h2><h1 id="2-MySQL-基础架构"><a href="#2-MySQL-基础架构" class="headerlink" title="2. MySQL 基础架构"></a>2. MySQL 基础架构</h1><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131104299.png" alt="MySQL基础架构"></p><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，同时还有一个日志模块binlog，这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有</li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了</strong>，可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></li></ul><h2 id="2-1-Server-层基本组件"><a href="#2-1-Server-层基本组件" class="headerlink" title="2.1. Server 层基本组件"></a>2.1. Server 层基本组件</h2><h3 id="2-1-1-连接器"><a href="#2-1-1-连接器" class="headerlink" title="2.1.1. 连接器"></a>2.1.1. 连接器</h3><p>连接器主要负责身份认证和权限相关的功能</p><p>当用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p><h3 id="2-1-2-查询缓存（MySQL-8-0-版本后移除）"><a href="#2-1-2-查询缓存（MySQL-8-0-版本后移除）" class="headerlink" title="2.1.2. 查询缓存（MySQL 8.0 版本后移除）"></a>2.1.2. 查询缓存（MySQL 8.0 版本后移除）</h3><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集，不推荐使用</p><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p><p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空</p><h3 id="2-1-3-分析器"><a href="#2-1-3-分析器" class="headerlink" title="2.1.3. 分析器"></a>2.1.3. 分析器</h3><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p><p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h3 id="2-1-4-优化器"><a href="#2-1-4-优化器" class="headerlink" title="2.1.4. 优化器"></a>2.1.4. 优化器</h3><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。经过了优化器之后，这个语句具体该如何执行就已经定下来。</p><h3 id="2-1-5-执行器"><a href="#2-1-5-执行器" class="headerlink" title="2.1.5. 执行器"></a>2.1.5. 执行器</h3><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果</p><h2 id="2-2-语句执行分析"><a href="#2-2-语句执行分析" class="headerlink" title="2.2. 语句执行分析"></a>2.2. 语句执行分析</h2><ul><li><strong>查询语句</strong>的执行流程如下：权限校验（如果命中缓存）—-&gt;查询缓存—-&gt;分析器—-&gt;优化器—-&gt;权限校验—-&gt;执行器—-&gt;引擎</li><li><strong>更新语句</strong>的执行流程如下：分析器——&gt;权限校验——&gt;执行器—-&gt;引擎—-redo log（prepare 状态）—-&gt;binlog—-&gt;redo log（commit状态）</li></ul><h2 id="2-3-MySQL存储引擎"><a href="#2-3-MySQL存储引擎" class="headerlink" title="2.3. MySQL存储引擎"></a>2.3. MySQL存储引擎</h2><p><code>show engines</code> 命令查看 MySQL 支持的所有存储引擎</p><p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎</p><p>所有的存储引擎中只有 InnoDB 支持事务</p><h3 id="2-3-1-MySQL-存储引擎架构"><a href="#2-3-1-MySQL-存储引擎架构" class="headerlink" title="2.3.1. MySQL 存储引擎架构"></a>2.3.1. MySQL 存储引擎架构</h3><p> <strong>插件式架构</strong>。可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库</strong></p><h3 id="2-3-2-MyISAM-和-InnoDB-区别"><a href="#2-3-2-MyISAM-和-InnoDB-区别" class="headerlink" title="2.3.2. MyISAM 和 InnoDB 区别"></a>2.3.2. MyISAM 和 InnoDB 区别</h3><p><strong>是否支持行级锁</strong></p><p>MyISAM 只有表级锁（table-level locking），而 InnoDB 支持行级锁（row-level locking）和表级锁，默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下性能比 InnoDB 差</p><p><strong>是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，SQL 标准定义了四个隔离级别，具有提交（commit）和回滚（rollback）事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</p><p><strong>是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。阿里的《Java 开发手册》明确规定禁止使用外键</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可</p><p><strong>是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>索引实现不一样</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。而 MyISAM，索引文件和数据文件是分离的。InnoDB 引擎中，表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p><strong>性能有差别</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系</p><p><strong>总结</strong></p><p>MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。请无脑使用 InnoDB</p><h1 id="3-MySQL-锁"><a href="#3-MySQL-锁" class="headerlink" title="3. MySQL 锁"></a>3. MySQL 锁</h1><h2 id="3-1-锁的类型"><a href="#3-1-锁的类型" class="headerlink" title="3.1. 锁的类型"></a>3.1. 锁的类型</h2><p>共享锁（Share Lock，S 锁）：也称为读锁（Read Lock），在读取数据时使用。多个事务可以同时持有共享锁，但是一个事务持有共享锁时，其他事务不能获取排它锁。</p><p>排它锁（Exclusive Lock，X 锁）：也称为写锁（Write Lock），在更新数据时使用。只有一个事务可以持有排它锁，其他事务不能获取共享锁和排它锁。</p><p>意向锁：快速判断是否可以对某个表使用表锁</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁</li></ul><p>行级锁（Row Lock）：是针对行数据进行的锁定，可以实现对表中某些行的读和写的互斥操作。行级锁可以是共享锁或排它锁。</p><p>表级锁（Table Lock）：是针对整张表进行的锁定，可以实现对整张表的读和写的互斥操作。表级锁可以是共享锁或排它锁。</p><h2 id="3-2-行锁-amp-表锁"><a href="#3-2-行锁-amp-表锁" class="headerlink" title="3.2. 行锁&amp;表锁"></a>3.2. 行锁&amp;表锁</h2><p>MyISAM 仅仅支持表级锁，一锁就锁整张表，在并发写的情况下性非常差。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁</p><p><strong>表锁</strong></p><p>表级锁是MySQL中最基本的锁机制，它是对整张表进行加锁，可以实现对整张表的读和写的互斥操作。当一个线程获得了表级锁后，<strong>其他线程就不能再对该表进行写操作，只能进行读操作</strong></p><p>MySQL中的表级锁分为两种：共享锁和排它锁。共享锁是读锁，用于保证多个线程可以同时读取同一张表，而不会冲突。排它锁是写锁，用于保证只有一个线程可以对表进行写操作，其他线程不能进行读或写操作。</p><p>表级锁的优点是锁定粒度大，可以保证操作的原子性，缺点是并发性能差，容易出现锁等待和死锁。</p><p>表锁可以使用以下语句进行设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCK TABLES ...;</span><br></pre></td></tr></table></figure><p>在上面的语句中，LOCK TABLES语句用于锁定表格。当一个事务获取了某个表的表锁后，其他事务就无法修改该表数据，直到该事务释放表锁为止</p><p><strong>行锁</strong></p><p>行级锁是MySQL中一种更细粒度的锁机制，它是在表的行级别上进行加锁，可以实现对表中某些行的读和写的互斥操作。当一个线程获得了行级锁后，其他线程可以继续读取该表的其他行，但不能读取或修改被锁定的行</p><p><strong>MySQL中的行级锁是基于存储引擎实现的</strong>，不同的存储引擎对行级锁的支持不同。例如，InnoDB存储引擎支持行级锁，而MyISAM存储引擎不支持行级锁。</p><p>行级锁的优点是锁定粒度小，可以提高并发性能，缺点是需要占用更多的系统资源，同时也容易出现死锁等问题</p><p>行锁可以使用以下语句进行设置：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p>在上面的语句中，SELECT语句用于查询数据，FOR UPDATE语句用于设置行锁。当一个事务获取了某一行的行锁后，其他事务就无法修改该行数据，直到该事务释放行锁为止</p><p><strong>MySQL行锁和表锁都可能会遇到一些问题，具体问题和解决方案如下：</strong></p><p>行锁的死锁问题：当多个事务同时请求行级锁时，可能会出现死锁的情况。解决方案可以采用加锁顺序一致、限制事务持有锁的时间等方式来避免死锁。</p><p>表锁的并发性问题：表锁的加锁粒度比较大，可能会导致并发性能下降。解决方案可以采用分库分表、使用更细粒度的锁等方式来提高并发性能。</p><p>表锁的读写冲突问题：表锁会导致整张表的读和写互斥，可能会影响系统的并发性能和响应时间。解决方案可以采用读写分离、使用更细粒度的锁等方式来提高并发性能和响应时间。</p><p>行锁的性能问题：行级锁的加锁粒度比较细，可能会导致锁竞争频繁、锁定资源过多等性能问题。解决方案可以采用使用更细粒度的锁、优化SQL语句、增加硬件资源等方式来提高性能。</p><p>行锁和表锁的选择问题：在使用锁时需要根据具体的业务需求和系统架构选择合适的锁机制。一般来说，如果并发访问的数据比较少，可以使用表级锁；如果并发访问的数据比较频繁，可以使用行级锁</p><h1 id="4-InnoDB-对-MVCC-的实现"><a href="#4-InnoDB-对-MVCC-的实现" class="headerlink" title="4. InnoDB 对 MVCC 的实现"></a>4. InnoDB 对 MVCC 的实现</h1><p>MVCC（Multi-Version Concurrency Control）是一种用于保证数据库并发访问正确性的机制，常用于支持事务的数据库系统中。MVCC采用多版本的方式来控制并发，确保每个事务读取的数据是一致性的。</p><p>在MVCC机制下，每个事务在读取数据时都可以看到一个自己的“版本”或“快照”，不同的事务看到的数据版本可能是不同的。当一个事务修改数据时，不会直接覆盖原来的数据，而是创建一个新的版本。这样，其他事务在读取数据时可以继续看到旧版本的数据，而不会受到新版本数据的影响。</p><p>在MVCC机制下，每个数据行都有一个版本号或时间戳，用来标识这个数据行的版本。当一个事务需要读取数据时，它会读取该数据行的最新版本（或符合事务隔离级别的版本），如果该版本是其他事务创建的，那么该事务就会根据版本号或时间戳的不同而采取不同的对策。如果该版本是已提交的，那么该事务可以直接读取数据；如果该版本是未提交的，那么该事务就需要等待该事务的提交；如果该版本被其他事务锁定，那么该事务也需要等待锁的释放。</p><p>MVCC机制通常使用在支持快照隔离级别的数据库系统中，比如MySQL、PostgreSQL等。它可以提高数据库的并发性能和可靠性，避免了传统锁机制中的死锁、饥饿等问题。</p><h1 id="5-MySQL-事务（重点）"><a href="#5-MySQL-事务（重点）" class="headerlink" title="5. MySQL 事务（重点）"></a>5. MySQL 事务（重点）</h1><h2 id="5-1-背景"><a href="#5-1-背景" class="headerlink" title="5.1. 背景"></a>5.1. 背景</h2><p>我们需要插入多条相关联的数据到数据库，但是这个过程可能会遇到下面这些问题：</p><ul><li>数据库中途突然因为某些原因挂掉了</li><li>客户端突然因为网络原因连接不上数据库了</li><li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改</li></ul><p>事务的作用是为了维护数据的一致性和完整性，即使发生故障时也是如此</p><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p><h2 id="5-2-数据库事务"><a href="#5-2-数据库事务" class="headerlink" title="5.2. 数据库事务"></a>5.2. 数据库事务</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131104442.png" alt="事务"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 开启一个事务</span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"># 多条 <span class="keyword">SQL</span> 语句</span><br><span class="line">SQL1,SQL2...</span><br><span class="line">## 提交事务</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务的 <strong>ACID</strong> 特性：</p><ul><li><p><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p></li><li><p><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p></li><li><p><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p></li><li><p><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p></li></ul><p><strong>重点</strong>：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p><p>注意：MySQL事务回滚的原理是通过回滚日志 Undo log 来实现的</p><h2 id="5-3-并发事务带来的问题"><a href="#5-3-并发事务带来的问题" class="headerlink" title="5.3. 并发事务带来的问题"></a>5.3. 并发事务带来的问题</h2><p>多个事务并发运行，经常会操作相同的数据来完成各自的任务（如 多个用户并发的对同一数据进行操作）</p><h3 id="5-3-1-脏读（Dirty-read）"><a href="#5-3-1-脏读（Dirty-read）" class="headerlink" title="5.3.1. 脏读（Dirty read）"></a>5.3.1. 脏读（Dirty read）</h3><p>A事务读取了B事务中还未提交的数据，但当B事务提交失败进行回滚时，导致数据并没有被提交到数据库，那A事务读取到的就是脏数据，这就是脏读</p><h3 id="5-3-2-丢失修改（Lost-to-modify）"><a href="#5-3-2-丢失修改（Lost-to-modify）" class="headerlink" title="5.3.2. 丢失修改（Lost to modify）"></a>5.3.2. 丢失修改（Lost to modify）</h3><p>A事务读取一个数据时，B事务也访问了该数据，那么在A事务中修改了这个数据后，如果B事务也修改了这个数据。这样导致A事务内的修改结果被丢失，这就是丢失修改</p><h3 id="5-3-3-不可重复读（Unrepeatable-read）"><a href="#5-3-3-不可重复读（Unrepeatable-read）" class="headerlink" title="5.3.3. 不可重复读（Unrepeatable read）"></a>5.3.3. 不可重复读（Unrepeatable read）</h3><p>A事务内多次读同一数据。在A事务还没有结束的同时，B事务也访问该数据。则在A事务中的两次读数据之间，由于B事务的修改，可能导致A事务两次读取的数据不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，这就是不可重复读</p><h3 id="5-3-4-幻读（Phantom-read）"><a href="#5-3-4-幻读（Phantom-read）" class="headerlink" title="5.3.4. 幻读（Phantom read）"></a>5.3.4. 幻读（Phantom read）</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</p><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读</p><h2 id="5-4-并发事务的控制方式"><a href="#5-4-并发事务的控制方式" class="headerlink" title="5.4. 并发事务的控制方式"></a>5.4. 并发事务的控制方式</h2><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 InnoDB 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><h2 id="5-5-事务隔离级别"><a href="#5-5-事务隔离级别" class="headerlink" title="5.5. 事务隔离级别"></a>5.5. 事务隔离级别</h2><p>事务隔离级别是指在多个事务并发执行时，各个事务之间相互隔离的程度。数据库管理系统通过实现不同的隔离级别来平衡并发性和数据一致性之间的关系</p><h3 id="5-5-1-四个隔离级别"><a href="#5-5-1-四个隔离级别" class="headerlink" title="5.5.1. 四个隔离级别"></a>5.5.1. 四个隔离级别</h3><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。可以通过<code>SELECT @@tx_isolation;</code>命令来查看</p><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读</li></ul><p>注意：隔离级别越高，会对并发性能产生越大的影响，因此需要根据具体情况进行选择。</p><h3 id="5-5-2-MySQL-隔离级别的实现"><a href="#5-5-2-MySQL-隔离级别的实现" class="headerlink" title="5.5.2. MySQL 隔离级别的实现"></a>5.5.2. MySQL 隔离级别的实现</h3><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读</p><h1 id="6-MySQL-索引（重点）"><a href="#6-MySQL-索引（重点）" class="headerlink" title="6. MySQL 索引（重点）"></a>6. MySQL 索引（重点）</h1><h2 id="6-1-索引介绍"><a href="#6-1-索引介绍" class="headerlink" title="6.1. 索引介绍"></a>6.1. 索引介绍</h2><p><strong>索引是一种用于快速查询和检索数据的数据结构</strong>。索引，我们也称之为 index 或者 key</p><p>MySQL 的索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎的索引工作方式都不一样，甚至相同类型的索引，在不同的存储引擎中实现方案都不同</p><ul><li>减少了服务器需要扫描的数据量。</li><li>索引可以帮助服务器避免排序和创建临时表。</li><li>索引将随机 IO 变为了顺序 IO</li></ul><h2 id="6-2-索引的底层数据结构"><a href="#6-2-索引的底层数据结构" class="headerlink" title="6.2. 索引的底层数据结构"></a>6.2. 索引的底层数据结构</h2><p>常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构</p><h3 id="6-2-1-B树-amp-B-树的异同"><a href="#6-2-1-B树-amp-B-树的异同" class="headerlink" title="6.2.1. B树&amp;B+树的异同"></a>6.2.1. B树&amp;B+树的异同</h3><p>B 树的所有节点既存放键(key) 也存放 数据(data)</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131104397.png" alt="b-tree"></p><p>B+树只有叶子节点存放 key 和 data，其他内节点只存放 key</p><p>B+Tree 非叶子节点只保存关键字的索引和指向下一个节点的指针</p><p>B+Tree 叶子节点的关键字从小到大按顺序排列</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131105136.png" alt="b+tree"></p><h3 id="6-2-2-树高问题"><a href="#6-2-2-树高问题" class="headerlink" title="6.2.2. 树高问题"></a>6.2.2. 树高问题</h3><p>在 InnoDB 存储引擎中，B+Tree 的高度一般为 2-4 层，这就可以满足 千万级的数据的存储，查找数据的时候，一次页的查找代表一次 IO，那我们通过主键索引查询的时候，其实最多只需要 2-4 次 IO 操作就可以了</p><h2 id="6-3-MyISAM-amp-InnoDB-索引的区别"><a href="#6-3-MyISAM-amp-InnoDB-索引的区别" class="headerlink" title="6.3. MyISAM&amp;InnoDB 索引的区别"></a>6.3. MyISAM&amp;InnoDB 索引的区别</h2><p>InnoDB 引擎中，其数据文件本身就是索引文件。而 MyISAM，索引文件和数据文件是分离的</p><p>MyISAM 引擎中，B+Tree 叶节点的 <strong>data 域存放的是数据记录的地址</strong>。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为<strong>非聚簇索引（非聚集索引）</strong></p><p>InnoDB 引擎中，其数据文件本身就是索引文件。其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 <strong>data 域保存了完整的数据记录</strong>。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为<strong>聚簇索引（聚集索引）</strong>。其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方</p><p>InnoDB 引擎中，在根据主索引搜索时，直接找到 key 所在的节点即可取出数据。如果不是主键索引，叶子节点存储的是主键+列值。最终还是要<strong>回表</strong>，也就是要通过主键再查找一次，即需要先取出主键的值，再走一遍主索引</p><p>因此，在设计表的时候，<strong>不建议使用过长的字段作为主键，也不建议使用无序的字段作为主键，这样会造成主索引频繁分裂</strong></p><h2 id="6-4-索引的类型"><a href="#6-4-索引的类型" class="headerlink" title="6.4. 索引的类型"></a>6.4. 索引的类型</h2><p><strong>按照底层存储方式角度划分：</strong></p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引</li></ul><p><strong>按照应用维度划分：</strong></p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个</li><li>普通索引：仅加速查询</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）</li><li>覆盖索引：一个索引包含所有需要查询的字段的值</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并</li><li><p>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替</p><h2 id="6-5-索引的使用场景"><a href="#6-5-索引的使用场景" class="headerlink" title="6.5. 索引的使用场景"></a>6.5. 索引的使用场景</h2></li><li><p>全值匹配。如果我们要搜索 username 为 ac 且 age 为 98 的用户，就可以直接使用索引精确定位到</p></li><li><p>最左匹配。</p></li><li><p>前缀匹配。如果我们搜索的关键字只是 username 字段的前半部分，那么很明显，也是可以使用索引的，例如搜索所有以 a 开始的 username。</p></li><li><p>范围匹配。如果我们的搜索条件是一个范围，很明显也可以使用到上述索引，例如搜索姓名介于 ab～cc 之间的用户，只需要先从索引树的根节点开始，先找到 ab，然后根据叶子节点之间的指针顺藤摸瓜，找到 cc 之后的第一个数据（不满足条件的第一个数据）结束。</p></li><li><p>前面全值匹配，后面范围匹配。</p></li><li><p>覆盖索引。有的时候，我们搜索的数据都在索引树中了，例如上图中的索引，我们想搜索 username 为 bw 的用户的 age，由于 age 就在索引树中，直接返回即可，这就是覆盖索引了。</p></li></ul><h2 id="6-6-主键索引（重点）"><a href="#6-6-主键索引（重点）" class="headerlink" title="6.6. 主键索引（重点）"></a>6.6. 主键索引（重点）</h2><p>数据表的主键列使用的就是主键索引</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复（即只能有一个字段被设为主键）</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</p><h2 id="6-7-二级索引"><a href="#6-7-二级索引" class="headerlink" title="6.7. 二级索引"></a>6.7. 二级索引</h2><p>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，<strong>通过二级索引，可以定位主键的位置</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引</p><h2 id="6-8-自适应哈希索引"><a href="#6-8-自适应哈希索引" class="headerlink" title="6.8. 自适应哈希索引"></a>6.8. 自适应哈希索引</h2><p>InnoDB 索引有一个特性叫做自适应哈希索引，整个过程是全自动的，不需要开发者配置。</p><p>当 InnoDB 监控到某些索引值被频繁的访问时，那么它就会在 B+Tree 索引之上，构建一个 Hash 索引，进而通过 Hash 查找来快速访问数据。</p><p>默认情况下，自适应哈希索引是开启的状态</p><h2 id="6-9-聚簇索引-amp-非聚簇索引"><a href="#6-9-聚簇索引-amp-非聚簇索引" class="headerlink" title="6.9. 聚簇索引&amp;非聚簇索引"></a>6.9. 聚簇索引&amp;非聚簇索引</h2><h3 id="6-9-1-聚簇索引的优缺点"><a href="#6-9-1-聚簇索引的优缺点" class="headerlink" title="6.9.1. 聚簇索引的优缺点"></a>6.9.1. 聚簇索引的优缺点</h3><p><strong>优点</strong> ：</p><ul><li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。<strong>相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作</strong>。</li></ul><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li></ul><h3 id="6-9-2-非聚簇索引的优缺点"><a href="#6-9-2-非聚簇索引的优缺点" class="headerlink" title="6.9.2. 非聚簇索引的优缺点"></a>6.9.2. 非聚簇索引的优缺点</h3><p><strong>优点</strong> ：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong> ：</p><ul><li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li><strong>可能会二次查询（回表）</strong>：非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</li></ul><h2 id="6-10-覆盖索引-amp-联合索引"><a href="#6-10-覆盖索引-amp-联合索引" class="headerlink" title="6.10. 覆盖索引&amp;联合索引"></a>6.10. 覆盖索引&amp;联合索引</h2><h3 id="6-10-1-覆盖索引"><a href="#6-10-1-覆盖索引" class="headerlink" title="6.10.1. 覆盖索引"></a>6.10.1. 覆盖索引</h3><p>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询</p><p>如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表</p><h3 id="6-10-2-联合索引"><a href="#6-10-2-联合索引" class="headerlink" title="6.10.2. 联合索引"></a>6.10.2. 联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>，它可以加速基于多个字段的联合查询操作</p><p>例如，在一个订单表中，如果需要根据“订单日期”和“订单状态”两个字段进行查询，那么可以在这两个字段上创建一个复合索引</p><p>需要注意的是，复合索引的字段顺序非常重要。例如，如果在上面的订单表中，复合索引的字段顺序是“订单状态”，“订单日期”，那么当查询操作执行时，数据库引擎就无法使用这个复合索引来加速查询，因为索引的第一个字段不是查询条件中的字段。因此，<strong>在创建复合索引时，需要根据实际的查询需求和字段组合来选择合适的字段顺序</strong></p><p><strong>最左前缀匹配原则</strong></p><p>最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>）才会停止匹配。对于 <strong><code>&gt;=</code></strong>、<strong><code>&lt;=</code></strong>、<strong><code>BETWEEN</code></strong>、<strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p><h2 id="6-11-索引下推"><a href="#6-11-索引下推" class="headerlink" title="6.11. 索引下推"></a>6.11. 索引下推</h2><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数</p><h2 id="6-12-正确使用索引的一些建议"><a href="#6-12-正确使用索引的一些建议" class="headerlink" title="6.12. 正确使用索引的一些建议"></a>6.12. 正确使用索引的一些建议</h2><h3 id="6-12-1-选择合适的字段创建索引"><a href="#6-12-1-选择合适的字段创建索引" class="headerlink" title="6.12.1. 选择合适的字段创建索引"></a>6.12.1. 选择合适的字段创建索引</h3><ul><li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0、1、true、false 这样语义较为清晰的短值或短字符作为替代</li><li><strong>被频繁查询的字段</strong> ：创建索引的字段应该是查询操作非常频繁的字段</li><li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引</li><li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间</li><li><strong>被经常频繁用于连接的字段</strong> ：该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率</li><li><strong>被频繁更新的字段</strong>不建议使用索引</li></ul><h3 id="6-12-2-限制每张表上的索引数量"><a href="#6-12-2-限制每张表上的索引数量" class="headerlink" title="6.12.2. 限制每张表上的索引数量"></a>6.12.2. 限制每张表上的索引数量</h3><p>索引并不是越多越好，建议单张表索引不超过 5 个</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能</p><h3 id="6-12-3-尽可能的建立联合索引而不是单列索引"><a href="#6-12-3-尽可能的建立联合索引而不是单列索引" class="headerlink" title="6.12.3. 尽可能的建立联合索引而不是单列索引"></a>6.12.3. 尽可能的建立联合索引而不是单列索引</h3><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升</p><h3 id="6-12-4-注意避免冗余索引"><a href="#6-12-4-注意避免冗余索引" class="headerlink" title="6.12.4. 注意避免冗余索引"></a>6.12.4. 注意避免冗余索引</h3><p>如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的。在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引</p><h3 id="6-12-5-删除长期未使用的索引"><a href="#6-12-5-删除长期未使用的索引" class="headerlink" title="6.12.5. 删除长期未使用的索引"></a>6.12.5. 删除长期未使用的索引</h3><p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗</p><p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用</p><h3 id="6-12-6-分析语句的执行计划"><a href="#6-12-6-分析语句的执行计划" class="headerlink" title="6.12.6. 分析语句的执行计划"></a>6.12.6. 分析语句的执行计划</h3><p>使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息</p><h2 id="6-13-索引失效"><a href="#6-13-索引失效" class="headerlink" title="6.13. 索引失效"></a>6.13. 索引失效</h2><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li>使用 <code>SELECT *</code> 进行查询</li><li>创建了复合索引，但查询条件未遵守最左匹配原则</li><li>在索引列上进行计算、函数、类型转换等操作</li><li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like &#39;%abc&#39;</code></li><li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到</li><li>数据库表中的数据量过大，导致索引失效。当一张表中的数据量很大时，查询操作可能需要扫描大量的数据，这时索引就可能无法发挥作用。解决方法可以是增加索引、优化查询语句，或者对数据进行分区处理</li><li>使用了大量的JOIN操作，导致索引失效。当进行多表JOIN操作时，如果每个表都有自己的索引，那么数据库可能会选择错误的执行计划，导致索引失效。解决方法可以是增加联合索引、优化查询语句，或者对数据进行分区处理</li><li>发生隐式转换<h1 id="7-MySQL-日志（重点）"><a href="#7-MySQL-日志（重点）" class="headerlink" title="7. MySQL 日志（重点）"></a>7. MySQL 日志（重点）</h1></li></ul><p>MySQL日志主要包含：错误日志、查询日志、慢查询日志、事务日志、二进制日志。其中比较重要的有二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p><p>MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong></p><p>MySQL日志的存在是为了事务执行前、执行时、执行后服务</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131105084.png" alt="MySQL日志"></p><h2 id="7-1-redo-log"><a href="#7-1-redo-log" class="headerlink" title="7.1. redo log"></a>7.1. redo log</h2><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。是物理日志</p><p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性</p><p>每条 redo 记录由 <code>表空间号+数据页号+偏移量+修改数据长度+具体修改的数据</code> 组成</p><p><code>Buffer Pool</code> ：InnoDB查询一条记录，会从硬盘中把一页的数据加载出来，加载出来的数据叫数据页放在 Buffer Pool 中。后续的查询都是先从中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p><code>redo log buffer</code>：更新数据时，将在某个数据页上做了什么修改，记录到重做日志缓存里（redo log buffer），接着刷盘到 <code>redo log</code> 文件里</p><p>刷盘：清空 redo log buffer，将其中的内容写到 <code>redo log</code> 文件里</p><h3 id="7-1-1-刷盘时机"><a href="#7-1-1-刷盘时机" class="headerlink" title="7.1.1. 刷盘时机"></a>7.1.1. 刷盘时机</h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p><p><strong>页修改之后为什么不直接刷盘呢？</strong></p><p>在MySQL数据库中，为了提高性能，数据的修改通常会先被写入到内存中，而不是直接刷盘。这种方式被称为 <code>脏页</code>，表示该页的内容已经被修改但还没有被写入磁盘。直到满足以下条件之一才会被刷盘：</p><ul><li><p>该页被替换出内存：当内存空间不足时，系统会将一些脏页替换出内存，将其写入磁盘。</p></li><li><p>调度程序触发：MySQL的调度程序会定期检查内存中的脏页数量，如果达到一定阈值，就会触发将这些脏页写入磁盘。</p></li><li><p>事务提交：在事务提交之前，会将该事务产生的所有脏页写入磁盘</p></li></ul><p>将数据写入磁盘是一种昂贵的操作，频繁地刷盘会导致数据库性能下降。因此，使用脏页机制可以将磁盘写入操作的次数减少，从而提高数据库的性能。</p><h3 id="7-1-2-日志文件组"><a href="#7-1-2-日志文件组" class="headerlink" title="7.1.2. 日志文件组"></a>7.1.2. 日志文件组</h3><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131105141.png" alt="日志文件组"></p><p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ul><li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li><li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li></ul><p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p><p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录</p><h3 id="7-1-3-总结"><a href="#7-1-3-总结" class="headerlink" title="7.1.3. 总结"></a>7.1.3. 总结</h3><p><strong>redo log 如何保证事务的持久性？</strong></p><p>具体来说，当一个事务需要更新数据时，MySQL会将更新操作记录到redo log中，同时将数据缓存在内存中。在数据被写入磁盘之前，MySQL会先将redo log写入磁盘，确保数据更新操作已经被持久化</p><h2 id="7-2-binlog"><a href="#7-2-binlog" class="headerlink" title="7.2. binlog"></a>7.2. binlog</h2><p><code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于<code>给 ID=2 这一行的 c 字段加 1</code>，属于MySQL的Server层</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志</p><p><code>binlog</code> 会记录所有涉及更新数据的逻辑操作，并且是顺序写</p><p>MySQL数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><h3 id="7-2-1-记录格式"><a href="#7-2-1-记录格式" class="headerlink" title="7.2.1. 记录格式"></a>7.2.1. 记录格式</h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定</p><p><strong>statement</strong></p><p>记录的内容是<code>SQL</code>语句原文</p><p><strong>row</strong></p><p>记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据</p><p>通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度</p><p><strong>mixed</strong></p><p>记录的内容是前两者的混合</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p><p><strong>引起数据不一致的情况</strong>：</p><p>如：执行 <code>update T set update_time=now() where id=1</code> ，<code>update_time=now()</code> 这里会获取当前系统时间，直接执行会导致与原库的数据不一致</p><h3 id="7-2-2-写入机制"><a href="#7-2-2-写入机制" class="headerlink" title="7.2.2. 写入机制"></a>7.2.2. 写入机制</h3><p>事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p><p>可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p><h2 id="7-3-两阶段提交"><a href="#7-3-两阶段提交" class="headerlink" title="7.3. 两阶段提交"></a>7.3. 两阶段提交</h2><p><strong>binlog和redo log对比</strong></p><p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p><p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样</p><p><strong><code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</strong></p><p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p><p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后从库用<code>binlog</code>日志恢复数据时，就会少这一次更新，而主库使用 <code>redo log</code>日志恢复，最终数据不一致</p><p>为了解决两份日志之间的<strong>逻辑一致</strong>问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131105100.png" alt="两阶段提交"></p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p><p><strong>场景一</strong>：使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131105446.png" alt="两阶段提交-回滚"></p><p><strong>场景二</strong>：<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p><p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p><h2 id="7-4-undo-log"><a href="#7-4-undo-log" class="headerlink" title="7.4. undo log"></a>7.4. undo log</h2><p>保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong></p><p>MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的</p><h3 id="7-4-1-总结"><a href="#7-4-1-总结" class="headerlink" title="7.4.1. 总结"></a>7.4.1. 总结</h3><p><strong>undo log 如何保证事务的原子性？</strong></p><p>当一个事务执行更新操作时，MySQL会将原始数据记录到undo log中，并将新数据写入磁盘。并且，回滚日志会先于数据持久化到磁盘上。如果事务执行过程中发生错误，MySQL可以通过undo log将数据回滚到事务开始之前的状态，从而保证事务的原子性</p><h2 id="7-5-小结"><a href="#7-5-小结" class="headerlink" title="7.5. 小结"></a>7.5. 小结</h2><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong></p><p>MySQL 使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong></p><p>MySQL 依靠<code>binlog</code>来同步数据，保证<strong>数据一致性</strong></p><h2 id="7-6-慢查询日志"><a href="#7-6-慢查询日志" class="headerlink" title="7.6. 慢查询日志"></a>7.6. 慢查询日志</h2><p>MySQL慢查询日志是MySQL数据库的一种功能，用于记录执行时间超过预设阈值的SQL语句，以便进行性能分析和优化</p><p><strong>慢查询日志有什么用</strong></p><p>优化查询语句：通过分析慢查询日志，可以找到执行时间较长的SQL语句，然后进行优化，如增加索引、调整查询语句等，从而提高查询性能。</p><p>监控数据库负载：MySQL慢查询日志记录了执行时间超过阈值的SQL语句，可以用于监控数据库的负载情况，及时发现数据库负载过高的情况，采取相应的措施避免系统崩溃。</p><p>调整系统配置：MySQL慢查询日志的分析还可以帮助DBA或开发人员调整系统配置，如调整缓存大小、调整连接池大小等，从而进一步提高数据库的性能</p><h2 id="7-7-利用日志解决数据一致性问题"><a href="#7-7-利用日志解决数据一致性问题" class="headerlink" title="7.7. 利用日志解决数据一致性问题"></a>7.7. 利用日志解决数据一致性问题</h2><p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题</p><h1 id="8-MySQL-查询缓存"><a href="#8-MySQL-查询缓存" class="headerlink" title="8. MySQL 查询缓存"></a>8. MySQL 查询缓存</h1><p>从 MySQL 5.7.20 开始，就已经默认弃用查询缓存了。在 MySQL 8.0及之后，更是直接删除了查询缓存的功能</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- （query_cache_type 为 ON 表示已经开启）</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%query_cache%&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="9-MySQL-底层知识"><a href="#9-MySQL-底层知识" class="headerlink" title="9. MySQL 底层知识"></a>9. MySQL 底层知识</h1><h2 id="9-1-InnoDB-读-amp-写"><a href="#9-1-InnoDB-读-amp-写" class="headerlink" title="9.1. InnoDB 读&amp;写"></a>9.1. InnoDB 读&amp;写</h2><p><strong>计算机</strong>在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而<strong>文件系统</strong>（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB</p><p>但是 InnoDB 在进行磁盘操作的时候，并不是以扇区或者块为依据的，是以页为单位的，有时候也称作逻辑页，每个逻辑页的大小默认是 16KB，即四个块。这就意味着，InnoDB 在实际操作磁盘的时候，每次从磁盘上读取数据，至少读取 16KB，每次向磁盘上写数据，也至少写 16KB，并不是你需要 1KB 就读取 1KB，即使你只需要 1KB 的数据，InnoDB 也会从磁盘中将 16KB 的数据读取到内存中。</p><p><strong>参考文章</strong></p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">文章1</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI1NDY0MTkzNQ==&amp;mid=2247503786&amp;idx=1&amp;sn=baccbb718b13b6ebaa3462a82c0d2a04&amp;chksm=e9c09dcadeb714dc82268aa266aea9072c2bab6be2a2966f6ae430d0c59ec09f0a1ad5fcb47d&amp;mpshare=1&amp;scene=23&amp;srcid=0412J74mODavwFMb5bknxV4T">文章2</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-13-SpringMVC/"/>
      <url>/2024/10/28/2023-03-13-SpringMVC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-什么是Spring-MVC"><a href="#1-什么是Spring-MVC" class="headerlink" title="1. 什么是Spring MVC"></a>1. 什么是Spring MVC</h1><p>MVC即模型（Model）、视图（View）、 控制器（Controller），是一种软件设计规范，将业务逻辑、数据、视图分离开的代码组织方式，降低了视图与业务逻辑间的双向偶合</p><p>Spring MVC 下一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层（控制层，返回数据给前台页面），各层间的调用关系又如下：</p><p><strong>遵循Controller–Service接口–ServiceImpt实现类–Mapper接口模式</strong></p><p>就是用Spring MVC编写Controller处理请求，再将结果转换成json响应给客户端</p><h1 id="2-Spring-MVC的核心组件"><a href="#2-Spring-MVC的核心组件" class="headerlink" title="2. Spring MVC的核心组件"></a>2. Spring MVC的核心组件</h1><p>DispatcherServlet ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应</p><p>HandlerMapping：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 Handler ，并会将请求涉及到的拦截器和 Handler 一起封装</p><p>HandlerAdapter：<strong>处理器适配器</strong>，根据 HandlerMapping找到的 Handler ，适配执行对应的 Handler</p><p>Handler（Controller）：<strong>请求处理器</strong>，处理实际请求的处理器，返回逻辑视图（即页面名称）</p><p>ViewResolver：<strong>视图解析器</strong>，根据 Handler 返回的逻辑视图，解析并渲染出真实的视图（即页面文件），并传递给 DispatcherServlet 响应客户端</p><h1 id="3-Spring-MVC工作原理（重点）"><a href="#3-Spring-MVC工作原理（重点）" class="headerlink" title="3. Spring MVC工作原理（重点）"></a>3. Spring MVC工作原理（重点）</h1><p>Spring的web框架围绕DispatcherServlet设计</p><p><strong>工作原理</strong></p><p>客户端（浏览器）发送请求， DispatcherServlet 拦截请求</p><p>DispatcherServlet 根据请求信息调用 HandlerMapping</p><p>HandlerMapping 根据 uri 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装</p><p>DispatcherServlet 调用 HandlerAdapter适配执行 Handler</p><p>Handler 完成对用户请求的处理后，会返回一个 ModelAndView对象给DispatcherServlet，ModelAndView 包括数据模型和逻辑视图，通俗的讲就是页面中的数据和页面名称</p><p>ViewResolver 会根据逻辑 View 查找实际的 View（即根据页面名称去查找真实的页面文件）</p><p>DispaterServlet 把返回的 Model 传给 View（视图渲染）</p><p>把 View 返回给请求者（浏览器）</p><p><img src="F:\笔记\博客\文章图片\springmvc工作原理.png" alt="springmvc工作原理"></p><h1 id="4-搭建SpringMVC"><a href="#4-搭建SpringMVC" class="headerlink" title="4. 搭建SpringMVC"></a>4. 搭建SpringMVC</h1><p>创建一个maven项目，添加web的支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.maven.archetypes:maven-archetype-webapp</span><br></pre></td></tr></table></figure><p>pom.xml中添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 src/main/webapp/WEB-INF/web.xml，注册DispatcherServlet</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注册DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联一个springmvc的配置文件:【servlet-name】-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--启动级别-1--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--    springmvc中 /的含义：只匹配所有请求，不匹配jsp页面</span></span><br><span class="line"><span class="comment">                     /*的含义：匹配所有请求，包括jsp页面</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写SpringMVC的配置文件 src/main/resources/springmvc-servlet.xml</p><p><strong>使用springMVC必须配置的三大件：处理器映射器、处理器适配器、视图解析器</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--    springmvc核心三要素--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--    视图解析器 模板引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        前缀    --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        后缀--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建Controller</strong></p><p>编写业务Controller ，要么实现Controller接口，要么使用<code>@Controller</code>注解。需要返回一个ModelAndView</p><p>控制器负责解析用户的请求并将其转换为一个模型</p><p>注意：以接口的方式实现控制器的缺点是一个控制器中只有一个方法，如果要多个方法则需要定义多个Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> <span class="keyword">implements</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//ModelAndView 模型和视图</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//封装对象，放在ModelAndView中</span></span><br><span class="line">        mv.addObject(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;HelloSpringMVC!&quot;</span>);</span><br><span class="line">        <span class="comment">//封装要跳转的视图，放在ModelAndView中</span></span><br><span class="line">        mv.setViewName(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 跳转到/WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册bean，在 src/main/resources/springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- /hello表示访问的是/hello.jsp --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;/hello&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.controller.HelloController&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建视图层</strong></p><p>编写jsp页面，src/main/webapp/WEB-INF/jsp/hello.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;hello&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;hello springmvc&lt;/h1&gt;&gt;</span><br><span class="line">$&#123;msg&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>配置Tomcat运行</strong></p><p>若遇到 IDEA控制台乱码问题，则打开tomcat下的 conf/logging.properties 修改 java.util.logging.ConsoleHandler.encoding = GBK</p><p>除此以外，其他地方的所有编码都设为UTF-8</p><p><strong>可能遇到的问题：访问出现404，排查步骤：</strong></p><ol><li>查看控制台输出，看一下是不是缺少了什么jar包</li><li>如果jar包存在，显示无法输出，就在IDEA的项目发布中，添加lib依赖</li><li>重启Tomcat 即可解决</li></ol><h1 id="5-SpringMVC中使用注解"><a href="#5-SpringMVC中使用注解" class="headerlink" title="5. SpringMVC中使用注解"></a>5. SpringMVC中使用注解</h1><p>pom.xml 同上</p><p>src/main/webapp/WEB-INF/web.xml 同上</p><p>src/main/webapp/WEB-INF/jsp/hello.jsp 同上</p><p>配置 src/main/resources/springmvc-servlet.xml：</p><ol><li>让IOC的注解生效：设置自动扫描包的功能</li><li>静态资源过滤 ：HTML . JS . CSS . 图片 ， 视频 …..</li><li>MVC的注解驱动</li><li>配置视图解析器</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.hy.controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">&quot;internalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>创建Controller</strong></p><p>编写业务Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span> <span class="comment">// 让Spring IOC容器初始化时自动扫描到</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        <span class="comment">//向模型中添加属性msg与值，可以在JSP页面中取出并渲染</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;hello,SpringMVC&quot;</span>);</span><br><span class="line">        <span class="comment">// 跳转到 /WEB-INF/jsp/hello.jsp</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Controller 配合视图解析器 InternalResourceViewResolver使用，返回到指定页面</p><p><strong>创建视图层</strong></p><p>同上</p><p><strong>@RequestMapping</strong></p><p>@RequestMapping注解用于映射url到控制器类或一个特定的处理程序方法。可用在类或方法上。用在类上，表示类中的所有响应请求的方法都是以该地址作为父路径</p><h1 id="6-SpringMVC的转发和重定向"><a href="#6-SpringMVC的转发和重定向" class="headerlink" title="6. SpringMVC的转发和重定向"></a>6. SpringMVC的转发和重定向</h1><p><strong>转发</strong></p><ul><li>请求转发是服务器内部的跳转</li><li>地址栏比发生变化</li><li>只有一个请求响应</li></ul><p>转发通常用于以下情况：</p><ul><li>当某个请求需要经过多个处理组件或模块处理时，服务器可以将请求转发给下一个组件，直到处理完成。</li><li>当服务器需要对请求进行预处理或过滤时，可以将请求转发给专门的过滤器或拦截器进行处理。</li></ul><p><strong>重定向</strong></p><ul><li>请求重定向是浏览器自动发起对跳转目标的请求</li><li>地址栏会发生变化</li><li>两次请求响应</li></ul><p>重定向通常用于以下情况：</p><ul><li>当某个页面已经被移除或更改URL，服务器可以返回重定向响应，让客户端自动请求新的URL。</li><li>当网站需要将用户请求导向到不同的服务器或不同的部分时，可以使用重定向。</li></ul><h2 id="6-1-转发"><a href="#6-1-转发" class="headerlink" title="6.1. 转发"></a>6.1. 转发</h2><p>在Spring MVC中，转发是指将请求传递给另一个处理器或视图进行处理，然后将处理结果返回给客户端，使用<code>forward:</code>前缀来指定转发的目标地址</p><p><strong>有视图解析器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/target&quot;</span>; <span class="comment">// 转发到&quot;/target&quot;处理器或视图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无视图解析器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/forward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">forwardExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;forward:/target.jsp&quot;</span>; <span class="comment">// 转发到&quot;/target&quot;处理器或视图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-2-重定向"><a href="#6-2-重定向" class="headerlink" title="6.2. 重定向"></a>6.2. 重定向</h2><p>在Spring MVC中，重定向是指服务器返回一个特定的响应，告诉客户端将请求发送到另一个URL，使用<code>redirect:</code>前缀来指定重定向的目标地址</p><p><strong>有视图解析器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/target&quot;</span>; <span class="comment">// 重定向到&quot;/target&quot; URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无视图解析器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/redirect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">redirectExample</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;redirect:/target.jsp&quot;</span>; <span class="comment">// 重定向到&quot;/target&quot; URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>视图解析器就是实现controller中return的值和视图解析器前缀、后缀的拼接</strong></p><p>以用户登录功能为例：首先请求登录页面，提交用户名和密码的表单，验证通过后，转发到指定页面，验证失败后，重定向到指定页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="comment">// 访问登录页</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toLogin&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 跳转到登录界面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;forward:/login.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理登录页接收到的参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;login&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogin</span><span class="params">(String username,String password)</span>&#123;</span><br><span class="line">        <span class="comment">/* 验证参数，验证登录</span></span><br><span class="line"><span class="comment">            验证成功，则记录session信息，同时重定向到首页</span></span><br><span class="line"><span class="comment">            验证失败，则执行 return toLogin();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> toLogin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用户退出登录</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/logout&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogout</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        <span class="comment">// 销毁session对象</span></span><br><span class="line">        request.getSession().invalidate();</span><br><span class="line">        <span class="comment">// 重定向到登录页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:toLogin&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-数据处理（重点）"><a href="#7-数据处理（重点）" class="headerlink" title="7. 数据处理（重点）"></a>7. 数据处理（重点）</h1><h2 id="7-1-接收的数据"><a href="#7-1-接收的数据" class="headerlink" title="7.1. 接收的数据"></a>7.1. 接收的数据</h2><p><strong>提交的参数名称和后端方法中定义的参数名一致</strong></p><p>请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提交数据 : http://localhost:8080/hello?name=hy</span><br></pre></td></tr></table></figure><p>后端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交的参数名称和后端方法中定义的参数名不一致</strong></p><p>请求</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提交数据 : http://localhost:8080/hello?username=hy</span><br></pre></td></tr></table></figure><p>后端使用 <code>@RequestParam</code> 处理（建议不管一致不一致都处理一下）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name)</span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交的是一个对象</strong></p><p>假设前端传递的是一个对象User，则匹配User对象中的字段名。如果字段名一致则可以接收。如果字段名不一致则接收不到，结果为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/test&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="comment">// 接收User对象</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test1</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        <span class="comment">//转发</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/WEB-INF/jsp/test.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交的参数是URL模板变量的形式</strong></p><p><code>@PathVariable</code>注解，让Controller方法参数的值对应绑定到URL模板变量上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestFulController</span> &#123;</span><br><span class="line">    <span class="comment">//映射访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commit/&#123;p1&#125;/&#123;p2&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(<span class="meta">@PathVariable</span> <span class="type">int</span> p1, <span class="meta">@PathVariable</span> <span class="type">int</span> p2, Model model)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> p1+p2;</span><br><span class="line">        <span class="comment">//Spring MVC会自动实例化一个Model对象用于向视图中传值</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;结果：&quot;</span>+result);</span><br><span class="line">        <span class="comment">//返回视图位置</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>提交的参数是Json格式的</strong></p><p>在控制器的请求方法参数上添加<code>@RequestBody</code>注解，该注解将请求的JSON数据转换为对应的Java对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyController</span> &#123;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/data&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processData</span><span class="params">(<span class="meta">@RequestBody</span> MyData data)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理接收到的JSON数据</span></span><br><span class="line">        System.out.println(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-返回的数据"><a href="#7-2-返回的数据" class="headerlink" title="7.2. 返回的数据"></a>7.2. 返回的数据</h2><p><strong>通过ModelMap</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, ModelMap model)</span>&#123;</span><br><span class="line">    <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;name&quot;</span>,name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过Model（推荐）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(<span class="meta">@RequestParam(&quot;username&quot;)</span> String name, Model model)</span>&#123;</span><br><span class="line">    <span class="comment">//封装要显示到视图中的数据</span></span><br><span class="line">    model.addAttribute(<span class="string">&quot;msg&quot;</span>,name);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>直接返回JSON格式数据，而不是向视图中封装数据</strong></p><p>JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，<strong>本质是一个字符串</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;键名&quot;</span><span class="punctuation">:</span><span class="string">&quot;值&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Jackson（推荐）</strong></p><p>导入依赖 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>转为 json格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> mapper.writeValueAsString(...);</span><br></pre></td></tr></table></figure><p>解决 json乱码问题，在src/main/resources/springmvc-servlet.xml 上添加一段消息StringHttpMessageConverter转换配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:message-converters</span> <span class="attr">register-defaults</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;objectMapper&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;failOnEmptyBeans&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:message-converters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以封装一个JsonUtils类专门实现JSON格式的转换</p><h1 id="8-乱码问题解决"><a href="#8-乱码问题解决" class="headerlink" title="8. 乱码问题解决"></a>8. 乱码问题解决</h1><p>在 src/main/webapp/WEB-INF/web.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="9-SpringMVC拦截器"><a href="#9-SpringMVC拦截器" class="headerlink" title="9. SpringMVC拦截器"></a>9. SpringMVC拦截器</h1><p>拦截器是SpringMVC框架的，只有使用了SpringMVC框架的工程才能使用，拦截器是AOP思想的具体应用</p><p>拦截器只会拦截访问的控制器方法，不会拦截静态资源，如果访问的是jsp/html/css/image/js 是不会进行拦截的</p><h2 id="9-1-自定义拦截器"><a href="#9-1-自定义拦截器" class="headerlink" title="9.1. 自定义拦截器"></a>9.1. 自定义拦截器</h2><p><img src="F:\笔记\博客\文章图片\QQ截图20230107172231.png" alt="QQ截图20230107172231"></p><p>实现 HandlerInterceptor 接口即可，该接口包含三个方法，分别在请求处理的不同阶段调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// preHandle() 方法在请求处理之前调用，可以用于进行一些预处理操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理前&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// postHandle() 方法在请求处理之后调用，在视图渲染之前调用，可以用于修改 ModelAndView 对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;处理后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// afterCompletion() 方法在请求处理完成之后调用，可以用于进行一些资源清理操作，也可以用来统计请求耗时</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;清理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在xml 配置文件，配置启动拦截器 src/main/resources/springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--拦截器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- /**表示过滤这个请求下的所有请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--实现拦截的类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.interceptor.HelloInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在Javaconfig 配置类中，配置启动拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addPathPatterns方法定义拦截的地址</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">excludePathPatterns定义排除某些地址不被拦截</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">添加的一个拦截器没有addPathPattern任何一个ur则默认拦截所有请求</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果没有excludePathPatterns任何一个请求，则默认不放过任何一个请求</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span> <span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor( <span class="keyword">new</span> <span class="title class_">LoginInterceptor</span>()).addPathPatterns (<span class="string">&quot;/user/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-2-拦截器的执行顺序"><a href="#9-2-拦截器的执行顺序" class="headerlink" title="9.2. 拦截器的执行顺序"></a>9.2. 拦截器的执行顺序</h2><ul><li>请求到达 DispatcherServlet</li><li>DispatcherServlet 发送至 Interceptor ，执行 preHandle</li><li>请求达到 Controller</li><li>请求结束后，postHandle 执行</li></ul><h2 id="9-3-拦截器应用-登录验证"><a href="#9-3-拦截器应用-登录验证" class="headerlink" title="9.3. 拦截器应用-登录验证"></a>9.3. 拦截器应用-登录验证</h2><p>三个页面：</p><ol><li>main.jsp（首页，提供跳转到登录页的功能，默认不拦截）</li><li>login.jsp（登录信息提交页，实现登录信息输入功能，默认不拦截）</li><li>hello.jsp（登录后才可以自由访问的页面，默认拦截，必须登录后访问）</li></ol><p>main.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/doLogin&quot;</span>&gt;Please Login&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/hello&quot;</span>&gt;MyPage&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/logout&quot;</span>&gt;LogOut&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>login.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;h1&gt;登录页面&lt;/h1&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/login&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    name:&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    pwd:&lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt; &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>hello.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;welcome $&#123;name&#125;! you are logining&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginController</span> &#123;</span><br><span class="line">    <span class="comment">// 首页</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/main&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;main&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 登录页</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/doLogin&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogin</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理登录信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/login&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">(Model model,HttpSession session, <span class="meta">@RequestParam(&quot;username&quot;)</span> String username, <span class="meta">@RequestParam(&quot;password&quot;)</span> String password)</span>&#123;</span><br><span class="line">        <span class="comment">// 接收登录信息，把用户信息存在session中</span></span><br><span class="line">        session.setAttribute(<span class="string">&quot;userLoinInfo&quot;</span>,username);</span><br><span class="line">        <span class="comment">// 传递信息到视图</span></span><br><span class="line">        model.addAttribute(<span class="string">&quot;name&quot;</span>,username);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 欢迎页面</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doHello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注销功能，将用户信息从session中删除</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/logout&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doLogout</span><span class="params">(HttpSession session)</span>&#123;</span><br><span class="line">        session.removeAttribute(<span class="string">&quot;userLoinInfo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;login&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/* 判断是否登录</span></span><br><span class="line"><span class="comment">       判断依据：session中是否有用户信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">        <span class="comment">// 访问 /hello时，若已经登录，则放行，否则拦截</span></span><br><span class="line">        <span class="keyword">if</span> (session.getAttribute(<span class="string">&quot;userLoinInfo&quot;</span>) != <span class="literal">null</span> &amp;&amp; request.getRequestURI().contains(<span class="string">&quot;/hello&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问 /doLogin 则放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;/doLogin&quot;</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问 /main 则放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;/main&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问 /login 则放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;/login&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 访问 /logout 则放行</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestURI().contains(<span class="string">&quot;/logout&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已放行&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已拦截&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置拦截器 src/main/resources/springmvc-servlet.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--拦截器配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--            /**表示过滤这个请求下的所有请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--实现拦截的类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.hy.interceptor.LoginInterceptor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="10-文件上传和下载"><a href="#10-文件上传和下载" class="headerlink" title="10. 文件上传和下载"></a>10. 文件上传和下载</h1><h2 id="10-1-文件上传"><a href="#10-1-文件上传" class="headerlink" title="10.1. 文件上传"></a>10.1. 文件上传</h2><p>Spring MVC为文件上传提供了直接的支持，这种支持是用 MultipartResolver实现的</p><p>导入依赖 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写上传页面 file.jsp</p><p>前端表单要求：为了能上传文件，必须将表单的method设置为POST，并将enctype设置为multipart/form-data。只有在这样的情况下，浏览器才会把用户选择的文件以二进制数据发送给服务器</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;file&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/upload&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;upload&quot;</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>文件上传配置</p><p>注意：这个bean的id必须为 multipartResolver，否则上传文件会报400的错误</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--文件上传配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 请求的编码格式，必须和jSP的pageEncoding属性一致，以便正确读取表单的内容，默认为ISO-8859-1 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;utf-8&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上传文件大小上限，单位为字节（10485760=10M） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10485760&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxInMemorySize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;40960&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CommonsMultipartFile 的常用方法：</p><ol><li>String getOriginalFilename()：获取上传文件的原名</li><li>InputStream getInputStream()：获取文件流</li><li>void transferTo(File dest)：将上传文件保存到一个目录文件中</li></ol><p>采用file.transferTo 来保存上传的文件</p><p><strong>MultipartFile 和 CommonsMultipartFile的区别</strong></p><p>MultipartFile 和 CommonsMultipartFile 都是用来接收上传的文件流的MultipartFile是一个接口，CommonsMultipartFile是MultipartFile接口的实现类。使用MultipartFile 作为形参接收上传文件时，直接用即可。CommonsMultipartFile 作为形参接收上传文件时，必需添加@RequestParam注解，否则会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UploadController</span> &#123;</span><br><span class="line">    <span class="comment">// 文件上传页面</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/file&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">file</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;file&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理上传的文件</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/upload&quot;,method = RequestMethod.POST)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fileUpload</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> CommonsMultipartFile file, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 设置上传路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getSession().getServletContext().getRealPath(<span class="string">&quot;/upload&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建上传路径的文件夹</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">realPath</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (!realPath.exists()) &#123;</span><br><span class="line">            realPath.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印上传文件地址</span></span><br><span class="line">        System.out.println(<span class="string">&quot;fileSavePath:\t&quot;</span> + realPath);</span><br><span class="line">        <span class="comment">// 通过CommonsMultipartFile的方法直接写文件</span></span><br><span class="line">        file.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(realPath + <span class="string">&quot;/&quot;</span> +file.getOriginalFilename()));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-文件下载"><a href="#10-2-文件下载" class="headerlink" title="10.2. 文件下载"></a>10.2. 文件下载</h2><p>步骤：</p><ol><li>设置 response 响应头</li><li>读取文件 — InputStream</li><li>写出文件 — OutputStream</li><li>执行操作</li><li>关闭流 （先开后关）</li></ol><p>down.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;down&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/down&quot;</span>&gt;downPage&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>控制器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DownController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/getDown&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDown</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;down&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/down&quot;,method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">down</span><span class="params">(HttpServletResponse response, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 要下载的图片的地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> request.getServletContext().getRealPath(<span class="string">&quot;/static&quot;</span>);</span><br><span class="line">        <span class="comment">// 图片名字</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> <span class="string">&quot;15.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">//设置response响应头</span></span><br><span class="line">        response.reset(); <span class="comment">// 设置页面不缓存</span></span><br><span class="line">        response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        response.setContentType(<span class="string">&quot;multype/form-data&quot;</span>);</span><br><span class="line">        <span class="comment">// 设置响应头</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment;filename=&quot;</span> + filename);</span><br><span class="line">        response.setContentType(<span class="string">&quot;image/jpeg&quot;</span>);</span><br><span class="line">        <span class="comment">// 以流的形式下载文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path,filename);</span><br><span class="line">        <span class="comment">// 读取文件：输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">        <span class="comment">// 写出文件：输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行写出操作</span></span><br><span class="line">        <span class="keyword">while</span> ((index=input.read(body))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            out.write(body,<span class="number">0</span>,index);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.close();</span><br><span class="line">        input.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="11-视图解析器"><a href="#11-视图解析器" class="headerlink" title="11. 视图解析器"></a>11. 视图解析器</h1><h2 id="11-1-Spring-MVC提供的视图解析器"><a href="#11-1-Spring-MVC提供的视图解析器" class="headerlink" title="11.1. Spring MVC提供的视图解析器"></a>11.1. Spring MVC提供的视图解析器</h2><p>InternalResourceViewResolver：用于解析JSP或HTML等资源文件</p><p>FreeMarkerViewResolver：用于解析 FreeMarker 模板</p><p>TilesViewResolver：用于解析 Tiles 布局</p><p>ContentNegotiatingViewResolver：复合视图解析器，可以根据请求的 Accept 头信息来选择对应的视图解析器进行解析</p><h2 id="11-2-自定义视图解析器"><a href="#11-2-自定义视图解析器" class="headerlink" title="11.2. 自定义视图解析器"></a>11.2. 自定义视图解析器</h2><p>创建自定义的视图解析器类 ViewConfig ，并实现 ViewResolver 接口</p><p>在该类中实现 resolveViewName() 方法，用于根据视图名称解析视图</p><p>以下示例中，创建了一个名为 ViewConfig 的类，实现了 <code>ViewResolver</code> 接口，并重写了其中的 <code>resolveViewName()</code> 方法。在该方法中，检查逻辑视图名称是否以<code>&quot;myview:&quot;</code>  前缀开头。如果是，则创建一个名为 <code>MyView</code> 的自定义视图对象，并设置其 URL 属性为逻辑视图名称去掉前缀之后的部分。否则，返回 <code>null</code> 表示无法解析视图名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewConfig</span> <span class="keyword">implements</span> <span class="title class_">ViewResolver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> View <span class="title function_">resolveViewName</span><span class="params">(String viewName, Locale locale)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewName.startsWith(<span class="string">&quot;myview:&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">viewPath</span> <span class="operator">=</span> viewName.substring(<span class="string">&quot;myview:&quot;</span>.length());</span><br><span class="line">            <span class="type">MyView</span> <span class="variable">view</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyView</span>();</span><br><span class="line">            view.setUrl(viewPath);</span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 返回 null 表示无法解析视图名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Javaconfig 配置类中，配置启动自定义视图解析器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyWebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureViewResolvers</span><span class="params">(ViewResolverRegistry registry)</span> &#123;</span><br><span class="line">        registry.viewResolver(<span class="keyword">new</span> <span class="title class_">ViewConfig</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-27-Redis%E5%BA%94%E7%94%A8/"/>
      <url>/2024/10/28/2023-03-27-Redis%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Redis介绍"><a href="#1-Redis介绍" class="headerlink" title="1. Redis介绍"></a>1. Redis介绍</h1><p>Redis是一种基于内存的键值存储系统，它支持多种数据结构，Redis具有以下特点：</p><ul><li>快速：Redis是一种基于内存的存储系统，因此具有非常快的读写速度</li><li>持久化：Redis支持数据持久化，可以将数据保存到磁盘上，以便在服务器重启后恢复数据</li><li>支持多种数据结构：Redis支持多种数据结构，例如字符串、哈希表、列表、集合、有序集合等，可以满足不同的数据存储需求</li><li>分布式：Redis支持分布式存储，可以将数据分布在多个节点上，以提高数据处理能力和可用性</li><li>事务：Redis支持事务，可以将多个操作封装在一个事务中进行，以保证数据的一致性</li></ul><h2 id="1-1-Redis的使用场景"><a href="#1-1-Redis的使用场景" class="headerlink" title="1.1. Redis的使用场景"></a>1.1. Redis的使用场景</h2><p>Redis适用于需要快速读写、高并发、多种数据结构的场景，例如缓存、计数器、消息队列等。在后端开发中，Redis通常用于以下场景：</p><ul><li>缓存：将热点数据存储在Redis中，以提高系统的读写性能。例如，将数据库查询结果、API响应结果、页面片段等存储在Redis中，以减少对数据库和API的访问。</li><li>分布式锁：基于 Redisson实现分布式锁，以保证多个进程或线程之间的数据一致性。例如，在分布式系统中，多个进程或线程需要对同一个资源进行操作时，可以使用Redis实现分布式锁，以保证只有一个进程或线程可以访问该资源。</li><li>计数器：使用Redis实现计数器，以统计某个事件发生的次数。例如，统计网站的PV（Page View）、UV（Unique Visitor）、注册用户数等。</li><li>消息队列：使用Redis实现消息队列，以实现异步处理任务。例如，将用户提交的任务放入Redis队列中，由后台进程或线程进行处理。</li><li>地理位置：使用Redis实现地理位置查询，以实现附近的人、附近的店铺等功能。例如，将用户的地理位置存储在Redis中，使用Redis提供的地理位置查询功能，查询附近的人、附近的店铺等。</li><li>实时排行榜：使用Redis实现实时排行榜，以统计某个事件的排名。例如，统计网站的热门文章、热门商品等。通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜</li><li>会话管理：使用Redis实现会话管理，以实现用户登录、注销等功能。例如，将用户的会话信息存储在Redis中，使用Redis提供的会话管理功能，实现用户登录、注销等功能。</li></ul><h2 id="1-2-Redis为什么快"><a href="#1-2-Redis为什么快" class="headerlink" title="1.2. Redis为什么快"></a>1.2. Redis为什么快</h2><p><strong>内存存储</strong>：Redis 将所有数据保存在内存中，而不是硬盘上。内存的读写速度远高于硬盘，因此 Redis 的数据访问速度极快。</p><p><strong>单线程模型</strong>：Redis 使用单线程事件循环来处理请求，这避免了多线程间的上下文切换和锁竞争，从而提高了性能。不过，Redis 也通过使用 I/O 多路复用技术来处理多个连接，这使得单线程也能高效处理大量并发请求。</p><p><strong>高效的数据结构</strong>：Redis 内部实现了多种高效的数据结构，包括字符串、列表、集合、有序集合和哈希表等。这些数据结构都经过精心设计和优化，以确保高效的存储和访问性能。</p><p><strong>优化的网络通信</strong>：Redis 使用了基于 TCP 的二进制协议，该协议精简且高效，减少了通信开销。此外，Redis 的请求/响应模型非常简单，进一步减少了协议解析所需的时间。</p><p><strong>持久化机制</strong>：虽然 Redis 主要将数据保存在内存中，但它也支持将数据持久化到硬盘上。Redis 提供了 RDB 快照和 AOF 日志两种持久化方式，用户可以根据需求选择合适的持久化策略，从而在保证性能的同时也能提高数据的可靠性。</p><p><strong>良好的缓存机制</strong>：Redis 提供了多种缓存淘汰策略（如 LRU、LFU 等），用户可以根据实际需求选择合适的策略，从而在高并发场景下依然能够保持稳定的性能。</p><p><strong>紧凑的编码</strong>：Redis 对常用的数据类型进行了紧凑的编码优化。例如，对于小整数，Redis 使用特殊的编码方式来减少内存占用和加快访问速度。</p><h2 id="1-3-为什么要用-Redis"><a href="#1-3-为什么要用-Redis" class="headerlink" title="1.3. 为什么要用 Redis"></a>1.3. 为什么要用 Redis</h2><p><strong>高性能</strong></p><p>如果用户访问的数据属于高频数据并且不会经常改变的话，那就可以将该用户访问的数据存在缓存中。保证用户下一次再访问这些数据的时候可以直接从缓存中获取。操作缓存就是直接操作内存，速度相当快。</p><p><strong>高并发</strong></p><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数</p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）</p><h1 id="2-Redis数据类型"><a href="#2-Redis数据类型" class="headerlink" title="2. Redis数据类型"></a>2. Redis数据类型</h1><p>Redis 主要支持以下几种数据类型：</p><p><strong>基础数据类型</strong></p><ul><li>string（字符串）: 基本的数据存储单元，可以存储字符串、整数或者浮点数。</li><li>hash（哈希）:一个键值对集合，可以存储多个字段。</li><li>list（列表）:一个简单的列表，可以存储一系列的字符串元素。</li><li>set（集合）:一个无序集合，可以存储不重复的字符串元素。</li><li>zset（sorted set：有序集合）: 类似于集合，但是每个元素都有一个分数（score）与之关联。</li></ul><p><strong>特殊数据类型</strong></p><ul><li>位图（Bitmaps）：基于字符串类型，可以对每个位进行操作。</li><li>超日志（HyperLogLogs）：用于基数统计，可以估算集合中的唯一元素数量。</li><li>地理空间（Geospatial）：用于存储地理位置信息。</li><li>发布/订阅（Pub/Sub）：一种消息通信模式，允许客户端订阅消息通道，并接收发布到该通道的消息。</li><li>流（Streams）：用于消息队列和日志存储，支持消息的持久化和时间排序。</li><li>模块（Modules）：Redis 支持动态加载模块，可以扩展 Redis 的功能。</li></ul><h1 id="3-基础数据类型"><a href="#3-基础数据类型" class="headerlink" title="3. 基础数据类型"></a>3. 基础数据类型</h1><p>简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）</p><p>Redis 基础数据类型的底层数据结构实现如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">String</th><th style="text-align:left">List</th><th style="text-align:left">Hash</th><th style="text-align:left">Set</th><th style="text-align:left">Zset</th></tr></thead><tbody><tr><td style="text-align:left">SDS</td><td style="text-align:left">LinkedList/ZipList/QuickList</td><td style="text-align:left">Hash Table、ZipList</td><td style="text-align:left">ZipList、Intset</td><td style="text-align:left">ZipList、SkipList</td></tr></tbody></table></div><p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList</p><ul><li>字符串：字符串是Redis中最基本的数据结构，可以存储任何类型的数据，例如数字、文本、二进制数据等。字符串的最大长度为512MB。</li><li>哈希表：哈希表是一种键值对集合，其中每个键都对应一个值。哈希表可以存储任何类型的数据，例如数字、文本、二进制数据等。哈希表的最大长度为232-1。</li><li>列表：列表是一种有序的字符串集合，其中每个元素都有一个索引。列表可以存储任何类型的数据，例如数字、文本、二进制数据等。列表的最大长度为232-1。</li><li>集合：集合是一种无序的字符串集合，其中每个元素都是唯一的。集合可以存储任何类型的数据，例如数字、文本、二进制数据等。集合的最大长度为232-1。</li><li>有序集合：有序集合是一种有序的字符串集合，其中每个元素都有一个分数。有序集合可以存储任何类型的数据，例如数字、文本、二进制数据等。有序集合的最大长度为232-1。</li></ul><h2 id="3-1-String（字符串）"><a href="#3-1-String（字符串）" class="headerlink" title="3.1. String（字符串）"></a>3.1. String（字符串）</h2><p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据</p><h3 id="3-1-1-应用场景"><a href="#3-1-1-应用场景" class="headerlink" title="3.1.1. 应用场景"></a>3.1.1. 应用场景</h3><p><strong>需要存储常规数据的场景</strong></p><ul><li>举例 ：缓存 session、token、图片地址、序列化后的对象（相比较于 Hash 存储更节省内存）</li><li>相关命令 ： <code>SET</code>、<code>GET</code></li></ul><p><strong>需要计数的场景</strong></p><ul><li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数</li><li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> </li></ul><p><strong>分布式锁</strong></p><p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）</p><h2 id="3-2-List（列表）"><a href="#3-2-List（列表）" class="headerlink" title="3.2. List（列表）"></a>3.2. List（列表）</h2><p>Redis 中的 List 就是双链表数据结构的实现</p><h3 id="3-2-1-应用场景"><a href="#3-2-1-应用场景" class="headerlink" title="3.2.1. 应用场景"></a>3.2.1. 应用场景</h3><p><strong>信息流展示</strong></p><ul><li>举例 ：最新文章、最新动态。</li><li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li></ul><p><strong>消息队列</strong></p><p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p><p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决</p><h2 id="3-3-Hash（哈希）"><a href="#3-3-Hash（哈希）" class="headerlink" title="3.3. Hash（哈希）"></a>3.3. Hash（哈希）</h2><p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，可以直接修改这个对象中的某些字段的值</p><h3 id="3-3-1-应用场景"><a href="#3-3-1-应用场景" class="headerlink" title="3.3.1. 应用场景"></a>3.3.1. 应用场景</h3><p><strong>对象数据存储场景</strong></p><ul><li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li><li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key（用户ID）</span><br><span class="line">field（商品ID）value（商品数量）</span><br><span class="line">field（商品ID）value（商品数量）</span><br><span class="line">field（商品ID）value（商品数量）</span><br></pre></td></tr></table></figure><h2 id="3-4-Set（集合）"><a href="#3-4-Set（集合）" class="headerlink" title="3.4. Set（集合）"></a>3.4. Set（集合）</h2><p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p><p>可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</p><h3 id="3-4-1-应用场景"><a href="#3-4-1-应用场景" class="headerlink" title="3.4.1. 应用场景"></a>3.4.1. 应用场景</h3><p><strong>需要存放的数据不能重复的场景</strong></p><ul><li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li><li>相关命令：<code>SCARD</code>（获取集合数量）</li></ul><p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p><ul><li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li><li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）</li></ul><p><strong>需要随机获取数据源中的元素的场景</strong></p><ul><li>举例 ：抽奖系统、随机。</li><li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）</li></ul><h2 id="3-5-Sorted-Set（有序集合）"><a href="#3-5-Sorted-Set（有序集合）" class="headerlink" title="3.5. Sorted Set（有序集合）"></a>3.5. Sorted Set（有序集合）</h2><p>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表</p><h3 id="3-5-1-应用场景"><a href="#3-5-1-应用场景" class="headerlink" title="3.5.1. 应用场景"></a>3.5.1. 应用场景</h3><p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p><ul><li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p><ul><li>举例 ：优先级任务队列。</li><li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li></ul><h1 id="4-特殊数据结构"><a href="#4-特殊数据结构" class="headerlink" title="4. 特殊数据结构"></a>4. 特殊数据结构</h1><h2 id="4-1-Pub-Sub（发布-订阅）"><a href="#4-1-Pub-Sub（发布-订阅）" class="headerlink" title="4.1. Pub/Sub（发布/订阅）"></a>4.1. Pub/Sub（发布/订阅）</h2><p>一种消息传递机制，允许发送者（发布者）将消息发送到一个或多个通道，并且允许接收者（订阅者）接收来自一个或多个通道的消息。发布者和订阅者之间是松散耦合的，这意味着它们不需要知道彼此的存在</p><p><strong>基本概念</strong></p><ul><li><strong>频道（Channel）</strong>：消息的传递媒介。发布者将消息发布到频道，订阅者订阅频道以接收消息。</li><li><strong>发布者（Publisher）</strong>：发送消息的一方，将消息发布到一个或多个频道。</li><li><strong>订阅者（Subscriber）</strong>：接收消息的一方，订阅一个或多个频道来接收消息。</li></ul><p><strong>基本命令</strong></p><ul><li>发布消息：<code>PUBLISH channel message</code></li><li>订阅频道：<code>SUBSCRIBE channel [channel ...]</code></li><li>取消订阅：<code>UNSUBSCRIBE [channel ...]</code></li></ul><p><strong>使用场景</strong></p><ul><li>实时消息处理：如聊天系统、实时通知等。</li><li>事件驱动架构：在微服务架构中，各个微服务通过消息传递进行通信。</li><li>日志收集：集中收集和处理分散的日志信息。</li><li>数据更新通知：当某些数据更新时，通知相关服务或客户端进行处理。</li></ul><p><strong>注意事项</strong></p><ul><li>消息丢失：Redis 的 Pub/Sub 没有持久化机制，消息只能被在线的订阅者实时消费，不能重复消费，如果订阅者在消息发布时不在线，则会丢失该消息。</li><li>消息顺序：消息的顺序保证是基于每个订阅者的，即订阅者接收到的消息顺序与发布者发送的顺序一致。</li><li>扩展性：Redis 的 Pub/Sub 适用于中小规模的实时消息传递。在大规模分布式系统中，可能需要使用更专业的消息队列系统（如 Kafka、RabbitMQ 等）来替代。</li></ul><h2 id="4-2-Streams（流）"><a href="#4-2-Streams（流）" class="headerlink" title="4.2. Streams（流）"></a>4.2. Streams（流）</h2><p>Redis Streams 是 Redis 5.0 引入的一种新的数据结构，旨在支持高效的消息队列和日志处理等场景。它提供了强大的功能，如持久化、消费组和消息确认，适用于需要可靠消息传递和重复消费的应用场景。</p><p><strong>基本概念</strong></p><ul><li>Stream：一个按时间顺序保存的消息日志，每条消息都有一个唯一的 ID。</li><li>Entry：Stream 中的每条消息，包含一个 ID 和一个字段-值对的集合。</li><li>Consumer Group：消费者组，允许多个消费者协同处理一个 Stream，并支持消息确认和未处理消息的重分配。</li><li>Consumer：消费者组中的一个成员，负责处理 Stream 中的消息。</li></ul><p><strong>基本命令</strong></p><ul><li>添加消息：<code>XADD mystream * field1 value1 field2 value2</code>（<code>*</code> 表示自动生成消息 ID）</li><li>读取消息：<code>XRANGE mystream - +</code>，读取 Stream 中的所有消息，<code>-</code> 和 <code>+</code> 分别表示流的起始和结束。</li></ul><p><strong>使用场景</strong></p><ul><li>日志收集与处理：将日志数据写入 Stream，并由多个消费者组进行处理和分析。</li><li>消息队列：在分布式系统中使用 Stream 作为消息队列，支持消息确认和重试机制。</li><li>事件源：保存事件日志，支持事件溯源和重放。</li></ul><p>Redis Streams 提供了强大的消息队列功能，适用于需要高吞吐量、消息持久化和消费者组协同处理的场景。通过合理使用这些功能，可以构建高效可靠的分布式消息处理系统。</p><h2 id="4-3-Bitmap（位存储）"><a href="#4-3-Bitmap（位存储）" class="headerlink" title="4.3. Bitmap（位存储）"></a>4.3. Bitmap（位存储）</h2><p>通过 Bitmap，只需要一个 bit 位来表示某个元素对应的值或者状态。可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）</p><p>通过以下例子理解Bitmap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我们有1千万个整数，整数的范围在1到1亿之间。如何快速查找某个整数是否在这1千万个整数中呢？</span><br><span class="line"></span><br><span class="line">可以使用一种特殊的散列表，那就是位图来解决</span><br><span class="line">申请一个大小为1亿、布尔类型（true或者false）的数组。将这1千万个整数作为数组下标，将对应的数组值设置成true。比如，整数5对应下标为5的数组值设置为true，也就是array[5]=true。</span><br><span class="line">查询某个整数K是否在这1千万个整数中的时候，只需将array[K]取出来，看是否等于true。如果等于true，那说明1千万整数中包含这个整数K；相反，就表示不包含这个整数K。</span><br></pre></td></tr></table></figure><h3 id="4-3-1-应用场景"><a href="#4-3-1-应用场景" class="headerlink" title="4.3.1. 应用场景"></a>4.3.1. 应用场景</h3><p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p><ul><li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li><li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code></li></ul><h2 id="4-4-HyperLogLog（基数统计）"><a href="#4-4-HyperLogLog（基数统计）" class="headerlink" title="4.4. HyperLogLog（基数统计）"></a>4.4. HyperLogLog（基数统计）</h2><p>HyperLogLog 是一种有名的基数计数概率算法</p><p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素</p><h3 id="4-4-1-应用场景"><a href="#4-4-1-应用场景" class="headerlink" title="4.4.1. 应用场景"></a>4.4.1. 应用场景</h3><p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p><ul><li>举例 ：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li><li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code></li></ul><h2 id="4-5-Geospatial-index（地理位置）"><a href="#4-5-Geospatial-index（地理位置）" class="headerlink" title="4.5. Geospatial index（地理位置）"></a>4.5. Geospatial index（地理位置）</h2><p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score（权重参数）使用</p><p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能</p><p>GEO 底层是 Sorted Set ，可以对 GEO 使用 Sorted Set 相关的命令</p><h3 id="4-5-1-应用场景"><a href="#4-5-1-应用场景" class="headerlink" title="4.5.1. 应用场景"></a>4.5.1. 应用场景</h3><p><strong>需要管理使用地理空间数据的场景</strong></p><ul><li>举例：附近的人。</li><li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code></li></ul><h1 id="5-数据一致性策略"><a href="#5-数据一致性策略" class="headerlink" title="5. 数据一致性策略"></a>5. 数据一致性策略</h1><p>为了保证缓存和数据库的一致性，常用的策略包括：</p><ul><li><strong>缓存失效（Cache Invalidation）</strong>：在数据库更新时，主动删除缓存中的对应数据，确保缓存中的数据是最新的。</li><li><strong>双写（Dual Write）</strong>：在数据库和缓存中同时进行写操作，确保两者数据一致。</li></ul><h1 id="6-常见的缓存读写策略"><a href="#6-常见的缓存读写策略" class="headerlink" title="6. 常见的缓存读写策略"></a>6. 常见的缓存读写策略</h1><h2 id="6-1-Cache-Aside-Pattern（旁路缓存模式）"><a href="#6-1-Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="6.1. Cache Aside Pattern（旁路缓存模式）"></a>6.1. Cache Aside Pattern（旁路缓存模式）</h2><p>使用比较多的一个缓存读写模式，比较适合读请求比较多的场景</p><p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准</p><p><strong>写</strong></p><ul><li>先更新 db</li><li>然后直接删除 cache</li></ul><p><strong>读</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回</li><li>再把数据放到 cache 中</li></ul><h2 id="6-2-Read-Write-Through-Pattern（读写穿透）"><a href="#6-2-Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="6.2. Read/Write Through Pattern（读写穿透）"></a>6.2. Read/Write Through Pattern（读写穿透）</h2><p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p>分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能</p><p><strong>写</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 db</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）</li></ul><p><strong>读</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 </li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应</li></ul><h2 id="6-3-Write-Behind-Pattern（异步缓存写入）"><a href="#6-3-Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="6.3. Write Behind Pattern（异步缓存写入）"></a>6.3. Write Behind Pattern（异步缓存写入）</h2><p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写</p><p>但是Write Behind Pattern 只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</p><p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量</p><h1 id="7-Redis-线程模型"><a href="#7-Redis-线程模型" class="headerlink" title="7. Redis 线程模型"></a>7. Redis 线程模型</h1><h2 id="7-1-Redis-单线程模型"><a href="#7-1-Redis-单线程模型" class="headerlink" title="7.1. Redis 单线程模型"></a>7.1. Redis 单线程模型</h2><p>Redis 6.0 之前主要还是单线程处理</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：文件事件处理器</p><p>文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</p><h2 id="7-2-Redis6-0-多线程"><a href="#7-2-Redis6-0-多线程" class="headerlink" title="7.2. Redis6.0 多线程"></a>7.2. Redis6.0 多线程</h2><p><strong>6.0之前为何不使用多线程</strong></p><ul><li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络</li><li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能</li></ul><p><strong>6.0之后为何使用多线程</strong></p><p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行</p><h1 id="8-Redis-内存管理（重点）"><a href="#8-Redis-内存管理（重点）" class="headerlink" title="8. Redis 内存管理（重点）"></a>8. Redis 内存管理（重点）</h1><h2 id="8-1-设置缓存过期时间"><a href="#8-1-设置缓存过期时间" class="headerlink" title="8.1. 设置缓存过期时间"></a>8.1. 设置缓存过期时间</h2><p>有助于缓解内存的消耗</p><p>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间</p><p>业务场景：需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效</p><h2 id="8-2-判断数据是否过期"><a href="#8-2-判断数据是否过期" class="headerlink" title="8.2. 判断数据是否过期"></a>8.2. 判断数据是否过期</h2><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key（键），过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间</p><p>过期字典是存储在 redisDb 这个结构里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    dict *dict;     <span class="comment">//数据库键空间,保存着数据库中所有键值对</span></span><br><span class="line">    dict *expires   <span class="comment">// 过期字典,保存着键的过期时间</span></span><br><span class="line">    ...</span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h2 id="8-3-过期的数据的删除策略（重点）"><a href="#8-3-过期的数据的删除策略（重点）" class="headerlink" title="8.3. 过期的数据的删除策略（重点）"></a>8.3. 过期的数据的删除策略（重点）</h2><p>惰性删除 ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</p><p>定期删除 ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p><p>Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> </p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这就需要内存淘汰机制</p><h2 id="8-4-Redis-内存淘汰机制"><a href="#8-4-Redis-内存淘汰机制" class="headerlink" title="8.4. Redis 内存淘汰机制"></a>8.4. Redis 内存淘汰机制</h2><p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据</strong></p><p><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</p><p><strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</p><p><strong>volatile-random</strong>：从已设置过期时间的数据集中任意选择数据淘汰</p><p><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</p><p><strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</p><p><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错</p><h1 id="9-Redis-持久化机制（重点）"><a href="#9-Redis-持久化机制（重点）" class="headerlink" title="9. Redis 持久化机制（重点）"></a>9. Redis 持久化机制（重点）</h1><p>Redis 支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</p><h2 id="9-1-RDB-持久化"><a href="#9-1-RDB-持久化" class="headerlink" title="9.1. RDB 持久化"></a>9.1. RDB 持久化</h2><p>快照持久化是 Redis 默认采用的持久化方式</p><p>Redis 在某个时间点上对存储在内存里面的数据进行的一次拍摄，用来记录数据的状态和变化，RDB 文件存储的内容是经过压缩的二进制数据</p><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程</li><li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项</li></ul><h2 id="9-2-AOF-持久化"><a href="#9-2-AOF-持久化" class="headerlink" title="9.2. AOF 持久化"></a>9.2. AOF 持久化</h2><p>开启 AOF 持久化后，每执行一次写命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中。与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式：推荐 appendfsync everysec方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><h2 id="9-3-AOF-日志"><a href="#9-3-AOF-日志" class="headerlink" title="9.3. AOF 日志"></a>9.3. AOF 日志</h2><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志</p><p><strong>为什么在执行完命令之后记录日志</strong></p><ul><li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p><strong>在执行完命令之后记录日志带来的风险</strong></p><ul><li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</li></ul><h2 id="9-4-AOF-重写"><a href="#9-4-AOF-重写" class="headerlink" title="9.4. AOF 重写"></a>9.4. AOF 重写</h2><p>当 AOF 变得太大时，Redis 能够在后台自动重写一个新的 AOF 文件替换旧的AOF文件。该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作</p><p>重写AOF文件是指将内存中的数据写入到磁盘中，以便在Redis重启时可以重新加载数据。可以通过执行 BGREWRITEAOF 命令来重写AOF文件。该命令会在后台执行，不会阻塞Redis服务器</p><p>在重写期间，Redis会继续将新的写命令追加到旧的AOF文件中，以确保不会丢失任何数据</p><h2 id="9-5-AOF和RDB的选用"><a href="#9-5-AOF和RDB的选用" class="headerlink" title="9.5. AOF和RDB的选用"></a>9.5. AOF和RDB的选用</h2><p>在Redis重启时，可以通过加载RDB文件或者重放AOF文件来恢复数据。</p><p>RDB的优点是文件比较小，恢复速度比较快。缺点是可能会丢失最后一次快照之后的所有数据。</p><p>AOF的优点是数据比较安全，可以最大程度地避免数据丢失。缺点是文件比较大，恢复速度比较慢，要一条一条地执行命令。</p><p>一般来说，如果数据比较重要，建议使用AOF持久化方式。如果数据不是很重要，可以使用RDB持久化方式。如果两种方式都使用，Redis会优先使用AOF文件来恢复数据。</p><h1 id="10-Redis-生产问题（重点）"><a href="#10-Redis-生产问题（重点）" class="headerlink" title="10. Redis 生产问题（重点）"></a>10. Redis 生产问题（重点）</h1><h2 id="10-1-缓存穿透"><a href="#10-1-缓存穿透" class="headerlink" title="10.1. 缓存穿透"></a>10.1. 缓存穿透</h2><p>根本原因：Redis中不存在请求所访问的key，导致大量请求直接访问数据库</p><p>指查询一个一定不存在的数据，由于缓存是不命中时被动写，即从 DB 查询到数据，则更新到缓存中，并且出于容错考虑，如果从 DB 查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要去 DB 查询，失去了缓存的意义。在流量大时，DB 可能就挂掉了</p><p><strong>情况一：redis中没有key，数据库中没有key。如黑客攻击不断尝试错误的信息</strong></p><p>方案一： 使用布隆过滤器，在缓存的基础上，构建布隆过滤器数据结构，在布隆过滤器中存储对应的 key，如果存在，则说明 key 对应的值为空。这样整个业务逻辑如下：</p><ul><li>根据 key 查询缓存，如果存在对应的值，直接返回；如果不存在则继续执行。</li><li>根据 key 查询缓存在布隆过滤器的值，如果存在值，则说明该 key 不存在对应的值，直接返回空，如果不存在值，继续向下执行。</li><li>查询 DB 对应的值，如果存在，则更新到缓存，并返回该值，如果不存在值，则更新缓存到布隆过滤器中，并返回空</li></ul><p>方案二：参数校验与限制，对传入的参数进行严格校验，防止恶意构造的请求直接访问数据库。例如，限制查询参数的长度和格式</p><p>方案三：缓存空对象，当从 DB 查询数据为空，我们仍然将这个空结果进行缓存，具体的值需要使用特殊的标识， 能和真正缓存的数据区分开，另外将其过期时间设为较短时间。</p><p><strong>情况二：redis中没有key，数据库中有key。如新业务刚上线，redis是空的</strong></p><p>方案一：预热redis，运行批处理脚本，将可能会大量访问的数据，提前加载到redis中，业务再开张</p><p><strong>布隆过滤器</strong></p><p>布隆过滤器是一种概率型数据结构，用于测试一个元素是否属于一个集合。它是一种高效的空间概率型数据结构</p><p>布隆过滤器使用一个位数组和一组哈希函数实现。当一个元素被添加到集合中时，它被哈希使用一组哈希函数，并将位数组中对应的位设置为1。当我们想要检查一个元素是否在集合中时，我们使用相同的一组哈希函数对元素进行哈希，并检查位数组中对应的位是否设置为1。如果所有位都设置为1，则该元素可能在集合中。如果任何位没有设置为1，则该元素肯定不在集合中。</p><p>可能会出现误判的情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><h2 id="10-2-缓存击穿"><a href="#10-2-缓存击穿" class="headerlink" title="10.2. 缓存击穿"></a>10.2. 缓存击穿</h2><p>某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库</p><p><strong>缓存穿透和缓存击穿有什么区别</strong></p><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p><p><strong>解决办法</strong></p><ul><li>设置热点数据永不过期或者过期时间比较长。</li><li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间，比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力</li></ul><h2 id="10-3-缓存雪崩"><a href="#10-3-缓存雪崩" class="headerlink" title="10.3. 缓存雪崩"></a>10.3. 缓存雪崩</h2><p>大量的key是存在的，但是同时失效了，所有请求全部达到 DB 中，导致 DB 负荷大增，最终挂掉的情况</p><p>比如，对于系统 A，假设每天高峰期每秒 5000 个请求，本来缓存在高峰期可以扛住每秒 4000 个请求，但是缓存机器意外发生了全盘宕机。缓存挂了，此时 1 秒 5000 个请求全部落数据库，数据库必然扛不住，它会报一下警，然后就挂了。此时，如果没有采用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了</p><p><strong>解决方案</strong>：</p><ul><li>缓存高可用：使用 Redis Sentinel 等搭建缓存的高可用，避免缓存挂掉无法提供服务的情况，从而降低出现缓存雪崩的情况。</li><li>使用本地缓存：如果使用本地缓存，即使分布式缓存挂了，也可以将 DB 查询的结果缓存到本地，避免后续请 求全部达到 DB 中。当然引入本地缓存也会有相应的问题，比如本地缓存实时性如何保证。对于这个问题，可以使用消息队列，在数据更新时，发布数据更新的消息，而进程中有相应的消费者消费该消息，从而更新本地缓存；简单点可以通过设置较短的过期时间，请求时从 DB 重新拉取。</li><li>请求限流和服务降级：通过限制 DB 的每秒请求数，避免数据库挂掉。对于被限流的请求，采用服务降级处理，比如提供默认的值，或者空白值。</li><li>采用 Redis 集群</li></ul><h1 id="11-Redis-集群"><a href="#11-Redis-集群" class="headerlink" title="11. Redis 集群"></a>11. Redis 集群</h1><p>Redis支持三种集群方案</p><ul><li>主从复制模式</li><li>Sentinel（哨兵）模式</li><li>Cluster模式</li></ul><h2 id="11-1-Redis主从复制"><a href="#11-1-Redis主从复制" class="headerlink" title="11.1. Redis主从复制"></a>11.1. Redis主从复制</h2><p>主从复制模式中包含一个主数据库实例（master）与一个或多个从数据库实例（slave）</p><p>具体工作机制为：</p><ul><li>slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令</li><li>master将保存的快照文件发送给slave，并继续记录执行的写命令</li><li>slave接收到快照文件后，加载快照文件，载入数据</li><li>master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化</li><li>此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li></ul><p>优点：</p><p>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</p><p>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</p><p>缺点：</p><p>不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复</p><p>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</p><p>难以支持在线扩容，Redis的容量受限于单机配置</p><h2 id="11-2-Redis-Sentinel"><a href="#11-2-Redis-Sentinel" class="headerlink" title="11.2. Redis Sentinel"></a>11.2. Redis Sentinel</h2><p>哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障</p><p>哨兵就是来为Redis集群站哨的，一旦发现问题能做出相应的应对处理。其功能包括：监视、选主、通知、自我监控</p><h2 id="11-3-Redis-Cluster"><a href="#11-3-Redis-Cluster" class="headerlink" title="11.3. Redis Cluster"></a>11.3. Redis Cluster</h2><p>哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题</p><p>Cluster模式的具体工作机制：</p><p>在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383</p><p>当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作</p><p>为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点</p><p>当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了</p><p>Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用。</p><p>客户端分片、代理分片、服务器端分片</p><h1 id="12-Redis-事务（不推荐用）"><a href="#12-Redis-事务（不推荐用）" class="headerlink" title="12. Redis 事务（不推荐用）"></a>12. Redis 事务（不推荐用）</h1><p>Redis事务可以通过MULTI、EXEC、DISCARD和WATCH命令来实现。其中，MULTI命令用于开启一个事务，EXEC命令用于执行事务，DISCARD命令用于取消事务，WATCH命令用于监视一个或多个键，如果一个被 WATCH 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。如果 WATCH 与 事务 在同一个 Session 里，并且被 WATCH 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><p>注意：Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）</p><h1 id="13-Redis-性能优化"><a href="#13-Redis-性能优化" class="headerlink" title="13. Redis 性能优化"></a>13. Redis 性能优化</h1><h2 id="13-1-使用批量操作减少网络传输"><a href="#13-1-使用批量操作减少网络传输" class="headerlink" title="13.1. 使用批量操作减少网络传输"></a>13.1. 使用批量操作减少网络传输</h2><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT</p><p><strong>原生批量操作命令</strong></p><p>Redis服务器本身支持的：mget、hmget、sadd等</p><p><strong>pipeline（流水线）</strong></p><p>将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输，pipeline 是非原子操作</p><p><strong>Lua 脚本</strong></p><p>一段 Lua 脚本可以视作一条命令执行，可以看作是原子操作。一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行</p><h2 id="13-2-大量-key-集中过期问题"><a href="#13-2-大量-key-集中过期问题" class="headerlink" title="13.2. 大量 key 集中过期问题"></a>13.2. 大量 key 集中过期问题</h2><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢</p><p>如何解决：</p><ol><li>给 key 设置随机过期时间。</li><li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>建议不管是否开启 lazy-free，我们都<strong>尽量给 key 设置随机过期时间</strong></p><h2 id="13-3-Redis-bigkey"><a href="#13-3-Redis-bigkey" class="headerlink" title="13.3. Redis bigkey"></a>13.3. Redis bigkey</h2><p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey，应该尽量避免写入 bigkey</p><p>可以使用Redis自带命令查找bigkey或使用专用工具</p><h2 id="13-4-Redis-内存碎片（重点）"><a href="#13-4-Redis-内存碎片（重点）" class="headerlink" title="13.4. Redis 内存碎片（重点）"></a>13.4. Redis 内存碎片（重点）</h2><p><strong>Redis产生内存碎片的原因</strong></p><p>Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间：</p><p>Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认jemalloc。当程序申请内存时，jemalloc 会给它分配最接近其申请值的那个较大的空间，比如程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存</p><p>频繁修改 Redis 中的数据也会产生内存碎片：</p><p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统</p><p><strong>查看 Redis 内存碎片</strong></p><p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息</p><p><code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重</p><p><strong>清理 Redis 内存碎片</strong></p><p>Redis4.0-RC3 版本以后自带了内存整理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 开启内存清理</span><br><span class="line">config set activedefrag yes</span><br><span class="line"></span><br><span class="line"># 内存碎片占用空间达到 500mb 的时候开始清理</span><br><span class="line">config set active-defrag-ignore-bytes 500mb</span><br><span class="line"></span><br><span class="line"># 内存碎片率大于 1.5 的时候开始清理</span><br><span class="line">config set active-defrag-threshold-lower 50</span><br><span class="line"></span><br><span class="line"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span><br><span class="line">config set active-defrag-cycle-min 20</span><br><span class="line"></span><br><span class="line"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span><br><span class="line">config set active-defrag-cycle-max 50</span><br></pre></td></tr></table></figure><p>重启节点可以做到内存碎片重新整理</p><h1 id="14-Redis-使用规范"><a href="#14-Redis-使用规范" class="headerlink" title="14. Redis 使用规范"></a>14. Redis 使用规范</h1><p><a href="https://developer.aliyun.com/article/531067">阿里云 Redis 开发规范</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-04-13-SpringSecurity/"/>
      <url>/2024/10/28/2023-04-13-SpringSecurity/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Security"><a href="#1-Spring-Security" class="headerlink" title="1. Spring Security"></a>1. <a href="https://docs.spring.io/spring-security/reference/5.7/servlet/getting-started.html">Spring Security</a></h1><p>主要介绍前后端分离的SpringBoot项目中SpringSecurity的使用</p><h2 id="1-1-版本问题"><a href="#1-1-版本问题" class="headerlink" title="1.1. 版本问题"></a>1.1. 版本问题</h2><p>SpringBoot 2.7.0版本中SpringSecurity已经弃用<code>WebSecurityConfigurerAdapter</code></p><p>新用法非常简单，无需再继承<code>WebSecurityConfigurerAdapter</code>，只需直接声明配置类，再配置一个生成<code>SecurityFilterChainBean</code>的方法，把原来的<code>HttpSecurity</code>配置移动到该方法中即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SpringSecurity 5.4.x以上新用法配置</span></span><br><span class="line"><span class="comment"> * 为避免循环依赖，仅用于配置HttpSecurity</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity httpSecurity)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//省略HttpSecurity的配置</span></span><br><span class="line">        <span class="keyword">return</span> httpSecurity.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>升级 <code>Spring Boot 2.7.0</code>版本后，<code>Spring Security</code>对于配置方法有了大的更改，但是其他使用是没啥影响的</p><h2 id="1-2-导入依赖"><a href="#1-2-导入依赖" class="headerlink" title="1.2. 导入依赖"></a>1.2. 导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，在浏览器访问项目地址会进入Spring Security内置登录页面</p><ul><li>用户名： user</li><li>密码：项目启动后，打印在控制台中</li></ul><p><strong>修改默认的用户名密码</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:  </span><br><span class="line">  security:  </span><br><span class="line">    user:  </span><br><span class="line">      name: admin  </span><br><span class="line">      password: admin123</span><br></pre></td></tr></table></figure><h1 id="2-Spring-Security-配置"><a href="#2-Spring-Security-配置" class="headerlink" title="2. Spring Security 配置"></a>2. Spring Security 配置</h1><p>在 Spring Security 中，认证与授权的相关校验都是在一系列的过滤器链中完成的</p><p>如果想要配置过滤器链，可以通过自定义<code>SecurityFilterChain</code> 来实现。如果想要配置WebSecurity，可以通过<code>WebSecurityCustomizer</code> 来实现</p><p><strong>Spring Security中重要的类</strong></p><ul><li>WebSecurityConfigurerAdapter：自定义Security策略（自己编写配置类要继承该类）</li><li>AuthenticationManagerBuilder：自定义认证策略</li><li>@EnableWebSecurity：开启WebSecurity模式 （@Enablexxx 开启某个功能）</li></ul><h1 id="3-身份认证（Authentication）"><a href="#3-身份认证（Authentication）" class="headerlink" title="3. 身份认证（Authentication）"></a>3. 身份认证（Authentication）</h1><p>Spring Security 提供了多种身份验证机制，包括基于表单、基于HTTP基本认证、基于LDAP等</p><p>下面主要介绍基于表单的认证</p><h2 id="3-1-用户名密码认证"><a href="#3-1-用户名密码认证" class="headerlink" title="3.1. 用户名密码认证"></a>3.1. 用户名密码认证</h2><p>在实际项目中，认证逻辑是需要自定义控制的。将 UserDetailsService 接口的实现类用<code>@Bean</code>放入Spring容器即可自定义认证逻辑</p><p>UserDetailsService 的实现类必须重写 loadUserByUsername 方法，该方法定义了具体的认证逻辑，参数 username 是前端传来的用户名，我们需要根据传来的用户名查询到该用户（一般是从数据库查询），并将查询到的用户封装成一个UserDetails对象，该对象是Spring Security提供的用户对象，包含用户名、密码、权限。Spring Security会根据 UserDetails对象中的密码和客户端提供密码进行比较。相同则认证 通过，不相同则认证失败。</p><h3 id="3-1-1-内存认证"><a href="#3-1-1-内存认证" class="headerlink" title="3.1.1. 内存认证"></a>3.1.1. 内存认证</h3><p>InMemoryUserDetailsManager 是 UserDetailsService 接口的一个实现类，它将登录页传来的用户名密码和内存中用户名密码做匹配认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableWebSecurity</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line"><span class="meta">@Bean</span>  </span><br><span class="line"><span class="keyword">public</span> UserDetailsService <span class="title function_">memoryUser</span><span class="params">()</span>&#123;  </span><br><span class="line">    <span class="comment">// 内存认证  </span></span><br><span class="line">    <span class="type">InMemoryUserDetailsManager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InMemoryUserDetailsManager</span>();  </span><br><span class="line">    <span class="comment">// 创建用户  </span></span><br><span class="line">    <span class="type">UserDetails</span> <span class="variable">user</span> <span class="operator">=</span> User.withUsername(<span class="string">&quot;admin&quot;</span>).password(passwordEncoder().encode(<span class="string">&quot;admin123&quot;</span>)).roles(<span class="string">&quot;admin&quot;</span>).build();  </span><br><span class="line">    <span class="comment">// 将用户加载到内存中  </span></span><br><span class="line">    manager.createUser(user);  </span><br><span class="line">    <span class="keyword">return</span> manager;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-数据库认证"><a href="#3-1-2-数据库认证" class="headerlink" title="3.1.2. 数据库认证"></a>3.1.2. 数据库认证</h3><p>Spring Security 默认从内存加载用户，需要实现从数据库加载并校验用户。</p><ul><li>创建 <strong>UserServiceImpl</strong> 类</li><li>实现 <strong>UserDetailsService</strong> 接口</li><li>重写 <strong>loadUserByUsername</strong> 方法</li><li>根据用户名校验用户并查询用户相关权限信息（授权）</li><li>将数据封装成 <strong>UserDetails</strong>（创建类并实现该接口） 并返回</li></ul><h3 id="3-1-3-密码解析器"><a href="#3-1-3-密码解析器" class="headerlink" title="3.1.3. 密码解析器"></a>3.1.3. 密码解析器</h3><p>Spring Security要求容器中必须有 PasswordEncoder 实例，之前使用的NoOpPasswordEncoder 是 PasswordEncoder 的实现类，意思是不解析密码，使用明文密码。Spring Security官方推荐的是 BCryptPasswordEncoder。在开发中，我们将 BCryptPasswordEncoder 的实例放入Spring容器即可，并且在用户注册完成后，将密码加密再保存到数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableWebSecurity</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：同一密码每次加密后生成的密文互不相同，因此需使用 matches() 方法来进行比较</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordEncoder.encode(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(<span class="string">&quot;123456&quot;</span>, password);</span><br></pre></td></tr></table></figure><h3 id="3-1-4-自定义登录"><a href="#3-1-4-自定义登录" class="headerlink" title="3.1.4. 自定义登录"></a>3.1.4. 自定义登录</h3><p>Spring Security 默认提供了登录页面，但在实际项目中是使用自己的登录页面。Spring Security也支持用户自定义登录页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>  </span><br><span class="line"><span class="meta">@EnableWebSecurity</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span>  </span><br><span class="line">    <span class="keyword">public</span> SecurityFilterChain <span class="title function_">filterChain</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception&#123;  </span><br><span class="line">        http  </span><br><span class="line">                <span class="comment">// 过滤请求  </span></span><br><span class="line">                .authorizeRequests()  </span><br><span class="line">                <span class="comment">// 接口放行  </span></span><br><span class="line">                .antMatchers(<span class="string">&quot;/user/login&quot;</span>).permitAll()  </span><br><span class="line">                .anyRequest()  </span><br><span class="line">                .authenticated()  </span><br><span class="line">                .and()  </span><br><span class="line">                .csrf().disable()  </span><br><span class="line">                .headers().cacheControl().disable()  </span><br><span class="line">                .and()  </span><br><span class="line">                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);  </span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> http.build();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring Security 为了防止CSRF攻击，默认开启了CSRF防护，这限制了除了 GET请求以外的大多数方法。我们要想正常使用Spring Security需要突破CSRF防护</p><p><strong>解决方法一：关闭CSRF防护：</strong></p><p><code>http.csrf().disable();</code></p><h2 id="3-2-认证后的处理"><a href="#3-2-认证后的处理" class="headerlink" title="3.2. 认证后的处理"></a>3.2. 认证后的处理</h2><p>认证后，如果除了跳转页面还需要执行一些自定义代码时， 如：统计访问量，推送消息等操作时，可以自定义处理器</p><p>在前后端分离这样的开发架构下，前后端的交互都是通过 JSON 来进行，无论登录成功还是失败，都不会有什么服务端跳转或者客户端跳转之类。</p><p>登录成功了，服务端就返回一段登录成功的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，就和后端没有关系了。</p><p>登录失败了，服务端就返回一段登录失败的提示 JSON 给前端，前端收到之后，该跳转该展示，由前端自己决定，也和后端没有关系了。</p><h3 id="3-2-1-认证成功后的处理方式"><a href="#3-2-1-认证成功后的处理方式" class="headerlink" title="3.2.1. 认证成功后的处理方式"></a>3.2.1. 认证成功后的处理方式</h3><h3 id="3-2-2-认证失败后的处理方式"><a href="#3-2-2-认证失败后的处理方式" class="headerlink" title="3.2.2. 认证失败后的处理方式"></a>3.2.2. 认证失败后的处理方式</h3><h2 id="3-3-会话管理"><a href="#3-3-会话管理" class="headerlink" title="3.3. 会话管理"></a>3.3. 会话管理</h2><p>Security将用户信息保存在会话中，并提供会话管理，我们可以从 SecurityContext 对象中获取用户信息， SecurityContext 对象与当前线程进行绑定</p><p>SecurityContextHolder工具类就是把SecurityContext存储在当前线程中。</p><p>SecurityContextHolder可以用来设置和获取SecurityContext。它主要是给框架内部使用的，可以利用它获取当前用户的SecurityContext进行请求检查，和访问控制等。</p><p>在Web环境下，SecurityContextHolder是利用ThreadLocal来存储SecurityContext的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>  </span><br><span class="line"><span class="meta">@RestController</span>  </span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;  </span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span>  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">login</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">SecurityContext</span> <span class="variable">context</span> <span class="operator">=</span> SecurityContextHolder.getContext();  </span><br><span class="line">        System.out.println(context.toString());  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-4-remember-me-功能"><a href="#3-4-remember-me-功能" class="headerlink" title="3.4. remember me 功能"></a>3.4. remember me 功能</h2><p><code>记住我</code>功能，即下次访问系统时无需重新登录。当使用<code>记住我</code>功能登录后，Spring Security会生成一个令牌，令牌一方面保存到数据库中，另一方面生成一个叫 <code>remember-me</code> 的Cookie保存到客户端。之后客户端访问项目时自动携带令牌，不登录即可完成认证。</p><h2 id="3-5-退出登录"><a href="#3-5-退出登录" class="headerlink" title="3.5. 退出登录"></a>3.5. 退出登录</h2><p>在系统中一般都有退出登录的操作。退出登录后，Spring Security 进行了以下操作：</p><ul><li>清除认证状态</li><li>销毁HttpSession对象 </li><li>跳转到登录页面</li></ul><h2 id="3-6-退出成功处理器"><a href="#3-6-退出成功处理器" class="headerlink" title="3.6. 退出成功处理器"></a>3.6. 退出成功处理器</h2><h1 id="4-授权（Authorization）"><a href="#4-授权（Authorization）" class="headerlink" title="4. 授权（Authorization）"></a>4. 授权（Authorization）</h1><p>Spring Security 提供了强大的授权机制，可以基于角色、权限或自定义逻辑来控制用户对资源的访问权限。您可以在配置文件或注解中定义授权规则，以限制用户对特定功能或页面的访问。</p><h2 id="4-1-封装UserDetails对象"><a href="#4-1-封装UserDetails对象" class="headerlink" title="4.1. 封装UserDetails对象"></a>4.1. 封装UserDetails对象</h2><ul><li>查询用户</li><li>查询用户权限</li><li>将自定义权限集合转为Security的权限类型集合</li><li>封装为UserDetails对象</li><li>返回封装好的UserDetails对象</li></ul><h2 id="4-2-资源访问控制"><a href="#4-2-资源访问控制" class="headerlink" title="4.2. 资源访问控制"></a>4.2. 资源访问控制</h2><h3 id="4-2-1-配置类设置"><a href="#4-2-1-配置类设置" class="headerlink" title="4.2.1. 配置类设置"></a>4.2.1. 配置类设置</h3><h3 id="4-2-2-自定义访问控制逻辑"><a href="#4-2-2-自定义访问控制逻辑" class="headerlink" title="4.2.2. 自定义访问控制逻辑"></a>4.2.2. 自定义访问控制逻辑</h3><p>如果资源数量很多，一条条配置需要的权限效率较低。我们可以自定义访问控制逻辑，即访问资源时判断用户是否具有名为该资源 URL的权限。</p><h3 id="4-2-3-注解设置访问控制"><a href="#4-2-3-注解设置访问控制" class="headerlink" title="4.2.3. 注解设置访问控制"></a>4.2.3. 注解设置访问控制</h3><h2 id="4-3-无权限403处理方案"><a href="#4-3-无权限403处理方案" class="headerlink" title="4.3. 无权限403处理方案"></a>4.3. 无权限403处理方案</h2><ul><li>编写权限不足页面 noPermission.html</li><li>编写权限不足处理类</li><li>在Spring Security配置文件中配置异常处理</li></ul><h1 id="5-认证和授权的集成"><a href="#5-认证和授权的集成" class="headerlink" title="5. 认证和授权的集成"></a>5. 认证和授权的集成</h1><p>Spring Security 可以与其他常见的身份验证和授权机制进行集成，如LDAP、OAuth、OpenID Connect等。这使得在现代应用程序中实现单点登录（SSO）和第三方身份验证变得更加容易。</p><h1 id="6-安全事件和日志记录"><a href="#6-安全事件和日志记录" class="headerlink" title="6. 安全事件和日志记录"></a>6. 安全事件和日志记录</h1><p>Spring Security 提供了安全事件的记录和处理机制，您可以根据需要记录和处理登录成功、登录失败、访问受限等事件。这有助于监控应用程序的安全性和及时发现潜在的安全问题。</p><h1 id="7-Spring-Security-中重要对象汇总"><a href="#7-Spring-Security-中重要对象汇总" class="headerlink" title="7. Spring Security 中重要对象汇总"></a>7. Spring Security 中重要对象汇总</h1><h1 id="8-Spring-Security-常用的属性"><a href="#8-Spring-Security-常用的属性" class="headerlink" title="8. Spring Security 常用的属性"></a>8. Spring Security 常用的属性</h1><ol><li><code>security.basic.enabled</code>：设置是否启用HTTP基本认证，默认为<code>true</code>。</li><li><code>security.basic.realm</code>：设置HTTP基本认证的领域（realm）名称，默认为<code>Spring</code>。</li><li><code>security.enable-csrf</code>：设置是否启用跨站请求伪造（CSRF）保护，默认为<code>true</code>。</li><li><code>security.csrf.method</code>：设置CSRF保护使用的HTTP方法，默认为<code>POST</code>。</li><li><code>security.ignored</code>：设置忽略安全性保护的URL模式，默认为空。</li><li><code>security.headers.cache</code>：设置是否启用HTTP缓存头部，默认为<code>false</code>。</li><li><code>security.headers.hsts</code>：设置是否启用HTTP严格传输安全性（HSTS）头部，默认为<code>false</code>。</li><li><code>security.headers.frame</code>：设置是否允许在页面中显示嵌入式框架，默认为<code>DENY</code>。</li><li><code>security.headers.xss</code>：设置是否启用跨站脚本（XSS）保护，默认为<code>true</code>。</li><li><code>security.session.maximumSessions</code>：设置最大会话数，默认为无限制。</li><li><code>security.session.maxSessionsPreventsLogin</code>：设置是否阻止用户登录，如果超出了最大会话数，默认为<code>false</code>。</li><li><code>security.session.session-fixation-protection</code>：设置会话固定保护，默认为<code>none</code>。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Spring Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-04-25-SpringBoot%E9%A1%B9%E7%9B%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
      <url>/2024/10/28/2023-04-25-SpringBoot%E9%A1%B9%E7%9B%AE%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Boot通用项目结构"><a href="#1-Spring-Boot通用项目结构" class="headerlink" title="1. Spring Boot通用项目结构"></a>1. Spring Boot通用项目结构</h1><p>在Java 的web开发中，使用了Spring MVC 框架之后，我们的代码组织形式变成了controller，service，dao这种形式</p><p>以Spring Boot 构建的项目应该总体分为三大层</p><ul><li><code>项目根目录/src/main/java</code>：放置项目Java源代码</li><li><code>项目根目录/src/main/resources</code>：放置项目静态资源和配置文件</li><li><code>项目根目录/src/test/java</code>：放置项目测试用例代码</li></ul><h2 id="1-1-src-main-java目录下的结构"><a href="#1-1-src-main-java目录下的结构" class="headerlink" title="1.1. /src/main/java目录下的结构"></a>1.1. <code>/src/main/java</code>目录下的结构</h2><p>不同项目和团队实践不一样，稍许有区别，但整体安排应该差不多。如果是<strong>多模块</strong>的项目的话，下面的结构应该只对应其中一个模块，其他模块的代码组织也大致差不多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">|_annotation：放置项目自定义注解</span><br><span class="line">|_aspect：放置切面代码</span><br><span class="line">|_config：放置配置类</span><br><span class="line">|_constant：放置常量、枚举等定义</span><br><span class="line">   |__consist：存放常量定义</span><br><span class="line">   |__enums：存放枚举定义</span><br><span class="line">|_controller：放置控制器代码</span><br><span class="line">|_filter：放置一些过滤、拦截相关的代码</span><br><span class="line">|_mapper：放置数据访问层代码接口</span><br><span class="line">|_model：放置数据模型代码</span><br><span class="line">   |__entity：放置数据库实体对象定义</span><br><span class="line">   |__dto：存放数据传输对象定义</span><br><span class="line">   |__vo：存放显示层对象定义</span><br><span class="line">|_service：放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">   |__intf：存放业务逻辑接口定义</span><br><span class="line">   |__impl：存放业务逻辑实际实现</span><br><span class="line">|_util：放置工具类和辅助代码</span><br></pre></td></tr></table></figure><h2 id="1-2-src-main-resources目录下的结构"><a href="#1-2-src-main-resources目录下的结构" class="headerlink" title="1.2. /src/main/resources目录下的结构"></a>1.2. <code>/src/main/resources</code>目录下的结构</h2><p>主要存放静态配置文件和页面静态资源等东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">|_mapper：存放mybatis的XML映射文件（如果是mybatis项目）</span><br><span class="line">|_static：存放网页静态资源，比如下面的js/css/img</span><br><span class="line">   |__js：</span><br><span class="line">   |__css：</span><br><span class="line">   |__img：</span><br><span class="line">   |__font：</span><br><span class="line">   |__等等</span><br><span class="line">|_template：存放网页模板，比如thymeleaf/freemarker模板等</span><br><span class="line">   |__header</span><br><span class="line">   |__sidebar</span><br><span class="line">   |__bottom</span><br><span class="line">   |__XXX.html等等</span><br><span class="line">|_application.yml       基本配置文件</span><br><span class="line">|_application-dev.yml   开发环境配置文件</span><br><span class="line">|_application-test.yml  测试环境配置文件</span><br><span class="line">|_application-prod.yml  生产环境配置文件</span><br></pre></td></tr></table></figure><h2 id="1-3-控制器（controller）"><a href="#1-3-控制器（controller）" class="headerlink" title="1.3. 控制器（controller）"></a>1.3. 控制器（controller）</h2><p>controller 接收请求，并将请求转发至业务处理对象</p><p>接收业务请求处理结果，并将结果分发到响应页面</p><p>不执行实际的业务逻辑，调用service 接口中的方法去完成</p><p>控制器应该围绕用例、业务能力来设计</p><p><strong>controller层一般返回封装的结果类<code>Result</code></strong></p><p><strong>默认情况下，控制器是单例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 注入service接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="comment">// 查询所有用户信息</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/all&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-业务层（service）"><a href="#1-4-业务层（service）" class="headerlink" title="1.4. 业务层（service）"></a>1.4. 业务层（service）</h2><p>service，用于执行业务逻辑，如计算、验证、授权等</p><p>一般由两部分组成 <strong>一个Java接口和一个实现类</strong></p><p>serviceImpl是实现具体业务逻辑的，通常是把mapper和业务进行整合</p><p><strong>service层返回什么主要看controller层需要什么，一般返回操作的执行结果（成功、失败）、处理后的业务数据（如经过计算、过滤或转换的数据）、异常或错误信息</strong></p><p>最好围绕业务功能、领域、用例来构建服务，合理的使用单一职责原则</p><p>如 <code>AccountService</code>, <code>UserService</code> 这样的服务，比起 <code>DatabaseService</code>、<code>ValidationService</code> 这样的会更合适一些</p><p>定义接口 UserService</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="comment">// 对应于mapper层接口中定义的方法</span></span><br><span class="line">    List &lt;User&gt; queryUsers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口实现类 UserServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">// 注入mapper接口</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.queryUsers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-DAO层（mapper）"><a href="#1-5-DAO层（mapper）" class="headerlink" title="1.5. DAO层（mapper）"></a>1.5. DAO层（mapper）</h2><p>实现数据层的操作</p><p>dao（Data Access Objects）层也叫mapper层，用于从数据库或其他数据存储介质中读取和写入数据</p><p><strong>先设计mapper接口，然后在xml配置文件中进行配置</strong></p><p>定义接口 UserMapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">queryUsers</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在xml中写SQL语句</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hy.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id表示接口当中定义的方法. resultType,表示数据库查询的结果.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hy.entity.User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.hy.entity.User&quot;</span>&gt;</span></span><br><span class="line">        select * from login</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>mapper层返回什么主要看service层需要什么</strong></p><h2 id="1-6-工具类（utils）"><a href="#1-6-工具类（utils）" class="headerlink" title="1.6. 工具类（utils）"></a>1.6. 工具类（utils）</h2><p>utils，用于提供常用的实用程序方法，如日期格式化、字符串处理、加密解密等</p><h2 id="1-7-配置类（config）"><a href="#1-7-配置类（config）" class="headerlink" title="1.7. 配置类（config）"></a>1.7. 配置类（config）</h2><p>config，拓展功能、修改默认功能</p><h2 id="1-8-拦截器（interceptor）"><a href="#1-8-拦截器（interceptor）" class="headerlink" title="1.8. 拦截器（interceptor）"></a>1.8. 拦截器（interceptor）</h2><p>interceptor</p><h2 id="1-9-数据模型定义（model）"><a href="#1-9-数据模型定义（model）" class="headerlink" title="1.9. 数据模型定义（model）"></a>1.9. 数据模型定义（model）</h2><p>model包中放的都是POJO类，一个POJO类一般实现了JavaBean的标准，要在各个实体类中实现序列化接口，避免在微服务中出现错误</p><p><code>entity</code>是数据库实体对象定义，定义各个属性以及各个属性的getter()和setter()方法，与数据库表结构一一对应</p><p>《阿里巴巴Java开发手册》中定义如下（实际项目开发时，没有必要刻意照搬去定义这么多层对象）</p><p><code>DO（Data Object）</code>：与数据库表结构一一对应，通过DAO层向上传输数据源对象</p><p><code>DTO（Data Transfer Object）</code>：数据传输对象，Service层向外传输的对象</p><p><code>BO（Business Object）</code>：业务对象。由Service层输出的封装业务逻辑的对象</p><p><code>AO（Application Object）</code>：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高</p><p><code>VO（View Object）</code>：显示层对象，通常是Web向模板渲染引擎层传输的对象</p><p><code>Query</code>：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输</p><p><strong>实际开发中一般只涉及如下两种数据模型就够用了</strong></p><p><code>DTO/VO</code> 泛指控制层与服务层之间的数据传输对象</p><p><code>DO/Entity</code> 泛指服务层与DAO层间的数据传输对象</p><h2 id="1-10-各层间调用关系"><a href="#1-10-各层间调用关系" class="headerlink" title="1.10. 各层间调用关系"></a>1.10. 各层间调用关系</h2><p><strong>要遵循Controller–&gt;Service接口–&gt;ServiceImpt实现类–&gt;Mapper接口-&gt;SQL-&gt;DataBase的调用模式</strong></p><p><strong>每当我们拿到一个新的项目到手时，只要按照这个思路去看别人项目的代码，应该基本都是能理得顺的</strong>。</p><p>controller调用service接口，serviceimpl实现类调用mapper接口并实现其他业务</p><p>在Service接口有多个ServiceImpl实现类的情况，就需要指定参数名来选择哪个ServiceImpt实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Service层（此时有两个接口实现类）</span><br><span class="line">    <span class="meta">@Service(&quot;PCIImpt1&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PCIImpt1</span> imeplements PCI&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Service(&quot;PCIimpt2&quot;)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">PCIImpt2</span> imeplements PCI&#123;&#125;</span><br><span class="line"></span><br><span class="line">Controller层</span><br><span class="line">    <span class="meta">@Resource(name=&quot;PCIimpt2&quot;)</span>  <span class="comment">//填PCIimpt1，注入PCIimpt1实现类，填PCIimpt2，则注入PCIimpt2实现类</span></span><br><span class="line">    <span class="keyword">private</span> PCI pci;    <span class="comment">//注入接口以Resource手动指定接收</span></span><br></pre></td></tr></table></figure><p>controller层调用了service层接口中的方法，service层由service对应的接口和实现类组成，serviceImpl实现service的相关接口同时完成相关的业务逻辑处理</p><p>service层的实现类serviceImpl 再调用mapper层的接口，进行业务逻辑应用的处理</p><p>mapper层的接口在对应的xml配置文件中进行配置、实现以及关联，mapper层的任务就是向数据库发送sql语句，完成数据的处理任务</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131106489.png" alt="springmvc各层调用"></p><h2 id="1-11-编写顺序"><a href="#1-11-编写顺序" class="headerlink" title="1.11. 编写顺序"></a>1.11. 编写顺序</h2><p>先设计数据库表，然后定义好model，之后再实现其他部分</p><h1 id="2-Spring-Boot的最佳实践"><a href="#2-Spring-Boot的最佳实践" class="headerlink" title="2. Spring Boot的最佳实践"></a>2. Spring Boot的最佳实践</h1><h2 id="2-1-使用自定义BOM来维护第三方依赖"><a href="#2-1-使用自定义BOM来维护第三方依赖" class="headerlink" title="2.1. 使用自定义BOM来维护第三方依赖"></a>2.1. 使用自定义BOM来维护第三方依赖</h2><p>可以借鉴Spring IO Platform来编写自己的基础项目platform-bom，所有的业务模块项目应该以BOM的方式引入。这样在升级第三方依赖时，就只需要升级这一个依赖的版本而已<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.spring.platform<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>platform-bom<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Cairo-SR3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在项目中，为了比避免在pom.xml文件中重复导包的问题，可以自己创建一个父工程，将所有的依赖版本统一，避免出现jar包冲突和每个项目都要导包的问题。在创建项目时只需要继承父工程即可。类似于spring boot的父工程</p><h2 id="2-2-使用自动化配置"><a href="#2-2-使用自动化配置" class="headerlink" title="2.2. 使用自动化配置"></a>2.2. 使用自动化配置</h2><p>自动化配置是Spring Boot的一部分，它可以简化你的代码并使之工作。当在类路径上检测到特定的jar文件时，自动配置就会被激活。</p><p>使用它的最简单方法是依赖Spring Boot Starters</p><p>如果想与Redis进行集成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可为开发中常见的问题，创建自己的自动配置，即<strong>手动实现一个 starter</strong></p><h2 id="2-3-正确设计代码目录结构"><a href="#2-3-正确设计代码目录结构" class="headerlink" title="2.3. 正确设计代码目录结构"></a>2.3. 正确设计代码目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── main</span><br><span class="line">│   ├── java</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── bestpractice</span><br><span class="line">│   │           ├── config 存放配置类</span><br><span class="line">│   │           ├── constants 放置常量、枚举等定义</span><br><span class="line">│   │           ├── controller 放置控制器代码</span><br><span class="line">│   │           ├── dao 放置数据访问层代码接口</span><br><span class="line">│   │           ├── exception</span><br><span class="line">│   │           ├── filter 放置一些过滤、拦截相关的代码</span><br><span class="line">│   │           ├── manager 放置数据访问层代码接口</span><br><span class="line">│   │           ├── model</span><br><span class="line">│   │           │   ├── entity 放置数据库实体对象定义</span><br><span class="line">│   │           │   ├── dto 存放数据传输对象定义</span><br><span class="line">│   │           │   └── vo 存放显示层对象定义</span><br><span class="line">│   │           ├── service 放置具体的业务逻辑代码（接口和实现分离）</span><br><span class="line">│   │           │   ├── impl 存放业务逻辑实际实现</span><br><span class="line">│   │           ├── task</span><br><span class="line">│   │           ├── utils 放置工具类和辅助代码</span><br><span class="line">│   │           └── BestPracticeApplication.java</span><br><span class="line">│   │</span><br><span class="line">│   └── resources</span><br></pre></td></tr></table></figure><h2 id="2-4-保持Controller层的简洁"><a href="#2-4-保持Controller层的简洁" class="headerlink" title="2.4. 保持Controller层的简洁"></a>2.4. 保持Controller层的简洁</h2><p>了解设计REST API的最佳实践</p><p><code>Controller</code>层里可以做参数校验、异常抛出等操作，但建议不要放太多业务逻辑，业务逻辑尽量放到<code>Service</code>层代码中去做</p><h2 id="2-5-围绕业务功能构建Service"><a href="#2-5-围绕业务功能构建Service" class="headerlink" title="2.5. 围绕业务功能构建Service"></a>2.5. 围绕业务功能构建Service</h2><p><code>Service</code>层做实际业务逻辑，完整的业务逻辑包含验证、缓存等</p><p>功能模块<code>Service</code>之间引用时，建议不要渗透到<code>DAO</code>层（或者<code>mapper</code>层），基于<code>Service</code>层进行调用和复用比较合理</p><p>业务逻辑层<code>Service</code>和数据库<code>DAO</code>层的操作对象不要混用。<code>Controller</code>层的数据对象不要直接渗透到<code>DAO</code>层（或者<code>mapper</code>层）；同理数据表实体对象<code>Entity</code>也不要直接传到<code>Controller</code>层进行输出或展示。</p><h2 id="2-6-使用全局异常处理"><a href="#2-6-使用全局异常处理" class="headerlink" title="2.6. 使用全局异常处理"></a>2.6. 使用全局异常处理</h2><p>Spring Boot提供了两种主要方法：</p><p>使用 <code>HandlerExceptionResolver</code> 定义全局异常处理策略</p><p>在控制器上添加 <code>@ExceptionHandler</code> 注解，这在某些特定场景下使用可能会很有用</p><h2 id="2-7-使用-slf4j-日志"><a href="#2-7-使用-slf4j-日志" class="headerlink" title="2.7. 使用 slf4j 日志"></a>2.7. 使用 slf4j 日志</h2><p>应该使用日志框架进行日志记录，而不是使用<code>System.out.println()</code>手动执行。建议将 Slf4j 与 Spring Boot 中默认的日志框架 logback 一起使用。可以使用 Lombok的 <code>@Slf4j</code> 注释非常轻松地创建日志记录器</p><p>在Spring Boot中完成，几乎没有配置。只需获取该类的记录器实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(MyClass.class);</span><br></pre></td></tr></table></figure><h2 id="2-8-代码测试"><a href="#2-8-代码测试" class="headerlink" title="2.8. 代码测试"></a>2.8. 代码测试</h2><p>测试切片，你可以根据需要仅连接部分应用程序</p><h2 id="2-9-使用Swagger接口文档工具"><a href="#2-9-使用Swagger接口文档工具" class="headerlink" title="2.9. 使用Swagger接口文档工具"></a>2.9. 使用Swagger接口文档工具</h2><p>在大多数情况下，其他应用程序将通过REST API 调用你的应用程序。因此我们需要维护一份API文档。文档应该由代码生成。</p><h2 id="2-10-使数据库独立于核心业务逻辑之外"><a href="#2-10-使数据库独立于核心业务逻辑之外" class="headerlink" title="2.10. 使数据库独立于核心业务逻辑之外"></a>2.10. 使数据库独立于核心业务逻辑之外</h2><p>理想情况下，你不希望服务知道它正在与哪个数据库通信，这需要一些抽象来封装对象的持久性</p><p><strong>一些优秀的持久层框架可以帮助我们做到这些</strong></p><h2 id="2-11-使用Spring-Initializr来开始一个新的Spring-Boot项目"><a href="#2-11-使用Spring-Initializr来开始一个新的Spring-Boot项目" class="headerlink" title="2.11. 使用Spring Initializr来开始一个新的Spring Boot项目"></a>2.11. 使用Spring Initializr来开始一个新的Spring Boot项目</h2><p>使用Initializr创建应用程序可确保你获得经过测试和验证的依赖项，这些依赖项适用于Spring自动配置。</p><h2 id="2-12-使用-Lombok"><a href="#2-12-使用-Lombok" class="headerlink" title="2.12. 使用 Lombok"></a>2.12. 使用 Lombok</h2><p>Lombok 是一个 Java 库，可用于减少代码并允许我们使用其注释编写干净的代码</p><h2 id="2-13-避免空指针异常"><a href="#2-13-避免空指针异常" class="headerlink" title="2.13. 避免空指针异常"></a>2.13. 避免空指针异常</h2><ul><li>为了避免 NullPointerException，我们可以使用 java.util 包中的 Optional。</li><li>我们还可以使用空安全库。例如：Apache Commons StringUtils</li><li>对已知对象调用 equals() 和 equalsIgnoreCase() 方法。</li><li>使用 valueOf() 而不是 toString()</li><li><p>使用基于 IDE 的 @NotNull 和 @Nullable 注释</p><h2 id="2-14-使用集合框架的最佳实践"><a href="#2-14-使用集合框架的最佳实践" class="headerlink" title="2.14. 使用集合框架的最佳实践"></a>2.14. 使用集合框架的最佳实践</h2></li><li><p>对我们的数据集使用适当的集合。</p></li><li>将 forEach 与 Java 8 功能结合使用，并避免使用旧版 for 循环。</li><li>使用接口类型而不是实现。</li><li>使用 isEmpty() 而不是 size() 以获得更好的可读性。</li><li>不返回空值，可以返回空集合。</li><li>如果我们使用对象作为要存储在基于哈希的集合中的数据，则应重写 equals() 和 hashCode() 方法。<h2 id="2-15-使用分页"><a href="#2-15-使用分页" class="headerlink" title="2.15. 使用分页"></a>2.15. 使用分页</h2></li></ul><p>使用物理分页</p><h2 id="2-16-使用自定义响应对象"><a href="#2-16-使用自定义响应对象" class="headerlink" title="2.16. 使用自定义响应对象"></a>2.16. 使用自定义响应对象</h2>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-09-%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2024/10/28/2023-02-09-%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-编程规约"><a href="#1-编程规约" class="headerlink" title="1. 编程规约"></a>1. 编程规约</h1><h2 id="1-1-命名规约"><a href="#1-1-命名规约" class="headerlink" title="1.1. 命名规约"></a>1.1. 命名规约</h2><p>1.<strong>【强制】</strong> 代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p><ol><li><code>反例： _name / __name / $Object / name_ / name$ / Object$</code></li></ol><p>2.<strong>【强制】</strong> 代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><blockquote><p>说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。<br>注意，即使纯拼音命名方式也要避免采用。</p></blockquote><ol><li><code>反例： DaZhePromotion [打折] / getPingfenByName()  [评分] / int某变量 = 3</code></li><li><code>正例： alibaba / taobao / youku / hangzhou等国际通用的名称，可视同英文。</code></li></ol><p>3.<strong>【强制】</strong> 类名使用UpperCamelCase风格，必须遵从驼峰形式，但以下情形例外：（领域模型的相关命名）DO / BO / DTO / VO等。</p><ol><li><code>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal /   TaPromotion</code></li><li><code>反例：macroPolo / UserDo / XMLService / TCPUDPDeal /   TAPromotion</code></li></ol><p>4.<strong>【强制】</strong> 方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。</p><ol><li><code>正例： localValue / getHttpMessage() /  inputUserId</code></li></ol><p>5.<strong>【强制】</strong> 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p><ol><li><code>正例： MAX_STOCK_COUNT</code></li><li><code>反例： MAX_COUNT</code></li></ol><p>6.<strong>【强制】</strong> 抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。</p><p>7.<strong>【强制】</strong> 中括号是数组类型的一部分，数组定义如下：String[] args;</p><ol><li><code>反例：请勿使用String  args[]的方式来定义。</code></li></ol><p>8.<strong>【强制】</strong> POJO类中布尔类型的变量，都不要加is，否则部分框架解析会引起序列化错误。</p><ol><li><code>反例：定义为基本数据类型boolean isSuccess；的属性，</code></li><li><code>它的方法也是isSuccess()，RPC框架在反向解析的时候，“以为”对应的属性名称是success，导致属性获取不到，进而抛出异</code></li><li><code>常。</code></li></ol><p>9.<strong>【强制】</strong> 包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p><ol><li><code>正例：应用工具类包名为com.alibaba.open.util、类名为MessageUtils（此规则参考spring的框架结构）</code></li></ol><p>10.<strong>【强制】</strong> 杜绝完全不规范的缩写，避免望文不知义。</p><ol><li><code>反例： AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。</code></li></ol><p>11.<em>【推荐】</em> 如果使用到了设计模式，建议在类名中体现出具体模式。</p><blockquote><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。</p></blockquote><ol><li><code>正例：public class OrderFactory;</code></li><li><code>public class LoginProxy;</code></li><li><code>public class ResourceObserver;</code></li></ol><p>12.<em>【推荐】</em> 接口类中的方法和属性不要加任何修饰符号（public也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。</p><ol><li><code>正例：接口方法签名：void f();</code></li><li><code>接口基础常量表示：String COMPANY = &quot;alibaba&quot;;</code></li><li><code>反例：接口方法定义：public abstract void f();</code></li><li><code>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</code></li></ol><p>13.接口和实现类的命名有两套规则：</p><ul><li><p><strong>【强制】</strong> 对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。</p><ol><li><code>正例：CacheServiceImpl实现CacheService接口。</code></li></ol></li><li><p><em>【推荐】</em> 如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able的形式）。</p><ol><li><code>正例：AbstractTranslator实现 Translatable。</code></li></ol></li></ul><p>14.【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p><blockquote><p>说明：枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p></blockquote><ol><li><code>正例：枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKNOWN_REASON。</code></li></ol><p>15.【参考】各层命名规约：</p><ul><li>Service/DAO层方法命名规约</li></ul><ol><li>获取单个对象的方法用get做前缀。</li><li>获取多个对象的方法用list做前缀。</li><li>获取统计值的方法用count做前缀。</li><li>插入的方法用save（推荐）或insert做前缀。</li><li>删除的方法用remove（推荐）或delete做前缀。</li><li>修改的方法用update做前缀。</li></ol><ul><li>领域模型命名规约</li></ul><ol><li>数据对象：xxxDO，xxx即为数据表名。</li><li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx一般为网页名称。</li><li>POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</li></ol><h2 id="1-2-常量定义"><a href="#1-2-常量定义" class="headerlink" title="1.2. 常量定义"></a>1.2. 常量定义</h2><p>1.<strong>【强制】</strong> 不允许出现任何魔法值（即未经定义的常量）直接出现在代码中。</p><ol><li><code>反例： String key=&quot;Id#taobao_&quot;+tradeId；</code></li><li><code>cache.put(key,  value);</code></li></ol><p>2.<strong>【强制】</strong> long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。</p><blockquote><p>说明：Long a = 2l;写的是数字的21，还是Long型的2?</p></blockquote><p>3.<strong>【推荐】</strong> 不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts下。</p><blockquote><p>说明：大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></blockquote><p>4.<em>【推荐】</em> 常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p><ul><li>跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。</li><li>应用内共享常量：放置在一方库的modules中的constant目录下。</li></ul><ol><li><code>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：</code></li><li><code>类A中：public  static final String YES = &quot;yes&quot;;</code></li><li><code>类B中：public  static final String YES = &quot;y&quot;;</code></li><li><code>A.YES.equals(B.YES)，预期是true，但实际返回为false，导致产生线上问题。</code></li></ol><ul><li>子工程内部共享常量：即在当前子工程的constant目录下。</li><li>包内共享常量：即在当前包下单独的constant目录下。</li><li>类内共享常量：直接在类内部private static final定义。</li></ul><p>5.<em>【推荐】</em> 如果变量值仅在一个范围内变化用Enum类。如果还带有名称之外的延伸属性，必须使用Enum类，下面正例中的数字就是延伸信息，表示星期几。</p><ol><li><code>正例：publicEnum&#123;MONDAY(1),TUESDAY(2),WEDNESDAY(3),THURSDAY(4),FRIDAY(5),SATURDAY(6), SUNDAY(7);&#125;</code></li></ol><h2 id="1-3-格式规约"><a href="#1-3-格式规约" class="headerlink" title="1.3. 格式规约"></a>1.3. 格式规约</h2><p>1.<strong>【强制】</strong> 大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：</p><ul><li>左大括号前不换行。</li><li>左大括号后换行。</li><li>右大括号前换行。</li><li>右大括号后还有else等代码则不换行；表示终止右大括号后必须换行。</li></ul><p>2.<strong>【强制】</strong> 左括号和后一个字符之间不出现空格；同样，右括号和前一个字符之间也不出现空格。详见第5条下方正例提示。</p><p>3.<strong>【强制】</strong> if/for/while/switch/do等保留字与左右括号之间都必须加空格。</p><p>4.<strong>【强制】</strong> 任何运算符左右必须加一个空格。</p><blockquote><p>说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p></blockquote><p>5.<strong>【强制】</strong> 缩进采用4个空格，禁止使用tab字符。</p><blockquote><p>说明：如果使用tab缩进，必须设置1个tab为4个空格。IDEA设置tab为4个空格时，请勿勾选Use tab character；而在eclipse中，必须勾选insert spaces for tabs。</p></blockquote><ol><li><code>正例：（涉及1-5点）</code></li><li><code>public static void main(String args[]) &#123;</code></li><li><code>//缩进4个空格</code></li><li><code>String say = &quot;hello&quot;;</code></li><li><code>//运算符的左右必须有一个空格</code></li><li><code>int flag = 0;</code></li><li><code>//关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格</code></li><li><code>if (flag == 0) &#123;</code></li><li><code>System.out.println(say);</code></li><li><code>&#125;</code></li><li><code>//左大括号前加空格且不换行；左大括号后换行</code></li><li><code>if (flag == 1) &#123;</code></li><li><code>System.out.println(&quot;world&quot;);</code></li><li><code>//右大括号前换行，右大括号后有else，不用换行</code></li><li><code>&#125; else &#123;</code></li><li><code>System.out.println(&quot;ok&quot;);</code></li><li><code>//在右大括号后直接结束，则必须换行</code></li><li><code>&#125;</code></li><li><code>&#125;</code></li></ol><p>6.<strong>【强制】</strong> 单行字符数限制不超过 120个，超出需要换行，换行时遵循如下原则：</p><ul><li>第二行相对第一行缩进 4个空格，从第三行开始，不再继续缩进，参考示例。</li><li>运算符与下文一起换行。</li><li>方法调用的点符号与下文一起换行。</li><li>在多个参数超长，逗号后进行换行。</li><li><p>在括号前不要换行，见反例。</p><ol><li><code>正例：</code></li><li><code>StringBuffer sb = new StringBuffer();</code></li><li><code>//超过120个字符的情况下，换行缩进4个空格，并且方法前的点符号一起换行</code></li><li><code>sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...</code></li><li><code>.append(&quot;huang&quot;)...</code></li><li><code>.append(&quot;huang&quot;)...</code></li><li><code>.append(&quot;huang&quot;);</code></li><li><code>反例：</code></li><li><code>StringBuffer sb = new StringBuffer();</code></li><li><code>//超过120个字符的情况下，不要在括号前换行</code></li><li><code>sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append</code></li><li><code>(&quot;huang&quot;);</code></li><li><code>//参数很多的方法调用可能超过120个字符，不要在逗号前换行</code></li><li><code>method(args1, args2, args3, ...</code></li><li><code>, argsX);</code></li></ol></li></ul><p>7.<strong>【强制】</strong> 方法参数在定义和传入时，多个参数逗号后边必须加空格。</p><ol><li><code>正例：下例中实参的&quot;a&quot;,后边必须要有一个空格。</code></li><li><code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></li></ol><p>8.<strong>【强制】</strong> IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用windows格式。<br>9.<em>【推荐】</em> 没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。</p><ol><li><code>正例：</code></li><li><code>int a = 3;</code></li><li><code>long b = 4L;</code></li><li><code>float c = 5F;</code></li><li><code>StringBuffer sb = new StringBuffer();</code></li><li><code>说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的</code></li></ol><p>10.<em>【推荐】</em> 方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。</p><blockquote><p>说明：没有必要插入多行空格进行隔开。</p></blockquote><h2 id="1-4-OOP规约"><a href="#1-4-OOP规约" class="headerlink" title="1.4. OOP规约"></a>1.4. OOP规约</h2><p>1.<strong>【强制】</strong> 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p><p>2.<strong>【强制】</strong> 所有的覆写方法，必须加<code>@Override</code>注解。</p><ol><li><code>反例：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。</code></li><li><code>另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</code></li></ol><p>3.<strong>【强制】</strong> 相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。</p><blockquote><p>说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）</p></blockquote><ol><li><code>正例：public User getUsers(String type, Integer... ids)</code></li></ol><p>4.<strong>【强制】</strong> 对外暴露的接口签名，原则上不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加<a href="https://github.com/Deprecated" title="@Deprecated">@Deprecated</a>注解，并清晰地说明采用的新接口或者新服务是什么。</p><p>5.<strong>【强制】</strong> 不能使用过时的类或方法。</p><blockquote><p>说明：java.net.URLDecoder中的方法decode(StringencodeStr)这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></blockquote><p>6.<strong>【强制】</strong> Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。</p><ol><li><code>正例： &quot;test&quot;.equals(object);</code></li><li><code>反例： object.equals(&quot;test&quot;);</code></li><li><code>说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）</code></li></ol><p>7.<strong>【强制】</strong>所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。</p><blockquote><p>说明：对于Integer var=?在-128至127之间的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用<code>==</code>进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p></blockquote><p>8.<strong>【强制】</strong> 关于基本数据类型与包装数据类型的使用标准如下：</p><ul><li>所有的POJO类属性必须使用包装数据类型。</li><li>RPC方法的返回值和参数必须使用包装数据类型。</li><li>所有的局部变量【推荐】使用基本数据类型。</li></ul><blockquote><p>说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。</p></blockquote><ol><li><code>正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。</code></li><li><code>反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</code></li></ol><p>9.<strong>【强制】</strong> 定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。</p><ol><li><code>反例：POJO类的gmtCreate默认值为new   Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</code></li></ol><p>10.<strong>【强制】</strong> 序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。</p><blockquote><p>说明：注意serialVersionUID不一致会抛出序列化运行时异常。</p></blockquote><p>11.<strong>【强制】</strong> 构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</p><p>12.<strong>【强制】</strong> POJO类必须写toString方法。使用IDE的中工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。</p><blockquote><p>说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p></blockquote><p>13.<em>【推荐】</em> 使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。</p><blockquote><p>说明：<br>String str = “a,b,c,,”;<br>String[] ary = str.split(“,”);<br>//预期大于3，结果是3<br>System.out.println(ary.length);</p></blockquote><p>14.<em>【推荐】</em> 当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</p><p>15.<em>【推荐】</em> 类内方法定义顺序依次是：公有方法或保护方法 &gt;私有方法 &gt; getter/setter方法。</p><blockquote><p>说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。</p></blockquote><p>16.<em>【推荐】</em> setter方法中，参数名称与类成员变量名称一致，this.成员名=参数名。在getter/setter方法中，尽量不要增加业务逻辑，增加排查问题的难度。</p><ol><li><code>反例：</code></li><li><code>public Integer getData()&#123;</code></li><li><code>if(true)  &#123;</code></li><li><code>return data + 100;</code></li><li><code>&#125; else &#123;</code></li><li><code>return data - 100;</code></li><li><code>&#125;</code></li><li><code>&#125;</code></li></ol><p>17.<em>【推荐】</em> 循环体内，字符串的联接方式，使用StringBuilder的append方法进行扩展。</p><ol><li><code>反例：</code></li><li><code>String str = &quot;start&quot;;</code></li><li><code>for(int i=0; i&lt;100; i++)&#123;</code></li><li><code>str = str + &quot;hello&quot;;</code></li><li><code>&#125;</code></li><li><code>说明：反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。</code></li></ol><p>18.<em>【推荐】</em> final可提高程序响应效率，声明成final的情况：</p><ul><li>不需要重新赋值的变量，包括类属性、局部变量。</li><li>对象参数前加final，表示不允许修改引用的指向。</li><li>类方法确定不允许被重写。</li></ul><p>19.<em>【推荐】</em> 慎用Object的clone方法来拷贝对象。</p><blockquote><p>说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现属性对象的拷贝。</p></blockquote><p>20.<em>【推荐】</em> 类成员与方法访问控制从严：</p><ul><li>如果不允许外部直接通过new来创建对象，那么构造方法必须是private。</li><li>工具类不允许有public或default构造方法。</li><li>类非static成员变量并且与子类共享，必须是protected。</li><li>类非static成员变量并且仅在本类使用，必须是private。</li><li>类static成员变量如果仅在本类使用，必须是private。</li><li>若是static成员变量，必须考虑是否为final。</li><li>类成员方法只供类内部调用，必须是private。</li><li>类成员方法只对继承类公开，那么限制为protected。</li></ul><blockquote><p>说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。</p></blockquote><h2 id="1-5-集合处理"><a href="#1-5-集合处理" class="headerlink" title="1.5. 集合处理"></a>1.5. 集合处理</h2><p>1.<strong>【强制】</strong> 关于hashCode和equals的处理，遵循如下规则：</p><ul><li>只要重写equals，就必须重写hashCode。</li><li>因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。</li><li>如果自定义对象做为Map的键，那么必须重写hashCode和equals。</li></ul><ol><li><code>正例：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</code></li></ol><p>2.<strong>【强制】</strong> ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;</p><blockquote><p>说明：subList返回的是 ArrayList的内部类 SubList，并不是 ArrayList，而是ArrayList的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</p></blockquote><p>3.<strong>【强制】</strong> 在subList场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生ConcurrentModificationException异常。</p><p>4.<strong>【强制】</strong> 使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。</p><ol><li><code>反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。</code></li><li><code>正例：</code></li><li><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;(2);</code></li><li><code>list.add(&quot;guan&quot;);</code></li><li><code>list.add(&quot;bao&quot;);</code></li><li><code>String[] array = new String[list.size()];</code></li><li><code>array = list.toArray(array);</code></li><li><code>说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配</code></li><li><code>内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组</code></li><li><code>元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素</code></li><li><code>个数一致。</code></li></ol><p>5.<strong>【强制】</strong> 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。</p><blockquote><p>说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p></blockquote><ol><li><code>String[] str = new String[] &#123; &quot;a&quot;, &quot;b&quot; &#125;;</code></li><li><code>List list = Arrays.asList(str);</code></li><li><code>第一种情况：list.add(&quot;c&quot;);运行时异常。</code></li><li><code>第二种情况：str[0]= &quot;gujin&quot;;那么list.get(0)也会随之修改。</code></li></ol><p>6.<strong>【强制】</strong> 泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用add方法。</p><blockquote><p>说明：苹果装箱后返回一个<code>&lt;? extends Fruits&gt;</code>对象，此对象就不能往里加任何水果，包括苹果。</p></blockquote><p>7.<strong>【强制】</strong> 不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。</p><ol><li><code>反例：</code></li><li><code>List&lt;String&gt; a = new ArrayList&lt;String&gt;();</code></li><li><code>a.add(&quot;1&quot;);</code></li><li><code>a.add(&quot;2&quot;);</code></li><li><code>for (String temp : a) &#123;</code></li><li><code>if(&quot;1&quot;.equals(temp))&#123;</code></li><li><code>a.remove(temp);</code></li><li><code>&#125;</code></li><li><code>&#125;</code></li><li><code>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的</code></li><li><code>结果吗？</code></li><li><code>正例：</code></li><li><code>Iterator&lt;String&gt; it = a.iterator();</code></li><li><code>while(it.hasNext())&#123;</code></li><li><code>String temp = it.next();</code></li><li><code>if(删除元素的条件)&#123;</code></li><li><code>it.remove();</code></li><li><code>&#125;</code></li><li><code>&#125;</code></li></ol><p>8.<strong>【强制】</strong> 在 JDK7版本以上，Comparator要满足自反性，传递性，对称性，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。</p><blockquote><p>说明：</p><p>1）自反性：x，y的比较结果和y，x的比较结果相反。</p><p>2）传递性：x&gt;y,y&gt;z,则x&gt;z。</p><p>3）对称性：x=y,则x,z比较结果和y，z比较结果相同。</p></blockquote><ol><li><code>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</code></li><li><code>new Comparator&lt;Student&gt;() &#123;</code></li><li><code>@Override</code></li><li><code>public int compare(Student o1, Student o2) &#123;</code></li><li><code>return o1.getId() &gt; o2.getId() ? 1 : -1;</code></li><li><code>&#125;</code></li><li><code>&#125;</code></li></ol><p>9.<em>【推荐】</em> 集合初始化时，尽量指定集合初始值大小。</p><blockquote><p>说明：ArrayList尽量使用ArrayList(int initialCapacity)初始化。</p></blockquote><p>10.<em>【推荐】</em> 使用Map.foreach方法遍历Map类</p><p>11.<em>【推荐】</em> 高度注意Map类集合K/V能不能存储null值的情况，如下表格：</p><div class="table-container"><table><thead><tr><th>集合类</th><th>Key</th><th>Value</th><th>Super</th><th>说明</th></tr></thead><tbody><tr><td>Hashtable</td><td>不允许为null</td><td>不允许为null</td><td>Dictionary</td><td>线程安全</td></tr><tr><td>ConcurrentHashMap</td><td>不允许为null</td><td>不允许为null</td><td>AbstractMap</td><td>分段锁技术</td></tr><tr><td>TreeMap</td><td>不允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr><tr><td>HashMap</td><td>允许为null</td><td>允许为null</td><td>AbstractMap</td><td>线程不安全</td></tr></tbody></table></div><ol><li><code>反例：由于HashMap的干扰，很多人认为ConcurrentHashMap是可以置入null值，注意存储null值时会抛出NPE异常。</code></li></ol><p>12.【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。</p><blockquote><p>说明：稳定性指集合每次遍历的元素次序是一定的。有序性是指遍历的结果是按某种比较规则依次排列的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。</p></blockquote><p>13.【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。</p><h2 id="1-6-并发处理"><a href="#1-6-并发处理" class="headerlink" title="1.6. 并发处理"></a>1.6. 并发处理</h2><p>1.<strong>【强制】</strong> 获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p><blockquote><p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p></blockquote><p>2.<strong>【强制】</strong> 创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p><ol><li><code>正例：</code></li><li><code>public class TimerTaskThread extends Thread &#123;</code></li><li><code>public TimerTaskThread()&#123;</code></li><li><code>super.setName(&quot;TimerTaskThread&quot;);  ...</code></li><li><code>&#125;</code></li></ol><p>3.<strong>【强制】</strong> 线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p><blockquote><p>说明：使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></blockquote><p>4.<strong>【强制】</strong> 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><blockquote><p>说明：Executors返回的线程池对象的弊端如下：</p><p>1）FixedThreadPool和SingleThreadPool:</p><p>允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM。</p><p>2）CachedThreadPool和ScheduledThreadPool:</p><p>允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM。</p></blockquote><p>5.<strong>【强制】</strong> SimpleDateFormat是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。</p><ol><li><code>正例：注意线程安全，使用DateUtils。亦推荐如下处理：</code></li><li><code>private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123;</code></li><li><code>@Override</code></li><li><code>protected DateFormat initialValue() &#123;</code></li><li><code>return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</code></li><li><code>&#125;</code></li><li><code>&#125;;</code></li><li><code>说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替Simpledateformatter，</code></li><li><code>官方给出的解释：simple beautiful strong immutable thread-safe。</code></li></ol><p>6.<strong>【强制】</strong> 高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p>7.<strong>【强制】</strong> 对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p><blockquote><p>说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</p></blockquote><p>8.<strong>【强制】</strong> 并发修改同一记录时，避免更新丢失，要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。</p><blockquote><p>说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</p></blockquote><p>9.<strong>【强制】</strong> 多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。</p><p>10.<em>【推荐】</em> 使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法可以执行，避免主线程无法执行至countDown方法，直到超时才返回结果。</p><blockquote><p>说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。</p></blockquote><p>11.<em>【推荐】</em> 避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed导致的性能下降。</p><blockquote><p>说明：Random实例包括java.util.Random的实例或者 Math.random()实例。</p></blockquote><ol><li><code>正例：在JDK7之后，可以直接使用API  ThreadLocalRandom，在 JDK7之前，可以做到每个线程一个实例。</code></li></ol><p>12.<em>【推荐】</em> 通过双重检查锁（double-checked locking）（在并发场景）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration),推荐问题解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。</p><ol><li><code>反例：</code></li><li><code>class Foo &#123;</code></li><li><code>private Helper helper = null;</code></li><li><code>public Helper getHelper() &#123;</code></li><li><code>if (helper == null)  synchronized(this) &#123;</code></li><li><code>if (helper == null)</code></li><li><code>helper = new Helper();</code></li><li><code>&#125;</code></li><li><code>return helper;</code></li><li><code>&#125;</code></li><li><code>// other functions and members...</code></li><li><code>&#125;</code></li></ol><p>13.【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1);如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。</p><p>14.【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中注意规避此风险。</p><p>15.【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p><h2 id="1-7-控制语句"><a href="#1-7-控制语句" class="headerlink" title="1.7. 控制语句"></a>1.7. 控制语句</h2><p>1.<strong>【强制】</strong> 在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。</p><p>2.<strong>【强制】</strong> 在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements;</p><p>3.<em>【推荐】</em> 推荐尽量少用else， if-else的方式可以改写成：</p><ol><li><code>if(condition)&#123;</code></li><li><code>...</code></li><li><code>return obj;</code></li><li><code>&#125;</code></li><li><code>//接着写else的业务逻辑代码;</code></li><li><code>说明：如果非得使用if()...else if()...else...方式表达逻辑，【强制】请勿超过 3层，</code></li><li><code>超过请使用状态设计模式。</code></li><li><code>正例：逻辑上超过 3层的if-else代码可以使用卫语句，或者状态模式来实现。</code></li></ol><p>4.<em>【推荐】</em> 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。</p><blockquote><p>说明：很多 if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？</p></blockquote><ol><li><code>正例：</code></li><li><code>//伪代码如下</code></li><li><code>boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...);</code></li><li><code>if (existed) &#123;</code></li><li><code>...</code></li><li><code>&#125;</code></li><li><code>反例：</code></li><li><code>if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) &#123;</code></li><li><code>...</code></li><li><code>&#125;</code></li></ol><p>5.<em>【推荐】</em> 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。</p><p>6.<em>【推荐】</em> 接口入参保护，这种场景常见的是用于做批量操作的接口。</p><p>7.【参考】方法中需要进行参数校验的场景：</p><ul><li>调用频次低的方法。</li><li>行时间开销很大的方法，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。</li><li>需要极高稳定性和可用性的方法。</li><li>对外提供的开放接口，不管是RPC/API/HTTP接口。</li><li>敏感权限入口。</li></ul><p>8.【参考】方法中不需要参数校验的场景：</p><ul><li>极有可能被循环调用的方法，不建议对参数进行校验。但在方法说明里必须注明外部参数检查。</li><li>底层的方法调用频度都比较高，一般不校验。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。</li><li>被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</li></ul><h2 id="1-8-注释规约"><a href="#1-8-注释规约" class="headerlink" title="1.8. 注释规约"></a>1.8. 注释规约</h2><p>1.<strong>【强制】</strong> 类、类属性、类方法的注释必须使用Javadoc规范，使用<code>/*内容/</code>格式，不得使用<code>//xxx方式</code>。</p><blockquote><p>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p></blockquote><p>2.<strong>【强制】</strong> 所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。</p><blockquote><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p></blockquote><p>3.<strong>【强制】</strong> 所有的类都必须添加创建者信息。</p><p>4.<strong>【强制】</strong> 方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ /注释，注意与代码对齐。</p><p>5.<strong>【强制】</strong> 所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p><p>6.<em>【推荐】</em> 与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。</p><ol><li><code>反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</code></li></ol><p>7.<em>【推荐】</em> 代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。</p><blockquote><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p></blockquote><p>8.【参考】注释掉的代码尽量要配合说明，而不是简单的注释掉。</p><blockquote><p>说明：代码被注释掉有两种可能性：</p><p>1）后续会恢复此段代码逻辑。</p><p>2）永久不用。</p><p>前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p></blockquote><p>9.【参考】对于注释的要求：</p><ul><li>第一、能够准确反应设计思想和代码逻辑；</li><li>第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</li></ul><p>10.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</p><ol><li><code>反例：</code></li><li><code>// put elephant into fridge</code></li><li><code>put(elephant, fridge);</code></li><li><code>方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</code></li></ol><p>11.【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。</p><ul><li>待办事宜（TODO）:（标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。</li><li>错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</li></ul><h2 id="1-9-其他"><a href="#1-9-其他" class="headerlink" title="1.9. 其他"></a>1.9. 其他</h2><p>1.<strong>【强制】</strong> 在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。</p><blockquote><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则);</p></blockquote><p>2.<strong>【强制】</strong> velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。</p><blockquote><p>说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。</p></blockquote><p>3.<strong>【强制】</strong> 后台输送给页面的变量必须加$!{var}——中间的感叹号。</p><blockquote><p>说明：如果var=null或者不存在，那么${var}会直接显示在页面上。</p></blockquote><p>4.<strong>【强制】</strong> 注意 Math.random()这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。</p><p>5.<strong>【强制】</strong> 获取当前毫秒数System.currentTimeMillis();而不是new Date().getTime();</p><blockquote><p>说明：如果想获取更加精确的纳秒级时间值，用System.nanoTime()。在JDK8中，针对统计时间等场景，推荐使用Instant类。</p></blockquote><p>6.<em>【推荐】</em> 尽量不要在视图中加入变量声明、逻辑运算符，更不要在视图模板中加入任何复杂的逻辑。</p><blockquote><p>说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。</p></blockquote><p>7.<em>【推荐】</em> 任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p><p>8.<em>【推荐】</em> 对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</p><h1 id="3-MySQL规约"><a href="#3-MySQL规约" class="headerlink" title="3. MySQL规约"></a>3. MySQL规约</h1><h2 id="3-1-建表规约"><a href="#3-1-建表规约" class="headerlink" title="3.1. 建表规约"></a>3.1. 建表规约</h2><p>1.<strong>【强制】</strong> 表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsignedtinyint（ 1表示是，0表示否），此规则同样适用于odps建表。</p><blockquote><p>说明：任何字段如果为非负数，必须是unsigned。</p></blockquote><p>2.<strong>【强制】</strong> 表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p><ol><li><code>正例：getter_admin，task_config，level3_name</code></li><li><code>反例：GetterAdmin，taskConfig，level_3_name</code></li></ol><p>3.<strong>【强制】</strong> 表名不使用复数名词。</p><blockquote><p>说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。</p></blockquote><p>4.<strong>【强制】</strong> 禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。</p><p>5.<strong>【强制】</strong> 唯一索引名为uk<em>字段名；普通索引名则为idx</em>字段名。</p><blockquote><p>说明：uk<em>即 unique key；idx</em>即index的简称。</p></blockquote><p>6.<strong>【强制】</strong> 小数类型为decimal，禁止使用float和double。</p><blockquote><p>说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。</p></blockquote><p>7.<strong>【强制】</strong> 如果存储的字符串长度几乎相等，使用char定长字符串类型。</p><p>8.<strong>【强制】</strong> varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p><p>9.<strong>【强制】</strong> 表必备三字段：id, gmt_create, gmt_modified。</p><blockquote><p>说明：其中id必为主键，类型为unsigned bigint、单表时自增、步长为1。gmt_create,gmt_modified的类型均为date_time类型。</p></blockquote><p>10.<em>【推荐】</em> 表的命名最好是加上“业务名称_表的作用”。</p><ol><li><code>正例：tiger_task / tiger_reader / mpp_config</code></li></ol><p>11.<em>【推荐】</em> 库名与应用名称尽量一致。</p><p>12.<em>【推荐】</em> 如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p><p>13.<em>【推荐】</em> 字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：</p><ul><li>不是频繁修改的字段。</li><li>不是varchar超长字段，更不能是text字段。</li></ul><ol><li><code>正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</code></li></ol><p>14.<em>【推荐】</em> 单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。</p><blockquote><p>说明：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></blockquote><p>15.【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><ol><li><code>正例：人的年龄用unsigned tinyint（表示范围0-255，人的寿命不会超过255岁）；海龟就必须是smallint，但如果是太阳的年龄，就必须是int；如果是所有恒星的年龄都加起来，那么就必须使用bigint。</code></li></ol><h2 id="3-2-索引规约"><a href="#3-2-索引规约" class="headerlink" title="3.2. 索引规约"></a>3.2. 索引规约</h2><p>1.<strong>【强制】</strong> 业务上具有唯一特性的字段，即使是组合字段，也必须建成唯一索引。</p><blockquote><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验和控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></blockquote><p>2.<strong>【强制】</strong> 超过三个表禁止join。需要join的字段，数据类型保持绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p><blockquote><p>说明：即使双表join也要注意表索引、SQL性能。</p></blockquote><p>3.<strong>【强制】</strong> 在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度。</p><blockquote><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用<code>count(distinct left(列名,索引长度))/count(*)</code> 的区分度来确定。</p></blockquote><p>4.<strong>【强制】</strong> 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p><blockquote><p>说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></blockquote><p>5.<em>【推荐】</em> 如果有order by的场景，请注意利用索引的有序性。order by最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。</p><ol><li><code>正例：where a=? and b=? order  by c;索引：a_b_c</code></li><li><code>反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY  b;索引a_b无法排序。</code></li></ol><p>6.<em>【推荐】</em> 利用覆盖索引来进行查询操作，来避免回表操作。</p><blockquote><p>说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。</p></blockquote><ol><li><code>正例：能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用explain的结果，extra列会出现：using  index。</code></li></ol><p>7.<em>【推荐】</em> 利用延迟关联或者子查询优化超多分页场景。</p><blockquote><p>说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。</p></blockquote><ol><li><code>正例：先快速定位需要获取的id段，然后再关联：</code></li><li><code>SELECT a.* FROM表1  a, (select id from表1 where条件  LIMIT 100000,20 ) b where a.id=b.id</code></li></ol><p>8.<em>【推荐】</em> SQL性能优化的目标：至少要达到 range级别，要求是ref级别，如果可以是consts最好。</p><blockquote><p>说明：</p><p>1）consts单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p><p>2）ref指的是使用普通的索引（normal index）。</p><p>3）range对索引进行范围检索。</p></blockquote><ol><li><code>反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</code></li></ol><p>9.<em>【推荐】</em> 建组合索引的时候，区分度最高的在最左边。</p><ol><li><code>正例：如果where a=? and b=?，a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。</code></li><li><code>说明：存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：wherea&gt;?and b=?那么即使a的区分度更高，也必须把b放在索引的最前列。</code></li></ol><p>10.【参考】创建索引时避免有如下极端误解：</p><ul><li>误认为一个查询就需要建一个索引。</li><li>误认为索引会消耗空间、严重拖慢更新和新增速度。</li><li>误认为唯一索引一律需要在应用层通过“先查后插”方式解决。</li></ul><h2 id="3-3-SQL规约"><a href="#3-3-SQL规约" class="headerlink" title="3.3. SQL规约"></a>3.3. SQL规约</h2><p>1.<strong>【强制】</strong> 不要使用count(列名)或count(常量)来替代<code>count(*)</code>，<code>count(*)</code>就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。</p><blockquote><p>说明：<code>count(*)</code>会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p></blockquote><p>2.<strong>【强制】</strong> count(distinct col)计算该列除NULL之外的不重复数量。注意 count(distinctcol1, col2)如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p><p>3.<strong>【强制】</strong> 当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。</p><ol><li><code>正例：可以使用如下方式来避免sum的NPE问题：SELECT   IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</code></li></ol><p>4.<strong>【强制】</strong> 使用ISNULL()来判断是否为NULL值。注意：NULL与任何值的直接比较都为NULL。</p><blockquote><p>说明：</p><p>1） NULL&lt;&gt;NULL的返回结果是NULL，而不是false。</p><p>2） NULL=NULL的返回结果是NULL，而不是true。</p><p>3） NULL&lt;&gt;1的返回结果是NULL，而不是true。</p></blockquote><p>5.<strong>【强制】</strong> 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。</p><p>6.<strong>【强制】</strong> 不得使用外键与级联，一切外键概念必须在应用层解决。</p><blockquote><p>说明：（概念解释）学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></blockquote><p>7.<strong>【强制】</strong> 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p><p>8.<strong>【强制】</strong> 数据订正时，删除和修改记录时，要先select，避免出现误删除，确认无误才能执行更新语句。</p><p>9.<em>【推荐】</em> in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。</p><p>10.【参考】如果有全球化需要，所有的字符存储与表示，均以utf-8编码，那么字符计数方法</p><blockquote><p>注意：</p><p>说明：</p><p>SELECT LENGTH(“轻松工作”)；返回为12</p><p>SELECT CHARACTER_LENGTH(“轻松工作”)；返回为4</p><p>如果要使用表情，那么使用utfmb4来进行存储，注意它与utf-8编码的区别。</p></blockquote><p>11.【参考】TRUNCATETABLE比 DELETE速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。</p><blockquote><p>说明：TRUNCATE TABLE在功能上与不带 WHERE子句的 DELETE语句相同。</p></blockquote><h2 id="3-4-ORM规约"><a href="#3-4-ORM规约" class="headerlink" title="3.4. ORM规约"></a>3.4. ORM规约</h2><p>1.<strong>【强制】</strong> 在表查询中，一律不要使用 <code>*</code>作为查询的字段列表，需要哪些字段必须明确写明。</p><blockquote><p>说明：</p><p>1）增加查询分析器解析成本。</p><p>2）增减字段容易与resultMap配置不一致。</p></blockquote><p>2.<strong>【强制】</strong> POJO类的boolean属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。</p><blockquote><p>说明：参见定义POJO类以及数据库字段定义规定，在sql.xml增加映射，是必须的。</p></blockquote><p>3.<strong>【强制】</strong> 不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。</p><blockquote><p>说明：配置映射关系，使字段与DO类解耦，方便维护。</p></blockquote><p>4.<strong>【强制】</strong> xml配置中参数注意使用：#{} ，不要使用${}，此种方式容易出现SQL注入。</p><p>5.<strong>【强制】</strong> iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。</p><blockquote><p>说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合，线上因为这个原因曾经出现过OOM。</p></blockquote><ol><li><code>正例：在sqlmap.xml中引入  #start#, #size#</code></li><li><code>Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();</code></li><li><code>map.put(&quot;start&quot;, start);</code></li><li><code>map.put(&quot;size&quot;, size);</code></li></ol><p>6.<strong>【强制】</strong> 不允许直接拿HashMap与Hashtable作为查询结果集的输出。</p><p>7.<strong>【强制】</strong> 更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。</p><p>8.<strong>【推荐】</strong> 不要写一个大而全的数据更新接口，传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3;这是不对的。执行SQL时，尽量不要更新无改动的字段，一是易出错；二是效率低；三是binlog增加存储。</p><p>9.【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p><p>10.【参考】中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；表示不为空且不为null时执行；表示不为null值时执行。</p><h1 id="4-工程规约"><a href="#4-工程规约" class="headerlink" title="4. 工程规约"></a>4. 工程规约</h1><h2 id="4-1-应用分层"><a href="#4-1-应用分层" class="headerlink" title="4.1. 应用分层"></a>4.1. 应用分层</h2><ol><li>【推荐】默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推：</li></ol><p><img src="F:\笔记\博客\文章图片\分层.png" alt="分层"></p><ul><li>开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。</li><li>终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。</li><li>Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li>Service层：相对具体的业务逻辑服务层。</li><li>Manager层：通用业务处理层，它有如下特征：</li></ul><p>1 ） 对第三方平台封装的层，预处理返回结果及转化异常信息；</p><p>2 ） 对Service层通用能力的下沉，如缓存方案、中间件通用处理；</p><p>3 ） 与DAO层交互，对多个DAO的组合复用。</p><ul><li>DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。</li><li>外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</li></ul><ol><li><p>【参考】 （分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p></li></ol><ul><li>DO（Data Object）：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象。由Service层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象。在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用Map类来传输。</li></ul><h2 id="4-2-二方库依赖"><a href="#4-2-二方库依赖" class="headerlink" title="4.2. 二方库依赖"></a>4.2. 二方库依赖</h2><ol><li>【强制】定义GAV遵从以下规则：</li></ol><p>1 ） GroupID格式：<code>com.&#123;公司/BU &#125;.业务线.[子业务线]</code>，最多 4 级。<br>说明：<code>&#123;公司/BU&#125;</code> 例如：<code>alibaba/taobao/tmall/aliexpress</code>等BU一级；子业务线可选。<br>正例：<code>com.taobao.jstorm</code>或 <code>com.alibaba.dubbo.register</code><br>2 ） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br>正例：<code>dubbo-client / fastjson-api / jstorm-tool</code><br>3 ） Version：详细规定参考下方。</p><ol><li>【强制】二方库版本号命名方式：<code>主版本号.次版本号.修订号</code></li></ol><p>1 ） 主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。<br>2 ） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。<br>3 ） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。<br>说明：注意起始版本号必须为：1.0.0，而不是0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0</p><ol><li><p>【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。<br>说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行<code>dependency:resolve</code>前后信息比对，如果仲裁结果完全不一致，那么通过<code>dependency:tree</code>命令，找出差异点，进行排除jar包。</p></li><li>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。</li><li>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br>说明：依赖<code>springframework-core、-context、-beans</code>，它们都是同一个版本，可以定义一个变量来保存版本：<code>$&#123;spring.version&#125;</code>，定义依赖的时候，引用该版本。</li><li>【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。<br>说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。</li><li>【推荐】所有pom文件中的依赖声明放在<code>&lt;dependencies&gt;</code>语句块中，所有版本仲裁放在<code>&lt;dependencyManagement&gt;</code>语句块中<br>说明：<code>&lt;dependencyManagement&gt;</code>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<code>&lt;dependencies&gt;</code>所有声明在主pom的<code>&lt;dependencies&gt;</code>里的依赖都会自动引入，并默认被所有的子项目继承。</li><li>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</li><li>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br>1 ）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。<br>2 ）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</li></ol><h2 id="4-3-服务器"><a href="#4-3-服务器" class="headerlink" title="4.3. 服务器"></a>4.3. 服务器</h2><ol><li><p>【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。<br>说明：操作系统默认 240 秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。<br>正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout = 30</p></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。<br>说明：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为 1024 ，当并发连接数很大时很容易因为fd不足而出现<code>open too many files</code>错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p></li><li>【推荐】给JVM设置<code>-XX:+HeapDumpOnOutOfMemoryError</code>参数，让JVM碰到OOM场景时输出dump信息。<br>说明：OOM的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。</li><li>【推荐】在线上生产环境，JVM的<code>Xms和Xmx</code>设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。</li><li>【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-12-Java%E5%88%9D%E7%BA%A7/"/>
      <url>/2024/10/28/2023-02-12-Java%E5%88%9D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-认识java"><a href="#1-认识java" class="headerlink" title="1. 认识java"></a>1. 认识java</h1><p><strong>JSE</strong></p><p>主要用于编写C/S项目和提供标准的JAVA类库，是所有基于Java语言开发的基础</p><p><strong>JME</strong></p><p>嵌入式开发，向手机里的软件、掌上电脑等等</p><p><strong>JEE</strong></p><p>用来构建大型网站和B/S系统 ，作为一个企业版本，主要是给出一个开发企业级应用架构的解决方案，同时给出了在这个架构中相关组件以供开发人员使用</p><p><strong>classpath</strong></p><p>操作系统利用classpath变量来寻找当前后缀为class的字节码文件所存放的路径，并以最先找到的为准。从JDK1.6开始，不需要手动设置</p><p><strong>JAVA_HOME</strong></p><p>JAVA_HOME是一个约定，通常它指的是JDK的目录。如果需要JDK的话，大部分程序会默认去环境变量中取JAVA_HOME这个变量。</p><p><strong>JVM</strong></p><p>JVM是Java Virtual Machine的缩写。它是一种基于计算设备的规范，是一台虚拟机，即虚构的计算机。</p><p>JVM屏蔽了具体操作系统平台的信息（显然，就像是我们在电脑上开了个虚拟机一样），当然，JVM执行字节码时实际上还是要解释成具体操作平台的机器指令的。</p><p>通过JVM，Java实现了平台无关性，Java语言在不同平台运行时不需要重新编译，只需要在该平台上部署JVM就可以了。因而能实现一次编译多处运行。(就像是你的虚拟机也可以在任何安了VMWare的系统上运行)</p><p><strong>JRE</strong></p><p>JRE是Java Runtime Environment的缩写，也就是JVM的运行平台，联系平时用的虚拟机，大概可以理解成JRE=虚拟机平台+虚拟机本体(JVM)。类似于你电脑上的VMWare+适用于VMWare的Ubuntu虚拟机。这样我们也就明白了JVM到底是个什么</p><p><strong>JDK</strong></p><p>Java Develop Kit，Java的开发工具包，JDK本体也是Java程序，因此运行依赖于JRE，由于需要保持JDK的独立性与完整性，JDK的安装目录下通常也附有JRE。目前Oracle提供的Windows下的JDK安装工具会同时安装一个正常的JRE和隶属于JDK目录下的JRE</p><p><strong>Java命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">javac　编译源文件生成字节码文件</span><br><span class="line"></span><br><span class="line">java      运行字节码文件</span><br><span class="line"></span><br><span class="line">javadoc   由源文件中的文档注释生成html文档文件</span><br><span class="line"></span><br><span class="line">-d 指定文档生成路径 </span><br><span class="line">-encoding 设置文档编码</span><br><span class="line">-charset 设置字符编码</span><br><span class="line"></span><br><span class="line">javap   反编译显示类成员变量和成员函数首部</span><br><span class="line"></span><br><span class="line">jar   把一些类的字节码文件压缩成一个jar文件</span><br></pre></td></tr></table></figure><p><strong>开源JDK</strong></p><p>Open JDK<br><a href="https://openjdk.java.net/">https://openjdk.java.net/</a></p><p>Adopt Open JDK<br><a href="https://adoptopenjdk.net/">https://adoptopenjdk.net/</a></p><p>Amazon Corretto（推荐）<br><a href="https://aws.amazon.com/cn/corretto/">https://aws.amazon.com/cn/corretto/</a></p><h1 id="2-Java8新特性"><a href="#2-Java8新特性" class="headerlink" title="2. Java8新特性"></a>2. Java8新特性</h1><ul><li>Lambda表达式：Lambda表达式是一种简洁的语法，用于表示匿名函数。它们可以被视为是一种函数式编程的核心，可以使代码更加简洁和易于阅读。</li><li>Stream API：Stream API提供了一种新的处理集合数据的方式，它可以使代码更加简洁和易于阅读。它可以让你以声明式的方式进行操作，而不是使用迭代器进行循环。</li><li>新的日期和时间API：Java 8引入了一种新的日期和时间API，它提供了一种更加简单和易于使用的方式来处理日期和时间。它提供了一些新的类，如LocalDate、LocalTime和Instant，以及一些新的方法，如plusDays()和minusHours()。</li><li>接口的默认方法：Java 8允许接口中包含默认方法，这些方法可以在接口中进行实现。这就使得接口可以更加灵活，可以在不破坏现有实现的情况下进行扩展。</li><li>方法引用：方法引用是一种简洁的语法，用于表示对方法的引用。它可以使代码更加简洁和易于阅读。</li></ul><h1 id="3-值传递-amp-引用传递"><a href="#3-值传递-amp-引用传递" class="headerlink" title="3. 值传递&amp;引用传递"></a>3. 值传递&amp;引用传递</h1><p>Java中的参数传递方式是值传递。对于对象类型的参数，传递的是对象的引用（内存地址），因此看起来像是引用传递。但实际上，传递的是引用的值，而不是引用本身。因此，在函数或方法中重新赋值对象的引用不会影响到原始值，但对对象内部状态（属性值）的修改会影响到原始值。</p><h2 id="3-1-值传递"><a href="#3-1-值传递" class="headerlink" title="3.1. 值传递"></a>3.1. 值传递</h2><p>值传递是指在函数或方法中，<strong>将参数的值复制一份传递给函数或方法</strong>。在函数或方法中对参数的修改不会影响到原始值。这种传递方式常见于基本数据类型（例如int、double等）和不可变对象（例如String、Integer等）</p><p>例如，以下代码中的swap方法采用的是值传递的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    swap(x, y);</span><br><span class="line">    System.out.println(<span class="string">&quot;x = &quot;</span> + x + <span class="string">&quot;, y = &quot;</span> + y); <span class="comment">// 输出 x = 10, y = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-引用传递"><a href="#3-2-引用传递" class="headerlink" title="3.2. 引用传递"></a>3.2. 引用传递</h2><p>引用传递是指在函数或方法中，<strong>将参数的引用（内存地址）传递给函数或方法</strong>。在函数或方法中对参数的修改会影响到原始值。这种传递方式常见于可变对象（例如数组、集合等）。</p><p>例如，以下代码中的add方法采用的是引用传递的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(List&lt;Integer&gt; list, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    list.add(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    add(list, <span class="number">10</span>);</span><br><span class="line">    System.out.println(list); <span class="comment">// 输出 [10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-Java规范"><a href="#4-Java规范" class="headerlink" title="4. Java规范"></a>4. Java规范</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">区分大小写</span><br><span class="line">强类型语言</span><br><span class="line">文件名与类名，即main()所在类相同</span><br><span class="line">一个Java文件中只能有一个public类</span><br><span class="line">Java中字符和字符串都用Unicode编码表示</span><br><span class="line">在Unicode编码中一个字符占两个字节</span><br></pre></td></tr></table></figure><h1 id="5-Java文件命名"><a href="#5-Java文件命名" class="headerlink" title="5. Java文件命名"></a>5. Java文件命名</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个Java文件中只能有一个public类</span><br><span class="line">如果文件中只有一个类，文件名必须与类名一致</span><br><span class="line">如果文件中不止一个类，文件名必须与public类名一致</span><br><span class="line">如果文件中不止一个类，而且没有public类，文件名可与任一类名一致</span><br></pre></td></tr></table></figure><h1 id="6-注释"><a href="#6-注释" class="headerlink" title="6. 注释"></a>6. 注释</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">注释一行</span><br><span class="line">//</span><br><span class="line">注释多行</span><br><span class="line">/*  */</span><br><span class="line">文档注释</span><br><span class="line">/**</span><br><span class="line">*</span><br><span class="line">*</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="7-关键字"><a href="#7-关键字" class="headerlink" title="7. 关键字"></a>7. 关键字</h1><p>关键字的字母全部小写 </p><h1 id="8-标识符"><a href="#8-标识符" class="headerlink" title="8. 标识符"></a>8. 标识符</h1><p>包含：类名、变量名、常量名、方法名….</p><p>格式：以字母、下划线、<script type="math/tex">`开始，后面可跟字母、下划线、`</script>、数字</p><h1 id="9-数据类型"><a href="#9-数据类型" class="headerlink" title="9. 数据类型"></a>9. 数据类型</h1><h2 id="9-1-基本数据类型"><a href="#9-1-基本数据类型" class="headerlink" title="9.1. 基本数据类型"></a>9.1. 基本数据类型</h2><p>八大基本类型</p><p><strong>数值型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">整数类型</span><br><span class="line"><span class="comment">// 整数默认是int类型，如果数字过大，则必须在末尾加 L 否则会出错</span></span><br><span class="line"><span class="type">byte</span> </span><br><span class="line">占一个字节，数字大小为 -<span class="number">2</span>^<span class="number">7</span>——<span class="number">2</span>^<span class="number">7</span>-<span class="number">1</span>，默认值为 <span class="number">0</span></span><br><span class="line"><span class="type">short</span></span><br><span class="line">占两个字节，数字大小为 -<span class="number">2</span>^<span class="number">15</span>——<span class="number">2</span>^<span class="number">15</span>-<span class="number">1</span>，默认值为 <span class="number">0</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">占四个字节，数字大小为 -<span class="number">2</span>^<span class="number">31</span>———<span class="number">2</span>^<span class="number">31</span>-<span class="number">1</span>，默认值为 <span class="number">0</span></span><br><span class="line"><span class="type">long</span></span><br><span class="line">占八个字节，数字大小为 -<span class="number">2</span>^<span class="number">63</span>——<span class="number">2</span>^<span class="number">63</span>-<span class="number">1</span>，默认值为 <span class="number">0L</span></span><br><span class="line"></span><br><span class="line">浮点型</span><br><span class="line"><span class="comment">// 实数默认是double类型，如果希望一个实数是float类型，可以在数字后加 F</span></span><br><span class="line"><span class="type">float</span></span><br><span class="line">占用四个字节，默认值为 <span class="number">0.0F</span></span><br><span class="line"><span class="type">double</span></span><br><span class="line">占八个字节，默认值为 <span class="number">0.0</span></span><br></pre></td></tr></table></figure><p><strong>字符型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单引号包裹</span></span><br><span class="line"><span class="type">char</span></span><br><span class="line">占两个字节，数字大小为<span class="number">0</span>——<span class="number">2</span>^<span class="number">16</span>-<span class="number">1</span>，是Unicode编码，默认值为 <span class="string">&#x27;\u0000&#x27;</span>（空字符）</span><br></pre></td></tr></table></figure><p><strong>布尔型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span></span><br><span class="line">占一个字节，默认值为 <span class="literal">false</span>，只有两个值：<span class="literal">true</span>和<span class="literal">false</span>，且它们不能对应于任何整数值</span><br></pre></td></tr></table></figure><h2 id="9-2-引用数据类型"><a href="#9-2-引用数据类型" class="headerlink" title="9.2. 引用数据类型"></a>9.2. 引用数据类型</h2><p>类、接口、数组</p><h2 id="9-3-Java中的引用（重点）"><a href="#9-3-Java中的引用（重点）" class="headerlink" title="9.3. Java中的引用（重点）"></a>9.3. Java中的引用（重点）</h2><p>在Java中，引用是指一个对象的内存地址。当创建一个对象时，Java会在堆上为其分配内存，并返回一个引用，该引用指向该对象的内存地址。可以使用该引用来访问该对象</p><p>需要注意的是，<strong>Java中的引用是强引用</strong>。这意味着只要引用存在，垃圾收集器就不会释放该对象的内存。如果程序员不再需要该对象，可以将引用设置为null，这样垃圾收集器就可以释放该对象的内存</p><h2 id="9-4-拓展"><a href="#9-4-拓展" class="headerlink" title="9.4. 拓展"></a>9.4. 拓展</h2><p><strong>特殊字符</strong></p><p>反斜线 <code>\\</code>、退格 <code>\b</code>、回车 <code>\r</code>、制表符 <code>\t</code>、换行 <code>\n</code>、单引号 <code>&#39;</code></p><p><strong>进制整数</strong></p><p>Java中二进制0b开头、八进制0开头、十六进制0x开头</p><p><strong>浮点数拓展</strong></p><p>BigDecimal类（金融计算常用）</p><h1 id="10-类型转换"><a href="#10-类型转换" class="headerlink" title="10. 类型转换"></a>10. 类型转换</h1><h2 id="10-1-自动转换"><a href="#10-1-自动转换" class="headerlink" title="10.1. 自动转换"></a>10.1. 自动转换</h2><p>把小容量的类型转换为容量大的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如</span><br><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="10-2-强制转换"><a href="#10-2-强制转换" class="headerlink" title="10.2. 强制转换"></a>10.2. 强制转换</h2><p>把大容量的类型转换为容量小的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">88.88</span>;</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不能对boolean类型进行类型转换</span><br><span class="line"></span><br><span class="line">把大容量的类型转换为容量小的类型时，容易缺失精度</span><br><span class="line"></span><br><span class="line">整型、实型、字符型数据可混合运算，但要先转换为统一类型，转换从低级到高级（如：byte转int，因为byte占1字节，int占4字节，byte转int不丢失数据）</span><br></pre></td></tr></table></figure><h1 id="11-变量"><a href="#11-变量" class="headerlink" title="11. 变量"></a>11. 变量</h1><p>程序运行过程中，值可以改变的量，实质是内存上的一块空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型 变量名 = 变量值</span><br><span class="line">如</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><strong>类变量</strong></p><p>static修饰的变量</p><p><strong>实例变量</strong></p><p>实例变量，从属于对象，若不对变量进行初始化，则布尔值，默认false，除了基本类型默认值为0，其余的默认值都是null</p><p><strong>局部变量</strong></p><p>局部变量必须初始化即赋值后才可以使用，如果局部变量未赋值，编译无法通过。</p><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类变量 static</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> password;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例变量 ：从属于对象</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// main方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//局部变量</span></span><br><span class="line">        String $_a=<span class="string">&quot;asd&quot;</span>;</span><br><span class="line">        System.out.println($_a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="12-常量"><a href="#12-常量" class="headerlink" title="12. 常量"></a>12. 常量</h1><p>初始化后不能再改变值，常量名一般全大写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line">例</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">30</span>;</span><br></pre></td></tr></table></figure><p>final可以修饰成员方法，成员变量、类</p><p><strong>修饰方法</strong></p><p>表明方法是最终方法，不能被重写</p><p><strong>修饰变量</strong></p><p>表明变量是常量，不能再次被赋值</p><p><strong>修饰类</strong></p><p>表明类是最终类，不能被继承</p><p><strong>修饰局部变量</strong></p><p>变量是基本类型。表示基本数据类型的数据值不能发送改变</p><p>变量是引用类型。表示引用类型的地址值不能发生改变，但是地址里面的内容可以发生改变</p><h1 id="13-运算符"><a href="#13-运算符" class="headerlink" title="13. 运算符"></a>13. 运算符</h1><p><strong>优先级问题</strong></p><p>使用括号<code>()</code>解决优先级问题</p><h2 id="13-1-算术运算符"><a href="#13-1-算术运算符" class="headerlink" title="13.1. 算术运算符"></a>13.1. 算术运算符</h2><p>加<code>+</code> 、减<code>-</code>、乘<code>*</code>、除<code>/</code></p><p>运算结果和运算对象的类型有关，若运算对象中有一个是浮点型，则结果也为浮点型，否则为整型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AAA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        System.out.println(a/b); <span class="comment">//结果为 3.3333333</span></span><br><span class="line">        System.out.println(a/b); <span class="comment">//结果为 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取余<code>%</code></p><p>允许取余运算的被除数和除数是实数，所得的余数的正负只和被除数相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1</span>%-<span class="number">0.3</span>); <span class="comment">//结果为0.10000000000000003</span></span><br></pre></td></tr></table></figure><p><strong>字符的<code>+</code>操作</strong></p><p>拿字符的ASCII码来进行计算</p><p>当算术表达式包含多个基本数据类型的时候，整个算数表达式的类型会自动进行提升</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">byte类型，short类型和char类型都被提升到int类型</span><br><span class="line">整个表达式自动提升到表达式中最高等级操作数同样的类型</span><br></pre></td></tr></table></figure><p><strong>字符串的<code>+</code>操作</strong></p><p>当<code>+</code>操作中出现字符串时，<code>+</code>表示字符串的连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;123&quot;</span> + <span class="string">&quot;abc&quot;</span> 结果 <span class="string">&quot;123abc&quot;</span></span><br></pre></td></tr></table></figure><p>当连续进行<code>+</code>操作时，从左到右逐个执行(可以把非字符串转换成字符串)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;x&quot;</span> + <span class="number">32</span> + <span class="number">1</span> 结果 <span class="string">&quot;x321&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="number">32</span> + <span class="number">1</span> + <span class="string">&quot;x&quot;</span> 结果 <span class="string">&quot;33x&quot;</span></span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>); <span class="comment">//结果为 98</span></span><br><span class="line">System.out.print(<span class="string">&quot;&quot;</span> + <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>);  <span class="comment">//结果为a1</span></span><br></pre></td></tr></table></figure><h2 id="13-2-关系运算符"><a href="#13-2-关系运算符" class="headerlink" title="13.2. 关系运算符"></a>13.2. 关系运算符</h2><p><code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>!=</code>、<code>==</code></p><h2 id="13-3-逻辑运算符"><a href="#13-3-逻辑运算符" class="headerlink" title="13.3. 逻辑运算符"></a>13.3. 逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">逻辑非！</span><br><span class="line"></span><br><span class="line">结果取反</span><br><span class="line"></span><br><span class="line">逻辑与&amp;</span><br><span class="line"></span><br><span class="line">两边的表达式只要有一个是假的，整个式子就为假，两边都会执行</span><br><span class="line"></span><br><span class="line">逻辑或|</span><br><span class="line"></span><br><span class="line">两边的表达式只要有一个是真的，整个式子就为真，两边都会执行</span><br></pre></td></tr></table></figure><h2 id="13-4-短路逻辑运算符"><a href="#13-4-短路逻辑运算符" class="headerlink" title="13.4. 短路逻辑运算符"></a>13.4. 短路逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">短路与&amp;&amp;</span><br><span class="line"></span><br><span class="line">左边的表达式为假时，右边的表达式不执行</span><br><span class="line"></span><br><span class="line">短路或||</span><br><span class="line"></span><br><span class="line">左边的表达式为真时，右边的表达式不执行</span><br></pre></td></tr></table></figure><h2 id="13-5-赋值运算符"><a href="#13-5-赋值运算符" class="headerlink" title="13.5. 赋值运算符"></a>13.5. 赋值运算符</h2><p>不推荐使用</p><p><code>=</code>、<code>+=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></p><p>扩展的赋值运算符，隐含了强制类型转换</p><h2 id="13-6-自增自减运算符"><a href="#13-6-自增自减运算符" class="headerlink" title="13.6. 自增自减运算符"></a>13.6. 自增自减运算符</h2><p>不推荐使用</p><p><code>++</code>、<code>--</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如果放在变量前，就先执行自增或自减，然后变量才参与其他操作</span><br><span class="line">++a，就先执行 a = a + <span class="number">1</span>，之后再执行其他操作</span><br><span class="line"></span><br><span class="line">如果放在变量后，变量先参与其他操作，然后执行自增或自减</span><br><span class="line">a++，就先执行操作，之后再执行 a = a + <span class="number">1</span>    </span><br><span class="line">例</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;</span><br><span class="line">        System.out.println(b); <span class="comment">//结果为2</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;</span><br><span class="line">        System.out.println(b); <span class="comment">//结果为1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="13-7-三元运算符"><a href="#13-7-三元运算符" class="headerlink" title="13.7. 三元运算符"></a>13.7. 三元运算符</h2><p><code>关系表达式?表达式1:表达式2;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如：a &gt; b ? a : b;</span><br><span class="line"></span><br><span class="line">规则：</span><br><span class="line">    首先计算表达式的值</span><br><span class="line">    如果值为<span class="literal">true</span>，表达式<span class="number">1</span>的值，为运算结果</span><br><span class="line">    如果值为<span class="literal">false</span>，表达式<span class="number">2</span>的值，为运算结果</span><br></pre></td></tr></table></figure><h2 id="13-8-位运算符"><a href="#13-8-位运算符" class="headerlink" title="13.8. 位运算符"></a>13.8. 位运算符</h2><p>位运算效率高</p><p>按位与<code>&amp;</code>：把两个数的二进制位相与</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 &amp; 1 = 1</span><br><span class="line">1 &amp; 0 = 0</span><br><span class="line">0 &amp; 0 = 0</span><br><span class="line">0 &amp; 1 = 0</span><br></pre></td></tr></table></figure><p>按位或<code>|</code>：把两个数的二进制位相或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 | 1 = 1</span><br><span class="line">1 | 0 = 1</span><br><span class="line">0 | 0 = 0</span><br><span class="line">0 | 1 = 1</span><br></pre></td></tr></table></figure><p>按位取反<code>~</code>：把一个数字的二进制位取反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~1 = 0</span><br><span class="line">~0 = 1</span><br></pre></td></tr></table></figure><p>按位异或<code>^</code>：把两个数的二进制位异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 ^ 1 = 0</span><br><span class="line">1 ^ 0 = 1</span><br><span class="line">0 ^ 1 = 1</span><br><span class="line">0 ^ 0 = 0</span><br></pre></td></tr></table></figure><p>右移<code>&gt;&gt;</code>：右移运算符，num &gt;&gt; 1，相当于num除以2。当为正数时，前面补0，为负数时，前面补1</p><p>无符号右移<code>&gt;&gt;&gt;</code>：忽略符号位，空位都以0补齐</p><p>左移<code>&lt;&lt;</code>：左移运算符，num &lt;&lt; 1，相当于num乘以2。无论正负数，后面补0</p><h1 id="14-Java包"><a href="#14-Java包" class="headerlink" title="14. Java包"></a>14. Java包</h1><p>package语句作为Java源文件的第一条语句，指明该源文件定义的类所在的包</p><p>本质就是文件夹，对类进行分类管理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般利用公司域名倒置作为包名</span></span><br><span class="line"><span class="keyword">package</span> 包名;</span><br><span class="line">例</span><br><span class="line"><span class="keyword">package</span> sunrise;<span class="comment">//可以是合法标识符</span></span><br><span class="line"><span class="keyword">package</span> com.baidu.www;<span class="comment">//可以是若干标识符由`.`号分割</span></span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类中的package命令不是非得放在类的第一行，其上可以写注释和空行，但是对于import、类、变量等命令，则一定不能放在package命令之上</span><br></pre></td></tr></table></figure><p><strong>导包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> 包名;</span><br><span class="line">引入包中所有类，用<span class="keyword">import</span> 包名.*;</span><br><span class="line">引入包中某个类，用<span class="keyword">import</span> 包名.类名;</span><br></pre></td></tr></table></figure><p><strong>权限</strong></p><div class="table-container"><table><thead><tr><th>修饰符</th><th>同包同类</th><th>同一个类中，子类无关类</th><th>不同包的子类</th><th>不同包的无关类</th></tr></thead><tbody><tr><td>private</td><td>可以</td><td></td><td></td><td></td></tr><tr><td>默认</td><td>可以</td><td>可以</td><td></td><td></td></tr><tr><td>protected</td><td>可以</td><td>可以</td><td>可以</td><td></td></tr><tr><td>public</td><td>可以</td><td>可以</td><td>可以</td><td>可以</td></tr></tbody></table></div><h1 id="15-Scanner类"><a href="#15-Scanner类" class="headerlink" title="15. Scanner类"></a>15. Scanner类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Scanner 对象</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">// 判断是否输入字符串</span></span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext())&#123;</span><br><span class="line">            <span class="comment">// 使用next方法接收</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭io流</span></span><br><span class="line">        scanner.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-1-Scanner的方法"><a href="#15-1-Scanner的方法" class="headerlink" title="15.1. Scanner的方法"></a>15.1. Scanner的方法</h2><p><code>nextByte()</code>方法用来读取用户输入的byte数据， <code>hasNextByte()</code>方法用来判断用户输入的数据类型是否为byte</p><p>这些方法执行时都会堵塞，等待输入回车确认</p><div class="table-container"><table><thead><tr><th>获取数据</th><th>判断数据</th></tr></thead><tbody><tr><td><code>nextByte()</code></td><td><code>hasNextByte()</code></td></tr><tr><td><code>nextDouble()</code></td><td><code>hasNextDouble()</code></td></tr><tr><td><code>nextFloat()</code></td><td><code>hasNextFloat()</code></td></tr><tr><td><code>nextInt()</code></td><td><code>hasNextInt()</code></td></tr><tr><td><code>nextLine()</code></td><td><code>hasNextLine()</code></td></tr><tr><td><code>nextLong</code></td><td><code>hasNextLong()</code></td></tr><tr><td><code>nextShort</code></td><td><code>hasNextShort()</code></td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">next()不会吸取字符前/后的空格/Tab键，只吸取字符，开始吸取字符（字符前后不算）直到遇到空格/Tab键/回车截止吸取</span><br><span class="line"></span><br><span class="line">nextLine()吸取字符前后的空格/Tab键，回车键截止</span><br></pre></td></tr></table></figure><h2 id="15-2-格式化输出"><a href="#15-2-格式化输出" class="headerlink" title="15.2. 格式化输出"></a>15.2. 格式化输出</h2><div class="table-container"><table><thead><tr><th>输出控制符</th><th>针对的数据类型</th></tr></thead><tbody><tr><td>%d</td><td>int，long int，short，byte</td></tr><tr><td>%x，%X，%#x，%#X</td><td>int，long int</td></tr><tr><td>%c</td><td>char</td></tr><tr><td>%f</td><td>float，double</td></tr><tr><td>%m.nf</td><td>输出的数占m列，小数点后保留n位</td></tr><tr><td>%s</td><td>String</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(<span class="string">&quot;Name: %s, Age: %d, Salary: %.2f%n&quot;</span>, name, age, salary);</span><br></pre></td></tr></table></figure><p>使用 String.format 进行格式化输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(<span class="string">&quot;Name: %s, Age: %d, Salary: %.2f%n&quot;</span>, name, age, salary);</span><br><span class="line">System.out.print(formattedString);</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%x和%X的区别是显示十六进制数a-f的大小写</span><br><span class="line"></span><br><span class="line">%x和%#x的区别是显示或不显示0x前缀</span><br></pre></td></tr></table></figure><p>三种输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print() <span class="comment">//一般的标准输出，不换行</span></span><br><span class="line">System.out.println() <span class="comment">//一般的标准输出，换行    </span></span><br><span class="line">System.out.printf() <span class="comment">//格式化输出，不换行</span></span><br></pre></td></tr></table></figure><p>占位符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;插入 &#123;&#125; 条题目执行时长：&#123;&#125;&quot;</span>, questionInfoVoList.size(), stopWatch.getTotalTimeMillis());</span><br></pre></td></tr></table></figure><h1 id="16-流程控制"><a href="#16-流程控制" class="headerlink" title="16. 流程控制"></a>16. 流程控制</h1><h2 id="16-1-顺序"><a href="#16-1-顺序" class="headerlink" title="16.1. 顺序"></a>16.1. 顺序</h2><h2 id="16-2-选择"><a href="#16-2-选择" class="headerlink" title="16.2. 选择"></a>16.2. 选择</h2><p>if、else if、else、switch</p><h2 id="16-3-循环"><a href="#16-3-循环" class="headerlink" title="16.3. 循环"></a>16.3. 循环</h2><p>while、do while、for</p><p><strong>增强for循环</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">简化数组和Collection集合的遍历</span><br><span class="line">实现Iterable接口的类允许其对象成为增强型for语句的目标</span><br><span class="line"></span><br><span class="line">for(元素类型 变量名 : 数组或Collection集合)&#123;</span><br><span class="line">在此处使用变量即可，该变量就是元素</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;java&quot;</span>);</span><br><span class="line">        c.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s:c)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">continue，结束本次循环，开始下一次循环</span><br><span class="line"></span><br><span class="line">break，停止循环</span><br><span class="line"></span><br><span class="line">if、while、for中进行真假判断时，只能使用逻辑表达式</span><br></pre></td></tr></table></figure><h1 id="17-方法"><a href="#17-方法" class="headerlink" title="17. 方法"></a>17. 方法</h1><p>具有独立功能的代码块</p><h2 id="17-1-定义"><a href="#17-1-定义" class="headerlink" title="17.1. 定义"></a>17.1. 定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法头</span></span><br><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line">    <span class="keyword">return</span> 参数;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">...</span><br><span class="line">         ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：方法不能嵌套定义</p><h2 id="17-2-方法调用"><a href="#17-2-方法调用" class="headerlink" title="17.2. 方法调用"></a>17.2. 方法调用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名()</span><br></pre></td></tr></table></figure><h2 id="17-3-参数"><a href="#17-3-参数" class="headerlink" title="17.3. 参数"></a>17.3. 参数</h2><p>形参、实参、可变参数</p><p><strong>可变参数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">方法声明时，在指定参数类型后加一个省略号(...)</span><br><span class="line">一个方法中只能指定一个可变参数，它必须是方法的最后一个参数。任何普通的参数必须在它</span><br><span class="line">之前声明。</span><br><span class="line">    </span><br><span class="line">    例</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstTest</span><span class="params">(<span class="type">char</span> s,<span class="type">int</span> ...i)</span> &#123; <span class="comment">// i 就是可变参数</span></span><br><span class="line">        <span class="keyword">if</span> (i.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(i[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="17-4-方法重载"><a href="#17-4-方法重载" class="headerlink" title="17.4. 方法重载"></a>17.4. 方法重载</h2><p>同一个类中的多个方法只有参数列表不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多个方法在同一个类中</span></span><br><span class="line"><span class="comment">多个方法具有相同的方法名</span></span><br><span class="line"><span class="comment">多个方法的参数不同（参数类型不同或数量不同）</span></span><br><span class="line"><span class="comment">只与参数列表有关，与返回值无关</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">jiafa</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c + d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">jiafa</span><span class="params">(<span class="type">int</span> c,<span class="type">int</span> d,<span class="type">int</span> e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c + d + e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">a</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();</span><br><span class="line">        </span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,A.jiafa(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,A.jiafa(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="18-数组"><a href="#18-数组" class="headerlink" title="18. 数组"></a>18. 数组</h1><h2 id="18-1-声明-amp-创建"><a href="#18-1-声明-amp-创建" class="headerlink" title="18.1. 声明&amp;创建"></a>18.1. 声明&amp;创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明数组变量</span></span><br><span class="line"><span class="type">int</span>[] boys;<span class="comment">//推荐</span></span><br><span class="line">或</span><br><span class="line"><span class="type">int</span> boys[];</span><br><span class="line"><span class="comment">// 使用new来创建数组</span></span><br><span class="line">boys = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><h2 id="18-2-初始化"><a href="#18-2-初始化" class="headerlink" title="18.2. 初始化"></a>18.2. 初始化</h2><p><strong>动态初始化</strong></p><p>初始化时，只指定数组长度，具体值由系统分配默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] boy = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>静态初始化</strong></p><p>初始化时，只指定数组元素的具体值，无需指定数组的长度，由系统决定数组长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] boy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">或</span><br><span class="line"><span class="type">int</span>[] boy = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="18-3-访问数组"><a href="#18-3-访问数组" class="headerlink" title="18.3. 访问数组"></a>18.3. 访问数组</h2><p>使用索引访问数组中的元素，索引从0开始</p><h2 id="18-4-特点总结"><a href="#18-4-特点总结" class="headerlink" title="18.4. 特点总结"></a>18.4. 特点总结</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数组变量属引用类型</span><br><span class="line"></span><br><span class="line">数组中的元素可以是任何数据类型，包括基本类型和引用类型。</span><br><span class="line"></span><br><span class="line">数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型,数组对象本身是在堆中的。</span><br></pre></td></tr></table></figure><h2 id="18-5-数组的使用"><a href="#18-5-数组的使用" class="headerlink" title="18.5. 数组的使用"></a>18.5. 数组的使用</h2><p>获取数组的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名.length</span><br></pre></td></tr></table></figure><p>数组作为返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 数组变量;</span><br></pre></td></tr></table></figure><h2 id="18-6-Arrays类"><a href="#18-6-Arrays类" class="headerlink" title="18.6. Arrays类"></a>18.6. Arrays类</h2><p>打印数组元素，toString</p><p>排序数组元素，sort</p><p>给数组赋值，fill</p><p>比较数组中元素的值，equals</p><p>查找数组元素，binarySearch，通过binarySearch方法能对排序好的数组进行二分查找法操作</p><h2 id="18-7-常见问题"><a href="#18-7-常见问题" class="headerlink" title="18.7. 常见问题"></a>18.7. 常见问题</h2><p>索引越界</p><p>空指针异常</p><h1 id="19-对象数组"><a href="#19-对象数组" class="headerlink" title="19. 对象数组"></a>19. 对象数组</h1><p>使用基本数据类型的类创建数组，数组中的每个元素是对象</p><p><strong>声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A m1,m2,m3;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">A [] m = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p><strong>创建</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    A(<span class="type">int</span> a)&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        A [] m = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        m[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">2</span>);</span><br><span class="line">        m[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">3</span>);</span><br><span class="line">        m[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line">            System.out.println(m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="20-类和对象"><a href="#20-类和对象" class="headerlink" title="20. 类和对象"></a>20. 类和对象</h1><h2 id="20-1-类的三大特性"><a href="#20-1-类的三大特性" class="headerlink" title="20.1. 类的三大特性"></a>20.1. 类的三大特性</h2><ul><li>封装</li><li>继承</li><li>多态：操作多态、继承多态</li></ul><h2 id="20-2-类的构成"><a href="#20-2-类的构成" class="headerlink" title="20.2. 类的构成"></a>20.2. 类的构成</h2><p>把一类事物的静态属性和动态可以执行的操作组合在一起所得到的就是类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="type">int</span> high;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">speed</span> <span class="operator">=</span> <span class="number">80</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>成员变量</strong></p><ul><li>类中方法之外的变量</li><li>位于堆内存</li><li>若不赋值，则是该类型的初始值（eg：int 为0，Integer 为 null）</li><li>伴随对象的产生和消亡</li><li>成员变量可以是Java允许的任何数据类型</li></ul><p><strong>局部变量</strong></p><ul><li>类中方法内或方法声明上的变量</li><li>位于栈内存</li><li>必须先赋值，才能使用</li><li>伴随方法的产生和消亡</li></ul><p><strong>方法</strong></p><p>静态方法（static修饰的）</p><p>非静态方法（不加static关键字的方法，在类定义时没有占用内存，只有在类被实例化成对象时，对象调用该方法才被分配内存）</p><p>注意：一个Java文件中只能有一个main方法</p><h2 id="20-3-类的访问控制"><a href="#20-3-类的访问控制" class="headerlink" title="20.3. 类的访问控制"></a>20.3. 类的访问控制</h2><p>权限大小：私有&lt; 默认&lt; 保护&lt; 公有</p><p>在同一个类中，可以访问该类中的所有修饰符。而在其他类中，只能访问公共（<code>public</code>）成员</p><ul><li><code>default</code>（默认）：如果没有明确指定访问修饰符，则使用默认修饰符。默认修饰符的访问权限是包级别的，它允许同一个包中的其他类访问。</li><li><code>public</code>：<code>public</code>修饰符表示公共访问权限，可以在任何地方访问该类、方法或属性，包括其他包中的类。</li><li><code>protected</code>：<code>protected</code>修饰符表示受保护的访问权限，它允许同一个包中的其他类以及其他包中的子类访问该类、方法或属性。子类可以继承并访问父类中的<code>protected</code>成员。  </li><li><code>private</code>：<code>private</code>修饰符表示私有访问权限，只允许在同一个类中访问该类、方法或属性。其他类无法直接访问私有成员。</li></ul><p><strong>注意</strong></p><p>在类的内部，所有成员可以互相访问，访问控制符是透明的。访问控制符是针对外部访问而言的</p><p><strong>外部访问的方式</strong></p><ul><li>通过类名</li><li>通过类对象名</li><li>通过子类访问</li></ul><h2 id="20-4-类的构造方法"><a href="#20-4-类的构造方法" class="headerlink" title="20.4. 类的构造方法"></a>20.4. 类的构造方法</h2><p>类在创建时，该方法自动调用，用来给所创建的对象一个初始状态，IDEA右键 generate —&gt; constructor快速生成构造方法</p><p>注意：类中有构造方法才能被实例化。若不创建构造方法，则java会默认创建一个无参的构造方法。一旦定义了有参构造，无参构造就必须显示定义。构造方法名字必须与所在类的名字一样。构造方法没有返回值类型，也不能写void。一个类中可以有多个构造方法。构造方法可以有参也可以无参</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">A() &#123;&#125;</span><br><span class="line">A(<span class="type">int</span> c, <span class="type">int</span> d)&#123;<span class="comment">//有参构造方法</span></span><br><span class="line">i = c;</span><br><span class="line">j = d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-5-一个标准的类"><a href="#20-5-一个标准的类" class="headerlink" title="20.5. 一个标准的类"></a>20.5. 一个标准的类</h2><p>成员变量（使用private修饰）</p><p>构造方法（提供一个无参构造方法、提供有参构造方法）</p><p>成员方法（提供每一个成员变量对应的setXxx()、getXxx()、提供一个显示对象信息的toString()）</p><p>创建对象并为其成员变量赋值的两种方式：</p><ul><li>无参构造方法创建对象后使用setXxx()赋值</li><li>使用带参构造方法直接创建带有属性值的对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//无参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-6-对象"><a href="#20-6-对象" class="headerlink" title="20.6. 对象"></a>20.6. 对象</h2><p>类的实例化结果是一个具体的实体</p><p><img src="F:\笔记\博客\文章图片\创建对象的内存.png" alt="创建对象的内存"></p><p><strong>对象的引用</strong></p><p>用类创建一个对象时，对象中就存放着引用（指向对象实体的一个地址），如果两个对象有相同的实体就有相同的引用</p><p><strong>对象的实体</strong></p><p>用类创建一个对象时，成员变量被分配内存空间，，这些内存空间就是对象的实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//new A()，在堆中动态分配一块区域，被当作了A的对象实体</span></span><br><span class="line">    <span class="comment">//aa本身的内存是在栈中分配的</span></span><br><span class="line">    <span class="comment">//堆中内存的地址赋给了aa</span></span><br><span class="line">    <span class="comment">//aa指向堆中的内存，aa代表了堆中的内存</span></span><br><span class="line">    aa.j;         <span class="comment">//aa.i代表aa这个静态指针变量所指向的动态内存中的A对象</span></span><br><span class="line">    aa.i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果类中没有带参构造方法，或者类中没有成员变量对应的setXxx()函数，那么创建的对象将无法修改类中定义的成员变量的值，则该对象的成员变量的值和类中成员变量的值始终是一致的</p><h2 id="20-7-对象的组合"><a href="#20-7-对象的组合" class="headerlink" title="20.7. 对象的组合"></a>20.7. 对象的组合</h2><p>一个类把对象作为自己的成员变量，那么创建对象时，该对象中就会有其他对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该例子中，b类将a类对象作为自己的成员变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">b</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="number">45</span>;</span><br><span class="line">    <span class="type">a</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">a</span>();<span class="comment">// a类对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">b</span> <span class="variable">li</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">b</span>();</span><br><span class="line">        System.out.println(li.group.aa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-8-this"><a href="#20-8-this" class="headerlink" title="20.8. this"></a>20.8. this</h2><p>谁最终调用函数，this就指向谁，this指向的是正在运行当前代码的那个对象</p><p>静态函数（static修饰的）内部没有this指针</p><p><strong>用法</strong></p><p>通过类名，new出一个对象的过程，叫做”类的实例化”。类中的this会在实例化的时候指向新new出的对象。所以，this.属性、 this.方法 实际上是将属性和方法绑定在即将new出的对象上面</p><ul><li>this.成员变量 ， 访问本类的成员变量</li><li>this.成员方法()，  访问本类成员方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">num</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">this</span>.x);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.num(<span class="number">2</span>);</span><br><span class="line">        b.num(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**结果</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>当局部变量和成员变量同名的情况下必须使用this指定成员变量的变量名。如果二者名称不同，系统会自动隐含一个this，可以不写（建议写明）</p><h2 id="20-9-static"><a href="#20-9-static" class="headerlink" title="20.9. static"></a>20.9. static</h2><p>static声明了属性和方法是属于类本身的，不创建对象也可以直接访问（前提是非私有）</p><p>static 修饰的属性、方法伴随类一起加载</p><p>非静态方法可访问静态方法，而静态方法不能访问非静态</p><p><strong>静态代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最先执行，且只执行一次</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态导入包</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.random;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.PI;</span><br></pre></td></tr></table></figure><h2 id="20-10-Class-vs-Object-in-Java"><a href="#20-10-Class-vs-Object-in-Java" class="headerlink" title="20.10. Class vs Object in Java"></a>20.10. Class vs Object in Java</h2><div class="table-container"><table><thead><tr><th>Aspect</th><th>Class</th><th>Object</th></tr></thead><tbody><tr><td>定义</td><td>类是用于创建对象的模板</td><td>对象是类的特定实例</td></tr><tr><td>语法</td><td>使用 Class关键字声明</td><td>使用new关键字和类构造函数创建</td></tr><tr><td>目的</td><td>定义对象的结构和行为</td><td>基于类创建真实的实体</td></tr><tr><td>使用</td><td>包含由类的所有实例共享的类变量(字段)和方法</td><td>具有自己属性值的唯一实例，并且可以调用类中定义的方法</td></tr><tr><td>例子</td><td>public class Car { // Class variables and methods go here }</td><td>Car myCar = new Car(); // Creates an instance of the Car class</td></tr><tr><td>内存分配</td><td>类定义存储在JVM的方法区域中</td><td>对象在运行时在堆中动态分配内存</td></tr><tr><td>访问控制</td><td>public, private, or protected</td><td>在其声明的范围内访问</td></tr><tr><td>生命周期</td><td>存在于程序的整个执行过程中</td><td>由JVM的垃圾收集器创建、使用并最终销毁</td></tr></tbody></table></div><h1 id="21-封装"><a href="#21-封装" class="headerlink" title="21. 封装"></a>21. 封装</h1><p>高内聚，低耦合</p><p>将信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的public方法来实现对隐藏信息的访问和操作成员变量</p><p>eg：在Java Bean中使用setXxx()、getXxx()操作成员变量</p><h1 id="22-继承"><a href="#22-继承" class="headerlink" title="22. 继承"></a>22. 继承</h1><ul><li>子类（派生类）、父类（基类）</li><li>JAVA中类只有单继承，没有多继承，即一个类只能有一个父类</li><li>Java可以有多重继承，即一个类可以继承某一个类的子类</li><li>子类可以继承父类的非私有属性和方法，但私有的数据或函数，可以通过可继承的函数set、get间接的去访问（重点）</li><li>Java中子类名的特点，子类名都以其父类名作为子类名的后缀，如 FileOutputStream（子类）OutputStream（父类）</li></ul><h2 id="22-1-Object类"><a href="#22-1-Object类" class="headerlink" title="22.1. Object类"></a>22.1. Object类</h2><p>Object类是Java<code>java.lang</code>包下的核心类，是所有类的父类，创建一个类的时候如果没有明确的继承一个父类的话，那么它就是Object的子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二者等价</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span> &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="22-2-extends"><a href="#22-2-extends" class="headerlink" title="22.2. extends"></a>22.2. extends</h2><p><code>子类名 extends 父类名</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">math</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;<span class="comment">//继承于父类family</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d,%s\n&quot;</span>,a.math,a.name);<span class="comment">//访问的是父类中的成员变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h2 id="22-3-变量访问的特点"><a href="#22-3-变量访问的特点" class="headerlink" title="22.3. 变量访问的特点"></a>22.3. 变量访问的特点</h2><p>在子类中访问一个变量，先在子类局部范围找，然后再到子类成员中找，最后到父类成员中找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">math</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">170</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;<span class="comment">//继承于父类family</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">math</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;赵四&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(a.math  + a.name + a.high); <span class="comment">//子类中找不到high变量，所以是父类中的high变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果是</span></span><br><span class="line"><span class="comment">2赵四170</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="22-4-构造方法的访问特点"><a href="#22-4-构造方法的访问特点" class="headerlink" title="22.4. 构造方法的访问特点"></a>22.4. 构造方法的访问特点</h2><p>子类不继承父类的构造方法</p><p>子类中的构造方法默认都会访问父类中的无参的构造方法。因为子类继承父类的数据，可能会使用父类的数据，所以在子类初始化前，一定先初始化父类</p><p>每个子类的构造方法的第一条默认语句都是super()，即父类的无参构造方法</p><h2 id="22-5-成员方法的访问特点"><a href="#22-5-成员方法的访问特点" class="headerlink" title="22.5. 成员方法的访问特点"></a>22.5. 成员方法的访问特点</h2><p>通过子类对象访问一个方法，先在子类局部范围找，然后再到子类成员中找，最后到父类成员中找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mc</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是父类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;<span class="comment">//继承于父类family</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">mb</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是子类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.mc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果是</span></span><br><span class="line"><span class="comment">这是父类</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="22-6-子类访问父类的方式"><a href="#22-6-子类访问父类的方式" class="headerlink" title="22.6. 子类访问父类的方式"></a>22.6. 子类访问父类的方式</h2><ul><li>在子类内部访问父类成员</li><li>通过子类对象名访问父类成员</li><li>通过子类的类名访问父类成员</li></ul><h2 id="22-7-super"><a href="#22-7-super" class="headerlink" title="22.7. super"></a>22.7. super</h2><p>代表父类对象引用</p><p><strong>用法</strong></p><p>子类使用super调用父类的构造方法或子类使用super调用被子类隐藏的成员变量和方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">super.成员变量，访问父类成员变量</span><br><span class="line">super(参数)，访问父类的构造方法(只能在子类的构造方法里调用)</span><br><span class="line">super.成员方法，访问父类成员方法</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">子类无法直接继承父类的构造方法，只能通过<span class="built_in">super</span>语句</span><br><span class="line">如果在子类的构造方法中，显示的写出了<span class="built_in">super</span>语句，必须保证，该语句是第一条语句，否则出错</span><br><span class="line">例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> j;</span><br><span class="line">    family(<span class="type">int</span> i,<span class="type">int</span> j)&#123;</span><br><span class="line">        <span class="built_in">this</span>.i = i;</span><br><span class="line">        <span class="built_in">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> c;</span><br><span class="line">    A(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">int</span> c)&#123;</span><br><span class="line">        <span class="built_in">super</span>(i,j);<span class="comment">//调用父类的构造方法</span></span><br><span class="line">        <span class="comment">//family(i,j);//直接调用父类的构造方法是错的</span></span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;%d,%d\n&quot;</span>,a.c,a.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*结果是</span></span><br><span class="line"><span class="comment">3,1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="22-8-成员变量隐藏"><a href="#22-8-成员变量隐藏" class="headerlink" title="22.8. 成员变量隐藏"></a>22.8. 成员变量隐藏</h2><p>子类中定义的成员变量只要和父类中的成员变量同名（类型可以相同也可以不同），则子类会隐藏父类的同名变量。被隐藏的父类变量，在子类中可以使用<code>super</code>关键字引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">math</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">170</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;<span class="comment">//继承于父类family</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">math</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;<span class="comment">//隐藏了父类的 int math</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">180</span>;<span class="comment">// 隐藏了父类的 int high</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.math + <span class="string">&quot; &quot;</span> + <span class="built_in">this</span>.high);    <span class="comment">// 2 180</span></span><br><span class="line">        System.out.println(<span class="built_in">super</span>.math + <span class="string">&quot; &quot;</span> + <span class="built_in">super</span>.high);<span class="comment">//1 170  通过super访问被隐藏的父类变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-9-方法的重写"><a href="#22-9-方法的重写" class="headerlink" title="22.9. 方法的重写"></a>22.9. 方法的重写</h2><p>在子类中重新定义父类的方法</p><p><strong>条件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">有子类、父类的继承关系</span><br><span class="line">子类只能重写父类中的非静态方法</span><br><span class="line">在子类中重写父类的方法时，子类方法的权限不能低于父类，父类的私有方法不能被重写，<span class="keyword">static</span>、<span class="keyword">final</span>修饰的方法也不能重写</span><br><span class="line">子类方法抛出的异常范围必须低于父类方法</span><br><span class="line">重写的方法，必须和被重写的方法具有相同的名称、参数列表、返回值类型（即除了方法体，其余必须相同）</span><br><span class="line">例</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">family</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">math</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">170</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pou</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是被重写的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">family</span>&#123;<span class="comment">//继承于父类family</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">math</span> <span class="operator">=</span> <span class="string">&quot;2&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">pou</span><span class="params">()</span>&#123; <span class="comment">//重写父类中的pou()方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;这是重写后的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a.pou();</span><br><span class="line">        <span class="comment">// 父类的引用指向子类</span></span><br><span class="line">        <span class="comment">// // 对象能执行哪些方法，主要看对象左边的类型</span></span><br><span class="line">        <span class="type">family</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(); <span class="comment">//子类重写了父类的方法</span></span><br><span class="line">        f.pou();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="23-多态"><a href="#23-多态" class="headerlink" title="23. 多态"></a>23. 多态</h1><p>Java 的多态是指同一个类的对象在不同情况下表现出来的不同行为和状态。即一个父类可能有若干子类，各子类实现父类方法有多种多样，调用父类方法时，父类引用变量指向不同子类实例而执行不同方法，这就是所谓父类方法是多态的。</p><h2 id="23-1-条件"><a href="#23-1-条件" class="headerlink" title="23.1. 条件"></a>23.1. 条件</h2><p>多态的前提条件有三个：</p><ul><li>子类继承父类</li><li>子类重写父类的方法</li><li>父类引用指向子类的对象</li></ul><h2 id="23-2-类型转换"><a href="#23-2-类型转换" class="headerlink" title="23.2. 类型转换"></a>23.2. 类型转换</h2><p><strong>对象 instanceof 类</strong></p><p>当左面的对象是右面的类创建的对象时，该结果 true，否则为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        System.out.println(a <span class="keyword">instanceof</span> A); <span class="comment">//结果为true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父转子</strong></p><p>强制转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="comment">// 强制转换</span></span><br><span class="line"><span class="type">Son</span> <span class="variable">f2</span> <span class="operator">=</span> (Son) f1;</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">强制转换后，可调用子类独有的方法</span><br></pre></td></tr></table></figure><p><strong>子转父</strong></p><p>父类的引用指向子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Father</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();<span class="comment">//编译看左边，执行看右边</span></span><br></pre></td></tr></table></figure><h2 id="23-3-多态的形式"><a href="#23-3-多态的形式" class="headerlink" title="23.3. 多态的形式"></a>23.3. 多态的形式</h2><p>通过实现类对象实例化，叫接口多态</p><p>多态的形式：具体类多态，抽象类多态，接口多态</p><p>多态的前提：有继承或实现关系，有方法重写，有父(类/接口)引用指向(子/实现)类对象</p><h1 id="24-Object类详解（重点）"><a href="#24-Object类详解（重点）" class="headerlink" title="24. Object类详解（重点）"></a>24. Object类详解（重点）</h1><p>Object类是类层次结构的根，每个类都可以将Object作为超类，所有类直接或间接继承自该类</p><h2 id="24-1-运算符"><a href="#24-1-运算符" class="headerlink" title="24.1. ==运算符"></a>24.1. <code>==</code>运算符</h2><ul><li>既可以判断基本类型，又可以判断引用类型</li><li>如果判断基本类型，判断的是值是否相等</li><li>如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象</li></ul><h2 id="24-2-equals"><a href="#24-2-equals" class="headerlink" title="24.2. equals"></a>24.2. equals</h2><ul><li>equals是Object类中的方法，只能判断引用类型</li><li>equals 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如Integer、String</li></ul><p><strong>自定义类中如何重写equals</strong></p><p>可参考String类中对equals的重写方式</p><h2 id="24-3-hashCode"><a href="#24-3-hashCode" class="headerlink" title="24.3. hashCode"></a>24.3. hashCode</h2><ul><li>提高具有哈希结构的容器的效率</li><li>两个引用，如果指向的是同一个对象，则哈希值是一样的</li><li>两个引用，如果指向的是不同对象，则哈希值是不一样的</li><li>哈希值主要是根据地址来的，但是哈希值不等价于地址（哈希值是将对象的内部地址转换为整数来实现，因为Java程序运行在Java虚拟机中）</li><li>在集合中往往会重写hashCode</li></ul><h2 id="24-4-toString"><a href="#24-4-toString" class="headerlink" title="24.4. toString"></a>24.4. toString</h2><ul><li>默认返回：<code>全类名+@+哈希值的十六进制</code>，子类往往重写toString方法，用于返回对象的属性信息</li><li>重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式</li><li>当直接输出一个对象时，toString方法会被默认的调用</li></ul><h2 id="24-5-finalize"><a href="#24-5-finalize" class="headerlink" title="24.5. finalize"></a>24.5. finalize</h2><ul><li>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</li><li>什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。不是立即回收而是有一套垃圾回收算法</li><li>垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制</li><li>可以重写finalize方法，写自己的业务逻辑代码（比如释放资源、数据库连接、或者打开文件）</li></ul><p>实际开发中用的少，几乎不用</p><h1 id="25-抽象类和方法"><a href="#25-抽象类和方法" class="headerlink" title="25. 抽象类和方法"></a>25. 抽象类和方法</h1><p>抽象类是对事物的抽象</p><p>抽象类和抽象方法必须使用 abstract 修饰</p><h2 id="25-1-抽象方法"><a href="#25-1-抽象方法" class="headerlink" title="25.1. 抽象方法"></a>25.1. 抽象方法</h2><p>没有方法体的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h2 id="25-2-抽象类"><a href="#25-2-抽象类" class="headerlink" title="25.2. 抽象类"></a>25.2. 抽象类</h2><p>不能new 抽象类，只能靠子类去实现它</p><p>若类中有抽象方法，则该类必须定义为抽象类</p><p>抽象类中可以写普通的方法</p><p>抽象类中的方法，应由子类实现。但如果子类也是抽象类，则不必实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写抽象类中的方法，通过子类对象实例化来实现抽象类实例化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;<span class="comment">//重写抽象类中的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;吃鱼&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//  Animal a = new Animal();  //抽象类不能实例化</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();<span class="comment">//多态实现实例化</span></span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子类是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;<span class="comment">//子类定义为抽象类</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-3-抽象类的成员"><a href="#25-3-抽象类的成员" class="headerlink" title="25.3. 抽象类的成员"></a>25.3. 抽象类的成员</h2><p><strong>成员变量</strong></p><p>常量或变量</p><p><strong>构造方法</strong></p><p>有构造方法但是不能实例化，作用是用于子类访问父类数据的初始化</p><p><strong>成员方法</strong></p><p>可以有抽象方法，限定子类必须完整某些动作。也可以有非抽象方法，提高代码的复用性</p><h2 id="25-4-抽象类名作为形参和返回值"><a href="#25-4-抽象类名作为形参和返回值" class="headerlink" title="25.4. 抽象类名作为形参和返回值"></a>25.4. 抽象类名作为形参和返回值</h2><p>方法的形参是抽象类名，方法的返回值是抽象类名，它们都对应该抽象类的子类对象</p><h1 id="26-接口"><a href="#26-接口" class="headerlink" title="26. 接口"></a>26. 接口</h1><p>接口是对行为的抽象</p><p>可以把接口理解为提供了一系列功能列表的约定，接口本身不提供功能，它只定义行为。但是谁要用，就要先实现我，遵守我的约定，然后再自己去实现我约定的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getStudent</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStudentById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStudentName</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-1-接口特点"><a href="#26-1-接口特点" class="headerlink" title="26.1. 接口特点"></a>26.1. 接口特点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;&#125;</span><br></pre></td></tr></table></figure><p>接口用 interface 修饰</p><p>接口没有构造方法，所以接口不能实例化</p><p>接口中的所有定义其实都是抽象的 public abstract</p><h2 id="26-2-接口实现类"><a href="#26-2-接口实现类" class="headerlink" title="26.2. 接口实现类"></a>26.2. 接口实现类</h2><p>用 implements 表示，通过类来实现接口</p><p>implements可以实现多个接口</p><p>接口实现类中需要重写接口中的所有方法，若该实现类是抽象类则不用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 类名 implements 接口<span class="number">1</span>,接口<span class="number">2</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重写接口中的抽象方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Jumpping</span> &#123;     <span class="comment">//创建一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Jumpping</span>&#123;    <span class="comment">//用类实现一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span> &#123;    <span class="comment">//重写接口中的抽象方法</span></span><br><span class="line">        System.out.print(<span class="string">&quot;猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Jumpping</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();     <span class="comment">//编译看左边，执行看右边</span></span><br><span class="line">    j.jump();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口实现类是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Jumpping</span> &#123;     <span class="comment">//创建一个接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">jump</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Jumpping</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-3-接口的成员"><a href="#26-3-接口的成员" class="headerlink" title="26.3. 接口的成员"></a>26.3. 接口的成员</h2><p><strong>成员变量</strong></p><p>只能是常量，默认修饰符是public static final</p><p><strong>构造方法</strong></p><p>接口没有构造方法，因此接口不能实例化</p><p><strong>成员方法</strong></p><p>只能是抽象方法，默认修饰符是 public abstract</p><h2 id="26-4-接口名作为形参和返回值"><a href="#26-4-接口名作为形参和返回值" class="headerlink" title="26.4. 接口名作为形参和返回值"></a>26.4. 接口名作为形参和返回值</h2><p>方法的形参是接口名，方法的返回值是接口名，它们都对应该接口的实现类对象</p><h1 id="27-类-amp-接口的关系"><a href="#27-类-amp-接口的关系" class="headerlink" title="27. 类&amp;接口的关系"></a>27. 类&amp;接口的关系</h1><h2 id="27-1-类和类的关系"><a href="#27-1-类和类的关系" class="headerlink" title="27.1. 类和类的关系"></a>27.1. 类和类的关系</h2><p><code>类 extends 类</code></p><p>继承关系，只能单继承，但是可以多层继承</p><h2 id="27-2-类和接口的关系"><a href="#27-2-类和接口的关系" class="headerlink" title="27.2. 类和接口的关系"></a>27.2. 类和接口的关系</h2><p><code>类 implements 接口</code></p><p>实现关系，可单实现，也可以多实现，还可以在继承一个类的同时实现多个接口</p><h2 id="27-3-接口和接口的关系"><a href="#27-3-接口和接口的关系" class="headerlink" title="27.3. 接口和接口的关系"></a>27.3. 接口和接口的关系</h2><p>继承关系，可以单继承，也可以多继承</p><h1 id="28-抽象类-amp-接口的区别"><a href="#28-抽象类-amp-接口的区别" class="headerlink" title="28. 抽象类&amp;接口的区别"></a>28. 抽象类&amp;接口的区别</h1><div class="table-container"><table><thead><tr><th></th><th>成员区别</th></tr></thead><tbody><tr><td>抽象类</td><td>变量、常量、有构造方法、抽象方法、非抽象方法</td></tr><tr><td>接口</td><td>常量、抽象方法</td></tr><tr><td></td><td><strong>关系区别</strong></td></tr><tr><td>类与类</td><td>继承、单继承</td></tr><tr><td>类与接口</td><td>实现、单实现、多实现</td></tr><tr><td>接口与接口</td><td>继承、单继承、多继承</td></tr><tr><td></td><td><strong>设计理念区别</strong></td></tr><tr><td>抽象类</td><td>对类抽象，包括属性、行为</td></tr><tr><td>接口</td><td>对行为抽象，主要是行为</td></tr></tbody></table></div><h1 id="29-内部类"><a href="#29-内部类" class="headerlink" title="29. 内部类"></a>29. 内部类</h1><p>就是在一个类中定义一个类</p><p>内部类分为成员内部类、局部内部类、匿名内部类和静态内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-1-匿名内部类"><a href="#29-1-匿名内部类" class="headerlink" title="29.1. 匿名内部类"></a>29.1. 匿名内部类</h2><p>匿名内部类是我们平常用得最多的，尤其是启动多线程的时候，会经常用到，并且 IDE 也会帮我们自动生成。</p><p>前提：存在一个类或接口，这里的类可以是具体的类，也可以是抽象类</p><p>本质：是一个继承了该类或实现了该接口的子类匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类是唯一一种没有构造方法的类</p><p>匿名内部类的作用主要是用来继承其他类或者实现接口，并不需要增加额外的方法，方便对继承的方法进行实现或者重写</p><h1 id="30-枚举"><a href="#30-枚举" class="headerlink" title="30. 枚举"></a>30. 枚举</h1><p>为了间接表示一些固定的值，Java提供了枚举（Enum），它是指变量的值一一列出来，变量的值只限于列举出来的值的范围内</p><p>利用枚举，我们可以清晰地表达代码中的常量，使代码更为可读、可维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个枚举类，用来表示春、夏、秋、冬这四个固定值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">    SPRING,</span><br><span class="line">    SUMMER,</span><br><span class="line">    AUTUMN,</span><br><span class="line">    WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-1-枚举类的特点"><a href="#30-1-枚举类的特点" class="headerlink" title="30.1. 枚举类的特点"></a>30.1. 枚举类的特点</h2><ul><li>所有枚举类都是Enum的子类</li><li>可以通过<code>枚举类名.枚举项名称</code>访问指定的枚举项</li><li>每一个枚举项实际上就是该枚举的一个对象</li><li>枚举类也是一个类，可以定义成员变量</li><li>枚举类的第一行上必须是枚举项，最后一个枚举项后的分号可以省略，但如果枚举类有其他内容，分号不能省略，建议不要省略</li><li>枚举类可以有构造器，但必须是private的，它默认也是private的</li><li>枚举类可以有抽象方法，但枚举项必须重写该方法</li><li>枚举不可以继承</li><li>枚举其实就是特殊的常量类</li></ul><h2 id="30-2-枚举的方法"><a href="#30-2-枚举的方法" class="headerlink" title="30.2. 枚举的方法"></a>30.2. 枚举的方法</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>String name()</td><td>获取枚举项的名称</td></tr><tr><td>int ordinal()</td><td>返回枚举项在枚举类中的索引值</td></tr><tr><td>int compareTo(E o)</td><td>比较两个枚举项，返回的是索引值的差值</td></tr><tr><td>String toString()</td><td>返回枚举常量的名称</td></tr><tr><td>static <code>&lt;T&gt;</code> T valueOf(Class<code>&lt;T&gt;</code> type, String name)</td><td>获取指定枚举类中指定名称的枚举值</td></tr><tr><td>values()</td><td>获得所有的枚举项</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">NodeEnum</span>&#123;</span><br><span class="line"><span class="comment">// 枚举项1</span></span><br><span class="line">        CUSTOMER(<span class="number">11147</span>,<span class="string">&quot;formtable_19&quot;</span>,<span class="string">&quot;hcdz&quot;</span>,<span class="string">&quot;xdfly&quot;</span>),</span><br><span class="line"><span class="comment">// 枚举项2</span></span><br><span class="line">        SUPPLIER(<span class="number">10799</span>,<span class="string">&quot;formtable20&quot;</span>,<span class="string">&quot;hcdz&quot;</span>,<span class="string">&quot;xdfly&quot;</span>),</span><br><span class="line">        <span class="comment">// 枚举项3</span></span><br><span class="line">        SALENOTE(<span class="number">11107</span>,<span class="string">&quot;formtable97&quot;</span>,<span class="string">&quot;hcdz&quot;</span>,<span class="string">&quot;sjly&quot;</span>);</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line">        NodeEnum(Integer nodeId, String tableName, String backFieldName, String fromFieldName) &#123;</span><br><span class="line">            <span class="built_in">this</span>.nodeId = nodeId;</span><br><span class="line">            <span class="built_in">this</span>.tableName = tableName;</span><br><span class="line">            <span class="built_in">this</span>.backFieldName = backFieldName;</span><br><span class="line">            <span class="built_in">this</span>.fromFieldName = fromFieldName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 节点id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Integer nodeId;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 表名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String tableName;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 回传地址字段名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String backFieldName;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 来源标志字段名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String fromFieldName;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getNodeId</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> nodeId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getTableName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> tableName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getBackFieldName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> backFieldName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">getFromFieldName</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fromFieldName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据节点id获取对应的枚举值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nodeid</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String,Object&gt; <span class="title function_">nodeIdOf</span><span class="params">(<span class="type">int</span> nodeid)</span>&#123;</span><br><span class="line">            Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">            <span class="keyword">for</span>(NodeEnum nodeEnum : values())&#123;</span><br><span class="line">                <span class="keyword">if</span>(nodeEnum.getNodeId().equals(nodeid))&#123;</span><br><span class="line">                    map.put(<span class="string">&quot;tableName&quot;</span>, nodeEnum.getTableName());</span><br><span class="line">                    map.put(<span class="string">&quot;fromFieldName&quot;</span>, nodeEnum.getFromFieldName());</span><br><span class="line">                    map.put(<span class="string">&quot;backFieldName&quot;</span>, nodeEnum.getBackFieldName());</span><br><span class="line">                    map.put(<span class="string">&quot;success&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> map;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(<span class="string">&quot;success&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="31-基本数据类型的包装类"><a href="#31-基本数据类型的包装类" class="headerlink" title="31. 基本数据类型的包装类"></a>31. 基本数据类型的包装类</h1><div class="table-container"><table><thead><tr><th>数据类型</th><th>类包装</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr></tbody></table></div><p><strong>基本数据类型和其对应的包装类在初始化值方面的区别</strong></p><p>基本数据类型的包装类在未显式赋值时，会有一个特殊的默认值 <code>null</code>，表示它们没有被初始化</p><p>在使用包装类时，如果没有显式地给它们赋值，在使用时可能会遇到 NullPointerException（空指针异常）的情况</p><h2 id="31-1-int和String转换"><a href="#31-1-int和String转换" class="headerlink" title="31.1. int和String转换"></a>31.1. int和String转换</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>转String</span><br><span class="line">返回<span class="type">int</span>参数的字符串表示形式</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line"></span><br><span class="line">String转<span class="type">int</span></span><br><span class="line">将数字的字符串形式转为<span class="type">int</span>类型，是Integer类中的方法</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(String s)</span></span><br></pre></td></tr></table></figure><h2 id="31-2-Character类常用方法"><a href="#31-2-Character类常用方法" class="headerlink" title="31.2. Character类常用方法"></a>31.2. Character类常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">isDigit(<span class="type">char</span> ch)<span class="comment">//判断数字字符</span></span><br><span class="line">isLetter(<span class="type">char</span> ch)<span class="comment">//判断字母字符</span></span><br><span class="line">isLetterOrDigit(<span class="type">char</span> ch)<span class="comment">//判断数字字符或字母字符</span></span><br><span class="line">isLowerCase(<span class="type">char</span> ch)<span class="comment">//判断小写字母字符   </span></span><br><span class="line">isUpperCase(<span class="type">char</span> ch)<span class="comment">//判断大写字母字符    </span></span><br><span class="line">toLowerCase(<span class="type">char</span> ch)<span class="comment">//转为小写形式    </span></span><br><span class="line">toUpperCase(<span class="type">char</span> ch)<span class="comment">//转为大写字符    </span></span><br><span class="line">isSpaceChar(<span class="type">char</span> ch)<span class="comment">//判断空格    </span></span><br></pre></td></tr></table></figure><h1 id="32-大数的处理"><a href="#32-大数的处理" class="headerlink" title="32. 大数的处理"></a>32. 大数的处理</h1><p>BigInteger 适合保存比较大的整型</p><p>BigDecimal 适合保存精度更高浮点型（金融中常用）</p><h1 id="33-常用类"><a href="#33-常用类" class="headerlink" title="33. 常用类"></a>33. 常用类</h1><h2 id="33-1-Math类"><a href="#33-1-Math类" class="headerlink" title="33.1. Math类"></a>33.1. Math类</h2><p>Math类里面提供的基本上都是基础的数学公式</p><h2 id="33-2-Random类"><a href="#33-2-Random类" class="headerlink" title="33.2. Random类"></a>33.2. Random类</h2><p>产生一个随机数。此外任何随机的操作都可以利用Random来处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"><span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> random.nextInt(<span class="number">10</span>);<span class="comment">//在范围 0 - 9 之间获取一个随机数</span></span><br></pre></td></tr></table></figure><h2 id="33-3-System类"><a href="#33-3-System类" class="headerlink" title="33.3. System类"></a>33.3. System类</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static void exit(int status)</td><td>终止当前运行的Java虚拟机</td></tr><tr><td>public static long currentTimeMillis()</td><td>返回当前时间，毫秒为单位</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        System.exit(<span class="number">0</span>);<span class="comment">// 直接退出虚拟机</span></span><br><span class="line">        System.out.println(<span class="string">&quot;123&quot;</span>);<span class="comment">//该语句不执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-4-Arrays类"><a href="#33-4-Arrays类" class="headerlink" title="33.4. Arrays类"></a>33.4. Arrays类</h2><p>包含用于操作数组的各种方法</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public static String toString(int[] a)</td><td>返回数组的内容的字符串表示形式</td></tr><tr><td>public static void sort(int[] a)</td><td>按数字顺序排列数组</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">int</span> a [] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//[4, 5, 2, 3, 1]</span></span><br><span class="line">        Arrays.sort(a);</span><br><span class="line">        System.out.println(Arrays.toString(a));<span class="comment">//[1, 2, 3, 4, 5]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-5-Runtime类"><a href="#33-5-Runtime类" class="headerlink" title="33.5. Runtime类"></a>33.5. Runtime类</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-12-Java%E4%B8%AD%E7%BA%A7/"/>
      <url>/2024/10/28/2023-02-12-Java%E4%B8%AD%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-异常类"><a href="#1-异常类" class="headerlink" title="1. 异常类"></a>1. 异常类</h1><h2 id="1-1-异常分类"><a href="#1-1-异常分类" class="headerlink" title="1.1. 异常分类"></a>1.1. 异常分类</h2><p>Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">Throwable--&gt; A(Error)</span><br><span class="line">A--&gt;VirtulMachineError</span><br><span class="line">A--&gt;AWTError</span><br><span class="line">A--&gt;...</span><br><span class="line">Throwable--&gt; B(Exception)</span><br><span class="line">B--&gt;非RuntimeException-受检查异常</span><br><span class="line">B--&gt;RuntimeException-非受检查异常</span><br></pre></td></tr></table></figure><p><strong>Error（错误）</strong></p><p>程序本生是不能处理错误的，只能依靠外界干预。Error 是系统内部的错误，由 jvm 抛出，交给系统来处理，如 内存溢出，jvm 虚拟机自身的非正常运行</p><p><strong>Exception（异常）</strong></p><p>异常会导致程序非正常终止，可以预先检测，被捕获处理掉，使程序继续运行</p><div class="table-container"><table><thead><tr><th>分类</th><th>原因</th><th>解决</th></tr></thead><tbody><tr><td>编译时异常、Checked Exception、受检查异常</td><td>有语法错误</td><td>必须处理。Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译</td></tr><tr><td>运行时异常、Unchecked Exception、非受检查异常</td><td>一般是由程序逻辑错误引起的。比如算术异常，空指针异常 NullPointerException</td><td>可以不处理。Java 代码在编译过程中 ，即使不处理不受检查异常也可以正常通过编译</td></tr></tbody></table></div><p><code>RuntimeException</code> 及其子类都统称为非受检查异常</p><p>常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code></p><p>常见的非受检查异常有：<code>NullPointerException</code>(空指针错误)</p><p><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</p><p><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</p><p><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</p><p><code>ClassCastException</code>（类型转换错误）</p><p><code>ArithmeticException</code>（算术错误）</p><h2 id="1-2-Throwable"><a href="#1-2-Throwable" class="headerlink" title="1.2. Throwable"></a>1.2. Throwable</h2><p><strong>Throwable的成员方法</strong></p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public String getMessage()</td><td>返回此throwable的详细消息字符串</td></tr><tr><td>public String toString()</td><td>返回此可抛出的简短描述</td></tr><tr><td>public void printStackTrace()</td><td>把异常的错误信息输出在控制台</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">      test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>( AnswerWrongException e)&#123;</span><br><span class="line">    <span class="comment">// 把异常的错误信息输出在控制台</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-异常处理"><a href="#1-3-异常处理" class="headerlink" title="1.3. 异常处理"></a>1.3. 异常处理</h2><p>异常处理程序机制：</p><ul><li>抛出异常</li><li>try-catch-finally 捕获和处理异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Family</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Family</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Family</span>();</span><br><span class="line">        <span class="comment">// try监控区</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(f1.a / f1.b);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ArithmeticException e)&#123; <span class="comment">// catch捕获异常</span></span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123; <span class="comment">//处理善后工作</span></span><br><span class="line">            System.out.println(<span class="string">&quot;family&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-1-捕获异常"><a href="#1-3-1-捕获异常" class="headerlink" title="1.3.1. 捕获异常"></a>1.3.1. 捕获异常</h3><p><strong>try-catch</strong></p><p>程序从try中执行代码，出现异常，自动生成一个异常类对象，该异常对象将被提交给Java运行时的系统</p><p>当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理</p><p>执行完毕后，程序会继续往下执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的程序</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型   异常对象)&#123;<span class="comment">//指定可能出现的异常类型</span></span><br><span class="line">    异常处理的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要捕获多个异常，则异常类型 要从小到大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能出现异常的程序</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e1)&#123;</span><br><span class="line">    异常处理的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(Throwable e2)&#123;</span><br><span class="line">    异常处理的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>finally语句</strong></p><p>可省略，不管是否会出现异常，finally都会执行，通常用于进行资源清除、关闭打开的文件等最后进行的处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    java语句</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span>   异常对象<span class="number">1</span>)&#123;    </span><br><span class="line">    异常处理                       </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-2-抛出异常"><a href="#1-3-2-抛出异常" class="headerlink" title="1.3.2. 抛出异常"></a>1.3.2. 抛出异常</h3><p><strong>throw</strong></p><p>由程序本身主动抛出类异常对象，并对此异常进行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> 异常类对象 (必须为Throwable子类对象)</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">5</span>,b=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArithmeticException</span>();<span class="comment">//</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(a/b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;除数不能为零！&quot;</span>);</span><br><span class="line">        e.printStackTrace();   <span class="comment">//显示异常信息</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throws</strong></p><p>写在可能出现异常的方法声明之后，throws可以列出多个可能出现的系统异常，用逗号分隔。声明该方法可能会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throws</span> 异常类名;</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestThrows</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ArithmeticException&#123;<span class="comment">//</span></span><br><span class="line">System.out.println(<span class="number">6</span>/<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>throw和throws区别</strong></p><div class="table-container"><table><thead><tr><th>throws</th><th>throw</th></tr></thead><tbody><tr><td>用在方法声明后面，跟的是异常类名</td><td>用在方法体内，跟的是异常对象名</td></tr><tr><td>表示抛出异常，由该方法的调用者来处理</td><td>表示抛出异常，由方法体内的语句处理</td></tr><tr><td>表示出现异常的一种可能性，并不一定会发生这些异常</td><td>执行throw一定抛出了某种异常</td></tr></tbody></table></div><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编译时异常必须进行处理，可用try-catch或throws，若使用throws，将来谁调用谁处理</span><br><span class="line">运行时异常可以不处理，出问题后修改代码 </span><br></pre></td></tr></table></figure><h2 id="1-4-自定义异常"><a href="#1-4-自定义异常" class="headerlink" title="1.4. 自定义异常"></a>1.4. 自定义异常</h2><p>自定义异常类只需要继承Exception类即可，并规定哪些方法产生这样异常</p><p>使用自定义的异常类创建对象，并抛出所创建的异常对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class 异常类名 <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    无参构造</span><br><span class="line">    带参构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScoreException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ScoreException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Check</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkScore</span><span class="params">(<span class="type">int</span> score)</span> <span class="keyword">throws</span> ScoreException&#123;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">0</span> || score&gt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="comment">//throw new ScoreException();</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ScoreException</span>(<span class="string">&quot;分数异常，分数超范围&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;分数正常&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScanScore</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入分数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">Check</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Check</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t.checkScore(score);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ScoreException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-泛型"><a href="#2-泛型" class="headerlink" title="2. 泛型"></a>2. 泛型</h1><p>避免项目之中出现 <code>ClassCastException</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">本质是将所操作的数据类型指定为一个参数</span><br><span class="line"></span><br><span class="line">这种参数可用在类、方法、接口中，分别被称为泛型类、泛型方法、泛型接口</span><br><span class="line"></span><br><span class="line">&lt;类型1,类型2&gt; ：可指定多种类型的格式，多种类型之间用逗号隔开，这里的类型可以看作是形参</span><br><span class="line"></span><br><span class="line">调用的时候，给定的类型可以看作实参，并且实参的类型只能是引用数据类型，如果要操作基本类型必须使用相应的包装类，如果不设置泛型类型时，自动将使用Object</span><br></pre></td></tr></table></figure><p><strong>优点</strong></p><p>把运行时期的问题提前到了编译期间</p><p>避免了强制类型转换</p><p>同时也避免了对象的向下转型处理（可以避免安全隐患）</p><h2 id="2-1-泛型类"><a href="#2-1-泛型类" class="headerlink" title="2.1. 泛型类"></a>2.1. 泛型类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">修饰符 class 类名&lt;参数&gt;&#123; <span class="comment">//此处参数可以随便写为任意标识，常见如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">例</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T param;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化时，传入具体数据类型</span></span><br><span class="line">Demo&lt;String&gt; s1 = <span class="keyword">new</span> <span class="title class_">Demo</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h2 id="2-2-泛型方法"><a href="#2-2-泛型方法" class="headerlink" title="2.2. 泛型方法"></a>2.2. 泛型方法</h2><p>注意：如果一个类上没有定义泛型，那么也可以使用泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 &lt;参数&gt; 返回值类型 方法名(参数 变量名)&#123;<span class="comment">//此处参数可以随便写为任意标识，常见如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line">&#125;</span><br><span class="line">例</span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Generic</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Generic</span> <span class="variable">g1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>();<span class="comment">//</span></span><br><span class="line">        g1.show(<span class="number">2</span>);</span><br><span class="line">        <span class="type">Generic</span> <span class="variable">g2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Generic</span>();<span class="comment">//</span></span><br><span class="line">        g2.show(<span class="string">&quot;字符串&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-泛型接口"><a href="#2-3-泛型接口" class="headerlink" title="2.3. 泛型接口"></a>2.3. 泛型接口</h2><p>直接在接口之中进行使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Generic</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于泛型接口的子类而言现在就有两种实现方式</p><p>方法一：在子类之中继续设置泛型定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericImpl</span>&lt;S&gt;<span class="keyword">implements</span> <span class="title class_">Generic</span>&lt;S&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(S s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：在子类实现父接口的时候直接定义出具体泛型类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GenericImpl</span> <span class="keyword">implements</span> <span class="title class_">Generic</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-泛型通配符"><a href="#2-4-泛型通配符" class="headerlink" title="2.4. 泛型通配符"></a>2.4. 泛型通配符</h2><p><strong>泛型上限</strong></p><p><code>&lt;?extends 类&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?<span class="keyword">extends</span> <span class="title class_">Number</span>: 表示该泛型类型只允许设置Number或Number的子类</span><br></pre></td></tr></table></figure><p><strong>泛型下限</strong></p><p><code>&lt;?super 类&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?<span class="built_in">super</span> Number&gt;：它表示的类型是Number或其父类型</span><br></pre></td></tr></table></figure><h1 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h1><p>用于表示匿名函数，Lambda表达式的格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameter1, parameter2, ...) -&gt; &#123; statement1; statement2; ... &#125;</span><br></pre></td></tr></table></figure><p>参数列表可以为空或包含一个或多个参数。如果有多个参数，它们必须用逗号分隔。花括号内的语句可以是一条语句或多条语句。如果只有一条语句，花括号可以省略</p><h1 id="4-File类文件操作"><a href="#4-File类文件操作" class="headerlink" title="4. File类文件操作"></a>4. File类文件操作</h1><p>File类是唯一与文件本身操作（创建、删除、重命名等）有关的类</p><p>File类是Comparable接口的子类，所以File类的对象可以进行排序</p><p>如果想进行File 类的操作，必须提供完整的路径，主要通过File类的构造方法处理</p><h2 id="4-1-构造方法"><a href="#4-1-构造方法" class="headerlink" title="4.1. 构造方法"></a>4.1. 构造方法</h2><p>以下三种方法，效果一样，推荐用第一种</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>File(String pathname)</td><td>创建新的File实例</td></tr><tr><td>File(String parent,String child)</td><td>从父路径名字符串和子路径名字符串创建新的File实例</td></tr><tr><td>File(File parent,String child )</td><td>从父抽象路径名和子路径名字符串创建新的File实例</td></tr></tbody></table></div><h2 id="4-2-创建功能"><a href="#4-2-创建功能" class="headerlink" title="4.2. 创建功能"></a>4.2. 创建功能</h2><p>进行文件创建的时候有一个重要的前提：文件的父路径必须首先存在</p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean createNewFile()</td><td>创建新空文件。若文件存在返回false</td></tr><tr><td>public boolean mkdir()</td><td>创建单级目录。若目录存在返回false</td></tr><tr><td>public boolean mkdirs()</td><td>创建多级目录。若目录存在返回false</td></tr></tbody></table></div><h2 id="4-3-删除功能"><a href="#4-3-删除功能" class="headerlink" title="4.3. 删除功能"></a>4.3. 删除功能</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>public boolean delete()</td><td>删除文件或目录</td></tr></tbody></table></div><p>注意：如果一个目录中有内容（子目录或文件），则不能直接删除该目录，需要先删除目录中的内容，才能删除该目录</p><h2 id="4-4-获取文件信息"><a href="#4-4-获取文件信息" class="headerlink" title="4.4. 获取文件信息"></a>4.4. 获取文件信息</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>renameTo(File)</td><td>文件重命名</td></tr><tr><td>public boolean isDirectory()</td><td>是否为目录</td></tr><tr><td>public boolean isFile()</td><td>是否为文件</td></tr><tr><td>public boolean exists()</td><td>是否存在文件、目录</td></tr><tr><td>public boolean canRead()</td><td>文件是否可读</td></tr><tr><td>public boolean canWrite()</td><td>文件是否可写</td></tr><tr><td>public long length()</td><td>获取文件长度，返回字节长度</td></tr><tr><td>public long lastModified()</td><td>获取最后一次修改日期时间</td></tr><tr><td>public String getAbsolutePath()</td><td>获取绝对路径</td></tr><tr><td>public String getPath()</td><td>获取相对路径</td></tr><tr><td>public String getName()</td><td>获取文件或目录的名称</td></tr><tr><td>public File getParentFile()</td><td>获取父路径</td></tr><tr><td>public File[] listFiles()</td><td>列出目录内容，返回File对象数组</td></tr><tr><td>public String[] list()</td><td>列出目录内容，返回字符串数组</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 创建一个File实例</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d://test//test1//demo1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//父路径是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (!f1.getParentFile().exists())&#123;  </span><br><span class="line">            <span class="comment">// 创建父路径</span></span><br><span class="line">            f1.getParentFile().mkdirs();  </span><br><span class="line">            <span class="comment">//创建文件</span></span><br><span class="line">            f1.createNewFile();     </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (f1.exists())&#123;</span><br><span class="line">            <span class="comment">// 删除文件</span></span><br><span class="line">            f1.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-文件遍历"><a href="#4-5-文件遍历" class="headerlink" title="4.5. 文件遍历"></a>4.5. 文件遍历</h2><p>最好的做法就是利用递归的形式来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">listDir</span><span class="params">(File file)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否为目录</span></span><br><span class="line">    <span class="keyword">if</span> (file.isDirectory())&#123;</span><br><span class="line">        File[] files = file.listFiles();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;files.length;x++)&#123;</span><br><span class="line">            <span class="comment">//递归调用</span></span><br><span class="line">            listDir(files[x]);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-IO流"><a href="#5-IO流" class="headerlink" title="5. IO流"></a>5. IO流</h1><p>输入：数据输入到计算机内存的过程即输入</p><p>输出：数据输出到外部存储（比如数据库，文件，远程主机）的过程即输出</p><p>常见的流：文件复制、文件上传、文件下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">IO流--&gt;A(字节流)</span><br><span class="line">IO流--&gt;B(字符流)</span><br><span class="line">A--&gt;A.a(InputStream)</span><br><span class="line">A--&gt;A.b(OutputStream)</span><br><span class="line">B--&gt;B.a(Reader)</span><br><span class="line">B--&gt;B.b(Writer)</span><br><span class="line">A.a--&gt;A.a.1(FileInputStream)</span><br><span class="line">A.a--&gt;A.a.2(FilterInputStream)</span><br><span class="line">A.a--&gt;A.a.3(ObjectInputStream)</span><br><span class="line">A.a--&gt;A.a.4(ByteArrayInputStream)</span><br><span class="line">A.b--&gt;A.b.1(...)</span><br><span class="line">A.b--&gt;A.b.2(FilterOutputStream)</span><br><span class="line">A.b--&gt;A.b.3(...)</span><br><span class="line">A.b--&gt;A.b.4(...)</span><br><span class="line">B.a--&gt;B.a.1(BufferedReader)</span><br><span class="line">B.a--&gt;B.a.2(InputStreamReader)</span><br><span class="line">B.a--&gt;B.a.3(StringReader)</span><br><span class="line">B.b--&gt;B.b.1(...)</span><br><span class="line">B.b--&gt;B.b.2(...)</span><br><span class="line">B.b--&gt;B.b.3(...)</span><br><span class="line">B.b--&gt;B.b.4(PrintWriter)</span><br><span class="line">A.a.2--&gt;A.a.2.1(BufferedInputStream)</span><br><span class="line">A.a.2--&gt;A.a.2.2(DataInputStream)</span><br><span class="line">A.b.2--&gt;A.b.2.1(...)</span><br><span class="line">A.b.2--&gt;A.b.2.2(...)</span><br><span class="line">A.b.2--&gt;A.b.2.3(PrintStream)</span><br><span class="line">B.a.2--&gt;B.a.2.1(FileWriter)</span><br></pre></td></tr></table></figure><h2 id="5-1-分类"><a href="#5-1-分类" class="headerlink" title="5.1. 分类"></a>5.1. 分类</h2><p>字节处理流：OutputStream（输出字节流）、InputStream（输入字节流）</p><p>字符处理流：Writer（输出字符流）、Reduce（输入字符流）</p><p>字节流可以复制任意文件数据，字符流只能复制文本数据</p><h2 id="5-2-步骤"><a href="#5-2-步骤" class="headerlink" title="5.2. 步骤"></a>5.2. 步骤</h2><p>要读写的内容，可直接使用记事本打开，则使用字符流，否则使用字节流</p><p>下面以文件处理的流程为例：</p><p>（1）如果现在要进行的是文件的读写操作，则一定要通过 File 类找到一个文件路径；</p><p>（2）通过字节流或字符流的子类把父类对象实例化；</p><p>（3）利用字节流或字符流中的方法实现数据的输入与输出操作；</p><p>（4）流的操作属于资源操作，资源操作结束后必须进行关闭处理。</p><h2 id="5-3-编码和解码"><a href="#5-3-编码和解码" class="headerlink" title="5.3. 编码和解码"></a>5.3. 编码和解码</h2><p><strong>编码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">byte[] getBytes() 使用平台默认的字符集将该String编码为一系列字节，结果存储到新的字节数组中</span><br><span class="line"></span><br><span class="line">byte[] getByte(String charsetName) 使用指定的字符集将该String编码为一系列字节，结果存储到新的字节数组中</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] bys1 = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] bys2 = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(Arrays.toString(bys1));</span><br><span class="line">        System.out.println(Arrays.toString(bys2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String(byte[] bytes) 使用平台默认的字符集将字节数组解码为String</span><br><span class="line">String(byte[] bytes,String charsetName) 使用指定的字符集将字节数组解码为String</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;中国&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] bys1 = s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    <span class="type">byte</span>[] bys2 = s.getBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(Arrays.toString(bys1));</span><br><span class="line">    System.out.println(Arrays.toString(bys2));</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ss1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys1,<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">    System.out.println(ss1);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ss2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bys2,<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    System.out.println(ss2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-字节流（重点）"><a href="#6-字节流（重点）" class="headerlink" title="6. 字节流（重点）"></a>6. 字节流（重点）</h1><p>字节的数据是以 byte 类型为主实现的操作</p><h2 id="6-1-OutputStream"><a href="#6-1-OutputStream" class="headerlink" title="6.1. OutputStream"></a>6.1. OutputStream</h2><p>OutputStream 类定义的是一个公共的输出操作标准</p><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>public abstract void write(int b) throws IOException</td><td>输出单个字节数据</td></tr><tr><td>public void write(byte[] b) throws IOException</td><td>输出一组字节数据</td></tr><tr><td>public void write(byte[] b, int off, int len) throws IOException</td><td>输出部分字节数据</td></tr><tr><td>flush()</td><td>刷新此输出流并强制写出所有缓冲的输出字节</td></tr><tr><td>close()</td><td>关闭输出流释放相关的系统资源</td></tr></tbody></table></div><p>OutputStream 类是一个抽象类，而这个抽象类如果想要获得实例化对象，应该通过子类实例的向上转型完成。如果要进行文件写入操作，则可以使用 FileOutputStream 子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 只需要确保父目录存在，若没有创建文件，则自动帮助用户创建</span></span><br><span class="line">    <span class="keyword">if</span> (!f1.getParentFile().exists())&#123;</span><br><span class="line">        f1.getParentFile().mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过子类实例的向上转型完成实例化</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">    <span class="comment">// 将字符串变为字节数组</span></span><br><span class="line">    output.write(str.getBytes());</span><br><span class="line">    <span class="comment">//关闭 IO</span></span><br><span class="line">    output.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现换行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Windows下</span></span><br><span class="line">f1.write(<span class="string">&quot;\r\n&quot;</span>.getBytes());</span><br></pre></td></tr></table></figure><p>追加写入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加一个Boolean类型的参数 true</span></span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f1,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p>自动释放IO资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用try-catch结构执行，可实现自动释放IO资源</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    f1.write();</span><br><span class="line">&#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileOutputStream</code> 通常也会配合 <code>BufferedOutputStream</code>（字节缓冲输出流）来使用</p><p><code>ObjectOutputStream</code>将对象写入到输出流（<code>ObjectOutputStream</code>，序列化）</p><p><code>DataOutputStream</code> 用于写入指定类型数据，不能单独使用，必须结合 <code>FileOutputStream</code></p><h2 id="6-2-InputStream"><a href="#6-2-InputStream" class="headerlink" title="6.2. InputStream"></a>6.2. InputStream</h2><p>InputStream 类定义的是一个公共的输入操作标准</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>read()</td><td>读取输入流中下一个字节的数据。返回的值介于 0 到 255 之间，如果现在已经读取到底了，返回-1</td></tr><tr><td>public int read(byte[] b) throws IOException</td><td>读取一组字节数据，返回读取的字节个数，如果没有数据读取，已经读取到底了，则返回-1</td></tr><tr><td>public int read(byte[] b, int off, int len) throws IOException</td><td>读取一组字节数据，只截取一部分</td></tr><tr><td>available()</td><td>返回输入流中可以读取的字节数</td></tr><tr><td>close()</td><td>关闭输入流，释放相关的系统资源</td></tr><tr><td>readAllBytes()</td><td>读取输入流中的所有字节，返回字节数组</td></tr><tr><td>transferTo(OutputStream out)</td><td>将所有字节从一个输入流传递到一个输出流</td></tr></tbody></table></div><p>InputStream 类是一个抽象类，而这个抽象类如果想要获得实例化对象，应该通过子类实例的向上转型完成。如果要进行文件读取操作，则一定要使用 FileInputStream 子类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过子类实例的向上转型完成实例化</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f1);</span><br><span class="line">    <span class="comment">// 开辟缓冲区</span></span><br><span class="line">    <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 暂存读取的数据</span></span><br><span class="line">    input.read(data);</span><br><span class="line">    <span class="comment">// 字节转字符串</span></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">    <span class="comment">//关闭 IO</span></span><br><span class="line">    input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般不会直接单独使用 <code>FileInputStream</code> ，通常会配合 <code>BufferedInputStream</code>（字节缓冲输入流）来使用</p><p><code>ObjectInputStream</code> 用于从输入流中读取 Java 对象（反序列化）</p><p><code>DataInputStream</code> 用于读取指定类型数据，不能单独使用，必须结合 <code>FileInputStream</code></p><h1 id="7-字符流（重点）"><a href="#7-字符流（重点）" class="headerlink" title="7. 字符流（重点）"></a>7. 字符流（重点）</h1><p>字符流 = 字节流 + 编码表</p><p>因为汉字的存储是有编码的，GBK或UTF-8等，GBK编码占2个字节，UTF-8编码占3个字节，直接使用字节流读取，会导致无法读取到完整的汉字</p><p>字符流传输的本质：缓冲区的存在，数据先写入缓冲区，然后数据在缓冲区中根据编码格式进行输出</p><h2 id="7-1-Writer"><a href="#7-1-Writer" class="headerlink" title="7.1. Writer"></a>7.1. Writer</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>write(int b)</td><td>写入单个字符</td></tr><tr><td>public void write(char[] cbuf) throws IOException</td><td>输出字符数组</td></tr><tr><td>public void write( String str) throws IOException</td><td>输出字符串</td></tr><tr><td>append(CharSequence csq)</td><td>将指定的字符序列附加到指定的 Writer对象并返回该 Writer对象</td></tr><tr><td>flush()</td><td>刷新此输出流并强制写出所有缓冲的输出字符</td></tr></tbody></table></div><p>Writer 类是一个抽象类，而这个抽象类如果想要获得实例化对象，应该通过子类实例的向上转型完成。如果要进行文件写入操作，则可以使用 FileWriter 子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过子类实例的向上转型完成实例化</span></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(f1);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是是是&quot;</span>;</span><br><span class="line">    out.write(str);</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-2-Reader"><a href="#7-2-Reader" class="headerlink" title="7.2. Reader"></a>7.2. Reader</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>read()</td><td>从输入流读取一个字符</td></tr><tr><td>public int read(char[] cbuf) throws IOException</td><td>接收字符数组</td></tr><tr><td>read(char[] cbuf, int off, int len)</td><td>接收一段字符数组</td></tr></tbody></table></div><p>Reader 类是一个抽象类，而这个抽象类如果想要获得实例化对象，应该通过子类实例的向上转型完成。如果要进行文件读取操作，则可以使用 FileReader子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过子类实例的向上转型完成实例化</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(f1);</span><br><span class="line">    <span class="type">char</span>[] data = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> in.read(data);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-字节流与字符流区别"><a href="#8-字节流与字符流区别" class="headerlink" title="8. 字节流与字符流区别"></a>8. 字节流与字符流区别</h1><p><strong>字节流默认不使用缓冲区；字符流使用缓冲区</strong>。 字节流在操作的时候本身是不会用到缓冲区的，是与文件本身直接操作的，所以字节流在操作文件时，即使不关闭资源，文件也能输出；字符流在操作的时候是使用到缓冲区的。 如果字符流不调用close或flush方法，则不会输出任何内容</p><h1 id="9-字节缓冲流"><a href="#9-字节缓冲流" class="headerlink" title="9. 字节缓冲流"></a>9. 字节缓冲流</h1><p>字节缓冲流采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能</p><h2 id="9-1-BufferedInputStream"><a href="#9-1-BufferedInputStream" class="headerlink" title="9.1. BufferedInputStream"></a>9.1. BufferedInputStream</h2><p>会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。</p><p><code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。缓冲区的大小默认为 <strong>8192</strong> 字节，也可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小</p><h2 id="9-2-BufferedOutputStream"><a href="#9-2-BufferedOutputStream" class="headerlink" title="9.2. BufferedOutputStream"></a>9.2. BufferedOutputStream</h2><p>类似BufferedInputStream</p><h1 id="10-字符缓冲流"><a href="#10-字符缓冲流" class="headerlink" title="10. 字符缓冲流"></a>10. 字符缓冲流</h1><h2 id="10-1-BufferedReader"><a href="#10-1-BufferedReader" class="headerlink" title="10.1. BufferedReader"></a>10.1. BufferedReader</h2><p>利用 BufferedReader 类可以很好的解决输入流数据的读取问题</p><p>读取一行数据: <code>public String readLine() throws IOException</code></p><p>利用这个类实现键盘输入数据的标准化定义，实际开发中所有输入的数据全部都是字符串，方便用户验证与进行字符串的复杂处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入内容&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> input.readLine();</span><br><span class="line">    System.out.println(<span class="string">&quot;所输内容为：&quot;</span> + msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-BufferedWriter"><a href="#10-2-BufferedWriter" class="headerlink" title="10.2. BufferedWriter"></a>10.2. BufferedWriter</h2><p>…</p><h1 id="11-打印流"><a href="#11-打印流" class="headerlink" title="11. 打印流"></a>11. 打印流</h1><p>若要通过程序实现内容的输出，核心的本质一定要依靠 OutputStream 类完成，比起直接使用 OutputStream 类，使用装饰设计模式实现的 PrintWriter、 PrintStream 类的处理操作会更加的简单</p><h2 id="11-1-PrintStream"><a href="#11-1-PrintStream" class="headerlink" title="11.1. PrintStream"></a>11.1. PrintStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">pu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file));</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.baidasdasd&quot;</span>;</span><br><span class="line">    pu.printf(str);</span><br><span class="line">    pu.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-PrintWriter"><a href="#11-2-PrintWriter" class="headerlink" title="11.2. PrintWriter"></a>11.2. PrintWriter</h2><p>用法一样</p><h1 id="12-随机访问流"><a href="#12-随机访问流" class="headerlink" title="12. 随机访问流"></a>12. 随机访问流</h1><p>RandomAccessFile 支持随意跳转到文件的任意位置进行读写</p><p>前提：数据需要对齐存储，数据的保存位数要确定好</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>构造方法: public RandomAccessFile(File file, String mode)throws FileNotFoundException</td><td>文件处理模式: r、rw</td></tr><tr><td>public int skipBytes(int n) throws IOException</td><td>向下跳</td></tr><tr><td>public void seek(long pos) throws IOException</td><td>向回跳</td></tr></tbody></table></div><p><code>RandomAccessFile</code> 比较常见的一个应用就是实现大文件的 <strong>断点续传</strong> 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础</p><h1 id="13-转换流"><a href="#13-转换流" class="headerlink" title="13. 转换流"></a>13. 转换流</h1><p>实现字节流与字符流操作的功能转换，所谓的转换处理就是将接收到的字节流对象通过向上转型变为字符流对象</p><p><strong>字符流传输的本质：缓冲区的存在，数据先写入缓冲区，然后数据在缓冲区中根据编码格式进行输出</strong>。而字节流的数据不经过缓冲区</p><h2 id="13-1-InputStreamReader"><a href="#13-1-InputStreamReader" class="headerlink" title="13.1. InputStreamReader"></a>13.1. InputStreamReader</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(f1);</span><br><span class="line">    <span class="comment">// 字节流转字符流</span></span><br><span class="line">    <span class="type">char</span> []ss = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">Reader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(input);</span><br><span class="line">    in.read(ss);</span><br><span class="line">    in.close();</span><br><span class="line">    System.out.println(ss);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-2-OutputStreamWriter"><a href="#13-2-OutputStreamWriter" class="headerlink" title="13.2. OutputStreamWriter"></a>13.2. OutputStreamWriter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">File</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建字节流对象</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(f1);</span><br><span class="line">    <span class="comment">// 字节流转字符流</span></span><br><span class="line">    <span class="type">Writer</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(output);</span><br><span class="line">    out.write(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="14-文件拷贝实现（重点）"><a href="#14-文件拷贝实现（重点）" class="headerlink" title="14. 文件拷贝实现（重点）"></a>14. 文件拷贝实现（重点）</h1><p>应使用字节流，方便拷贝各类型文件</p><p>应使用部分拷贝，即读取一部分输出一部分数据，方便拷贝大型文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileUtil</span>&#123;</span><br><span class="line">    <span class="comment">//源文件路径</span></span><br><span class="line">    <span class="keyword">private</span> File srcFile;</span><br><span class="line">    <span class="comment">// 目标文件路径</span></span><br><span class="line">    <span class="keyword">private</span> File desFile;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUtil</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FileUtil</span><span class="params">(String srcFile,String desFile)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.srcFile = <span class="keyword">new</span> <span class="title class_">File</span>(srcFile);</span><br><span class="line">        <span class="built_in">this</span>.desFile = <span class="keyword">new</span> <span class="title class_">File</span>(desFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 文件拷贝处理</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">copy</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 源文件是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.srcFile.exists())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 目标路径的父目录是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">this</span>.desFile.getParentFile().exists())&#123;</span><br><span class="line">            <span class="built_in">this</span>.desFile.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            input = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="built_in">this</span>.srcFile);</span><br><span class="line">            out = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="built_in">this</span>.desFile);</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = input.read(data)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                out.write(data,<span class="number">0</span>,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(input != <span class="literal">null</span>) &#123;</span><br><span class="line">                input.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="literal">null</span>)&#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="15-内存流"><a href="#15-内存流" class="headerlink" title="15. 内存流*"></a>15. 内存流*</h1><p>需要实现 IO 操作，可是又不希望产生文件（相当于临时文件）则以内存为终端进行处理。</p><p>ByteArrayInputStream、ByteArrayOutputStream 分别是InputStream、OutputStream 的子类，如果要进行内存流操作，则应该通过子类实例的向上转型完成</p><h2 id="15-1-ByteArrayInputStream"><a href="#15-1-ByteArrayInputStream" class="headerlink" title="15.1. ByteArrayInputStream"></a>15.1. ByteArrayInputStream</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>构造方法 public ByteArrayInputStream(byte[] buf)</td></tr></tbody></table></div><h2 id="15-2-ByteArrayOutputStream"><a href="#15-2-ByteArrayOutputStream" class="headerlink" title="15.2. ByteArrayOutputStream"></a>15.2. ByteArrayOutputStream</h2><div class="table-container"><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>构造方法 public ByteArrayOutputStream()</td><td></td></tr><tr><td>public byte[] toByteArray()</td><td>获取内存数据</td></tr><tr><td>public String toString()</td><td>使用字符串的形式来获取内存数据</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(str.getBytes());</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((data = input.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">        out.write(Character.toUpperCase(data));</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="16-管道流"><a href="#16-管道流" class="headerlink" title="16. 管道流*"></a>16. 管道流*</h1><p>实现两个线程之间的 IO 处理操作，一个只负责发送，一个负责接收，中间靠一个管道连接</p><h2 id="16-1-字节管道流"><a href="#16-1-字节管道流" class="headerlink" title="16.1. 字节管道流"></a>16.1. 字节管道流</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PipedOutputStream、PipedInputStream</span><br><span class="line"></span><br><span class="line">连接处理：public void connect(PipedInputStream snk)throws IOException</span><br></pre></td></tr></table></figure><h2 id="16-2-字符管道流"><a href="#16-2-字符管道流" class="headerlink" title="16.2. 字符管道流"></a>16.2. 字符管道流</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PipedWriter、PipedReader</span><br><span class="line"></span><br><span class="line">连接处理：public void connect(PipedReader snk)throws IOException</span><br></pre></td></tr></table></figure><h1 id="17-System类的IO"><a href="#17-System类的IO" class="headerlink" title="17. System类的IO"></a>17. System类的IO</h1><p>这个系统类之中提供有三个常量：</p><p>标准输出(显示器)：<code>public static final PrintStream out</code></p><p>错误输出：<code>public static final PrintStream err;</code></p><p>标准输入(键盘)：<code>public static final InputStream in。</code></p><p>System.out 和 System.err 都是同一种类型的，如果现在使用的是 IDEA，则在使用System.err 输出的时使用红色字体，而 System.out 会使用黑色字体。</p><p>System.in 一般不直接用来接收键盘输入</p><h1 id="18-Scanner扫描流（重点）"><a href="#18-Scanner扫描流（重点）" class="headerlink" title="18. Scanner扫描流（重点）"></a>18. Scanner扫描流（重点）</h1><p>BufferedReader的代替品</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>构造方法 public Scanner (InputStream source)</td><td></td></tr><tr><td>public Scanner useDelimiter(String pattern)</td><td>设置分隔符，即遇到什么符号时换行</td></tr><tr><td>public String next()</td><td>取出数据</td></tr><tr><td>public boolean hasNext()</td><td>判断是否有数据</td></tr></tbody></table></div><p><strong>使用 Scanner 实现键盘数据输入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入年龄：&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (scan.hasNextInt())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄是:&quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">    scan.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 Scanner 读取数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\test\\test.txt&quot;</span>));</span><br><span class="line">    scan.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(scan.hasNext())&#123;</span><br><span class="line">        System.out.println(scan.next());</span><br><span class="line">    &#125;</span><br><span class="line">    scan.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="19-对象序列化"><a href="#19-对象序列化" class="headerlink" title="19. 对象序列化"></a>19. 对象序列化</h1><p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p><p>对象本来存在于堆内存，将对象保存到磁盘中，就是实现了对象序列化</p><p>使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息，字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p><p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p><p>在 Java 中有一个强制性的要求：如果要序列化对象，那么该对象所在的类必须实现 java.io.Serializable 父接口，作为序列化的标记。这个接口描述的是一种类的能力。Serializable是一个标记接口，实现该接口，不需要重写任何方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现 Serializable 父接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Family</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Family</span><span class="params">(<span class="type">int</span> age,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>类名称</th><th>序列化 ObjectOutputStream</th><th>反序列化 ObjectInputStream</th></tr></thead><tbody><tr><td>构造方法</td><td>public<code> </code>ObjectOutputStream(OutputStream out) throws IOException</td><td>public<code> </code>ObjectInputStream(InputStream in) throws IOException</td></tr><tr><td>操作方法</td><td>public final void writeObject(Object obji) throws IOException</td><td>public final Object readObject() throws IOException</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">saveObject</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;D:\\test\\class.family&quot;</span>));</span><br><span class="line">    oos.writeObject(obj);</span><br><span class="line">    oos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">loadObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\test\\class.family&quot;</span>));</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    ois.close();</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>transient关键字</strong></p><p>假设类之中有一些是需要计算保存的属性内容往往是不需要被数列化的，这个时候就可以使用 transient</p><h1 id="20-文件上传的实现（重点）"><a href="#20-文件上传的实现（重点）" class="headerlink" title="20. 文件上传的实现（重点）"></a>20. 文件上传的实现（重点）</h1><p>前端form表单，必须是<code>multipart/form-data</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/seller/goods&#125;&quot;</span> <span class="attr">th:method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>后端Java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Upload</span> &#123;</span><br><span class="line">    <span class="comment">// 封装调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">picture</span><span class="params">(MultipartFile photo)</span> <span class="keyword">throws</span> IOException&#123;</span><br><span class="line">        <span class="comment">//获取文件名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;fileName:\t&quot;</span> + photo.getOriginalFilename());</span><br><span class="line">        <span class="comment">//取文件类型</span></span><br><span class="line">        System.out.println(<span class="string">&quot;fileType:\t&quot;</span> + photo.getContentType());</span><br><span class="line">        <span class="comment">//获取当前工程路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">path</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>) + <span class="string">&quot;\\upload\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> saveFile(photo,path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存上传文件至服务器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">saveFile</span><span class="params">(MultipartFile photo, String path)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">File</span> <span class="variable">files</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        <span class="keyword">if</span> (files.exists())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件夹已创建&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            files.mkdirs();</span><br><span class="line">            System.out.println(<span class="string">&quot;文件夹创建成功&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> path + photo.getOriginalFilename();</span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(path);</span><br><span class="line">        photo.transferTo(file);</span><br><span class="line">        System.out.println(<span class="string">&quot;filePath:\t&quot;</span> + filePath);</span><br><span class="line">        <span class="keyword">return</span> filePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="21-IO流总结"><a href="#21-IO流总结" class="headerlink" title="21. IO流总结"></a>21. IO流总结</h1><p>在以后的开发过程中，如果程序需要输出数据一定使用打印流，输入数据一定使用Scanner扫描流</p><h1 id="22-集合"><a href="#22-集合" class="headerlink" title="22. 集合"></a>22. 集合</h1><p>一种存储空间可变的存储模型</p><p><strong>和数组的区别</strong></p><p>数组长度固定，集合长度不固定</p><p>数组中只能存储相同类型的数据，而集合可以存储不同类型的数据，前提是它们都是Object类型的</p><p>数组可以通过索引直接访问元素，而集合需要通过迭代器或者foreach语句来访问元素</p><p>数组是基于连续内存分配的，所以在创建时必须指定大小，而集合则是基于动态内存分配的，可以根据需要自动调整大小</p><p>数组是基于连续内存分配的，所以访问数组元素的效率比访问集合元素的效率高。但是集合具有更高的灵活性和可扩展性</p><p><strong>无序性</strong>是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的</p><p><strong>不可重复性</strong>是指添加的元素按照 <code>equals()</code> 判断时 ，返回 false，需要同时重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">集合--&gt; A(Collection-单列)</span><br><span class="line">A--&gt;a(List-有序的&amp;可重复的)</span><br><span class="line">A--&gt;c(Set-无序的&amp;不可重复的)</span><br><span class="line">A--&gt;b(Queue-有序的&amp;可重复的)</span><br><span class="line">a--&gt;ArrayList-数组</span><br><span class="line">a--&gt;LinkedList-双向链表</span><br><span class="line">a--&gt;Vector-数组-不常用</span><br><span class="line">c--&gt;HashSet-无序&amp;唯一-底层是哈希表</span><br><span class="line">c--&gt;LinkedHashSet-有序-唯一-底层是哈希表和链表</span><br><span class="line">c--&gt;TreeSet-有序&amp;唯一-底层是红黑树-自平衡的排序二叉树</span><br><span class="line">集合--&gt; B(Map-存放键值对)</span><br><span class="line">B--&gt;B.a(HashMap-数组&amp;链表组成)</span><br><span class="line">B--&gt;B.b(LinkedHashMap-继承自HashMap)</span><br><span class="line">B--&gt;B.c(TreeMap-红黑树-自平衡的排序二叉树)</span><br><span class="line">B--&gt;B.d(Hashtable-不常用)</span><br></pre></td></tr></table></figure><h1 id="23-Collection"><a href="#23-Collection" class="headerlink" title="23. Collection"></a>23. Collection</h1><p>是单列集合的顶层接口</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public boolean add(E e)</td><td>向集合添加元素</td></tr><tr><td><code>public boolean addAll(Collection&lt;?extends E&gt; c)</code></td><td>向集合追加一组数据</td></tr><tr><td>public boolean remove(Object o)</td><td>删除指定元素，需要equals方法支持</td></tr><tr><td>public void clear()</td><td>清空集合，让根节点为空，同时执行GC操作</td></tr><tr><td>public boolean contains(Object o)</td><td>判断集合中是否存在指定的元素</td></tr><tr><td>public boolean isEmpty()</td><td>判断集合是否为空</td></tr><tr><td>public int size()</td><td>获取集合长度</td></tr><tr><td>public Object[] toArray()</td><td>将集合变为对象数组返回</td></tr><tr><td><code>public Iterator&lt;E&gt; iterator()</code></td><td>将集合变为Iterator 接口</td></tr></tbody></table></div><p>集合操作有两个方法最为常用： add ()、 iterator()</p><h2 id="23-1-List"><a href="#23-1-List" class="headerlink" title="23.1. List"></a>23.1. List</h2><p>有序：插入的顺序就是其存储顺序</p><p>其最大的特点是<strong>允许保存重复元素数据</strong></p><p>用户可以<strong>通过索引来增删改查元素</strong></p><p><strong>List扩充的方法</strong></p><div class="table-container"><table><thead><tr><th>特有方法</th><th>说明</th></tr></thead><tbody><tr><td><code>public ListIterator&lt;E&gt;listIterator()</code></td><td>返回ListIterator接口对象</td></tr><tr><td>public E set(int index,E element)</td><td>修改数据</td></tr><tr><td>public E get(int index)</td><td>查找数据</td></tr></tbody></table></div><p>List 本身依然属于一个接口，对于接口要想使用则一定要使用子类来完成定义，在 List 子接口中有三个常用子类： ArrayList、Vector、 LinkedList，其中ArrayList使用频率最高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; c = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h3 id="23-1-1-ArrayList（重点）"><a href="#23-1-1-ArrayList（重点）" class="headerlink" title="23.1.1. ArrayList（重点）"></a>23.1.1. ArrayList（重点）</h3><p>应用场景：当需要一个基于数组的动态列表，<strong>支持随机访问</strong>和快速的插入/删除操作时</p><p>线程是否安全：线程不安全</p><p>是否允许重复：可重复的</p><p>是否有序：有序的（元素按照插入的顺序存储在数组中）</p><p>底层的数据结构：数组</p><p>自身数据结构：对象数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th>构造方法</th><th>说明</th></tr></thead><tbody><tr><td>public ArrayList()</td><td>开辟大小为 10 的数组</td></tr><tr><td>public ArrayList(int initialCapacity)</td><td>开辟指定大小的数组</td></tr></tbody></table></div><p><strong>ArrayList 的扩容机制（重点）</strong></p><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量，<code>ensureCapacity</code>方法会创建一个新的数组，并将原始数组中的元素复制到新数组中</p><p>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。用<code>add()</code>添加元素时调用<code>ensureCapacityInternal()</code>，该方法中判断是否大于10，若元素数量大于10，则进入 <code>grow()</code>进行扩容，<strong>ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（源码：int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)）</strong>。有可能会造成垃圾的产生以及性能的下降</p><p>所以在使用ArrayList子类的时候一定要估算出你的数据量会有多少，如果超过了 10  个，那么使用有参构造方法进行创建，以避免垃圾数组的产生</p><p><strong>ArrayList保存自定义类对象</strong></p><p>在使用 List 保存自定义类对象的时候如果需要使用到 contains 、remove 方法进行查询与删除处理时候，一定要保证自定义类之中已经成功的重写了 equals 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Family</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Family</span><span class="params">(<span class="type">int</span> age,String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 重写equals方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> Family))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Family</span> <span class="variable">fam</span> <span class="operator">=</span> (Family) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(fam.name) &amp;&amp; <span class="built_in">this</span>.age == fam.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Family&gt; array = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Family&gt;();</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Family</span>(<span class="number">10</span>,<span class="string">&quot;一&quot;</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Family</span>(<span class="number">12</span>,<span class="string">&quot;二&quot;</span>));</span><br><span class="line">        array.add(<span class="keyword">new</span> <span class="title class_">Family</span>(<span class="number">15</span>,<span class="string">&quot;三&quot;</span>));</span><br><span class="line">        <span class="comment">// 不重写equals方法，这里删不掉</span></span><br><span class="line">        array.remove(<span class="keyword">new</span> <span class="title class_">Family</span>(<span class="number">10</span>,<span class="string">&quot;一&quot;</span>));</span><br><span class="line">        array.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-1-2-LinkedList"><a href="#23-1-2-LinkedList" class="headerlink" title="23.1.2. LinkedList"></a>23.1.2. LinkedList</h3><p>应用场景：当需要一个基于链表的动态列表，支持<strong>高效的添加/删除操作</strong>和迭代操作时</p><p>线程是否安全：线程不安全</p><p>是否允许重复：可重复的</p><p>是否有序：有序的（元素按照添加的顺序存储在链表中）</p><p>底层的数据结构：链表</p><p>自身数据结构：双向链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; LinkList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>无参构造方法 public LinkedList()</td><td>创建空的list集合</td></tr><tr><td>public boolean add(E e)</td><td>编写自定义链表的时候，是判断了传入数据是否为null，如果为null则不进行保存，但是在LinkedList里面并没有做这样的处理，而是所有的数据都可以保存，而后此方法调用了linkLast()方法</td></tr></tbody></table></div><h3 id="23-1-3-Vector"><a href="#23-1-3-Vector" class="headerlink" title="23.1.3. Vector*"></a>23.1.3. Vector*</h3><p>继承结构与 ArrayList 是相同的，其实现操作与 ArrayList 是相同的</p><p>Vector类之中的操作方法采用的都是 synchronized 同步处理，是线程安全的，但是性能不如 ArrayList高</p><h2 id="23-2-Set"><a href="#23-2-Set" class="headerlink" title="23.2. Set"></a>23.2. Set</h2><p>不包含重复元素、无序</p><p>没有带索引的方法，所以不能使用for循环遍历，但<strong>可使用增强for遍历</strong></p><p>Set 集合的常规使用形式一定是依靠子类进行实例化的，所以 Set 接口之中有两个常用子类：HashSet、TreeSet。其中HashSet 使用最多</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; ss = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br><span class="line">        ss.add(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">        System.out.println(ss.size());</span><br><span class="line">        <span class="keyword">for</span> (String s:ss)&#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-2-1-HashSet"><a href="#23-2-1-HashSet" class="headerlink" title="23.2.1. HashSet"></a>23.2.1. HashSet</h3><p>应用场景：当需要一个无序的集合，其中没有重复元素，并且不需要维护元素的顺序时，<strong>常用于去重和集合运算（即求交、并、补集）</strong></p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的</p><p>是否有序：无序的（hashCode计算得到保存地址）</p><p>底层的数据结构：哈希表</p><p>自身数据结构：哈希表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><p><strong>hashCode</strong></p><p>属于Object类的方法，hashCode就是通过hash函数计算出的 int 类型的数值</p><p>hashCode确定了对象在hash表中的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h3 id="23-2-2-TreeSet（重点）"><a href="#23-2-2-TreeSet（重点）" class="headerlink" title="23.2.2. TreeSet（重点）"></a>23.2.2. TreeSet（重点）</h3><p>应用场景：当需要一个有序的集合，并且需要对元素进行自然排序或指定的比较器进行排序时（如 多线程异步查询数据，最后要保证数据结果的有序性，可使用TreeSet存储）</p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的</p><p>是否有序：有序的（可实现自定义排序）</p><p>底层的数据结构：红黑树</p><p>自身数据结构：红黑树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><h3 id="23-2-3-LinkedHashSet"><a href="#23-2-3-LinkedHashSet" class="headerlink" title="23.2.3. LinkedHashSet"></a>23.2.3. LinkedHashSet</h3><p>应用场景：当需要一个有序的集合，可以提供快速的插入、删除和查找元素操作，并且保证元素的有序性，元素的插入和取出顺序满足 FIFO（可利用该数据结构实现一个队列）</p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的</p><p>是否有序：有序的（元素的顺序是插入顺序）</p><p>底层的数据结构：哈希表和链表</p><p>自身数据结构：哈希表和双向链表（哈希表用于快速查找元素，双向链表用于维护插入顺序）</p><h3 id="23-2-4-比较-HashSet-amp-LinkedHashSet-amp-TreeSet"><a href="#23-2-4-比较-HashSet-amp-LinkedHashSet-amp-TreeSet" class="headerlink" title="23.2.4. 比较 HashSet&amp;LinkedHashSet&amp;TreeSet"></a>23.2.4. 比较 HashSet&amp;LinkedHashSet&amp;TreeSet</h3><ul><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 都是 <code>Set</code> 接口的实现类，都能保证元素唯一，并且都不是线程安全的</li><li><code>HashSet</code>、<code>LinkedHashSet</code> 和 <code>TreeSet</code> 的主要区别在于底层数据结构不同。<code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）<code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。<code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序</li><li>底层数据结构不同又导致这三者的应用场景不同。<code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景，<code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景，<code>TreeSet</code> 用于支持对元素自定义排序规则的场景</li></ul><h3 id="23-2-5-排序的实现（重点）"><a href="#23-2-5-排序的实现（重点）" class="headerlink" title="23.2.5. 排序的实现（重点）"></a>23.2.5. 排序的实现（重点）</h3><p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>comparable</code>接口的<code>compareTo()</code>方法或利用比较器<code>comparator</code>接口的<code>compare()</code>方法</p><p><strong>自然顺序（Comparable）</strong><br>TreeSet类的add()方法中会把存入的对象提升为Comparable类型<br>调用对象的compareTo()方法和集合中的对象比较（比较字符串对象时比较的是Unicode）<br>根据compareTo()方法返回的结果进行存储</p><p><strong>比较器顺序（Comparator）</strong><br>创建TreeSet的时候可以制定 一个Comparator<br>如果传入了Comparator的子类对象，那么TreeSet就会按照比较器中的顺序排序<br>add()方法内部会自动调用Comparator接口中compare()方法排序<br>调用的对象是compare方法的第一个参数，集合中的对象是compare方法的第二个参数</p><p><strong>两种方式的区别</strong><br>TreeSet构造函数什么都不传，默认按照类中Comparable的顺序（没有就报错ClassCastException）<br>TreeSet如果传入Comparator，就优先按照Comparator</p><p><strong>选用</strong><br>Comparable 让元素本身具有比较性，当元素本身不具有比较性时，就在TreeSe t建立实例的时候，传入Comparator接口，让容器自身具有比较性</p><p>TreeSet 自然排序的过程，即比较自定义对象的过程，需要自定义类实现comparable接口，重写comparaTo() 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Person&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Person o)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">//当compareTo方法返回0的时候集合中只有一个元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                <span class="comment">//当compareTo方法返回正数的时候集合会怎么存就怎么取</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;                <span class="comment">//当compareTo方法返回负数的时候集合会倒序存储</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>comparaTo() 方法返回值的含义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>:元素每次进行比较，都认为是相同的元素，所以不再向TreeSet里面插入除第一个元素以外的元素，即 TreeSet中就只插入了一个元素。</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> 正数:元素每次进行比较，都认为新插入的元素比上一个元素大，于是二叉树存储时，会储存在根的右侧，读取时就是正序排列，先进先出。</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> 负数:元素每次进行比较，都认为新插入的元素比上一个元素小，于是二叉树存储时，会储存在根的左侧，读取时就是倒序排列，先进后出</span><br></pre></td></tr></table></figure><br>在使用自定义类对象进行比较处理的时候，一定要将该类之中的所有属性都依次进行大小关系的匹配，否则如果某一个或某几个属性相同的时候它也会认为是重复数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;student&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    student()&#123;&#125;</span><br><span class="line">    student(String name,<span class="type">int</span> age)&#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(student s)</span>&#123;<span class="comment">//按照年龄排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="built_in">this</span>.age - s.age;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     TreeSet&lt;student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;student&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="type">student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;xixi&quot;</span>,<span class="number">50</span>);</span><br><span class="line">     <span class="type">student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;zhao&quot;</span>,<span class="number">12</span>);</span><br><span class="line">     <span class="type">student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">student</span>(<span class="string">&quot;dalao&quot;</span>,<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">     ts.add(s1);</span><br><span class="line">     ts.add(s2);</span><br><span class="line">     ts.add(s3);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (student s:ts)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;name:&quot;</span> + s.getName() + <span class="string">&quot;age:&quot;</span> + s.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-2-6-消除重复的原理（重点）"><a href="#23-2-6-消除重复的原理（重点）" class="headerlink" title="23.2.6. 消除重复的原理（重点）"></a>23.2.6. 消除重复的原理（重点）</h3><p><strong>TreeSet</strong> </p><p>利用了 Comparable 接口来实现了重复元素的判断，插入元素时调用 compareTo() 来判断重复元素</p><p><strong>HashSet</strong></p><p><code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功</p><p><strong>总结</strong></p><p>在 Java 程序之中真正的重复元素的判断处理利用的就是 hashCode() 与 equals() 两个方法共同作用完成的，而只有在排序要求情况下 TreeSet 才会利用Comparable 接口来实现。</p><h2 id="23-3-Collection-集合的遍历"><a href="#23-3-Collection-集合的遍历" class="headerlink" title="23.3. Collection 集合的遍历"></a>23.3. Collection 集合的遍历</h2><p>一共有四种输出迭代输出形式：Iterator迭代输出、ListIterator 双向迭代输出、Enumeration 枚举输出、for-each 输出，其中Iterator迭代输出使用最多</p><h3 id="23-3-1-Iterator（重要）"><a href="#23-3-1-Iterator（重要）" class="headerlink" title="23.3.1. Iterator（重要）"></a>23.3.1. Iterator（重要）</h3><p>只允许由前向后实现输出</p><p>获取Iterator接口对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Iterator&lt;T&gt;iterator()</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public boolean hasNext()</td><td>判断是否有数据</td></tr><tr><td>public E next()</td><td>取出当前数据</td></tr><tr><td>public default void remove()</td><td>删除</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    all.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    all.add(<span class="string">&quot;zz&quot;</span>);</span><br><span class="line">    all.add(<span class="string">&quot;asdasd&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化Iterator接口</span></span><br><span class="line">    Iterator&lt;String&gt; iter = all.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Collection.remove() 与 Iterator.remove() 的区别</strong></p><p>在进行迭代输出的时候如果使用了 Collection.remove() 则会造成并发更新异常，导致程序删除出错，而此时只能使用 Iterator.remove() 方法实现正常的删除处理。</p><h3 id="23-3-2-ListIterator"><a href="#23-3-2-ListIterator" class="headerlink" title="23.3.2. ListIterator"></a>23.3.2. ListIterator</h3><p>进行双向迭代处理，必须依靠 Iterator 的子接口：ListIterator  接口来实现</p><p>ListIterator 输出接口是专门为 List 集合准备的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">all.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line"><span class="comment">// 实例化ListIterator接口</span></span><br><span class="line">ListIterator&lt;String&gt; iter = all.listIterator();</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">方法</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:left">public boolean hasPrevious()</td><td>判断是否有前一个元素</td></tr><tr><td style="text-align:left">public E previous()</td><td>获取当前元素</td></tr></tbody></table></div><p>如果要想实现由后向前的遍历，那么首先要实现的是由前向后实现遍历处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    all.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    all.add(<span class="string">&quot;asdasd&quot;</span>);</span><br><span class="line">    <span class="comment">// 实例化ListIterator 接口</span></span><br><span class="line">    ListIterator&lt;String&gt; iter = all.listIterator();</span><br><span class="line">    <span class="comment">// 先实现由前向后的遍历</span></span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> iter.next();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再实现由后向前的遍历</span></span><br><span class="line">    <span class="keyword">while</span> (iter.hasPrevious())&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> iter.previous();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="23-3-3-Enumeration"><a href="#23-3-3-Enumeration" class="headerlink" title="23.3.3. Enumeration*"></a>23.3.3. Enumeration*</h3><p>Enumeration 只为Vector  一个类服务，如果要想获取 Enumeration 接口对象，就必须依靠 Vector 类提供的方法</p><p>获取Enumeration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Enumeration&lt;E&gt; <span class="title function_">elements</span><span class="params">()</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public boolean hasMoreElements()</td><td>判断是否有下一个元素</td></tr><tr><td>public E nextElement()</td><td>获取当前元素</td></tr></tbody></table></div><h3 id="23-3-4-for-each"><a href="#23-3-4-for-each" class="headerlink" title="23.3.4. for-each"></a>23.3.4. for-each</h3><p>加强型 for 循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    List&lt;String&gt; all = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    all.add(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">    all.add(<span class="string">&quot;zz&quot;</span>);</span><br><span class="line">    all.add(<span class="string">&quot;asdasd&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : all)&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-4-Collection常见操作"><a href="#23-4-Collection常见操作" class="headerlink" title="23.4. Collection常见操作"></a>23.4. Collection常见操作</h2><h3 id="23-4-1-Collection集合判空"><a href="#23-4-1-Collection集合判空" class="headerlink" title="23.4.1. Collection集合判空"></a>23.4.1. Collection集合判空</h3><p>使用 <code>isEmpty()</code> 方法，而不是 <code>size()==0</code> 的方式</p><h3 id="23-4-2-Collection集合转-Map"><a href="#23-4-2-Collection集合转-Map" class="headerlink" title="23.4.2. Collection集合转 Map"></a>23.4.2. Collection集合转 Map</h3><p>在使用 <code>java.util.stream.Collectors</code> 类的 <code>toMap()</code> 方法转为 <code>Map</code> 集合时，一定要注意当 value 为 null 时会抛 NPE 异常</p><h3 id="23-4-3-Collection集合转数组"><a href="#23-4-3-Collection集合转数组" class="headerlink" title="23.4.3. Collection集合转数组"></a>23.4.3. Collection集合转数组</h3><p>使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组</p><h3 id="23-4-4-数组转Collection集合"><a href="#23-4-4-数组转Collection集合" class="headerlink" title="23.4.4. 数组转Collection集合"></a>23.4.4. 数组转Collection集合</h3><p>通过<code>Arrays.asList()</code> 方法转换，该方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类，这个内部类并没有实现集合的修改方法或者说并没有重写这些方法，所以<strong>使用集合的修改方法: <code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常</strong></p><p>用 Java8 的 <code>Stream</code>实现转换（推荐）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer [] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray).collect(Collectors.toList());</span><br><span class="line"><span class="comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span></span><br><span class="line"><span class="type">int</span> [] myArray2 = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h2 id="23-5-Collections-工具类（不重要）"><a href="#23-5-Collections-工具类（不重要）" class="headerlink" title="23.5. Collections 工具类（不重要）"></a>23.5. Collections 工具类（不重要）</h2><h3 id="23-5-1-Stack"><a href="#23-5-1-Stack" class="headerlink" title="23.5.1. Stack*"></a>23.5.1. Stack*</h3><p>栈是Vector的一个子类，但是它使用的并不是 Vector 类所提供的方法</p><p>它实现了一个标准的后进先出的栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">public boolean empty()</td><td style="text-align:left">测试堆栈是否为空</td></tr><tr><td style="text-align:left">public Object peek( )</td><td style="text-align:left">查看堆栈顶部的对象，但不从堆栈中移除它。</td></tr><tr><td style="text-align:left">public Object pop( )</td><td style="text-align:left">移除堆栈顶部的对象，并作为此函数的值返回该对象。</td></tr><tr><td style="text-align:left">public Object push(Object element)</td><td style="text-align:left">把项压入堆栈顶部。</td></tr><tr><td style="text-align:left">public int search(Object element)</td><td style="text-align:left">返回对象在堆栈中的位置，以 1 为基数。</td></tr></tbody></table></div><h3 id="23-5-2-Queue"><a href="#23-5-2-Queue" class="headerlink" title="23.5.2. Queue"></a>23.5.2. Queue</h3><p>队列实现可以使用 LinkedList 的子类来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;String&gt;()</span><br></pre></td></tr></table></figure><p>队列的主要依靠 Queue 接口之中提供的方法来处理</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public boolean offer(E e)</td><td>队列之中追加数据</td></tr><tr><td>public E poll()</td><td>弹出后删除数据</td></tr></tbody></table></div><p><strong>PriortyQueue 优先级队列的实现</strong></p><p>有比较功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;String&gt;()</span><br></pre></td></tr></table></figure><h3 id="23-5-3-Properties"><a href="#23-5-3-Properties" class="headerlink" title="23.5.3. Properties"></a>23.5.3. Properties</h3><p>此类是 Hashtable 的子类</p><p>能操作的类型只能是 String 类型</p><p>Properties 往往用于读取配置资源的信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">prop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>()</span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>setProperty(String key, String value)</td><td>设置属性</td></tr><tr><td>getProperty(String key,String defaultValue)</td><td>取得属性，如果没有指定的 key 则返回默认值</td></tr><tr><td>list(PrintStream out)</td><td>获得属性列表</td></tr></tbody></table></div><p>Properties 类还有一个最重要的功能是它可以通过输出流输出属性，也可以使用输入流读取属性内容，而 Map 没有。</p><h3 id="23-5-4-Collections"><a href="#23-5-4-Collections" class="headerlink" title="23.5.4. Collections"></a>23.5.4. Collections</h3><p>是 Java 提供的一组集合数据的操作工具类，利用它可以实现各个集合的操作</p><p>可操作 Collection，可追加操作 List、Set、Queue、Map</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>reverse()</td><td>数据的反转</td></tr><tr><td>binarySearch()</td><td>使用二分查找，要先进行排序</td></tr><tr><td>addAll()</td><td>追加数据</td></tr><tr><td>sort()</td><td>排序</td></tr></tbody></table></div><p><strong>Collection 与 Collections 的区别</strong></p><p>Collection  是集合接口，允许保存单值对象。</p><p>Collections 是集合操作的工具类。</p><h1 id="24-Map"><a href="#24-Map" class="headerlink" title="24. Map"></a>24. Map</h1><p>在开发中：Collection 集合保存数据的目的是为了输出，Map 集合保存数据的目的是为了进行 key 的查找。</p><p>Map 的核心意义在于通过key 获取对应的 value</p><p>每个键对应一个值，当键重复时，键的值会被覆盖</p><p><strong>Map接口的定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K,V&gt;  <span class="comment">// K为键的类型，V为值的类型</span></span><br></pre></td></tr></table></figure><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th>常用方法</th><th>说明</th></tr></thead><tbody><tr><td><code>public V put(K key,V value)</code></td><td>添加元素，当键重复的时候该方法会返回旧的数据内容。默认返回null</td></tr><tr><td><code>public V get(Object key)</code></td><td>根据Key查询数据</td></tr><tr><td><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code></td><td>将Map集合转为Set集合</td></tr><tr><td><code>public V remove(Object key)</code></td><td>根据键删除键值元素</td></tr><tr><td><code>public void clear()</code></td><td>移除所有键值对元素</td></tr><tr><td><code>public boolean containsKey(Object key)</code></td><td>判断集合是否包含指定的键</td></tr><tr><td><code>public boolean containsValue(Object value)</code></td><td>判断集合是否包含指定的值</td></tr><tr><td><code>public boolean isEmpty()</code></td><td>判断集合是否为空</td></tr><tr><td><code>public int size()</code></td><td>集合的长度</td></tr><tr><td><code>public Set&lt;K&gt; keySet()</code></td><td>返回Map 中所有键的 Set 集合</td></tr></tbody></table></div><p>开发之中需要通过 Map 集合的子类来进行接口对象的实例化，而常用的子类：HashMap、Hashtable、TreeMap、LinkedHashMap 。其中HashMap使用频率最高</p><h2 id="24-1-HashMap"><a href="#24-1-HashMap" class="headerlink" title="24.1. HashMap"></a>24.1. HashMap</h2><p>应用场景：当需要一个无序的映射，其中键和值都可以为null，并且不需要维护映射的顺序时，<strong>HashMap适用于存储键值对，常用于缓存、索引和快速查找</strong></p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的（key是唯一的，用来索引到底层数组中的对应value）</p><p>是否有序：无序的</p><p>底层的数据结构：哈希表</p><p>自身数据结构：哈希表</p><p>HashMap使用一个哈希函数将key转换为一个数组索引，哈希函数应该是一致性的，即对于相同的key总是返回相同的索引</p><p>HashMap使用链表法来解决哈希冲突，即在相同索引的位置上维护一个链表，将哈希到该位置的所有键值对都添加到链表中</p><p>HashMap的性能取决于哈希函数的质量和插入、查找时哈希冲突的数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();</span><br></pre></td></tr></table></figure><h3 id="24-1-1-put方法的返回值"><a href="#24-1-1-put方法的返回值" class="headerlink" title="24.1.1. put方法的返回值"></a>24.1.1. put方法的返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,String&gt;();    </span><br><span class="line">System.out.println(map.put(<span class="string">&quot;ggg&quot;</span>,<span class="number">3</span>));<span class="comment">// 键没重复，返回null</span></span><br><span class="line">System.out.println(map.put(<span class="string">&quot;ggg&quot;</span>,<span class="number">4</span>));<span class="comment">// 键重复，返回旧的数据</span></span><br></pre></td></tr></table></figure><h3 id="24-1-2-HashMap-的扩容原理（重点）"><a href="#24-1-2-HashMap-的扩容原理（重点）" class="headerlink" title="24.1.2. HashMap 的扩容原理（重点）"></a>24.1.2. HashMap 的扩容原理（重点）</h3><p>在 HashMap 类里面提供有一个 <code>DEFAULT_INITIAL_CAPACITY</code> 常量，作为初始化的容量配置，这个常量的默认大小为 16 个元素</p><p>当保存的内容的容量超过了<code>阈值（DEFAULT_LOAD_FACTOR = 0.75f)</code>， 相当于<code>容量*阈值=12</code>的时候就会进行容量的扩充</p><p>在进行扩充的时候HashMap 采用的是成倍的扩充模式，即每一次都扩充2倍容量</p><h3 id="24-1-3-HashMap-的工作原理"><a href="#24-1-3-HashMap-的工作原理" class="headerlink" title="24.1.3. HashMap 的工作原理"></a>24.1.3. HashMap 的工作原理</h3><p>从JDK 1.8开始，HashMap的实现出现了改变，HashMap内部类提供有一个重要的常量<code>static final int TREEIFY_THRESHOLD = 8</code>，当链表长度小于阈值（默认为 8）时，则使用链表形式存储，若超过，则将链表转为红黑树，保证数据的查询性能</p><h3 id="24-1-4-HashSet和HashMap区别（重点）"><a href="#24-1-4-HashSet和HashMap区别（重点）" class="headerlink" title="24.1.4. HashSet和HashMap区别（重点）"></a>24.1.4. HashSet和HashMap区别（重点）</h3><p>都是基于哈希表实现的</p><p>存储方式不同：HashSet存储无序的唯一元素，HashMap存储键值对</p><p>元素查找方式不同：HashSet通过哈希值快速定位元素，HashMap先根据键的哈希值找到对应的桶（Bucket），然后再在桶中查找元素</p><p>应用场景不同：HashSet常用于去重和集合运算。HashMap常用于缓存、索引和快速查找</p><p><strong>什么是Bucket</strong></p><p>在哈希表中，Bucket（桶）是用来存储元素的容器，通常是一个数组或链表。每个Bucket都有一个唯一的索引或标识符，用于快速定位元素。具体地说，Bucket的作用是将元素根据它们的哈希值分组并存储在不同的位置上，以便在查找元素时能够更快地定位它们。</p><p>在Java中，HashMap和HashSet都是基于哈希表实现的集合类，它们内部都使用了Bucket来存储元素。对于HashMap，每个Bucket存储一个键值对，而对于HashSet，每个Bucket存储一个元素。当需要查找元素时，先根据元素的哈希值找到对应的Bucket，然后在Bucket中查找元素。</p><p>Bucket的数量通常与哈希表的容量相等，因此在创建哈希表时需要指定初始容量。如果Bucket的数量过少，可能会导致哈希冲突，影响查找效率；如果Bucket的数量过多，可能会浪费内存空间。因此，在使用哈希表时，需要根据实际需求选择合适的容量和负载因子（load factor）。</p><h3 id="24-1-5-Hash-冲突"><a href="#24-1-5-Hash-冲突" class="headerlink" title="24.1.5. Hash 冲突"></a>24.1.5. Hash 冲突</h3><p>HashMap 进行数据操作的时候出现了 Hash  冲突，当出现了 Hash  冲突之后为了保证程序的正常执行，会在冲突的位置上将所有 Hash 冲突的内容转为链表保存</p><h2 id="24-2-LinkedHashMap"><a href="#24-2-LinkedHashMap" class="headerlink" title="24.2. LinkedHashMap"></a>24.2. LinkedHashMap</h2><p>应用场景：当需要一个有序的映射，并且需要维护键值对插入的顺序时</p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的</p><p>是否有序：有序的（数据的保存顺序为添加时的顺序）</p><p>底层的数据结构：链表</p><p>自身数据结构：双向链表</p><p>当一个新元素被插入到LinkedHashMap中时，它会被添加到链表尾部，表示它是最新插入的元素。当访问一个已经存在的元素时，LinkedHashMap会将该元素移动到链表的尾部，表示它是最近访问的元素。因此，LinkedHashMap可以按照插入顺序或者访问顺序来遍历元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;String,Integer&gt;();</span><br></pre></td></tr></table></figure><h2 id="24-3-TreeMap"><a href="#24-3-TreeMap" class="headerlink" title="24.3. TreeMap"></a>24.3. TreeMap</h2><p>应用场景：当需要一个有序的映射，并且需要对键进行自然排序或指定的比较器进行排序时</p><p>线程是否安全：线程不安全</p><p>是否允许重复：不可重复的（key是唯一的，用来索引到底层数组中的对应value）</p><p>是否有序：有序的</p><p>底层的数据结构：红黑树</p><p>自身数据结构：红黑树</p><h2 id="24-4-Hashtable"><a href="#24-4-Hashtable" class="headerlink" title="24.4. Hashtable*"></a>24.4. Hashtable*</h2><p>进行数据存储的时候设置的 kev 或 value 都不允许为 null，否则会出现 NullPointerException 异常。</p><h2 id="24-5-HashMap和Hashtable-区别"><a href="#24-5-HashMap和Hashtable-区别" class="headerlink" title="24.5. HashMap和Hashtable 区别"></a>24.5. HashMap和Hashtable 区别</h2><p>HashMap中的方法都属于异步操作（非线程安全），HashMap中允许保存有null数据</p><p>Hashtable中的方法都属于同步方法（线程安全），Hashtable中不允许保存null数据</p><h2 id="24-6-HashMap-和-TreeMap-区别"><a href="#24-6-HashMap-和-TreeMap-区别" class="headerlink" title="24.6. HashMap 和 TreeMap 区别"></a>24.6. HashMap 和 TreeMap 区别</h2><p>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力</p><h2 id="24-7-HashMap-多线程操作导致死循环问题"><a href="#24-7-HashMap-多线程操作导致死循环问题" class="headerlink" title="24.7. HashMap 多线程操作导致死循环问题"></a>24.7. HashMap 多线程操作导致死循环问题</h2><p>不建议在多线程下使用 HashMap，因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap</p><p><strong>ConcurrentHashMap</strong></p><p>是Java中的一个线程安全的哈希表实现。它是HashMap 的一个并发版本，支持高并发的读写操作。与HashMap 不同的是ConcurrentHashMap 的读操作不需要加锁，因此可以实现高并发的读操作。同时，ConcurrentHashMap 的写操作也是线程安全的，可以保证数据的一致性</p><h2 id="24-8-Map集合的遍历（重点）"><a href="#24-8-Map集合的遍历（重点）" class="headerlink" title="24.8. Map集合的遍历（重点）"></a>24.8. Map集合的遍历（重点）</h2><p>Map的entrySet()方法返回一个实现Map.Entry接口的对象集合Set。集合中每个对象都是Map中一个特定的键值对。可以通过这个集合的迭代器，遍历获得每一个条目的键或值并对值进行更改。</p><p>Map.Entry接口中的常用方法如下：</p><ul><li>Object getKey()：返回条目的关键字　</li><li>Object getValue()：返回条目的值</li><li>Object setValue(Object value)：将相关映像中的值改为value，并且返回旧值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; params = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;  </span><br><span class="line">System.out.println(entry);;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-9-自定义Map"><a href="#24-9-自定义Map" class="headerlink" title="24.9. 自定义Map"></a>24.9. 自定义Map</h2><p><strong>自定义Map的key类型</strong></p><p>自定义 Key 类型的那个类中一定要重写 hashCode()  与 equals() 方法，否则无法查找到。</p><p><strong>自定义Map的value类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br></pre></td></tr></table></figure><p>在<code>map.get</code> 的时候会遇到类型不同的问题，Object不是所有类的基类么？</p><p>虽然Object是所有类的基类，但在使用<code>Map&lt;String, Object&gt;</code>时，获取值时返回的是Object类型的引用，需要进行类型转换才能使用具体类型的方法和属性。注意在进行类型转换时要确保类型的正确性，以避免ClassCastException异常。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-12-Java%E9%AB%98%E7%BA%A7/"/>
      <url>/2024/10/28/2023-02-12-Java%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Annotation-注解"><a href="#1-Annotation-注解" class="headerlink" title="1. Annotation 注解"></a>1. Annotation 注解</h1><p>可以被其他程序（比如：编译器等）读取</p><p>注解是以 <code>@注解名</code> 在代码中存在的，还可以添加一些参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(value=&quot;unchecked&quot;)</span></span><br></pre></td></tr></table></figure><p>可以附加在package、class、method、 field 等上面，相当于给他们添加了额外的辅助信息</p><p>可以通过反射机制编程实现对这些元数据的访问</p><h2 id="1-1-内置注解"><a href="#1-1-内置注解" class="headerlink" title="1.1. 内置注解"></a>1.1. 内置注解</h2><p><strong>@Override</strong></p><p><code>@Override</code>注解，只能用于标记方法，并且它只在编译期生效，不会保留在class文件中</p><p><code>@Override</code>注解用于指示一个方法覆盖了其父类中的方法</p><p><strong>@Deprecated</strong></p><p><code>@Deprecated</code>用于标记一个类、方法或字段已经被弃用, 不应该再被使用</p><p><strong>@SuppressWarnings</strong></p><p><code>@SuppressWarnings</code> 注解是用来抑制编译器发出的特定警告的一种方式</p><h2 id="1-2-元注解"><a href="#1-2-元注解" class="headerlink" title="1.2. 元注解"></a>1.2. 元注解</h2><p>负责注解其他注解</p><p><strong>@Target</strong> </p><p>表示我们的注解可以用在哪些地方</p><p><strong>@Retention</strong> </p><p>表示我们的注解在什么地方有效，<code>runtime&gt;class&gt;sources</code></p><p><strong>@Documented</strong> </p><p>表示是否将我们的注解生成在JAVAdoc中</p><p><strong>@Inherited</strong> </p><p>说明子类可以继承父类中的该注解</p><h2 id="1-3-自定义注解"><a href="#1-3-自定义注解" class="headerlink" title="1.3. 自定义注解"></a>1.3. 自定义注解</h2><p><code>@interface</code>用来声明一个注解</p><p>规定注解的参数格式：<code>参数类型 参数名()</code></p><p>参数只能是基本类型 Class、String 、enum等 </p><p>可以通过 default 来声明参数的默认值，注解元素必须要有值，我们定义注解元素时，经常使用空字符串或0作为默认值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用自定义注解</span></span><br><span class="line"><span class="comment">// 注解可以显示赋值，如果没有默认值，我们就必须给注解赋值</span></span><br><span class="line"><span class="meta">@MyAnnotation(name = &quot;嘿嘿&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">annotate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;asd&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 自定义注解</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line">@ <span class="keyword">interface</span> <span class="title class_">MyAnnotation</span>&#123;</span><br><span class="line">    <span class="comment">// 规定注解的参数：参数类型 + 参数名 + ()</span></span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 通过 default 来声明参数的默认值</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">age</span><span class="params">()</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Reflection-反射"><a href="#2-Reflection-反射" class="headerlink" title="2. Reflection 反射"></a>2. Reflection 反射</h1><p>反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</p><p><strong>正常方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[引入需要的&#x27;包类&#x27;名称]</span><br><span class="line">A--&gt;B[通过new实例化]</span><br><span class="line">B--&gt;C[取得实例化对象]</span><br></pre></td></tr></table></figure><p><strong>反射方式</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[实例化对象]</span><br><span class="line">A--&gt;B[getClass 方法]</span><br><span class="line">B--&gt;C[得到完整的&#x27;包类&#x27;名称]</span><br></pre></td></tr></table></figure><h2 id="2-1-何为反射"><a href="#2-1-何为反射" class="headerlink" title="2.1. 何为反射"></a>2.1. 何为反射</h2><p>加载完类之后，在堆内存的方法区中会产生一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。可以通过这个对象看到类的结构。这个对象反射出了完整的类的结构信息，所以称为反射</p><p>反射对性能有影响</p><h2 id="2-2-Reflection-API"><a href="#2-2-Reflection-API" class="headerlink" title="2.2. Reflection API"></a>2.2. Reflection API</h2><p>反射相关的主要API</p><p>Class  代表一个类</p><p>Method  代表类的方法</p><p>Field  代表类的成员变量</p><p>Constructor  代表类的构造器</p><h1 id="3-Class类"><a href="#3-Class类" class="headerlink" title="3. Class类"></a>3. Class类</h1><p>一个类被加载后，class对象就会产生，并且类的整个结构都会被封装在Class对象中</p><p>在Object类中定义了以下的方法，此方法将被所有子类继承</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于获取对象的运行时对象的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Class <span class="title function_">getClass</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2 id="3-1-特点"><a href="#3-1-特点" class="headerlink" title="3.1. 特点"></a>3.1. 特点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class本身也是一个类</span><br><span class="line">Class对象只能由系统建立，在堆中存放</span><br><span class="line">一个加载的类在JVM中只会有一个Class实例</span><br><span class="line">一个Class对象对应的是一个加载到JVM中的一个.class文件</span><br><span class="line">每个类的实例都会记得自己是由哪个Class实例所生成</span><br><span class="line">通过Class可以完整地得到一个类中的所有被加载的结构</span><br><span class="line">Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象</span><br></pre></td></tr></table></figure><h2 id="3-2-获取类的运行时结构"><a href="#3-2-获取类的运行时结构" class="headerlink" title="3.2. 获取类的运行时结构"></a>3.2. 获取类的运行时结构</h2><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>static ClassforName(String name)</td><td>返回指定类名的Class对象</td></tr><tr><td>Object newInstance()</td><td>调用缺省（即默认）构造函数，返回Class对象的一个实例</td></tr><tr><td>getName()</td><td>返回此Class对象所表示的实体（类，接口，数组类或void）的名称</td></tr><tr><td>Class getSuperClass()</td><td>返回当前Class对象的父类的Class对象</td></tr><tr><td>Class[] getinterfaces()</td><td>获取当前Class对象的接口</td></tr><tr><td>ClassLoader getClassLoader()</td><td>返回该类的类加载器</td></tr><tr><td>Constructor[] getConstructors()</td><td>返回一个包含某些Constructor对象的数组</td></tr><tr><td>Method getMothed(String name,Class.. T)</td><td>返回一个Method对象，此对象的形参类型为param Type</td></tr><tr><td>Field[] getDeclaredFields()</td><td>返回类的所有属性</td></tr></tbody></table></div><h2 id="3-3-获取Class类的实例"><a href="#3-3-获取Class类的实例" class="headerlink" title="3.3. 获取Class类的实例"></a>3.3. 获取Class类的实例</h2><p>若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> 类名.class</span><br></pre></td></tr></table></figure><p>已知某个类的实例，调用该实例的getClass()方法获取Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> 对象名.getClass()</span><br></pre></td></tr></table></figure><p>已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">cla</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.baidu.www.类名&quot;</span>);</span><br></pre></td></tr></table></figure><p>基本数据类型的包装类可以直接用<code>类名.Type</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.TYPE</span><br></pre></td></tr></table></figure><p>还可以利用ClassLoader</p><h2 id="3-4-哪些类型有Class对象"><a href="#3-4-哪些类型有Class对象" class="headerlink" title="3.4. 哪些类型有Class对象"></a>3.4. 哪些类型有Class对象</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</span><br><span class="line">interface：接口</span><br><span class="line">[]：数组</span><br><span class="line">enum：枚举</span><br><span class="line">annotation：注解@interface</span><br><span class="line">primitive type：基本数据类型</span><br><span class="line">void</span><br></pre></td></tr></table></figure><h1 id="4-类加载内存分析"><a href="#4-类加载内存分析" class="headerlink" title="4. 类加载内存分析"></a>4. 类加载内存分析</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(Java内存)</span><br><span class="line">A--&gt;A.1(堆)</span><br><span class="line">A--&gt;A.2(栈)</span><br><span class="line">A--&gt;A.3(方法区)</span><br><span class="line">A.1--&gt;A.1.1(存放new的对象和数组)</span><br><span class="line">A.1--&gt;A.1.2(可以被所有的线程共享.不会存放别的对象引用)</span><br><span class="line">A.2--&gt;A.2.1(存放基本变量类型,会包含这个基本类型的具体数值)</span><br><span class="line">A.2--&gt;A.2.2(引用对象的变量,会存放这个引用在堆里面的具体地址)</span><br><span class="line">A.3--&gt;A.3.1(可以被所有的线程共享)</span><br><span class="line">A.3--&gt;A.3.2(包含了所有的class和static变量)</span><br></pre></td></tr></table></figure><p><strong>加载</strong></p><p>一个类被加载后，class对象就会产生</p><p><strong>链接</strong></p><p>链接的准备阶段，为static分配内存</p><p><strong>初始化</strong></p><p>执行类构造器<code>&lt;clinit&gt; ()</code>方法</p><h2 id="4-1-分析类初始化"><a href="#4-1-分析类初始化" class="headerlink" title="4.1. 分析类初始化"></a>4.1. 分析类初始化</h2><p><strong>类的主动引用</strong></p><p>一定会发生类的初始化</p><p>当虚拟机启动，先初始化main方法所在的类</p><p>new一个类的对象</p><p>调用类的静态成员（除了final常量）和静态方法</p><p>使用java.lang.reflect包的方法对类进行反射调用</p><p>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Main类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Son</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>类的被动引用</strong></p><p>不会发生类的初始化</p><p>当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静态变量，不会导致子类初始化</p><p>通过数组定义类引用，不会触发此类的初始化</p><p>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</p><h2 id="4-2-类加载器"><a href="#4-2-类加载器" class="headerlink" title="4.2. 类加载器"></a>4.2. 类加载器</h2><p>类加载器作用是用来把类（class）装载进内存的</p><h1 id="5-动态创建对象"><a href="#5-动态创建对象" class="headerlink" title="5. 动态创建对象"></a>5. 动态创建对象</h1><h2 id="5-1-创建类的对象"><a href="#5-1-创建类的对象" class="headerlink" title="5.1. 创建类的对象"></a>5.1. 创建类的对象</h2><p>调用Class对象的newInstance()方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类必须有一个无参数的构造器</span><br><span class="line">类的构造器的访问权限需要足够</span><br></pre></td></tr></table></figure><p>调用类中的构造器，传递参数，进行实例化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">通过Class类的getDeclaredConstructor(Class .. parameterTypes)取得本类的指定形参类型的构造器</span><br><span class="line">向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数</span><br><span class="line">通过Constructor实例化对象</span><br></pre></td></tr></table></figure><h2 id="5-2-调用类的方法"><a href="#5-2-调用类的方法" class="headerlink" title="5.2. 调用类的方法"></a>5.2. 调用类的方法</h2><p>通过Class类的getMethod(String name,Class… parameterTypes)方法取得一个Method对象，并设置此方法操作时所需要的参数类型</p><p>之后使用Object invoke(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对象的参数信息</p><p>使用 Object invoke(Object obj, Object … args) 激活</p><p>若原方法声明为private，则需要在调用此invoke()方法前，显式调用方法对象setAccessible(true)方法，取消Java语言访问检查</p><h1 id="6-获取泛型信息"><a href="#6-获取泛型信息" class="headerlink" title="6. 获取泛型信息"></a>6. 获取泛型信息</h1><p>…</p><h1 id="7-获取注解信息"><a href="#7-获取注解信息" class="headerlink" title="7. 获取注解信息"></a>7. 获取注解信息</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = c1.getAnnotations()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-03-Element%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/"/>
      <url>/2024/10/28/2023-02-03-Element%E5%BC%80%E5%8F%91%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-双向绑定数据的修改问题"><a href="#1-双向绑定数据的修改问题" class="headerlink" title="1. 双向绑定数据的修改问题"></a>1. 双向绑定数据的修改问题</h1><p><code>&lt;el-form&gt;</code>中 <code>&lt;el-input&gt;</code> 双向绑定数据后，无法再修改编辑的问题。Vue实例创建时，form的属性名并未声明，因此Vue就无法对属性执行 getter/setter 转化过程，导致form属性不是响应式的，因此无法触发视图更新。显式地声明form这个对象的属性即可解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      formInline: &#123;</span><br><span class="line">      id: &#x27;&#x27;,</span><br><span class="line">      name: &#x27;&#x27;, </span><br><span class="line">      pwd: &#x27;&#x27;, </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  &#125;</span><br><span class="line"> 而不是</span><br><span class="line"> data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      formInline:&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-Element-UI的上传功能"><a href="#2-Element-UI的上传功能" class="headerlink" title="2. Element UI的上传功能"></a>2. Element UI的上传功能</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-upload</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;avatar-uploader&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">action</span>=<span class="string">&quot;http://localhost:8888/upload/picture&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:show-file-list</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:on-success</span>=<span class="string">&quot;handleAvatarSuccess&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:before-upload</span>=<span class="string">&quot;beforeAvatarUpload&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">name</span> = <span class="string">&quot;photo&quot;</span> </span></span><br><span class="line"><span class="tag">          &gt;</span></span><br><span class="line">          <span class="comment">&lt;!--这个name的值对应后端接收的参数名--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-if</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">:src</span>=<span class="string">&quot;imageUrl&quot;</span> <span class="attr">class</span>=<span class="string">&quot;avatar&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">i</span> <span class="attr">v-else</span> <span class="attr">class</span>=<span class="string">&quot;el-icon-plus avatar-uploader-icon&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-upload</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仅需关心如下参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">action：后端接收图片的地址</span><br><span class="line"></span><br><span class="line">name：photo，该值对应后端接收图片方法中的参数名称</span><br><span class="line"></span><br><span class="line">在Java中 public Result picture(MultipartFile photo)&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Element-UI的分页"><a href="#3-Element-UI的分页" class="headerlink" title="3. Element UI的分页"></a>3. Element UI的分页</h1><p>修改<code>&lt;el-table&gt;</code>中的 :data</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:data=<span class="string">&quot;tableData.slice((pages.currentPage-1)*pages.size,pages.currentPage*pages.size)&quot;</span>里面的tableData是接到的所有数据</span><br></pre></td></tr></table></figure><p>完整代码（仅分页功能）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">el-pagination</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">size-change</span>=<span class="string">&quot;handleSizeChange&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">current-change</span>=<span class="string">&quot;handleCurrentChange&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:page-sizes</span>=<span class="string">&quot;[5, 10, 15, 20]&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:page-size</span>=<span class="string">pages.size</span></span></span><br><span class="line"><span class="tag">            <span class="attr">layout</span>=<span class="string">&quot;total, sizes, prev, pager, next&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:total</span>=<span class="string">pages.total</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-pagination</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; show &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/student.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">   <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">pages</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">total</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">size</span>: <span class="number">5</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">currentPage</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">loadData</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">show</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">tableData</span> = response.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="property">total</span> = response.<span class="property">data</span>.<span class="property">data</span>.<span class="property">length</span></span></span><br><span class="line"><span class="language-javascript">      &#125;)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleSizeChange</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="property">size</span> = val;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleCurrentChange</span>(<span class="params">val</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">pages</span>.<span class="property">currentPage</span> = val;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-引入高德地图"><a href="#4-引入高德地图" class="headerlink" title="4. 引入高德地图"></a>4. 引入高德地图</h1><p><a href="https://lbs.amap.com/api/javascript-api/guide/abc/prepare">https://lbs.amap.com/api/javascript-api/guide/abc/prepare</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import AMapLoader from &#x27;@amap/amap-jsapi-loader&#x27;</span><br><span class="line">import &#123;createMap&#125; from &quot;@/api/node.js&quot;;</span><br><span class="line"></span><br><span class="line">window._AMapSecurityConfig = &#123;</span><br><span class="line">    // 申请时分配的</span><br><span class="line">  securityJsCode: &#x27;ceb74446c9ecaabe6020720a5bf9a26d&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      map: null,</span><br><span class="line">      mapData : []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    loadData() &#123;</span><br><span class="line">      createMap().then((response)=&gt;&#123;</span><br><span class="line">        this.mapData = response.data.data;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    initMap() &#123;</span><br><span class="line">      AMapLoader.load(&#123;</span><br><span class="line">        key: &#x27;5625def45684788ad4cd785a05538cdf&#x27;, // 申请好的Web端开发者Key，首次调用 load 时必填</span><br><span class="line">        version: &#x27;2.0&#x27;, // 指定要加载的 JSAPI 的版本，缺省时默认为 1.4.15</span><br><span class="line">        plugins: [&#x27;&#x27;] // 需要使用的的插件列表，如比例尺&#x27;AMap.Scale&#x27;等</span><br><span class="line">      &#125;)</span><br><span class="line">        .then(AMap =&gt; &#123;</span><br><span class="line">          this.map = new AMap.Map(&#x27;container&#x27;, &#123;</span><br><span class="line">            //设置地图容器id</span><br><span class="line">            viewMode: &#x27;3D&#x27;, //是否为3D地图模式</span><br><span class="line">            zoom: 10, //初始化地图级别</span><br><span class="line">            center: [121.473667, 31.230525] //初始化地图中心点位置</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">          // 批量添加圆点标记  绿色：#22dc19 、红色：#c80539</span><br><span class="line">          const circleMarkers = this.mapData</span><br><span class="line">          circleMarkers.forEach(marker =&gt; &#123; </span><br><span class="line">            marker.radius = 20</span><br><span class="line">            const circleMarker = new AMap.CircleMarker(</span><br><span class="line">              &#123; </span><br><span class="line">              map: this.map,</span><br><span class="line">              center: new AMap.LngLat(marker.center[0], marker.center[1]), radius: marker.radius, fillColor: marker.fillColor &#125;) </span><br><span class="line">              circleMarker.setMap(this.map) </span><br><span class="line">          &#125;) </span><br><span class="line">        &#125;)</span><br><span class="line">        .catch(e =&gt; &#123; console.log(e) &#125;) </span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;, </span><br><span class="line">  created() &#123;</span><br><span class="line">    this.loadData()</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123; //DOM初始化完成进行地图初始化 </span><br><span class="line">    this.initMap() </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;less&quot; scoped&gt;</span><br><span class="line">#container &#123;</span><br><span class="line">  padding: 0px;</span><br><span class="line">  margin: 0px;</span><br><span class="line">  width: 100vmax;</span><br><span class="line">  height: 100vmax;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h1 id="5-基于element-UI组件实现分组表格（合并单元格）"><a href="#5-基于element-UI组件实现分组表格（合并单元格）" class="headerlink" title="5. 基于element UI组件实现分组表格（合并单元格）"></a>5. 基于element UI组件实现分组表格（合并单元格）</h1><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-main</span> <span class="attr">class</span>=<span class="string">&quot;contailer&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">:data</span>=<span class="string">&quot;tableData&quot;</span> <span class="attr">:span-method</span>=<span class="string">&quot;spanMethod&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;classId&quot;</span> <span class="attr">label</span>=<span class="string">&quot;班级ID&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;className&quot;</span> <span class="attr">label</span>=<span class="string">&quot;班级名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;stuId&quot;</span> <span class="attr">label</span>=<span class="string">&quot;学号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;stuName&quot;</span> <span class="attr">label</span>=<span class="string">&quot;姓名&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;&#123;row&#125;&quot;</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">span</span> @<span class="attr">click</span>=<span class="string">&quot;sendMsg(row.classId)&quot;</span>&gt;</span>群发短信<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">template</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-main</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">tableData</span>:[  <span class="comment">//班级学生信息mock数据，该数据假设已经按着班级信息进行排序</span></span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;一班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1001</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan001&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;一班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1002</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan001&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;001&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;一班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1003</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan001&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;二班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1004</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan002&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;002&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;二班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1005</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan002&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;三班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1006</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan003&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;三班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1007</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan003&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;003&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;三班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1008</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan003&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">        &#123;<span class="attr">classId</span>:<span class="string">&#x27;004&#x27;</span>,<span class="attr">className</span>:<span class="string">&#x27;四班&#x27;</span>,<span class="attr">stuId</span>:<span class="number">1009</span>,<span class="attr">stuName</span>:<span class="string">&#x27;zhangsan004&#x27;</span>&#125;,</span></span><br><span class="line"><span class="language-javascript">      ]</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">computed</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">groupNum</span>(<span class="params"></span>)&#123;  <span class="comment">//获取班级列表数组</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Set</span>(<span class="variable language_">this</span>.<span class="property">tableData</span>.<span class="title function_">map</span>(<span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">className</span>));</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>:&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">classGroup</span>(<span class="params">name</span>)&#123;  <span class="comment">//根据班级名称获取学生数量</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tableData</span>.<span class="title function_">filter</span>(<span class="function"><span class="params">o</span> =&gt;</span> o.<span class="property">className</span> == name).<span class="property">length</span>;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">classNameLen</span>(<span class="params">name</span>)&#123;  <span class="comment">//根据班级名称获取该班级第一个学生在全量学生中的偏移位置</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> tmp = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">this</span>.<span class="property">groupNum</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> index = tmp.<span class="title function_">indexOf</span>(name);  <span class="comment">//某班级在全班级中的偏移位置</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">let</span> len = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; index;i++)&#123;</span></span><br><span class="line"><span class="language-javascript">        len += <span class="variable language_">this</span>.<span class="title function_">classGroup</span>(tmp[i]);</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> len;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sendMsg</span>(<span class="params">classId</span>)&#123;　　　　<span class="comment">//do something　　&#125;,</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">spanMethod</span>(<span class="params">data</span>) &#123;  <span class="comment">//对于表格数据进行分组合并操作，UI组件回调函数</span></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> &#123;row,column,rowIndex,columnIndex&#125; = data;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">if</span> (columnIndex &lt; <span class="number">2</span> || columnIndex &gt; <span class="number">3</span>) &#123;  <span class="comment">//班级合并展示区</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> len = <span class="variable language_">this</span>.<span class="title function_">classGroup</span>(row.<span class="property">className</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> lenName = <span class="variable language_">this</span>.<span class="title function_">classNameLen</span>(row.<span class="property">className</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (rowIndex === lenName) &#123;   <span class="comment">//某班级首位学生行</span></span></span><br><span class="line"><span class="language-javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">rowspan</span>:len,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">colspan</span>:<span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">          &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> &#123;   <span class="comment">//某班级非首位学生行</span></span></span><br><span class="line"><span class="language-javascript">          <span class="attr">rowspan</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">colspan</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">//学生信息展示区</span></span></span><br><span class="line"><span class="language-javascript">       <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">rowspan</span>: <span class="number">1</span>,</span></span><br><span class="line"><span class="language-javascript">          <span class="attr">colspan</span>: <span class="number">1</span></span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="6-引入Tinymce富文本"><a href="#6-引入Tinymce富文本" class="headerlink" title="6. 引入Tinymce富文本"></a>6. 引入Tinymce富文本</h1><p><a href="http://tinymce.ax-z.cn/">http://tinymce.ax-z.cn/</a></p><p>安装</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install tinymce@5.1.0 --save npm install @tinymce/tinymce-vue@3.0.1</span><br></pre></td></tr></table></figure><p>在<code>node_modules</code>下找到<code>tinymce</code>下的<code>skins</code>和<code>themes</code>文件夹复制粘贴到<code>public/tinymce</code>下</p><p>封装一个<code>tinymce</code>富文本组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import tinymce from &#x27;tinymce/tinymce&#x27; </span><br><span class="line">import Editor from &#x27;@tinymce/tinymce-vue&#x27; </span><br><span class="line">import &#x27;tinymce/themes/silver/theme&#x27;</span><br></pre></td></tr></table></figure><p>如果上面引入<code>tinymce/themes/silver/theme</code>报错可以尝试引入下面这两个 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;tinymce/themes/modern/theme&#x27;; </span><br><span class="line">import &quot;tinymce/icons/default&quot;;</span><br></pre></td></tr></table></figure><p>完整富文本组件代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;tinymce-editor&quot;&gt;</span><br><span class="line">    &lt;Editor v-model=&quot;myValue&quot; :init=&quot;init&quot; :disabled=&quot;disabled&quot; ref=&quot;editorRef&quot;</span><br><span class="line">      :key=&quot;timestamp&quot; @onClick=&quot;onClick&quot;&gt;</span><br><span class="line">    &lt;/Editor&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import tinymce from &#x27;tinymce/tinymce&#x27;</span><br><span class="line">import Editor from &#x27;@tinymce/tinymce-vue&#x27;</span><br><span class="line">import &#123; uploadFiles &#125; from &#x27;@/api/common.js&#x27;</span><br><span class="line">import &#x27;tinymce/themes/silver/theme&#x27;</span><br><span class="line">// 列表插件</span><br><span class="line">import &#x27;tinymce/plugins/lists&#x27;</span><br><span class="line">import &#x27;tinymce/plugins/advlist&#x27;</span><br><span class="line">// 上传图片插件</span><br><span class="line">import &#x27;tinymce/plugins/image&#x27;</span><br><span class="line">import &#x27;tinymce/plugins/imagetools&#x27;</span><br><span class="line">// 表格插件</span><br><span class="line">import &#x27;tinymce/plugins/table&#x27;</span><br><span class="line">// 自动识别链接插件</span><br><span class="line">import &#x27;tinymce/plugins/autolink&#x27;</span><br><span class="line">// 预览插件</span><br><span class="line">import &#x27;tinymce/plugins/preview&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;TinymceEditor&#x27;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Editor</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    // 传入一个value，使组件支持v-model绑定</span><br><span class="line">    value: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    disabled: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    menubar: &#123; // 菜单栏      </span><br><span class="line">      type: String,</span><br><span class="line">      default: &#x27;file edit insert view format table&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 相关插件配置</span><br><span class="line">    plugins: &#123;</span><br><span class="line">      type: [String, Array],</span><br><span class="line">      default:</span><br><span class="line">        &#x27;lists advlist image imagetools table autolink preview&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 工具栏配置</span><br><span class="line">    toolbar: &#123;</span><br><span class="line">      type: [String, Array],</span><br><span class="line">      default:</span><br><span class="line">        &#x27;undo redo |  formatselect | fontsizeselect | bold italic underline forecolor backcolor | alignleft aligncenter alignright alignjustify | bullist numlist outdent indent | lists image table preview&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 富文本高度</span><br><span class="line">    height: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: 500</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 当前时间戳,是为了解决回显问题</span><br><span class="line">      timestamp: 0,</span><br><span class="line">      //初始化配置</span><br><span class="line">      init: &#123;</span><br><span class="line">        language_url: &#x27;/tinymce/langs/zh_CN.js&#x27;, // 根据自己文件的位置，填写正确的路径，注意/可以直接访问到public文件</span><br><span class="line">        language: &#x27;zh_CN&#x27;,</span><br><span class="line">        skin_url: &#x27;/tinymce/skins/ui/oxide&#x27;, // 根据自己文件的位置，填写正确的路径。路径不对会报错</span><br><span class="line">        height: this.height,</span><br><span class="line">        plugins: this.plugins,</span><br><span class="line">        toolbar: this.toolbar,</span><br><span class="line">        branding: false,</span><br><span class="line">        menubar: false,</span><br><span class="line">        // 如需ajax上传可参考https://www.tiny.cloud/docs/configure/file-image-upload/#images_upload_handler</span><br><span class="line">        // 配置了此方法,即可手动选择图片</span><br><span class="line">        images_upload_handler: (blobInfo, success, failure) =&gt; &#123;</span><br><span class="line">          const formData = new FormData()</span><br><span class="line">          formData.append(&#x27;files&#x27;, blobInfo.blob());</span><br><span class="line">          uploadFiles(formData)</span><br><span class="line">            .then(res =&gt; &#123;</span><br><span class="line">              success(res.url)</span><br><span class="line">            &#125;)</span><br><span class="line">            .catch(err =&gt; &#123;</span><br><span class="line">              failure(err)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        resize: false,</span><br><span class="line">      &#125;,</span><br><span class="line">      myValue: this.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    // 需要什么事件可以自己增加 可用的事件参照文档=&gt; https://github.com/tinymce/tinymce-vue</span><br><span class="line">    onClick (e) &#123;</span><br><span class="line">      this.$emit(&#x27;onClick&#x27;, e, tinymce)</span><br><span class="line">    &#125;,</span><br><span class="line">    // 可以添加一些自己的自定义事件，如清空内容</span><br><span class="line">    clear () &#123;</span><br><span class="line">      this.myValue = &#x27;&#x27;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 解决切换页签后数据回显问题</span><br><span class="line">    setTinymceContent () &#123;</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        this.timestamp = new Date().getTime()</span><br><span class="line">      &#125;, 10)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    value: &#123;</span><br><span class="line">      handler (newValue) &#123;</span><br><span class="line">        this.myValue = newValue</span><br><span class="line">      &#125;,</span><br><span class="line">      immediate: true</span><br><span class="line">    &#125;,</span><br><span class="line">    myValue (newValue) &#123;</span><br><span class="line">      this.$emit(&#x27;input&#x27;, newValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;TinymceEditor v-model=&quot;form.noticeContent&quot; ref=&quot;tinymceEditorRef&quot;&gt;&lt;/TinymceEditor&gt;</span><br></pre></td></tr></table></figure><h1 id="7-引入ECharts"><a href="#7-引入ECharts" class="headerlink" title="7. 引入ECharts"></a>7. 引入ECharts</h1><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install echarts --save</span><br></pre></td></tr></table></figure><p>封装一个ECharts组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- :id表示从父组件中动态获取,chartId表示父组件中调用时应是chartId=&quot;&quot;的形式 --&gt;</span><br><span class="line">  &lt;div :id=&quot;chartId&quot; :data=&quot;chartData&quot; style=&quot;height: 420px;width:320px;&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import * as echarts from &quot;echarts&quot;;</span><br><span class="line">  export default &#123;</span><br><span class="line">    // 对应父组件中传递的数据的名称</span><br><span class="line">    props: &#123;</span><br><span class="line">      chartId: &#123;</span><br><span class="line">        type: String,</span><br><span class="line">        required: true</span><br><span class="line">      &#125;,</span><br><span class="line">       chartData: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        required: true</span><br><span class="line">       &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    // 封装的组件的名称</span><br><span class="line">    name: &quot;EChartsPie&quot;,</span><br><span class="line">    mounted() &#123;</span><br><span class="line">      this.getList();</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      getList() &#123;</span><br><span class="line">        this.chart = echarts.init(this.$el, &quot;macarons&quot;);</span><br><span class="line">        this.chart.setOption(&#123;</span><br><span class="line">        // 移动鼠标展示</span><br><span class="line">        tooltip: &#123;</span><br><span class="line">          trigger: &#x27;item&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        // 指示颜色的含义</span><br><span class="line">        legend: &#123;</span><br><span class="line">          orient: &#x27;vertical&#x27;,</span><br><span class="line">          left: &#x27;left&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        series: [</span><br><span class="line">          &#123;</span><br><span class="line">            type: &#x27;pie&#x27;,</span><br><span class="line">            radius: &#x27;50%&#x27;,</span><br><span class="line">            data: this.chartData</span><br><span class="line">          &#125;</span><br><span class="line">          ]</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">      // 打开加载层</span><br><span class="line">      openLoading() &#123;</span><br><span class="line">        this.$modal.loading(&quot;正在加载缓存监控数据，请稍候！&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      goTarget(href) &#123;</span><br><span class="line">        window.open(href, &quot;_blank&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用封装的ECharts子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;!-- 首页可视化大屏 --&gt;</span><br><span class="line">  &lt;div class=&quot;floor&quot;&gt;</span><br><span class="line">    &lt;!-- 楼栋单元可视化 --&gt;</span><br><span class="line">    &lt;el-row class=&quot;buildings&quot; v-if=&quot;showFlag.buildings&quot; v-for=&quot;building in buildings&quot; :key=&quot;building.buildingId&quot;&gt;</span><br><span class="line">      &lt;el-col :span=&quot;24&quot; class=&quot;buildingContainer&quot; &gt;</span><br><span class="line">        &lt;div class=&quot;building-name&quot; style=&quot;font-family: &#x27;Helvetica Neue&#x27;, sans-serif; font-size: 18px; color: #333; padding-left: 10px&quot;&gt;&#123;&#123; building.buildingName &#125;&#125;</span><br><span class="line">          &lt;div class=&quot;building&quot;&gt;</span><br><span class="line">            &lt;font-awesome-icon icon=&quot;building&quot; size=&quot;2xl&quot; style=&quot;color: #133c72;&quot; @click=&quot;showRooms(building)&quot;/&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;total-num&quot; style=&quot;font-family: &#x27;Helvetica Neue&#x27;, sans-serif; font-size: 14px; color: #333;&quot;&gt;</span><br><span class="line">            可用:&#123;&#123;building.totalAvailable&#125;&#125;&lt;br&gt;</span><br><span class="line">            已用:&#123;&#123;building.totalOccupied&#125;&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;!-- 可视化组件 --&gt;</span><br><span class="line">          &lt;EChartsPie :chartId=&quot;&#x27;pie&#x27; + building.buildingId&quot; :chartData=&quot;pieBuilding(building)&quot; style=&quot;width:320px;&quot;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/el-col&gt;</span><br><span class="line">    &lt;/el-row&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 宿舍人员信息可视化 --&gt;</span><br><span class="line">      &lt;div class=&quot;button&quot; style=&quot;position: absolute;&quot;&gt;</span><br><span class="line">        &lt;font-awesome-icon icon=&quot;arrow-left&quot; style=&quot;color: #1f3051;&quot; size=&quot;xl&quot; @click=&quot;showBuildings&quot; v-if=&quot;showFlag.rooms&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;el-row class=&quot;rooms&quot; v-if=&quot;showFlag.rooms&quot; v-for=&quot;room in rooms&quot; :key=&quot;room.roomId&quot; style=&quot;margin-top: 34px;&quot;&gt;</span><br><span class="line">        &lt;el-col :span=&quot;6&quot; class=&quot;roomContainer&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;room-name&quot; style=&quot;font-family: &#x27;Helvetica Neue&#x27;, sans-serif; font-size: 18px; color: #333; padding-left: 10px&quot;&gt;&#123;&#123; room.roomName &#125;&#125;</span><br><span class="line">          &lt;div class=&quot;room&quot;&gt;</span><br><span class="line">            &lt;font-awesome-icon</span><br><span class="line">              v-for=&quot;i in room.roomOccupied&quot;</span><br><span class="line">              :key=&quot;i&quot;</span><br><span class="line">              icon=&quot;user&quot;</span><br><span class="line">              size=&quot;lg&quot;</span><br><span class="line">              style=&quot;color: #1c4792&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">            &lt;font-awesome-icon</span><br><span class="line">              v-for=&quot;i in room.roomAvailable&quot;</span><br><span class="line">              :key=&quot;i&quot;</span><br><span class="line">              icon=&quot;user-plus&quot;</span><br><span class="line">              size=&quot;lg&quot;</span><br><span class="line">              style=&quot;color: #079711&quot;</span><br><span class="line">            /&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;div class=&quot;bed-num&quot; style=&quot;font-family: &#x27;Helvetica Neue&#x27;, sans-serif; font-size: 14px; color: #333;&quot;&gt;</span><br><span class="line">            可用:&#123;&#123;room.roomAvailable&#125;&#125;&lt;br&gt;</span><br><span class="line">            已用:&#123;&#123;room.roomOccupied&#125;&#125;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">          &lt;!-- 可视化组件 --&gt;</span><br><span class="line">          &lt;EChartsPie :chartId=&quot;&#x27;pie&#x27; + room.roomId&quot; :chartData=&quot;pieRoom(room)&quot; style=&quot;width:350px&quot;/&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;/el-col&gt;</span><br><span class="line">      &lt;/el-row&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;listRoomInfo,listBuildingInfo&#125; from &#x27;@/api/visual&#x27;</span><br><span class="line">import EChartsPie from &#x27;./EChartsPie.vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">components: &#123;</span><br><span class="line">    EChartsPie</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 控制显示顺序</span><br><span class="line">      showFlag: &#123;</span><br><span class="line">        rooms: false,</span><br><span class="line">        buildings: true</span><br><span class="line">      &#125;,</span><br><span class="line">      rooms: [],</span><br><span class="line">      buildings: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.getListBuilding();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    showRooms(building)&#123;</span><br><span class="line">      this.showFlag.rooms = true;</span><br><span class="line">      this.showFlag.buildings = false;</span><br><span class="line">      listRoomInfo(building.buildingId).then(response =&gt; &#123;</span><br><span class="line">        this.rooms = response.data;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    showBuildings()&#123;</span><br><span class="line">      this.showFlag.rooms = false;</span><br><span class="line">      this.showFlag.buildings = true;</span><br><span class="line">    &#125;,</span><br><span class="line">    getListBuilding()&#123;</span><br><span class="line">      listBuildingInfo().then(response =&gt; &#123;</span><br><span class="line">        this.buildings = response.data;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    //可视化数据</span><br><span class="line">    pieBuilding(building)&#123;</span><br><span class="line">       return [</span><br><span class="line">        &#123;value: building.totalOccupied, name:&quot;已用&quot;&#125;,</span><br><span class="line">        &#123;value: building.totalAvailable, name:&quot;可用&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    //可视化数据</span><br><span class="line">    pieRoom(room)&#123;</span><br><span class="line">       return [</span><br><span class="line">        &#123;value: room.roomOccupied, name:&quot;已用&quot;&#125;,</span><br><span class="line">        &#123;value: room.roomAvailable, name:&quot;可用&quot;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.floor,.back &#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  width: 98%;</span><br><span class="line">  margin: 10px 1%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 控制宿舍人员的样式 */</span><br><span class="line">.rooms &#123;</span><br><span class="line">  width: 45%;</span><br><span class="line">  margin-bottom: 10px;</span><br><span class="line">  /** 设置边框阴影*/</span><br><span class="line">  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);</span><br><span class="line">  /* 设置边角圆润 */</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 控制楼栋单元的样式 */</span><br><span class="line">.buildings &#123;</span><br><span class="line">  width: 25%;</span><br><span class="line">  margin-bottom: 20px;</span><br><span class="line">  /** 设置边框阴影*/</span><br><span class="line">  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);</span><br><span class="line">  /* 设置边角圆润 */</span><br><span class="line">  border-radius: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.buildingContainer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.roomContainer &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="8-引入图形库-fontawesome"><a href="#8-引入图形库-fontawesome" class="headerlink" title="8. 引入图形库-fontawesome"></a>8. 引入图形库-fontawesome</h1><p><a href="https://fontawesome.com/search?s=thin&amp;o=r">Font Awesome</a></p><p>安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p><code>main.js</code>全局引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 图形库</span><br><span class="line">/* import the fontawesome core */</span><br><span class="line">import &#123; library &#125; from &#x27;@fortawesome/fontawesome-svg-core&#x27;</span><br><span class="line"></span><br><span class="line">/* import font awesome icon component */</span><br><span class="line">import &#123; FontAwesomeIcon &#125; from &#x27;@fortawesome/vue-fontawesome&#x27;</span><br><span class="line"></span><br><span class="line">/* import specific icons */</span><br><span class="line">import &#123; faBed,faPerson,faUser,faUserPlus,faBuilding,faArrowLeft &#125; from &#x27;@fortawesome/free-solid-svg-icons&#x27;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/* add icons to the library */</span><br><span class="line">library.add(faBed,faPerson,faUser,faUserPlus,faBuilding,faArrowLeft)</span><br><span class="line"></span><br><span class="line">/* add font awesome icon component */</span><br><span class="line">Vue.component(&#x27;font-awesome-icon&#x27;, FontAwesomeIcon)</span><br></pre></td></tr></table></figure><h1 id="9-Element布局组件-el-row-el-col"><a href="#9-Element布局组件-el-row-el-col" class="headerlink" title="9. Element布局组件 el-row el-col"></a>9. Element布局组件 el-row el-col</h1><p><strong>分栏布局</strong></p><p>将网页划分成若干行，然后每行等分为若干列，称为<strong>栅栏布局</strong></p><p>element可将每行划分为24个分栏</p><p>每行使用<code>&lt;el-row&gt;</code>标签标识，然后每行内的列使用<code>&lt;el-col&gt;</code>标识</p><p>行内每列占整行的宽度比例，则使用<code>:span</code>属性进行设置</p><p><strong>分栏间隔</strong></p><p>为不同分栏之间设定一定的间隔，可以使用<code>&lt;el-row&gt;</code>标签的<code>:gutter</code>属性，默认间隔为0，要在分栏里面有新增元素，才能实现分栏间隔</p><p><strong>分栏偏移</strong></p><p>想让某个分栏不从左边显示，而是直接显示到中间或者右侧，可以借助<code>offset</code>属性来实现，表示偏移量</p><p><strong>对齐方式</strong></p><p>想让整个行居左、居中、居右对齐，则可以直接设置<code>&lt;el-row&gt;</code>的对齐方式。</p><p>此时需要先设置<code>type=&quot;flex&quot;</code>来启用对齐方式，然后通过<code>justify</code>属性来设置具体的对齐方式</p><p><strong>响应式布局</strong></p><p>element的响应式布局，通过为列设置不同分辨率下的占用宽度比例来实现的</p><p>实现在电脑和手机上都能自适应正常显示</p><h1 id="10-浮动和定位"><a href="#10-浮动和定位" class="headerlink" title="10. 浮动和定位"></a>10. 浮动和定位</h1><h2 id="10-1-浮动"><a href="#10-1-浮动" class="headerlink" title="10.1. 浮动"></a>10.1. 浮动</h2><p>标准文档流。所谓标准文档流就是文档的排列方式。浏览器会将块级元素从上到下排列，行内元素从左到右排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浮动属性值：</span><br><span class="line"></span><br><span class="line">float: left;</span><br></pre></td></tr></table></figure><p>浮动的元素会脱离标准文档流；元素浮动后，就不会占据文档流中的位置，那么在他后面的元素就会顶上来</p><p>清除浮动 <code>clear:both</code> 同时清除前面的左右浮动</p><h2 id="10-2-定位"><a href="#10-2-定位" class="headerlink" title="10.2. 定位"></a>10.2. 定位</h2><p><strong>固定定位</strong></p><p><code>position: fixed;</code>相对于浏览器窗口是固定位置。在不设置偏移量的时候是相对与body是固定位置。</p><p>设置固定定位后元素完全脱离标准文档流</p><p><strong>相对定位</strong></p><p><code>position: relative;</code>相对定位也可以通过偏移量移动位置。相对定位是相对与他本身在标准文档流中的位置进行定位</p><p><strong>绝对定位</strong></p><p><code>position: absolute;</code>绝对定位是相对于最近的有定位属性的父级进行定位。 如果所有的祖先元素都没有定位属性，就相对于浏览器的窗口进行定位</p><p>绝对定位也会完全脱离文档流。在设置相对定位时，一般给父元素设置相对定位，再子元素设置绝对定位。设置偏移量后子元素就相对与父元素偏移，而元素设置相对定位没有完全脱离文档流，这样也就不会影响父元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-13-Java%20Bean/"/>
      <url>/2024/10/28/2023-02-13-Java%20Bean/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Java-bean"><a href="#1-Java-bean" class="headerlink" title="1. Java bean"></a>1. Java bean</h1><p>Java bean 满足一些规范的Java类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">It is a regular Java class, except it follows certain conventions:</span><br><span class="line"></span><br><span class="line">All properties are private (use getters/setters)：属性私有</span><br><span class="line">A public no-argument constructor：无参构造</span><br><span class="line">Implements Serializable：实现Serializable接口</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">   <span class="keyword">private</span> String name;   </span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> salary;  </span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Employee</span><span class="params">(String name, <span class="type">int</span> salary)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">      <span class="built_in">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">( <span class="type">int</span> id )</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">( String name )</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSalary</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> salary;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSalary</span><span class="params">( <span class="type">int</span> salary )</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.salary = salary;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-serialVersionUID"><a href="#2-serialVersionUID" class="headerlink" title="2. serialVersionUID"></a>2. serialVersionUID</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BaseEntity</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建时间&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;创建人&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String createBy;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span>  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;修改时间&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> LocalDateTime updateTime;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;修改人&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String updateBy;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;备注&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String remark;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Schema(description = &quot;删除标志&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String delFlag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>serialVersionUID = 1L</code> 的作用</strong></p><p>序列化和反序列化必须保证serialVersionUID的一致性</p><p>在类中显式声明<code>serialVersionUID = 1L</code> 后，在序列化后，反序列化前，更改了类的属性或者方法，只要显式的指定了serialVersionUID的值， 那么在反序列化的过程中不会报错，只是反序列化出来的类中，我们反序列化前添加的属性值读取不到</p><h1 id="3-其他称呼"><a href="#3-其他称呼" class="headerlink" title="3. 其他称呼"></a>3. 其他称呼</h1><p>Java Bean、bean、pojo、实体类</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-11-Spring%E6%A0%B8%E5%BF%83/"/>
      <url>/2024/10/28/2023-03-11-Spring%E6%A0%B8%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-到底是如何管理对象的"><a href="#1-Spring-到底是如何管理对象的" class="headerlink" title="1. Spring 到底是如何管理对象的"></a>1. Spring 到底是如何管理对象的</h1><p>我们使用 Spring 的时候，大部分其实都是在使用 Spring 的核心容器功能。</p><p>Spring 的容器功能就是通过 BeanFactory 和对应的子类各种 xxxContext 去存储管理对象。</p><p>Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象</p><p>答：Spring使用IoC（Inversion of Control）容器来管理对象。IoC容器负责创建对象、装配对象、配置对象，并管理对象的整个生命周期。Spring的IoC容器是一个轻量级的容器，它不需要任何特殊的容器或服务器，只需要一个Java虚拟机即可。Spring的IoC容器可以管理任何Java对象，包括POJO（Plain Old Java Object）和JavaBean。</p><h1 id="2-Spring-注入对象的方式和对应原理"><a href="#2-Spring-注入对象的方式和对应原理" class="headerlink" title="2. Spring 注入对象的方式和对应原理"></a>2. Spring 注入对象的方式和对应原理</h1><p>当 Spring 成为对象容器后，它本身最重要的目的就是要去对系统中各种类进行对象注入。而工作中最常见的问题，就是 Spring 注入对象的各类问题。</p><p>也因此，广泛了解 Spring 注入对象的各类方式，从而能更加灵活地运用 Spring，深入理解注入对象的对应原理，从而能顺利无误地使用 Spring，就是我们深入学习 Spring 的重要目标。</p><p>答：Spring 注入对象的方式有三种：构造器注入、Setter注入和接口注入。构造器注入是通过构造器来注入对象，Setter注入是通过Setter方法来注入对象，接口注入是通过接口来注入对象。构造器注入的原理是在创建对象时，通过构造器参数来传递依赖对象；Setter注入的原理是在创建对象后，通过Setter方法来设置依赖对象；接口注入的原理是在创建对象时，通过接口方法来设置依赖对象。这些注入方式都是通过Spring容器来管理对象之间的依赖关系，从而实现松耦合的设计。</p><h1 id="3-Spring-是如何管理对象之间的依赖关系的"><a href="#3-Spring-是如何管理对象之间的依赖关系的" class="headerlink" title="3. Spring 是如何管理对象之间的依赖关系的"></a>3. Spring 是如何管理对象之间的依赖关系的</h1><p>除了使用完整对象的注入以外，工作中，我们还需要考虑对被注入对象属性的动态修改，可能还想要动态地注册新的 Bean 对象等等。</p><p>而要做到这些，我们就必须去了解 Spring 是如何管理对象之间的依赖关系的</p><p>答：Spring使用控制反转（IoC）和依赖注入（DI）来管理对象之间的依赖关系。在IoC中，对象不再负责管理它们所依赖的对象，而是将这个责任委托给Spring容器。Spring容器负责创建和管理对象，并将它们注入到需要它们的对象中。这种方式可以减少代码的耦合性，使代码更加灵活和可维护</p><h1 id="4-AOP-的实现原理以及对其的内部使用"><a href="#4-AOP-的实现原理以及对其的内部使用" class="headerlink" title="4. AOP 的实现原理以及对其的内部使用"></a>4. AOP 的实现原理以及对其的内部使用</h1><p>AOP 在 Spring 项目中被广泛用于权限、错误处理以及日志追踪等关键场景。</p><p>尤为重要的是，Spring 项目中的所有相关数据库事务，也都是通过 AOP 来管理和传播的。</p><p>答：AOP（面向切面编程）的实现原理是通过在程序运行期间动态地将代码切入到类的指定方法、指定位置上的编程思想。它的内部使用可以用于日志记录、性能统计、安全控制、事务处理、异常处理等方面</p><h1 id="5-Spring-的扩展点有哪些以及如何做"><a href="#5-Spring-的扩展点有哪些以及如何做" class="headerlink" title="5. Spring 的扩展点有哪些以及如何做"></a>5. Spring 的扩展点有哪些以及如何做</h1><p>很多时候，我们需要把公司的一些内部框架和系统嫁接到 Spring 中。为了减少开发成本，就要自定义一套完整的 Spring 扩展，比如：自定义注解、自定义配置类等。</p><p>想做到这些，就必须知道 Spring 有哪些扩展点，可以做什么扩展以及怎么做扩展。</p><ol><li>BeanPostProcessor：此接口允许您自定义Spring bean的初始化和销毁。您可以使用它在使用bean之前修改bean的属性或在销毁bean之后执行其他操作。</li><li>BeanFactoryPostProcessor：此接口允许您在创建Spring bean之前修改Spring bean的配置。您可以使用它添加或删除bean定义的属性或修改bean的范围。</li><li>ApplicationListener：此接口允许您监听Spring应用程序上下文中发生的事件。您可以使用它在发生某些事件时执行其他操作，例如创建bean或刷新应用程序上下文时。</li><li>HandlerInterceptor：此接口允许您拦截和修改Spring MVC应用程序中的HTTP请求和响应。您可以使用它向响应添加其他标头或在处理请求参数之前修改请求参数。</li></ol><p>要使用这些扩展点，您可以创建一个实现相应接口的类，并将其注册到Spring应用程序上下文中。</p><p>例如，要使用BeanPostProcessor接口，您可以创建一个实现该接口的类，并使用@Component注释进行注释。然后，您可以使用@Bean注释将该类注册到应用程序上下文中。</p><p>以下是在Spring应用程序中使用BeanPostProcessor接口的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在初始化bean之前修改bean的属性</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在bean初始化后执行其他操作</span></span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要将此类注册到应用程序上下文中，您可以将以下代码添加到配置类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MyBeanPostProcessor <span class="title function_">myBeanPostProcessor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyBeanPostProcessor</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Spring-MVC-的体系和重要类的作用"><a href="#6-Spring-MVC-的体系和重要类的作用" class="headerlink" title="6. Spring MVC 的体系和重要类的作用"></a>6. Spring MVC 的体系和重要类的作用</h1><p>SpringBoot 的 Web 功能，其实就是在和 SpringBoot 背后内置的 Spring MVC 打交道。</p><p>Spring MVC使用了大量的Java注解来定义控制器、模型、视图和处理器等。它还提供了丰富的功能和扩展点，例如拦截器、数据绑定、表单验证、国际化、文件上传等。</p><p>Spring MVC的核心组件包括：</p><ol><li>DispatcherServlet：中央控制器，用于将请求分发给适当的处理器。</li><li>HandlerMapping：用于将请求映射到适当的处理器（控制器）。</li><li>Controller：业务逻辑处理器，处理请求并生成相应的响应。</li><li>ViewResolver：用于查找视图（页面）并将其呈现给用户。</li><li>Model：用于保存和传递数据。</li></ol><h1 id="7-Spring-Boot-是如何自动配置好类的"><a href="#7-Spring-Boot-是如何自动配置好类的" class="headerlink" title="7. Spring Boot 是如何自动配置好类的"></a>7. Spring Boot 是如何自动配置好类的</h1><p>Spring Boot 本身就是以 Spring 作为对象容器，以 Spring MVC 实现 Web 功能的一套缝合框架。学习了 Spring 和 Spring MVC 之后，我们就理解了 Spring Boot 绝大部分功能。</p><p>但是，Spring Boot 是如何把 Spring 中的各个组件缝合在一起的？其中重要的思想就是自动配置。</p><p>所以，学习了 Spring Boot 的自动配置，我们就能从头到尾完整的了解 Spring Boot 的整体体系结构和相关对象管理流程。</p><h1 id="8-Spring-MVC拦截器"><a href="#8-Spring-MVC拦截器" class="headerlink" title="8. Spring MVC拦截器"></a>8. Spring MVC拦截器</h1><p>拦截器实现了HandlerInterceptor接口。HandlerInterceptor接口定义了三个方法：</p><ol><li><p>preHandle：在请求到达Controller之前执行，返回值为boolean类型。如果返回true，则请求继续执行；如果返回false，则请求中断。</p></li><li><p>postHandle：在Controller执行之后、视图渲染之前执行，可以对ModelAndView进行操作。</p></li><li><p>afterCompletion：在视图渲染之后执行，主要用于资源清理等操作。</p></li></ol><p>拦截器可以用于很多场景，例如：</p><ol><li><p>权限验证：拦截请求，检查用户是否有访问该资源的权限。</p></li><li><p>日志记录：记录请求的信息和处理耗时等信息，方便后续分析和优化。</p></li><li><p>参数校验：拦截请求，对请求参数进行校验，避免不合法的参数进入Controller。</p></li><li><p>资源缓存：拦截请求，判断请求的资源是否需要缓存，如果需要则从缓存中获取。</p></li></ol><h1 id="9-Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#9-Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="9. Spring,Spring MVC,Spring Boot 之间什么关系"></a>9. Spring,Spring MVC,Spring Boot 之间什么关系</h1><p>Spring 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码</p><p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p><p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-02-13-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2024/10/28/2023-02-13-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-多线程概念"><a href="#1-多线程概念" class="headerlink" title="1. 多线程概念"></a>1. 多线程概念</h1><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程</p><p>同一进程的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p><h2 id="1-1-了解堆和方法区"><a href="#1-1-了解堆和方法区" class="headerlink" title="1.1. 了解堆和方法区"></a>1.1. 了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</p><h2 id="1-2-并发与并行的区别"><a href="#1-2-并发与并行的区别" class="headerlink" title="1.2. 并发与并行的区别"></a>1.2. 并发与并行的区别</h2><ul><li><strong>并发</strong>：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li><li><strong>并行</strong>：两个及两个以上的作业在同一 <strong>时刻</strong> 执行</li></ul><h2 id="1-3-同步和异步的区别"><a href="#1-3-同步和异步的区别" class="headerlink" title="1.3. 同步和异步的区别"></a>1.3. 同步和异步的区别</h2><ul><li><strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待</li><li><strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回</li></ul><h2 id="1-4-多线程可能带来什么问题"><a href="#1-4-多线程可能带来什么问题" class="headerlink" title="1.4. 多线程可能带来什么问题"></a>1.4. 多线程可能带来什么问题</h2><p><strong>好处</strong></p><p>减少了系统上下文切换的开销，调度的开销</p><p>大大提高系统整体的并发能力以及性能</p><p><strong>坏处</strong></p><p>内存泄漏、死锁、线程不安全等</p><p><strong>线程安全问题</strong>是指多个线程同时访问同一个资源时可能会出现的问题。在多线程编程中，线程安全问题是非常常见的问题，例如竞态条件、死锁、饥饿等问题。为了避免线程安全问题，需要采取一些措施，例如使用锁、信号量、互斥量等机制来保证多个线程之间的同步和互斥</p><h2 id="1-5-多线程的使用场景"><a href="#1-5-多线程的使用场景" class="headerlink" title="1.5. 多线程的使用场景"></a>1.5. 多线程的使用场景</h2><ul><li>后台任务，例如：定时向大量（100w以上）的用户发送邮件</li><li>异步处理，例如：发微博、记录日志等</li><li>分布式计算</li></ul><h1 id="2-多线程的实现"><a href="#2-多线程的实现" class="headerlink" title="2. 多线程的实现"></a>2. 多线程的实现</h1><h2 id="2-1-继承-Thread-类实现多线程"><a href="#2-1-继承-Thread-类实现多线程" class="headerlink" title="2.1. 继承 Thread 类实现多线程"></a>2.1. 继承 Thread 类实现多线程</h2><p>继承 Thread 类，再重写 Thread 类中提供的一个 public void run() 方法，多线程要执行的功能都应该在 run()方法中进行定义</p><p>run()方法是不能够被直接调用的，要想启动多线程必须使用public void start() 方法完成 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承 Thread 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String title)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.title + <span class="string">&quot;run&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过start方法调用</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程A&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程B&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为什么多线程的启动不直接使用 run() 方法而必须使用 Thread 类中的 start()方法呢?（重点）</strong></p><p>new 一个 <code>Thread</code>，线程进入了新建状态。调用 <code>start()</code>方法，会启动一个线程并使线程进入就绪状态，当分配到时间片后就可以开始运行了。 <code>start()</code> 会执行线程的相应准备工作，然后自动执行 <code>run()</code> 方法的内容，这是真正的多线程工作。 但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作</p><p>任何情况下，只要定义了多线程，多线程的启动永远只有一种方案：Thread 类中的start()方法</p><h2 id="2-2-Runnable接口实现多线程"><a href="#2-2-Runnable接口实现多线程" class="headerlink" title="2.2. Runnable接口实现多线程"></a>2.2. Runnable接口实现多线程</h2><p>由于不再继承Thread父类了，此时的MyThread类中也就不再支持有start()这个继承的方法，可是不使用start()方法无法进行多线程启动</p><p>可通过Thread的构造方法：public Thread(Runnable target) 来启动多线程</p><p>Runnable接口避免了单继承的局限，所以优先考虑Runnable接口实现多线程，并且永远都是通过Thread类对象启动多线程</p><p>从JDK1.8开始，Runnable接口使用了函数式接口定义，所以也可以直接利用Lambda表达式进行线程类实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String title)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span> ; x &lt; <span class="number">10</span> ; x ++)&#123;</span><br><span class="line">            System.out.println(<span class="built_in">this</span>.title + <span class="string">&quot;run&quot;</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Thread的构造方法来启动多线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程A&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;线程B&quot;</span>));</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-Thread与Runnable关系"><a href="#2-3-Thread与Runnable关系" class="headerlink" title="2.3. Thread与Runnable关系"></a>2.3. Thread与Runnable关系</h2><p> Thread 类是 Runnable 接口的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">extends</span> <span class="title class_">Object</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>Runnable是一个接口，它只有一个run()方法，用于定义线程的任务。Thread是一个类，它实现了Runnable接口，并提供了一些额外的方法，如start()、sleep()、join()等，用于控制线程的执行</p><p>在进行 Thread 启动多线程的时候调用的是 start() 方法，而后调用的是 run()方法</p><p>但通过 Thread 类的构造方法传递了一个 Runnable 接口对象的时候，那么该接口对象将被 Thread 类中的 target 属性所保存，在 start() 方法执行的时候会调用Thread类中的 run() 方法，而这个 run() 方法去调用 Runnable 接口子类被覆写过的 run() 方法</p><p>在Java中，我们通常<strong>使用Thread类来创建和启动线程，而Runnable接口则用于定义线程的任务</strong></p><h2 id="2-4-Callable接口实现多线程"><a href="#2-4-Callable接口实现多线程" class="headerlink" title="2.4. Callable接口实现多线程"></a>2.4. Callable接口实现多线程</h2><p>实现Callable接口，然后重写call方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">// 重写call方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x=<span class="number">0</span>;x&lt;<span class="number">10</span>;x++)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;completed&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">        System.out.println(<span class="string">&quot;thread of return：&quot;</span> + task.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-Runnable-与-Callable-的区别"><a href="#2-5-Runnable-与-Callable-的区别" class="headerlink" title="2.5. Runnable 与 Callable 的区别"></a>2.5. Runnable 与 Callable 的区别</h2><p>Runnable 接口之中只提供有一个 run()方法，并且没有返回值</p><p>Callable 接口提供有 call()方法，可以有返回值</p><h1 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3. 线程的生命周期"></a>3. 线程的生命周期</h1><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> ，线程被调用 <code>start()</code>会进入就绪状态</p><p>RUNNABLE: 运行状态，线程被调用了，等待状态的线程得到了时间片</p><p>BLOCKED ：阻塞状态，需要等待锁释放</p><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）</p><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待</p><p>TERMINATED：终止状态，表示该线程已经运行完毕</p><h1 id="4-多线程常用操作"><a href="#4-多线程常用操作" class="headerlink" title="4. 多线程常用操作"></a>4. 多线程常用操作</h1><p>主线程可以创建若干个子线程，主线程负责处理整体流程，而子线程负责处理耗时流程</p><h2 id="4-1-线程的命名"><a href="#4-1-线程的命名" class="headerlink" title="4.1. 线程的命名"></a>4.1. 线程的命名</h2><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>构造方法 public Thread(Runnable target,String name)</td><td>命名线程</td></tr><tr><td>public final void setName(String name)</td><td>设置名字</td></tr><tr><td>public final String getName()</td><td>获取名字</td></tr><tr><td>public static Thread current Thread()</td><td>获取当前线程</td></tr></tbody></table></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程名</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">        <span class="comment">// 未命名线程</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-线程休眠"><a href="#4-2-线程休眠" class="headerlink" title="4.2. 线程休眠"></a>4.2. 线程休眠</h2><p>使用休眠的处理，让一个线程暂缓执行。必须进行异常的抛出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException</span><br></pre></td></tr></table></figure><p>休眠的主要特点是可以自动实现线程的唤醒，以继续进行后续的处理。需要注意的是，如果有多个线程对象，那么休眠也是有先后顺序的</p><h2 id="4-3-sleep-方法和-wait-方法对比"><a href="#4-3-sleep-方法和-wait-方法对比" class="headerlink" title="4.3. sleep() 方法和 wait() 方法对比"></a>4.3. sleep() 方法和 wait() 方法对比</h2><p><strong>共同点</strong> ：两者都可以暂停线程的执行</p><p><strong>区别</strong> ：</p><ul><li><strong><code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁</strong> 。</li><li><code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li><li><code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法</li></ul><h2 id="4-4-线程中断"><a href="#4-4-线程中断" class="headerlink" title="4.4. 线程中断"></a>4.4. 线程中断</h2><p>这种打断肯定是由其他线程完成的，中断线程必须进行异常的抛出</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public boolean isInterrupted()</td><td>判断线程是否被中断</td></tr><tr><td>public void interrupt()</td><td>中断线程执行</td></tr></tbody></table></div><h2 id="4-5-线程强制运行"><a href="#4-5-线程强制运行" class="headerlink" title="4.5. 线程强制运行"></a>4.5. 线程强制运行</h2><p>指的是当满足于某些条件之后，某个线程对象可以一直独占资源，直到该线程的程序执行结束</p><p>正常情况下，主线程与子线程是交替执行的（谁抢到CPU谁就执行），如果希望某个线程独占执行，可使用 jion()方法</p><h2 id="4-6-线程礼让"><a href="#4-6-线程礼让" class="headerlink" title="4.6. 线程礼让"></a>4.6. 线程礼让</h2><p>将资源让出去让别的线程先执行</p><p>每一次调用yield() 方法都只会礼让一次当前的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span></span><br></pre></td></tr></table></figure><h2 id="4-7-线程优先级"><a href="#4-7-线程优先级" class="headerlink" title="4.7. 线程优先级"></a>4.7. 线程优先级</h2><p>优先级越高越有可能先执行</p><p>在进行优先级定义的时候都是通过int 型的数字来完成的，而对于此数字的选择在Thread类里面就定义有三个常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最高优先级：public static final int MAX PRIORITY,10</span><br><span class="line"></span><br><span class="line">中等优先级：public static final int NORM PRIORITY,5</span><br><span class="line"></span><br><span class="line">最低优先级：public static final int MIN PRIORITY,1</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public finial void setPriority(int newPriority)</td><td>设置优先级</td></tr><tr><td>public final int getPriority()</td><td>获取优先级</td></tr></tbody></table></div><p>主线程是属于中等优先级，而默认创建的线程也是中等优先级。优先级高的可能先执行而不是绝对先执行</p><h1 id="5-线程的同步与死锁"><a href="#5-线程的同步与死锁" class="headerlink" title="5. 线程的同步与死锁"></a>5. 线程的同步与死锁</h1><h2 id="5-1-线程同步"><a href="#5-1-线程同步" class="headerlink" title="5.1. 线程同步"></a>5.1. 线程同步</h2><p>当多个线程同时访问共享资源时，可能会发生竞争条件，导致数据不一致或其他问题。使用 synchronized 关键字可以确保在任何时候只有一个线程可以访问共享资源（即上锁），从而避免竞争条件</p><p><strong>同步代码块</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步对象)&#123;</span><br><span class="line">同步代码操作 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般要进行同步对象处理的时候可以采用当前对象 this 进行同步</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        ......</span><br><span class="line">            .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>同步方法</strong>，只需要在方法定义上使用 synchronized 关键字即可</p><p>同步实际上会造成性能的降低</p><h2 id="5-2-线程死锁"><a href="#5-2-线程死锁" class="headerlink" title="5.2. 线程死锁"></a>5.2. 线程死锁</h2><p>死锁造成的主要原因是彼此都在互相等待着，等待着对方先让出资源</p><p>过多的同步会造成死锁</p><h2 id="5-3-释放锁（重点）"><a href="#5-3-释放锁（重点）" class="headerlink" title="5.3. 释放锁（重点）"></a>5.3. 释放锁（重点）</h2><p>在Java中，当同步方法或代码块执行完毕时，锁会自动释放。此外，如果线程在同步方法或代码块中抛出异常，则锁也会自动释放。如果需要在同步方法或代码块中提前释放锁，可以使用 wait 和 notify 方法来实现。具体来说，当一个线程调用 wait 方法时，它会释放对象的锁，并进入等待状态，直到另一个线程调用相同对象的 notify 方法来唤醒它。当一个线程调用 notify 方法时，它会通知等待该对象的线程，使其中的一个线程从等待状态中恢复并重新获取对象的锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait(); <span class="comment">// release lock and wait</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    notify(); <span class="comment">// notify waiting threads</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">doSomethingElse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        wait(); <span class="comment">// release lock and wait</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// do something else</span></span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    notify(); <span class="comment">// notify waiting threads</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，doSomething 和 doSomethingElse 方法都是同步的，并使用 wait 和 notify 方法来实现同步。当一个线程调用 doSomething 方法时，它会执行其中的代码，并将 flag 设置为 true，然后调用 notify 方法来唤醒doSomethingElse</p><h1 id="6-生产者-消费者模型"><a href="#6-生产者-消费者模型" class="headerlink" title="6. 生产者-消费者模型"></a>6. 生产者-消费者模型</h1><p>该模型用于解决多个线程之间的协作问题。在该模型中，有两种类型的线程：生产者和消费者。生产者线程负责生成数据并将其放入共享缓冲区中，而消费者线程负责从缓冲区中取出数据并进行处理。</p><p>Java提供了多种机制来实现生产者-消费者模型，其中最常用的是使用wait()、notify()和notifyAll()方法实现线程间的通信</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public final void wait() throws InterruptedException</td><td>死等</td></tr><tr><td>public final void wait(long timeout) throws InterruptedException</td><td>设置等待时间</td></tr><tr><td>public final void notify()</td><td>唤醒第一个等待线程</td></tr><tr><td>public final void notifyAll()</td><td>唤醒全部等待线程</td></tr></tbody></table></div><p>以下是一个使用wait() 和notify() 方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProducerConsumer</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个缓冲区</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; buffer = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (buffer.size() == capacity) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;Producer produced &quot;</span> + value);</span><br><span class="line">                buffer.add(value++);</span><br><span class="line">                notify();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (buffer.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> buffer.remove(<span class="number">0</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Consumer consumed &quot;</span> + value);</span><br><span class="line">                notify();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上示例中，创建了一个ProducerConsumer类，其中包含一个共享缓冲区和两个方法：produce()和consume()。在produce()方法中，使用synchronized关键字同步访问共享缓冲区，并在缓冲区已满时使用wait() 方法使生产者线程等待。在生产者线程生成数据并将其放入缓冲区后，我们使用notify()方法通知消费者线程可以开始消费数据。在consume()方法中，我们使用类似的方式同步访问共享缓冲区，并在缓冲区为空时使用wait() 方法使消费者线程等待。在消费者线程从缓冲区中取出数据并进行处理后，我们使用notify()方法通知生产者线程可以开始生成数据。需要注意的是，<strong>wait()和notify()方法必须在synchronized块中使用，以确保线程安全。</strong></p><h1 id="7-多线程深入"><a href="#7-多线程深入" class="headerlink" title="7. 多线程深入"></a>7. 多线程深入</h1><h2 id="7-1-停止线程"><a href="#7-1-停止线程" class="headerlink" title="7.1. 停止线程"></a>7.1. 停止线程</h2><p>不要直接用stop()方法</p><p>使用 flag 标志判断的方法来控制线程的停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">    ...</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h2 id="7-2-守护线程"><a href="#7-2-守护线程" class="headerlink" title="7.2. 守护线程"></a>7.2. 守护线程</h2><p>当一个进程中有线程还在执行的时候，守护线程将一直存在，并且运行在后台状态</p><p>如果程序执行完毕了，守护线程也就消失了，在整个的 JVM 里面最大的守护线程就是 GC 线程</p><p>在 Thread 类里面提供有如下的守护线程的操作方法</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>public final void setDaemon(boolean on)</td><td>设置为守护线程</td></tr><tr><td>public final boolean isDaemon()</td><td>判断是否为守护线程</td></tr></tbody></table></div><h2 id="7-3-volatile关键字"><a href="#7-3-volatile关键字" class="headerlink" title="7.3. volatile关键字"></a>7.3. volatile关键字</h2><p><code>volatile</code> 关键字可以保证变量的可见性。具体来说是当一个变量被声明为 volatile 时，它的值会被直接存储在主内存中，而不是存储在线程的工作内存中。这样，当一个线程修改了变量的值时，它会立即同步到主内存中，从而使其他线程可以看到这个修改</p><p>在正常进行变量处理的时候往往会经历如下的几个步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取变量原有的数据内容副本</span><br><span class="line">利用副本为变量进行数学计算</span><br><span class="line">将计算后的变量，保存到原始空间之中</span><br></pre></td></tr></table></figure><p>如果一个属性上追加了volatile 关键字，表示不使用副本而是直接操作原始变量</p><p><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-乐观锁和悲观锁"><a href="#8-乐观锁和悲观锁" class="headerlink" title="8. 乐观锁和悲观锁"></a>8. 乐观锁和悲观锁</h1><h2 id="8-1-悲观锁"><a href="#8-1-悲观锁" class="headerlink" title="8.1. 悲观锁"></a>8.1. 悲观锁</h2><p> Java 中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现</p><p>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</p><p>悲观锁通常用于多写场景，避免频繁失败和重试影响性能</p><h2 id="8-2-乐观锁"><a href="#8-2-乐观锁" class="headerlink" title="8.2. 乐观锁"></a>8.2. 乐观锁</h2><p>乐观锁通常用于多读场景，避免频繁加锁影响性能，大大提升了系统的吞吐量</p><h1 id="9-线程池"><a href="#9-线程池" class="headerlink" title="9. 线程池"></a>9. 线程池</h1><p>经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p><p>提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中，可以避免频繁创建销毁，实现重复利用</p><p><strong>优点</strong></p><p>性能优化、防止OOM（防止应用创建很多线程导致内存溢出）</p><p><img src="F:\笔记\博客\文章图片\图解线程池实现原理.png" alt="图解线程池实现原理"></p><h2 id="9-1-创建线程池"><a href="#9-1-创建线程池" class="headerlink" title="9.1. 创建线程池"></a>9.1. 创建线程池</h2><p><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></p><p>ThreadPoolExecutor 是 Executor接口的一个实现</p><p><code>ThreadPoolExecutor</code> 3 个最重要的参数：</p><ul><li><code>corePoolSize</code> ：核心线程数。任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><code>maximumPoolSize</code> ：最大线程数。任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><code>workQueue</code>：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><code>keepAliveTime</code>：线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁</li><li><code>unit</code> ： <code>keepAliveTime</code> 参数的时间单位。</li><li><code>threadFactory</code> ：executor 创建新线程的时候会用到。</li><li><code>handler</code> ：饱和策略</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// create a thread pool with 5 threads</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">      <span class="number">5</span>, <span class="comment">// core pool size</span></span><br><span class="line">      <span class="number">10</span>, <span class="comment">// maximum pool size</span></span><br><span class="line">      <span class="number">60</span>, <span class="comment">// keep-alive time</span></span><br><span class="line">      TimeUnit.SECONDS, <span class="comment">// time unit for keep-alive time</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;Runnable&gt;(<span class="number">100</span>) <span class="comment">// task queue</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// submit tasks to the thread pool</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">      executor.submit(<span class="keyword">new</span> <span class="title class_">MyTask</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// shutdown the thread pool</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> taskId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MyTask</span><span class="params">(<span class="type">int</span> taskId)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.taskId = taskId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task #&quot;</span> + taskId + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的示例中，使用 ThreadPoolExecutor 构造函数创建了一个线程池，它包含5个核心线程和10个最大线程。当线程池中的线程数量超过核心线程数时，新的任务会被放入任务队列中等待执行。如果任务队列已满，新的任务会创建新的线程来执行，直到线程数量达到最大线程数。线程空闲时间为60秒，超过这个时间后，空闲线程会被销毁。任务队列使用了一个大小为100的有界阻塞队列。最后，我们使用 executor.submit 方法提交任务到线程池中，并使用 executor.shutdown 方法关闭线程池</p><p><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建（不推荐）</strong></p><p><code>Executors</code> 返回线程池对象的弊端,，<strong>会有 OOM 风险。</strong>OOM是指当程序尝试使用超出可用内存的内存时，会抛出OutOfMemoryError异常</p><h2 id="9-2-线程池的饱和策略"><a href="#9-2-线程池的饱和策略" class="headerlink" title="9.2. 线程池的饱和策略"></a>9.2. 线程池的饱和策略</h2><p>指当线程池中的线程数量达到最大值并且任务队列已满时，新的任务应该如何处理</p><p>Java中的线程池提供了四种饱和策略：</p><ul><li>AbortPolicy（默认）：当线程池已满并且任务队列已满时，新的任务会抛出 RejectedExecutionException异常</li><li><p>CallerRunsPolicy：当线程池已满并且任务队列已满时，新的任务会在提交任务的线程中直接执行</p></li><li><p>DiscardPolicy：当线程池已满并且任务队列已满时，新的任务会被丢弃，不会抛出异常也不会执行</p></li><li><p>DiscardOldestPolicy：当线程池已满并且任务队列已满时，新的任务会替换任务队列中最早的任务</p></li></ul><h2 id="9-3-线程池常用的阻塞队列"><a href="#9-3-线程池常用的阻塞队列" class="headerlink" title="9.3. 线程池常用的阻塞队列"></a>9.3. 线程池常用的阻塞队列</h2><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中</p><p><strong>LinkedBlockingQueue</strong> 是一个无界队列，它可以存储任意数量的任务。当线程池中的线程数量达到核心线程数时，新的任务会被放入 LinkedBlockingQueue中等待执行。由于LinkedBlockingQueue 是无界队列，因此它可以存储任意数量的任务，但是当任务数量过多时，可能会导致内存溢出</p><p><strong>ArrayBlockingQueue</strong> 是一个有界队列，它可以存储固定数量的任务。当线程池中的线程数量达到核心线程数时，新的任务会被放入ArrayBlockingQueue中等待执行。由于 ArrayBlockingQueue是有界队列，因此它可以避免任务数量过多导致的内存溢出问题。但是当任务数量超过队列大小时，新的任务会被拒绝执行，除非使用合适的饱和策略</p><h2 id="9-4-给线程池命名"><a href="#9-4-给线程池命名" class="headerlink" title="9.4. 给线程池命名"></a>9.4. 给线程池命名</h2><p>默认情况下创建的线程名字类似 <code>pool-1-thread-n</code> 这样</p><p>自己实现 <code>ThreadFactor</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程工厂，它设置线程名称，有利于我们定位问题。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NamingThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory delegate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个带名字的线程池生产工厂</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NamingThreadFactory</span><span class="params">(ThreadFactory delegate, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.delegate = delegate;</span><br><span class="line">        <span class="built_in">this</span>.name = name; <span class="comment">// TODO consider uniquifying this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> delegate.newThread(r);</span><br><span class="line">        t.setName(name + <span class="string">&quot; [#&quot;</span> + threadNum.incrementAndGet() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-5-合理设定线程池的大小"><a href="#9-5-合理设定线程池的大小" class="headerlink" title="9.5. 合理设定线程池的大小"></a>9.5. 合理设定线程池的大小</h2><p>有一个简单并且适用面比较广的公式：</p><ul><li><strong>CPU 密集型任务(N+1)：</strong> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。</li><li><strong>I/O 密集型任务(2N)：</strong> 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</li></ul><h2 id="9-6-动态修改线程池的参数"><a href="#9-6-动态修改线程池的参数" class="headerlink" title="9.6. 动态修改线程池的参数"></a>9.6. 动态修改线程池的参数</h2><p>开源线程池：DynamicTp、Hippo4j</p><h2 id="9-7-相关API"><a href="#9-7-相关API" class="headerlink" title="9.7. 相关API"></a>9.7. 相关API</h2><p><strong>Executors类</strong></p><p>线程池的工厂类，用于创建不同类型的线程池</p><p><strong>ThreadPoolExecutor类</strong></p><p>ThreadPoolExecutor类是Java提供的一个灵活的线程池实现</p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>void execute(Runnable command)</td><td>执行任务，没有返回值，一般用来执行Runnable</td></tr><tr><td><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></td><td>执行任务，有返回值，一般来执行Callable</td></tr><tr><td>void shutdown()</td><td>关闭连接池</td></tr></tbody></table></div><h1 id="10-Future-模式"><a href="#10-Future-模式" class="headerlink" title="10. Future 模式"></a>10. Future 模式</h1><p>核心思想是异步调用，主要用在多线程领域，并非 Java 语言独有</p><h2 id="10-1-Future"><a href="#10-1-Future" class="headerlink" title="10.1. Future"></a>10.1. Future</h2><p>在 Java 中，Future 类只是一个泛型接口</p><p>将耗时任务交给Future处理，任务执行期间可以去做其他事情。并且，在这期间还可以取消任务以及获取任务的执行状态。一段时间之后，可以从 Future 里直接取出任务执行结果</p><p><strong>方法</strong></p><div class="table-container"><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>取消任务</td><td>boolean cancel(boolean mayInterruptIfRunning)</td></tr><tr><td>判断任务是否被取消</td><td>boolean isCancelled()</td></tr><tr><td>判断任务是否已经执行完成</td><td>boolean isDone()</td></tr><tr><td>获取任务执行结果</td><td>V get() throws InterruptedException, ExecutionException</td></tr><tr><td>指定时间内获取任务执行结果</td><td>V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</td></tr></tbody></table></div><h2 id="10-2-FutureTask"><a href="#10-2-FutureTask" class="headerlink" title="10.2. FutureTask"></a>10.2. FutureTask</h2><p>FutureTask 提供了 Future 接口的基本实现，常用来封装 Callable 和 Runnable，具有取消任务、查看任务是否执行完成、获取任务执行结果的方法。ExecutorService.submit() 方法返回的其实就是 Future 的实现类 FutureTask</p><p>FutureTask 不光实现了 Future 接口，还实现了Runnable 接口，因此可以作为任务直接被线程执行</p><p>FutureTask 有两个构造函数，可传入 Callable 或者 Runnable 对象。实际上，传入 Runnable 对象也会在方法内部转换为Callable 对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-03-03-SpringBoot/"/>
      <url>/2024/10/28/2023-03-03-SpringBoot/</url>
      
        <content type="html"><![CDATA[<h1 id="1-SpringBoot-的自动装配"><a href="#1-SpringBoot-的自动装配" class="headerlink" title="1. SpringBoot 的自动装配"></a>1. SpringBoot 的自动装配</h1><p>SpringBoot的核心是自动装配</p><p>使用Spring时，在开启某些 Spring 特性或者引入第三方依赖的时候，需要用 XML 或 Java 进行显式配置</p><p>使用Spring Boot，通过 Spring Boot 的全局配置文件 application.properties 或 application.yml 即可对项目进行设置，比如更换端口号，配置 Mybatis 属性等</p><p>SpringBoot 在启动时会扫描<code>META-INF/spring.factories</code>文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot</p><p>Spring Boot中要引入第三方依赖，直接引入一个 starter 即可。引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了</p><h2 id="1-1-自动装配原理"><a href="#1-1-自动装配原理" class="headerlink" title="1.1. 自动装配原理"></a>1.1. 自动装配原理</h2><p>SpringBoot 的核心注解  @SpringBootApplication</p><p><strong>@SpringBootApplication</strong> 看作是 @Configuration、@EnableAutoConfiguration、@ComponentScan 注解的集合。这三个注解的作用分别是：</p><ul><li>@EnableAutoConfiguration：启用 SpringBoot 的自动配置机制</li><li>@Configuration：允许在上下文中注册额外的 bean 或导入其他配置类</li><li>@ComponentScan： 扫描被@Component（@Service，@Controller）注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，也可以自定义不扫描某些 bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @SpringBootApplication的部分源码</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(</span></span><br><span class="line"><span class="meta">    excludeFilters = &#123;@Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;TypeExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">), @Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.CUSTOM,</span></span><br><span class="line"><span class="meta">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;</span></span><br><span class="line"><span class="meta">)</span></span><br></pre></td></tr></table></figure><p><strong>@EnableAutoConfiguration</strong> 是实现自动装配的重要注解，自动装配核心功能的实现实际是通过 AutoConfigurationImportSelector类，即 @EnableAutoConfiguration 源码中的 @Import({AutoConfigurationImportSelector.class})</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @EnableAutoConfiguration的部分源码</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span><span class="comment">// 作用：将main包下的所有组件注册到容器中</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span>  <span class="comment">//加载自动装配类 xxxAutoconfiguration</span></span><br></pre></td></tr></table></figure><p><strong>AutoConfigurationImportSelector</strong>实现加载自动装配类 <code>xxxAutoconfiguration</code>。AutoConfigurationImportSelector类的继承体系如下：可以看出 AutoConfigurationImportSelector 类实现了 ImportSelector接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IOC 容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title class_">DeferredImportSelector</span>, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DeferredImportSelector</span> <span class="keyword">extends</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ImportSelector</span> &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImportSelector接口中的selectImports方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123; <span class="comment">// 判断自动装配开关是否打开</span></span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 获取所有需要装配的bean</span></span><br><span class="line">        AutoConfigurationImportSelector.<span class="type">AutoConfigurationEntry</span> <span class="variable">autoConfigurationEntry</span> <span class="operator">=</span> <span class="built_in">this</span>.getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getAutoConfigurationEntry()</strong>方法，AutoConfigurationImportSelector类调用这个方法，主要负责加载自动配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getAutoConfigurationEntry()方法的源码</span></span><br><span class="line"><span class="keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry <span class="title function_">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.isEnabled(annotationMetadata)) &#123;<span class="comment">// 1.判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration=true，可在 application.properties 或 application.yml 中设置</span></span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 2.用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName</span></span><br><span class="line">        <span class="type">AnnotationAttributes</span> <span class="variable">attributes</span> <span class="operator">=</span> <span class="built_in">this</span>.getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = <span class="built_in">this</span>.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">        <span class="comment">// 3.获取需要自动装配的所有配置类，读取META-INF/spring.factories</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.removeDuplicates(configurations);</span><br><span class="line">        Set&lt;String&gt; exclusions = <span class="built_in">this</span>.getExclusions(annotationMetadata, attributes);</span><br><span class="line">        <span class="built_in">this</span>.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        <span class="comment">// 4.这一步会筛选，所以 spring.factories中这么多配置，不是每次启动都要全部加载。只有 @ConditionalOnXXX 中的所有条件都满足，该类才会生效</span></span><br><span class="line">        configurations = <span class="built_in">this</span>.getConfigurationClassFilter().filter(configurations);</span><br><span class="line">        <span class="built_in">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AutoConfigurationImportSelector</span>.AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-SpringBoot-Starter"><a href="#1-2-SpringBoot-Starter" class="headerlink" title="1.2. SpringBoot Starter"></a>1.2. SpringBoot Starter</h2><p><strong>Spring Boot Starter是什么</strong></p><p>a Spring Boot Starter is a set of pre-configured dependencies, packaged together to jumpstart the development of specific types of applications or components. These starters contain everything you need to get up and running quickly, reducing the complexity of configuring your application manually.</p><p><strong>Spring Boot Starter的工作方式</strong></p><ol><li>Pre-Packaged Dependencies: Each Starter includes a carefully curated collection of dependencies, such as libraries, frameworks, and configurations. These dependencies are chosen to cater to a specific use case or technology stack.</li><li>Auto-Configuration: Spring Boot automatically configures these dependencies based on sensible defaults and conventions. This eliminates the need for extensive configuration files and boilerplate code, saving you time and effort.</li><li>Ready-to-Use Templates: Starters often include template code or sample applications that serve as a foundation for your project. You can then build upon this foundation to create custom functionality.</li><li>Technology-Centric: Spring Boot offers a wide range of Starters tailored for various technologies, such as web development (Spring Boot Starter Web), data access (Spring Boot Starter Data JPA), and more. This allows you to pick the Starter that aligns with your project’s requirements.</li><li>Easy Customization: While Starters provide a quick start, Spring Boot allows for extensive customization. You can override default configurations and add additional dependencies as needed to tailor the application to your specific needs</li></ol><h2 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3. 总结"></a>1.3. 总结</h2><p>Spring Boot 通过@EnableAutoConfiguration开启自动装配，通过 SpringFactoriesLoader 最终加载META-INF/spring.factories中的自动配置类实现自动装配，自动配置类其实就是通过@Conditional按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p><p>给容器中自动配置类添加组件的时候，会从properties类中获取默认属性。我们只需要在配置文件中指定这些属性的值即可</p><p>核心：xxxAutoConfiguration（SpringBoot自动装配）—&gt; xxxxProperties封装配置文件中相关属性（可在配置文件中修改默认值）</p><p>结论：SpringBoot所有的自动配置都是在启动的时候描并加载，spring.factories所有的自动配置类都在这里，但是不一定生效，因为要判断条件是否成立，只要导入了对应的Starter，就有了启动器，自动装配就会生效，然后就配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A(自动装配原理)--&gt;A.1(&quot;@springBootApplication&quot;)</span><br><span class="line">A.1--&gt;A.1.1(&quot;@SpringBootConfiguration&quot;)</span><br><span class="line">A.1.1--&gt;A.1.1.1(&quot;@Configuration&quot;)</span><br><span class="line">A.1.1.1--&gt;A.1.1.1.1(&quot;@Component&quot;)</span><br><span class="line"></span><br><span class="line">A.1--&gt;A.1.2(&quot;@EnableAutoConfiguration:启用SpringBoot的自动配置机制&quot;)</span><br><span class="line">A.1.2--&gt;A.1.2.1(&quot;@AutoConfigurationPackage&quot;)</span><br><span class="line">A.1.2.1--&gt;A.1.2.1.1(&quot;AutoConfigurationPackages.Registrar.class自动注册表&quot;)</span><br><span class="line">A.1.2--&gt;A.1.2.2(&quot;AutoConfigurationlmportSelector.class自动导入包的核心&quot;)</span><br><span class="line">A.1--&gt;A.1.3(&quot;@ComponentScan:扫描当前主启动类同级的包&quot;)</span><br><span class="line">A.1.2.2--&gt;A.1.2.2.1(&quot;ImportSelector接口中的selectImports方法&quot;)</span><br><span class="line">A.1.2.2.1--&gt;A.1.2.2.1.1(&quot;getAutoConfigurationEntry()方法&quot;)</span><br><span class="line">A.1.2.2.1.1--&gt;A.1.2.2.1.1.1(&quot;SpringFactoriesLoader.loadFactoryNames()获取所有自动配置类名&quot;)</span><br><span class="line">A.1.2.2.1.1.1--&gt;A.1.2.2.1.1.1.1(&quot;SpringFactoriesLoader.loadSpringFactories(@NullableClassLoader classLoader)从META-INF/spring.factories加载自动配置类&quot;)</span><br></pre></td></tr></table></figure><h1 id="2-主启动类的运行"><a href="#2-主启动类的运行" class="headerlink" title="2. 主启动类的运行"></a>2. 主启动类的运行</h1><p>SpringApplication类主要做了如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">推断应用的类型是普通的项目还是Web项目</span><br><span class="line"></span><br><span class="line">推断并设置main方法的定义类，找到运行的主类</span><br><span class="line"></span><br><span class="line">找出所有的应用程序监听器，设置到listeners属性中</span><br><span class="line"></span><br><span class="line">查找并加载所有可用初始化器，设置到 initializers 属性中</span><br></pre></td></tr></table></figure><h1 id="3-搭建SpringBoot环境"><a href="#3-搭建SpringBoot环境" class="headerlink" title="3. 搭建SpringBoot环境"></a>3. 搭建SpringBoot环境</h1><p>初始化时，默认链接访问失败，就用国内的 <a href="https://start.springboot.io/">https://start.springboot.io/</a> 或者 <a href="https://start.aliyun.com">https://start.aliyun.com</a></p><p>在 Spring Initializr 中创建一个新项目时，各个参数的含义</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 公司域名</span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yatoil<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">//项目名称</span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yt-dorm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br></pre></td></tr></table></figure><h2 id="3-1-SpringBoot-单模块项目构建（常规）"><a href="#3-1-SpringBoot-单模块项目构建（常规）" class="headerlink" title="3.1. SpringBoot 单模块项目构建（常规）"></a>3.1. SpringBoot 单模块项目构建（常规）</h2><p>直接使用Spring Initializr按步骤走即可 </p><h2 id="3-2-SpringBoot-多模块项目构建（父-子模块）"><a href="#3-2-SpringBoot-多模块项目构建（父-子模块）" class="headerlink" title="3.2. SpringBoot 多模块项目构建（父/子模块）"></a>3.2. SpringBoot 多模块项目构建（父/子模块）</h2><p>创建项目结构：使用Spring Initializr 创建一个父目录，只留下<code>pom.xml</code>文件，之后在父目录下创建子模块<code>new module</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">demo-projectName（父）</span><br><span class="line">--&gt; demo-moduleName1（子）</span><br><span class="line">--&gt; demo-moduleName2（子）</span><br><span class="line">--&gt; ...</span><br><span class="line">pom.xml（父级）</span><br></pre></td></tr></table></figure><p>各级项目建立关联：在父目录下的<code>pom.xml</code>中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 对于聚合模块来说，其打包方式必须为pom，否则无法构建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指明聚合的模块 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-moduleName1<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">module</span>&gt;</span>demo-moduleName2<span class="tag">&lt;/<span class="name">module</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子级继承父级的项目依赖：在子级项目的<code>pom.xml</code>中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定当前项目的父项目，用于自动继承父项目的依赖项、插件、资源等配置信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="4-SpringBoot配置文件"><a href="#4-SpringBoot配置文件" class="headerlink" title="4. SpringBoot配置文件"></a>4. SpringBoot配置文件</h1><p>SpringBoot使用一个全局的配置文件，配置文件名称是固定的</p><h2 id="4-1-两种配置文件"><a href="#4-1-两种配置文件" class="headerlink" title="4.1. 两种配置文件"></a>4.1. 两种配置文件</h2><p><strong>不同名称的配置文件的优先级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application.properties &gt; application.yml</span><br></pre></td></tr></table></figure><p><strong>application.properties</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法结构：key=value</span><br><span class="line">server.port=8888</span><br></pre></td></tr></table></figure><p><strong>application.yml（推荐）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法结构：key:空格value</span><br><span class="line">server:</span><br><span class="line">port: 80</span><br></pre></td></tr></table></figure><h2 id="4-2-读取配置文件的内容"><a href="#4-2-读取配置文件的内容" class="headerlink" title="4.2. 读取配置文件的内容"></a>4.2. 读取配置文件的内容</h2><p>假如application.yml配置文件中有如下内容<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">admin123</span></span><br></pre></td></tr></table></figure></p><p><strong>方法一：@ConfigurationProperties</strong></p><p>如果专门编写了一个JavaBean来和配置文件进行映射，则推荐使用 <code>@ConfigurationProperties</code></p><p>使用前需要先在pom.xml中引入一个依赖（否则会报<code>Spring Boot Configuration Annotation Processor not configured</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>先用 <code>@ConfigurationProperties(prefix = &quot;配置文件中的类名&quot;)</code> 绑定配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java 类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">get()</span></span><br><span class="line"><span class="comment">set()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时注入该Java Bean后，即可使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure><p><strong>方法二：@Value</strong></p><p>如果获取的参数较少，则推荐直接使用<code>@Value(&quot;$&#123;...&#125;&quot;)</code>获取即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;user.name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br></pre></td></tr></table></figure><p><strong>方法三：Environment Object</strong></p><p>使用时先注入Environment Object </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br></pre></td></tr></table></figure><p>需要使用配置文件中的内容时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> env.getProperty(<span class="string">&quot;user.name&quot;</span>);</span><br></pre></td></tr></table></figure></p><h2 id="4-3-多种环境的配置"><a href="#4-3-多种环境的配置" class="headerlink" title="4.3. 多种环境的配置"></a>4.3. 多种环境的配置</h2><p>application-dev.yml 开发环境、application-prod.yml 生产环境</p><p>在application.yml 中选择激活哪个环境</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span> </span><br><span class="line"><span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles :</span></span><br><span class="line"><span class="attr">active:</span> <span class="string">dev</span>  <span class="comment"># dev表示激活开发环境  prod表示激活生产环境</span></span><br></pre></td></tr></table></figure><h2 id="4-4-多种配置方式"><a href="#4-4-多种配置方式" class="headerlink" title="4.4. 多种配置方式"></a>4.4. 多种配置方式</h2><p>xml配置文件、JavaConfig配置类、yml配置文件</p><p>所有第三方组件的xml配置文件都可以被yml中的配置代替，如 <code>mybatis-config.xml</code>、<code>logback.xml</code>等，但是xml中配置项过多时，建议使用xml配置文件，之后在yml中引入</p><h1 id="5-参数校验"><a href="#5-参数校验" class="headerlink" title="5. 参数校验"></a>5. 参数校验</h1><p>通常使用Spring自带的Validation校验参数</p><h1 id="6-国际化"><a href="#6-国际化" class="headerlink" title="6. 国际化"></a>6. 国际化</h1><p>i18n 全称 Internationalization，也就是国际化的意思，因为单词太长，所以中间的 18 个字母被缩写为 18，再加上开头和结尾的字母，就组成了 i18n。</p><p>通常要实现的效果是，前端有个按钮可以切换语言，对于前后端分离的项目建议把国际化做在前端。</p><h1 id="7-SpringData"><a href="#7-SpringData" class="headerlink" title="7. SpringData"></a>7. <a href="https://spring.io/projects/spring-data">SpringData</a></h1><p>对于数据访问，无论是SQL（关系型数据库）还是NoSQL（非关系型数据库），Spring Boot底层都是采用Spring Data的方式进行统一处理</p><p>Spring Boot2.X访问关系型数据库的三种主流姿势JDBC、MyBatis、JPA</p><p><strong>使用Java操作数据库必须先在pom.xml中导入对应的数据库驱动</strong></p><p>如：MySQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>操作MongoDB</strong></p><p>在pom.xml中导入依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-mongodb<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>yml 文件中添加以下配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">data:</span>  </span><br><span class="line">  <span class="attr">mongodb:</span>  </span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.163</span><span class="number">.5</span>  </span><br><span class="line">    <span class="attr">username:</span> <span class="string">&quot;root&quot;</span>  </span><br><span class="line">    <span class="attr">password:</span> <span class="string">&quot;root&quot;</span>  </span><br><span class="line">    <span class="attr">port:</span> <span class="number">27017</span>  </span><br><span class="line">    <span class="attr">authentication-database:</span> <span class="string">test</span>  </span><br><span class="line">    <span class="attr">database:</span> <span class="string">dormitory</span>  </span><br><span class="line">    <span class="attr">auto-index-creation:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="7-1-JDBC操作数据"><a href="#7-1-JDBC操作数据" class="headerlink" title="7.1. JDBC操作数据"></a>7.1. JDBC操作数据</h2><p>在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>操作MySQL</strong></p><p>在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml 文件中添加以下配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.mysql.cj.jdbc.Driver 适用于MySQL 8.x  </span><br><span class="line"></span><br><span class="line">com.mysql.jdbc.Driver 适用于MySQL5.x </span><br></pre></td></tr></table></figure><h2 id="7-2-Mybatis操作数据"><a href="#7-2-Mybatis操作数据" class="headerlink" title="7.2. Mybatis操作数据"></a>7.2. Mybatis操作数据</h2><p>在pom.xml中导入依赖，mybatis会自动引入jdbc部分依赖，所以不用手动添加jdbc依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml 文件中添加以下配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整合mybatis</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 搜索指定包别名</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.exam.**.domain</span></span><br><span class="line">  <span class="comment"># 配置mapper的扫描，找到所有的mapper.xml映射文件</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br><span class="line">  <span class="comment"># 加载全局的配置文件  </span></span><br><span class="line">  <span class="attr">configLocation:</span> <span class="string">classpath:mybatis/mybatis-config.xml</span></span><br></pre></td></tr></table></figure><h2 id="7-3-MyBatis-Plus操作数据"><a href="#7-3-MyBatis-Plus操作数据" class="headerlink" title="7.3. MyBatis-Plus操作数据"></a>7.3. MyBatis-Plus操作数据</h2><p>在pom.xml中导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>yml 文件中添加以下配置项</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">classpath:mapper/*.xml</span></span><br></pre></td></tr></table></figure><h2 id="7-4-在SpringBoot中使用多个数据源"><a href="#7-4-在SpringBoot中使用多个数据源" class="headerlink" title="7.4. 在SpringBoot中使用多个数据源"></a>7.4. 在SpringBoot中使用多个数据源</h2><p><strong>使用 Spring Boot 自带的多数据源配置</strong></p><p>yml 文件中添加以下配置项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">  # 主数据源</span><br><span class="line">    primary:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/test1?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">   ＃二号数据源   </span><br><span class="line">    secondary:</span><br><span class="line">      url: jdbc:mysql://localhost:3306/test2?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">      username: root</span><br><span class="line">      password: root</span><br><span class="line">      driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>在代码中通过 <code>@Qualifier</code> 注解来指定使用哪个数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;primaryDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource primaryDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;secondaryDataSource&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> DataSource secondaryDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-SpringBoot数据库连接池"><a href="#8-SpringBoot数据库连接池" class="headerlink" title="8. SpringBoot数据库连接池"></a>8. SpringBoot数据库连接池</h1><p>springboot2.x默认数据库连接池是Hikari</p><h1 id="9-SpringBoot日志框架"><a href="#9-SpringBoot日志框架" class="headerlink" title="9. SpringBoot日志框架"></a>9. SpringBoot日志框架</h1><p>在Spring Boot 中导入<code>spring-boot-starter-web</code>后，不需要单独引入SLF4J 和 Logback，可直接使用</p><h1 id="10-SpringBoot全局异常处理（重点）"><a href="#10-SpringBoot全局异常处理（重点）" class="headerlink" title="10. SpringBoot全局异常处理（重点）"></a>10. SpringBoot全局异常处理（重点）</h1><p>通常情况下我们用<code>try.....catch....</code>对异常进行捕捉处理，但是在实际项目中对业务模块进行异常捕捉，会造成代码重复和繁杂， 我们希望代码中只有业务相关的操作，所有的异常我们单独设立一个类来处理它</p><p>我们在可能发生异常的方法里<code>throw</code>抛给控制器。然后由全局异常处理器对异常进行统一处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SysIndexController</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 首页方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/index&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">index</span><span class="params">(ModelMap mmap)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 模拟用户未登录，抛出业务逻辑异常</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SysUser</span> <span class="variable">user</span> <span class="operator">=</span> ShiroUtils.getSysUser();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNull(user))</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LoginException</span>(<span class="string">&quot;用户未登录，无法访问请求。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">mmap.put(<span class="string">&quot;user&quot;</span>, user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-1-配置全局异常处理类"><a href="#10-1-配置全局异常处理类" class="headerlink" title="10.1. 配置全局异常处理类"></a>10.1. 配置全局异常处理类</h2><p>首先，我们需要新建一个类，在这个类上加上<code>@ControllerAdvice</code>或<code>@RestControllerAdvice</code>注解，这个类就配置成全局处理类了。（这个根据Controller层用的是<code>@Controller</code>还是<code>@RestController</code>来决定）</p><p>然后在类中新建方法，在方法上加上<code>@ExceptionHandler</code>注解并指定你想处理的异常类型，接着在方法内编写对该异常的操作逻辑，就完成了对该异常的全局处理</p><p><code>@ExceptionHandler</code>注解用于捕获在Spring Boot的Controller 层抛出的异常（如果已经编写了 <code>try-catch</code> 且在 catch 模块中没有使用 throw 抛出异常， 则 <code>@RestControllerAdvice</code> 捕获不到异常）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleAppException</span><span class="params">(BaseException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">return</span> Result.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> &#123;</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">      <span class="keyword">return</span> Result.error(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种异常处理方式下，会给所有或者指定的 Controller 织入异常处理的逻辑（AOP），当 Controller 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理</p><p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常</p><h2 id="10-2-自定义异常"><a href="#10-2-自定义异常" class="headerlink" title="10.2. 自定义异常"></a>10.2. 自定义异常</h2><ul><li>项目开发中经常是很多人负责不同的模块，使用自定义异常可以统一对外异常展示的方式。</li><li>自定义异常语义更加清晰明了，一看就知道是项目中手动抛出的异常</li></ul><p>先写一个自定义异常类，需要继承<code>RuntimeException</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Getter</span> <span class="comment">//只要getter方法，无需setter  </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">APIException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> code;  </span><br><span class="line">    <span class="keyword">private</span> String msg;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">APIException</span><span class="params">()</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1001</span>, <span class="string">&quot;接口错误&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">APIException</span><span class="params">(String msg)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>(<span class="number">1001</span>, msg);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">APIException</span><span class="params">(<span class="type">int</span> code, String msg)</span> &#123;  </span><br><span class="line">        <span class="built_in">super</span>(msg);  </span><br><span class="line">        <span class="built_in">this</span>.code = code;  </span><br><span class="line">        <span class="built_in">this</span>.msg = msg;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在全局异常处理类中加入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的全局异常  </span></span><br><span class="line">  <span class="meta">@ExceptionHandler(APIException.class)</span>  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">APIExceptionHandler</span><span class="params">(APIException e)</span> &#123;  </span><br><span class="line">      <span class="keyword">return</span> e.getMsg();  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当然还可以添加对<code>Exception</code>的处理，这样无论发生什么异常我们都能屏蔽掉然后响应数据给前端，不过建议最后项目上线时这样做，能够屏蔽掉错误信息暴露给前端，在开发中为了方便调试还是不要这样做</p><p><strong>无法捕获异常？</strong></p><p>可以从以下几个方面着手检查</p><ul><li>异常是否已被处理，即抛出异常后被catch</li><li>打印了日志或抛出了其它异常 </li><li>异常是否非Controller抛出，即在拦截器或过滤器中出现的异常</li></ul><h1 id="11-SpringBoot任务"><a href="#11-SpringBoot任务" class="headerlink" title="11. SpringBoot任务"></a>11. SpringBoot任务</h1><h2 id="11-1-异步任务"><a href="#11-1-异步任务" class="headerlink" title="11.1. 异步任务"></a>11.1. 异步任务</h2><p>在启动类上使用 <code>@EnableAsync</code> 开启异步功能</p><p>用<code>@Async</code>修饰方法，在执行时SpringBoot自动为其分配一个子线程实现异步执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsynService</span> &#123;</span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-定时任务"><a href="#11-2-定时任务" class="headerlink" title="11.2. 定时任务"></a>11.2. 定时任务</h2><p>在启动类上使用<code>@EnableScheduling</code>（spring提供） 开启定时功能 </p><p>用<code>@Scheduled</code>（spring提供）修饰方法，<code>@Scheduled</code>注解提供有多个属性，精细化配置定时任务执行规则，常用的属性有cron（cron表达式，设置定时任务触发的时间）、zone（指定cron表达式将被解析的时区。默认情况下，该属性是空字符串即使用服务器的本地时区）</p><p>注：中国地区服务器的时区通常默认为Asia/Shanghai</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScheduledTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span>  <span class="comment">// cron语法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-邮件任务"><a href="#11-3-邮件任务" class="headerlink" title="11.3. 邮件任务"></a>11.3. 邮件任务</h2><p>导入依赖 pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置 application.yml</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">mail:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">邮箱</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">密钥</span></span><br><span class="line">    <span class="comment"># 开启加密验证</span></span><br><span class="line">    <span class="attr">properties.mail.smtl.ssl.enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#邮件服务超时时间配置</span></span><br><span class="line"><span class="attr">properties.mail.smtp.connectiontime:</span> <span class="number">5000</span></span><br><span class="line"><span class="attr">properties.mail.smtp.timeout:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">properties.mail.smtp.writetimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure><p>实现纯文本邮件发送 SimpleMailMessage</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MailService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSenderImpl mailSender;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleMail</span><span class="params">(String to, String subject, String content)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMailMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMailMessage</span>();</span><br><span class="line">        message.setTo(to);</span><br><span class="line">        message.setSubject(subject);</span><br><span class="line">        message.setText(content);</span><br><span class="line">        mailSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现带附件和图片邮件发送 MimeMessage</p><h1 id="12-SpringBoot项目部署"><a href="#12-SpringBoot项目部署" class="headerlink" title="12. SpringBoot项目部署"></a>12. SpringBoot项目部署</h1><h2 id="12-1-SpringBoot项目打包"><a href="#12-1-SpringBoot项目打包" class="headerlink" title="12.1. SpringBoot项目打包"></a>12.1. SpringBoot项目打包</h2><p>对于使用 Maven 打包产生的项目产物，在不同的情况下会有不同需求，如：</p><ol><li>将所有代码相关文件打包为 jar 包，使用命令直接执行文件即可启动服务</li><li>文件和依赖分开，分为 jar 包和 /lib 下的依赖包信息，避免 jar 过大传输速度太慢</li><li>配置文件剥离，可以动态修改配置，分为 jar、/lib、.proerties 三个文件</li></ol><h3 id="12-1-1-默认完整打包版"><a href="#12-1-1-默认完整打包版" class="headerlink" title="12.1.1. 默认完整打包版"></a>12.1.1. 默认完整打包版</h3><p>项目完整Jar包，包括相关依赖信息，可以直接执行</p><p>SpringBoot 项目使用 Maven 打包后的 Jar 包产物命名方式是由项目的 pom.xml 文件定义的，其中的项目 id 和版本信息共同组成打包文件名称 <code>$&#123;artifactId&#125;-$&#123;version&#125;.jar</code></p><p>要自定义生成的文件名，可以在 pom.xml 的 build 标签中使用 finalName 标签自定义生成 jar 包名称</p><h3 id="12-1-2-依赖文件外置版"><a href="#12-1-2-依赖文件外置版" class="headerlink" title="12.1.2. 依赖文件外置版"></a>12.1.2. 依赖文件外置版</h3><p>若项目的依赖 jar 包比较多但是改动较少，在打包项目时就需要将三方依赖和当前项目分离开来，代码改变时只需要重新打包项目内容即可</p><p>SpringBoot 默认的配置并不能实现依赖项外置，需要借助 Maven 的 <code>maven-jar-plugin</code> 插件和 <code>maven-dependency-plugin</code> 插件完成。</p><p><code>maven-jar-plugin</code> 插件用来配置当前项目 jar 包的配置，如三方依赖引用的路径信息、启动类等。</p><p><code>maven-dependency-plugin</code> 插件则用来配置将项目的三方依赖放置在指定目录下，并配合 <code>maven-jar-plugin</code> 完成项目启动时的依赖</p><p>在 pom.xml 中添加以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将自己的项目代码打包成jar文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">addClasspath</span>&gt;</span>true<span class="tag">&lt;/<span class="name">addClasspath</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定包含的依赖文件位置 --&gt;</span>                        <span class="tag">&lt;<span class="name">classpathPrefix</span>&gt;</span>lib/<span class="tag">&lt;/<span class="name">classpathPrefix</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定启动类--&gt;</span>                        <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>com.domoment.leaves.LeavesApplication<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将依赖的jar文件全部放到lib目录下，会创建 lib 目录，将第三方依赖赋值到 lib 目录下 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>prepare-package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/lib<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteReleases</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteReleases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteSnapshots</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteSnapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">overWriteIfNewer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWriteIfNewer</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="12-1-3-配置文件外置版"><a href="#12-1-3-配置文件外置版" class="headerlink" title="12.1.3. 配置文件外置版"></a>12.1.3. 配置文件外置版</h3><p>若只是需要改动配置文件，而不需要修改源代码，配置文件放在 jar 文件外，会更方便。</p><p>此时可以在打包时将配置文件等内容移出产物 jar 包，并采用资源配置将配置文件复制到产物指定路径下。</p><p>在 pom.xml 中添加以下配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 把配置文件放到根目录和 jar 在一起 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 具体的脚本放置位置可以改，不一定是当前目录 . 代表当前目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>repackage<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>exec<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-resources-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用于生成jar包的plugin --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--将配置文件排除掉，不打包到jar文件内--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*.yml<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>*.conf<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;resources&gt;</code> 标签配置指定资源操作</p><p><code>spring-boot-maven-plugin</code> 配置打包同时输出 demo.jar 单文件和 demo-exec.jar 整合依赖的文件，可以选择使用</p><p><code>maven-jar-plugin</code> 插件中可以设置打包时 jar 包中排除指定的配置文件类型</p><h2 id="12-2-SpringBoot项目部署到服务器"><a href="#12-2-SpringBoot项目部署到服务器" class="headerlink" title="12.2. SpringBoot项目部署到服务器"></a>12.2. SpringBoot项目部署到服务器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar shop-0.0.1-SNAPSHOT.jar &gt; logName.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>注：nohup命令：不挂起，即关闭终端，程序继续运行</p><h2 id="12-3-SpringBoot项目部署配置项"><a href="#12-3-SpringBoot项目部署配置项" class="headerlink" title="12.3. SpringBoot项目部署配置项"></a>12.3. SpringBoot项目部署配置项</h2><p>在yml 配置文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 开发环境配置  </span><br><span class="line">server:  </span><br><span class="line">  # 服务器的HTTP端口，默认为8080  </span><br><span class="line">  port: 8001  </span><br><span class="line">  servlet:  </span><br><span class="line">    # 应用的访问路径  </span><br><span class="line">    context-path: /  </span><br><span class="line">  tomcat:  </span><br><span class="line">    # tomcat的URI编码  </span><br><span class="line">    uri-encoding: UTF-8  </span><br><span class="line">    # 连接数满后的排队数，默认为100  </span><br><span class="line">    accept-count: 1000  </span><br><span class="line">    threads:  </span><br><span class="line">      # tomcat最大线程数，默认为200  </span><br><span class="line">      max: 800  </span><br><span class="line">      # Tomcat启动初始化的线程数，默认值10  </span><br><span class="line">      min-spare: 100</span><br></pre></td></tr></table></figure><h2 id="12-4-SpringBoot项目定制banner"><a href="#12-4-SpringBoot项目定制banner" class="headerlink" title="12.4. SpringBoot项目定制banner"></a>12.4. SpringBoot项目定制banner</h2><p>创建banner.txt 放在 resources目录下</p><h1 id="13-计算代码执行时间"><a href="#13-计算代码执行时间" class="headerlink" title="13. 计算代码执行时间"></a>13. 计算代码执行时间</h1><p>Spring 或 Spring Boot 项目，可以在项目中直接使用 <code>StopWatch</code> 对象来统计代码执行时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StopWatch</span> <span class="variable">stopWatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StopWatch</span>();</span><br><span class="line"><span class="comment">// 开始时间</span></span><br><span class="line">stopWatch.start();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">代码块</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结束时间</span></span><br><span class="line">stopWatch.stop();</span><br><span class="line"><span class="comment">// 统计执行时间（秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 秒.%n&quot;</span>, stopWatch.getTotalTimeSeconds()); <span class="comment">// %n 为换行</span></span><br><span class="line"><span class="comment">// 统计执行时间（毫秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 毫秒.%n&quot;</span>, stopWatch.getTotalTimeMillis()); </span><br><span class="line"><span class="comment">// 统计执行时间（纳秒）</span></span><br><span class="line">System.out.printf(<span class="string">&quot;执行时长：%d 纳秒.%n&quot;</span>, stopWatch.getTotalTimeNanos());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-04-%E8%AE%BA%E5%A0%86&amp;%E6%A0%88/"/>
      <url>/2024/10/28/2023-01-04-%E8%AE%BA%E5%A0%86&amp;%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>堆（Heap）与栈（Stack）不同场景下，堆与栈代表不同的含义。一般情况下，有两层含义：</p><ul><li>程序内存布局场景下，堆与栈表示两种内存管理方式；</li><li>数据结构场景下，栈是一种先进后出的数据结构，堆则是一种排序方式</li></ul><h1 id="2-内存分配方式"><a href="#2-内存分配方式" class="headerlink" title="2. 内存分配方式"></a>2. 内存分配方式</h1><p>以C语言的内存管理（代码段、数据段，栈，堆）为例</p><p><img src="F:\笔记\博客\文章图片\e021bbbe94aa466da471e1eb14eedd2d.png" alt="e021bbbe94aa466da471e1eb14eedd2d"></p><div class="table-container"><table><thead><tr><th>段名</th><th>内容</th></tr></thead><tbody><tr><td>代码段</td><td>用于存放程序的二进制代码的空间</td></tr><tr><td>数据段</td><td>常量、已初始化全局变量、已初始化全局静态变量、局部静态变量</td></tr><tr><td>栈</td><td>由编译器自动分配释放，存放函数的参数值，局部变量等值。注：其操作方式类似于数据结构中的栈</td></tr><tr><td>堆</td><td>由程序员分配释放，若程序员不释放，则可能会引起内存泄漏。注：堆和数据结构中的堆不一样</td></tr></tbody></table></div><h2 id="2-1-栈简介"><a href="#2-1-栈简介" class="headerlink" title="2.1. 栈简介"></a>2.1. 栈简介</h2><p>栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。</p><p>函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量。</p><p>栈中存储的数据的生命周期随着函数的执行完成而结束。</p><h2 id="2-2-堆简介"><a href="#2-2-堆简介" class="headerlink" title="2.2. 堆简介"></a>2.2. 堆简介</h2><p>堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。</p><p>堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。</p><p>堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。</p><h1 id="3-数据结构中"><a href="#3-数据结构中" class="headerlink" title="3. 数据结构中"></a>3. 数据结构中</h1><h2 id="3-1-栈简介"><a href="#3-1-栈简介" class="headerlink" title="3.1. 栈简介"></a>3.1. 栈简介</h2><p>栈是一种运算受限的线性表，其限制是指只仅允许在表的一端进行插入和删除操作，这一端被称为栈顶（Top），相对地，把另一端称为栈底（Bottom）。把新元素放到栈顶元素的上面，使之成为新的栈顶元素称作进栈、入栈或压栈（Push）；把栈顶元素删除，使其相邻的元素成为新的栈顶元素称作出栈或退栈（Pop）。这种受限的运算使栈拥有“先进后出”的特性（First In Last Out），简称 FILO。</p><p>栈分顺序栈和链式栈两种。栈是一种线性结构，所以可以使用数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。使用数组实现的栈叫做顺序栈，使用链表实现的栈叫做链式栈，二者的区别是顺序栈中的元素地址连续，链式栈中的元素地址不连续。</p><h2 id="3-2-堆简介"><a href="#3-2-堆简介" class="headerlink" title="3.2. 堆简介"></a>3.2. 堆简介</h2><p>堆是一种常用的树形结构，是一种特殊的完全二叉树，当且仅当满足所有节点的值总是不大于或不小于其父节点的值的完全二叉树被称之为堆。堆的这一特性称之为堆序性。因此，在一个堆中，根节点是最大（或最小）节点。如果根节点最小，称之为小顶堆（或小根堆），如果根节点最大，称之为大顶堆（或大根堆）。堆的左右孩子没有大小的顺序。下面是一个小顶堆示例：</p><p>堆的存储一般都用数组来存储堆</p>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-02-MySQL%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%BC%8F%E5%AE%89%E8%A3%85/"/>
      <url>/2024/10/28/2023-01-02-MySQL%E5%8E%8B%E7%BC%A9%E5%8C%85%E5%BC%8F%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="1-step1"><a href="#1-step1" class="headerlink" title="1. step1"></a>1. step1</h1><p>解压缩。推荐使用压缩包版本，不要使用安装版</p><h1 id="2-step2"><a href="#2-step2" class="headerlink" title="2. step2"></a>2. step2</h1><p>配置my.ini文件</p><p>在你自己的安装路径下新建一个配置文件，文件名叫<code>my.ini</code>，然后把下面的配置代码复制到在<code>my.ini</code>（代码中的路径要改成自己的文件存放路径）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line">[mysqld]</span><br><span class="line">#设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=E:\mysql-5.7.29-winx64</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=E:\mysql-5.7.29-winx64\data</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=200</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"># binlog日志开启</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line"># binlog日志格式</span><br><span class="line">binlog-format=ROW</span><br><span class="line"># MySQL 5.7及以上数据库需要设置，否则报错</span><br><span class="line">server-id=123454</span><br></pre></td></tr></table></figure><h1 id="3-step3"><a href="#3-step3" class="headerlink" title="3. step3"></a>3. step3</h1><p>配置环境变量</p><p>以便在任何路径下都可以访问mysql服务</p><h1 id="4-step4"><a href="#4-step4" class="headerlink" title="4. step4"></a>4. step4</h1><p>进入bin目录下，以管理员身份打开 cmd</p><p><strong>首先进行初始化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --initialize --console</span><br></pre></td></tr></table></figure><p>记下初始密码，等下我们可以重置密码。</p><p><strong>注册为服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld install 服务名</span><br></pre></td></tr></table></figure><p><strong>启动mysql服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start 服务名</span><br></pre></td></tr></table></figure><p>注意：若无法启动，则操作如下</p><p><img src="F:\笔记\博客\文章图片\214adccf17574b7488826d714db22002.png" alt="img"></p><p><strong>登陆mysql</strong></p><p>登录本机的 MySQL 数据库，只需要输入以下命令即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p><strong>修改root用户的密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>以后想要使用mysql，以管理员身份打开cmd命令工具，输入<code>mysql -u root -p</code>，回车后再输入密码即可</p><p><strong>关闭mysql服务</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-11-Vue3%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/10/28/2023-01-11-Vue3%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Vue简介"><a href="#1-Vue简介" class="headerlink" title="1. Vue简介"></a>1. Vue简介</h1><p>Vue的核心组成</p><ul><li>数据绑定：Vue 提供了简单的语法来将数据绑定到 HTML 元素。这使得在 UI 中显示数据变得非常容易。</li><li>指令：Vue 提供了一系列指令来扩展 HTML 元素的功能。例如，可以使用 <code>v-if</code> 指令根据条件显示或隐藏元素。</li><li>组件：Vue 组件是自包含的 UI 元素，可以重用于不同的页面和应用程序。</li><li>路由：Vue 提供了一个路由系统，允许在单页面应用程序中导航到不同的页面。</li></ul><h1 id="2-Vue风格"><a href="#2-Vue风格" class="headerlink" title="2. Vue风格"></a>2. Vue风格</h1><p>Vue 的组件可以按两种不同的风格书写：<strong>选项式 API</strong> 和<strong>组合式 API</strong></p><p><strong>选项式</strong></p><p>函数、变量等数据，都会挂载到this上，是通过this去访问的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// data() 返回的属性将会成为响应式的状态</span></span><br><span class="line">  <span class="comment">// 并且暴露在 `this` 上</span></span><br><span class="line">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// methods 是一些用来更改状态与触发更新的函数</span></span><br><span class="line">  <span class="comment">// 它们可以在模板中作为事件处理器绑定</span></span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生命周期钩子会在组件生命周期的各个不同阶段被调用</span></span><br><span class="line">  <span class="comment">// 例如这个函数就会在组件挂载完成后被调用</span></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`The initial count is <span class="subst">$&#123;<span class="variable language_">this</span>.count&#125;</span>.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>组合式</strong></p><p>当你打算用 Vue 构建完整的单页应用，推荐采用组合式 API + 单文件组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineComponent</span>(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">NotifyMenu</span>, <span class="title class_">LinkList</span>, <span class="title class_">LoginCard</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> $q = <span class="title function_">useQuasar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginFormSwitch = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> leftDrawerOpen = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// loginFormSwitch.value = true</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">prompt</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateLoginSwitch</span>(<span class="params">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">      loginFormSwitch.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"></span><br><span class="line">      prompt,</span><br><span class="line"></span><br><span class="line">      updateLoginSwitch,</span><br><span class="line"></span><br><span class="line">      loginFormSwitch,</span><br><span class="line"></span><br><span class="line">      listLink,</span><br><span class="line"></span><br><span class="line">      showLogin,</span><br><span class="line"></span><br><span class="line">      leftDrawerOpen,</span><br><span class="line"></span><br><span class="line">      toggleLeftDrawer,</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>setup语法糖（推荐）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="title class_">NotifyMenu</span>, <span class="title class_">LinkList</span>, <span class="title class_">LoginCard</span> &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> $q = <span class="title function_">useQuasar</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginFormSwitch = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> leftDrawerOpen = <span class="title function_">ref</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">showLogin</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// loginFormSwitch.value = true</span></span><br><span class="line"></span><br><span class="line">      <span class="title function_">prompt</span>();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">updateLoginSwitch</span>(<span class="params">value</span>) &#123;</span><br><span class="line"></span><br><span class="line">      loginFormSwitch.<span class="property">value</span> = value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="3-定义变量"><a href="#3-定义变量" class="headerlink" title="3. 定义变量"></a>3. 定义变量</h1><p>在Vue 3中，创建<code>ref()</code>对象时，通常使用<code>const</code>或<code>let</code>，而不是<code>var</code>。</p><p>如果你创建的<code>ref()</code>对象的引用不会改变，那么应该使用<code>const</code>。这是最常见的情况，因为通常我们只需要改变<code>ref()</code>对象的<code>.value</code>属性，而不是<code>ref()</code>对象本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myRef = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// myRef will always point to the same ref object</span></span><br><span class="line"></span><br><span class="line">myRef.<span class="property">value</span> = <span class="number">1</span>; <span class="comment">// But we can change the value of the ref</span></span><br></pre></td></tr></table></figure><p>如果你需要在后面的代码中改变<code>ref()</code>对象的引用，那么应该使用<code>let</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myRef = <span class="title function_">ref</span>(<span class="number">0</span>); <span class="comment">// myRef points to a ref object</span></span><br><span class="line"></span><br><span class="line">myRef = <span class="title function_">ref</span>(<span class="number">1</span>); <span class="comment">// myRef now points to a different ref object</span></span><br></pre></td></tr></table></figure><p>避免使用<code>var</code>，因为它的作用域规则（函数级作用域和变量提升）可能会导致意外的行为。在现代JavaScript（包括Vue 3）开发中，<code>let</code>和<code>const</code>（它们都有块级作用域）是更好的选择。</p><h1 id="4-创建响应式状态"><a href="#4-创建响应式状态" class="headerlink" title="4. 创建响应式状态"></a>4. 创建响应式状态</h1><p>在Vue.js中，<code>reactive</code>和<code>ref</code>是用于创建响应式状态的两种不同方法。它们有一些关键的区别和使用场景。</p><h2 id="4-1-reactive"><a href="#4-1-reactive" class="headerlink" title="4.1. reactive"></a>4.1. <code>reactive</code></h2><p><code>reactive</code>用于将一个普通的对象转换为响应式对象。它会递归地将对象的所有属性都设为响应式属性。</p><p><strong>特点</strong>:</p><ul><li>适用于对象和数组。</li><li>自动深度响应式（对象内部的所有嵌套属性都会变成响应式）。</li><li>返回的对象仍然是一个普通的JavaScript对象，可以直接访问和操作。</li></ul><h2 id="4-2-ref"><a href="#4-2-ref" class="headerlink" title="4.2. ref"></a>4.2. <code>ref</code></h2><p><code>ref</code>用于创建一个包含单个值的响应式引用。它适用于基本类型（如字符串、数字、布尔值等）和对象。</p><p><strong>特点</strong>:</p><ul><li>适用于基本类型、对象、数组等。</li><li>对基本类型，<code>ref</code>会将值包裹在一个对象的<code>value</code>属性中。</li><li><p>对对象或数组，<code>ref</code>不会递归地将属性设为响应式，需要手动解包或通过<code>.value</code>访问。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3. 总结"></a>4.3. 总结</h2></li><li><p><code>reactive</code>更适合处理复杂的对象和数组，自动进行深度响应式处理。</p></li><li><code>ref</code>更灵活，适用于基本类型和需要单独引用的对象，可以通过<code>.value</code>访问和操作。</li></ul><h1 id="5-Vue数据绑定"><a href="#5-Vue数据绑定" class="headerlink" title="5. Vue数据绑定"></a>5. Vue数据绑定</h1><p>Vue.js 的数据绑定分为两种类型：单向绑定和双向绑定</p><h2 id="5-1-单向绑定"><a href="#5-1-单向绑定" class="headerlink" title="5.1. 单向绑定"></a>5.1. 单向绑定</h2><p>单向绑定用来绑定数据和属性以及表达式，可以给任何属性赋值，数据只能从data流向页面</p><p>这种绑定方式通过使用双大括号插值（Mustache语法）或<code>v-bind</code>指令来实现<code>v-bind</code>可以简写为 <code>:</code></p><p>使用双大括号插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用v-bind指令：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="5-2-双向绑定"><a href="#5-2-双向绑定" class="headerlink" title="5.2. 双向绑定"></a>5.2. 双向绑定</h2><p>双向绑定<code>v-model=&quot;&quot;</code>，只能给表单类，也就是具有value属性的元素进行数据双向绑定。双向绑定不仅可以将数据从组件的数据模型绑定到视图上，还可以将视图中的用户输入反向同步回数据模型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-3-计算属性（computed-properties）"><a href="#5-3-计算属性（computed-properties）" class="headerlink" title="5.3. 计算属性（computed properties）"></a>5.3. 计算属性（computed properties）</h2><p>计算属性是基于现有的数据属性计算出新值的属性。计算属性的结果会被缓存，只有在依赖的响应式数据发生变化时才会重新计算。计算属性可以像普通属性一样在模板中使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    fullName() &#123;</span><br><span class="line">        return this.firstName + &#x27; &#x27; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5-4-侦听器（watchers）"><a href="#5-4-侦听器（watchers）" class="headerlink" title="5.4. 侦听器（watchers）"></a>5.4. 侦听器（watchers）</h2><p>侦听器可以监听数据的变化，并在变化发生时执行相应的操作，比如发送网络请求或执行复杂的计算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">    firstName(newValue, oldValue) &#123;</span><br><span class="line">        // 在firstName发生变化时执行逻辑</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-Vue指令"><a href="#6-Vue指令" class="headerlink" title="6. Vue指令"></a>6. Vue指令</h1><p><strong>v-text</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 和下面的一样 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-bind</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imageSrc&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-model</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-if 和 v-else</strong><br>用于根据条件来渲染或销毁HTML元素。v-if指令根据条件的真假来决定是否渲染元素，而v-else指令则与v-if一起使用，用于渲染上一个兄弟元素中未被渲染的部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="line">    Content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    Alternative Content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-for</strong><br>用于循环渲染列表中的元素。可以将一个数组或对象遍历，并为每个元素生成对应的HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item.name &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-on</strong><br>用于监听DOM事件，并在触发事件时执行相应的方法。可以绑定多个事件监听器，以及传递事件参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleClick&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-show</strong></p><p>与v-if类似，也用于根据条件来显示或隐藏HTML元素。不同之处在于，v-show只是通过修改元素的样式来控制元素的显示与隐藏，而不是将元素从DOM中添加或移除。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">&quot;isVisible&quot;</span>&gt;</span></span><br><span class="line">    Content</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>v-html</strong> </p><p>用于将数据作为 HTML 解析并渲染到元素中。通过 <code>v-html</code>，您可以动态地将包含 HTML 结构的字符串绑定到元素的内容。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;htmlString&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>由于 <code>v-html</code> 涉及将字符串解析为 HTML，因此需要谨慎使用。使用不受信任的数据或用户输入作为 <code>htmlString</code> 可能导致 XSS（跨站脚本攻击）漏洞。确保在使用 <code>v-html</code> 时对数据进行适当的验证和过滤，以防止安全问题。</p><p><strong>使用JavaScript表达式</strong></p><p>使用双大括号插值来嵌入 JavaScript 表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; 2 + 2 &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&#123;&#123; 2 + 2 &#125;&#125;</code> 会被渲染为 4</p><p>在模板中执行更复杂的 JavaScript 表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7-Vue修饰符"><a href="#7-Vue修饰符" class="headerlink" title="7. Vue修饰符"></a>7. Vue修饰符</h1><p>修饰符，用于指出一个指令应该以特殊方式绑定</p><p><strong><code>.number</code></strong></p><p>如果想自动将用户的输入值转为 Number 类型，可以添加一个修饰符 number 给 v-model 来处理输入值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><code>.trim</code></strong></p><p>如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;msg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-过滤器"><a href="#8-过滤器" class="headerlink" title="8. 过滤器"></a>8. 过滤器</h1><p>Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示</p><h1 id="9-Vue-组件"><a href="#9-Vue-组件" class="headerlink" title="9. Vue 组件"></a>9. Vue 组件</h1><p>在 Vue 中，一个组件由模板、脚本和样式组成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">title</span>: <span class="string">&#x27;My Component&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello, Vue!&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">count</span>: <span class="number">0</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">count</span>++;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">h1</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="9-1-组件的分类"><a href="#9-1-组件的分类" class="headerlink" title="9.1. 组件的分类"></a>9.1. 组件的分类</h2><p><strong>根组件（App.vue）</strong></p><p>组件之间可相互嵌套，自定义组件一般都在App.vue组件中调用</p><p><strong>动态组件（Dynamic Components）</strong></p><p>动态组件是根据某个条件或事件，在运行时动态选择渲染的组件。Vue 提供了 <code>&lt;component&gt;</code> 元素来实现动态组件的渲染，可以根据不同的情况渲染不同的组件</p><p><strong>单文件组件（Single File Components）</strong></p><p>单文件组件是将组件的模板、脚本和样式都放在一个单独的文件中进行定义的组件。这种方式可以提高代码的可维护性，并且使组件的结构更加清晰。</p><p><strong>全局组件（Global Components）</strong></p><p>全局组件是在 Vue 实例中全局注册的组件，可以在应用程序的任何地方使用。全局组件在整个应用程序中都是可用的，适用于多个页面或组件之间的共享。</p><h2 id="9-2-生命周期钩子"><a href="#9-2-生命周期钩子" class="headerlink" title="9.2. 生命周期钩子"></a>9.2. 生命周期钩子</h2><ul><li>beforeCreate( 创建前 )</li><li>created ( 创建后 ）</li><li>beforeMount（挂载开始之前被调用）</li><li>mounted（挂载完成）</li><li>beforeUpdate（数据更新之前被调用）</li><li>updated(数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用)</li><li>beforeDestroy（我们将要销毁整个页面或实例时调用）</li><li>destroyed（我们的整个页面或实例被销毁之后调用）</li><li>activated（被 keep-alive 缓存的组件激活时调用）</li><li>deactivated（子可以看做是beforeDestory和destoryed的替代）</li></ul><h2 id="9-3-组件通信"><a href="#9-3-组件通信" class="headerlink" title="9.3. 组件通信"></a>9.3. 组件通信</h2><p>组件之间可以通过属性传递数据（props）、事件触发与监听（emit/listen）</p><p><strong>父组件向子组件传递数据</strong></p><p>父子组件是一种层级关系，其中一个组件（父组件）内部使用了另一个组件（子组件）</p><p>父组件通过子组件的props选项将数据传递给子组件</p><p>父组件<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ParentComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ChildComponent</span> <span class="attr">:message</span>=<span class="string">&quot;parentMessage&quot;</span> @<span class="attr">update</span>=<span class="string">&quot;handleUpdate&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">ChildComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./ChildComponent.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title class_">ChildComponent</span></span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">parentMessage</span>: <span class="string">&#x27;Hello from parent!&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">handleUpdate</span>(<span class="params">message</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(message); <span class="comment">// Output: &quot;Hello from child!&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><br>子组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ChildComponent.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;updateParent&quot;</span>&gt;</span>Send Message to Parent<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&#x27;message&#x27;</span>],</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">updateParent</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;Hello from child!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>子组件向父组件传递数据</strong></p><p>子组件主要通过事件传递数据给父组件</p><p>Vue 组件实例可以使用 <code>$emit</code> 方法触发自定义事件，其他组件可以使用 <code>$on</code> 方法监听这些自定义事件。这种方式适用于非父子组件之间的通信，组件之间可以通过自定义事件进行消息传递。</p><p>A组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ComponentA.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sendMessage&quot;</span>&gt;</span>Send Message<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">sendMessage</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.$emit(<span class="string">&#x27;custom-event&#x27;</span>, <span class="string">&#x27;Hello from Component A!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>B组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ComponentB.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">message</span>: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">this</span>.$on(<span class="string">&#x27;custom-event&#x27;</span>, <span class="function">(<span class="params">message</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">this</span>.<span class="property">message</span> = message; <span class="comment">// Update message when custom event is triggered</span></span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-12-IDEA%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/28/2023-01-12-IDEA%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-IDEA版本"><a href="#1-IDEA版本" class="headerlink" title="1. IDEA版本"></a>1. IDEA版本</h1><p>建议使用专业版，且使用大版本的最后一个更新版，如 2022.3.x</p><p>下载zip格式的，解压即用无需安装</p><h1 id="2-初始化配置"><a href="#2-初始化配置" class="headerlink" title="2. 初始化配置"></a>2. 初始化配置</h1><p>将项目都关闭后，在idea的初始界面进行配置，这样是全局的配置，对每个项目都生效的</p><h2 id="2-1-强制配置"><a href="#2-1-强制配置" class="headerlink" title="2.1. 强制配置"></a>2.1. 强制配置</h2><ul><li>IDEA中的text file encoding设置为UTF- 8，with no bom，transparent  to ascii 都勾选</li><li>IDEA中文件的换行符使用Unix格式，不要使用Windows格式</li><li>IDEA设置tab为 4 个空格，请勿勾选Use tab character</li></ul><h2 id="2-2-建议配置"><a href="#2-2-建议配置" class="headerlink" title="2.2. 建议配置"></a>2.2. 建议配置</h2><ul><li>字体设置<code>consolas</code></li><li>方法间加横线<code>editor-&gt;general-&gt;appearance-&gt; 选show method separators</code></li><li>代码提示不区分大小写<code>editor-&gt;general-&gt;code completion-&gt; 选all letters</code></li><li>自动导包功能及相关优化功能<code>Settings -&gt; Editor -&gt; General -&gt; Auto Import</code></li></ul><p><code>Add UNambiguous imports on the fly</code>选项：IDEA 将在书写代码的时候自动帮我们导入需要用到的包。但是对于那些同名的包，还是需要手动 Alt + Enter 进行导入</p><p><code>Optimize imports on the fly</code>选项：IDEA 将在我们书写代码的时候自动帮我们优化导入的包，比如自动去掉一些没有用到的包</p><ul><li>CTRL + 滑动滚轮 调整窗口显示大小</li></ul><p><code>Settings -&gt; Editor -&gt; General -&gt; Change font size (Zoom) with Ctrl+Mouse wheel</code></p><ul><li>代码编辑区显示行号</li></ul><p><code>Settings -&gt; Editor -&gt; General -&gt; Appearance</code> 勾选 <code>Show Line Numbers</code></p><h1 id="3-快捷键"><a href="#3-快捷键" class="headerlink" title="3. 快捷键"></a>3. 快捷键</h1><h2 id="3-1-模板相关"><a href="#3-1-模板相关" class="headerlink" title="3.1. 模板相关"></a>3.1. 模板相关</h2><p>idea里面提供了两套模板Live Templates和Postfix Completion。Live Templates 可以自定义，而 Postfix Completion 不可以。Postfix Completion的功能：快速生成语句，如 sout生成<code>System.out.println()</code></p><h3 id="3-1-1-Postfix-Completion"><a href="#3-1-1-Postfix-Completion" class="headerlink" title="3.1.1. Postfix Completion"></a>3.1.1. Postfix Completion</h3><p>具体可查看<code>editor-&gt;general-&gt;Postfix Completion</code></p><h3 id="3-1-2-File-and-Code-Template"><a href="#3-1-2-File-and-Code-Template" class="headerlink" title="3.1.2. File and Code Template"></a>3.1.2. File and Code Template</h3><p><strong>文件代码模板</strong></p><p><code>Settings -&gt; Editor -&gt; File and Code Template</code></p><p>当你选择某个文件生成时，就会按照这里面的模板生成指定的代码文件</p><h3 id="3-1-3-Live-Templates"><a href="#3-1-3-Live-Templates" class="headerlink" title="3.1.3. Live Templates"></a>3.1.3. Live Templates</h3><p><strong>定制代码模板</strong></p><p><code>Settings -&gt; Editor -&gt; Live Templates</code> 可以按照自己的使用习惯来定制相关的代码模板</p><h2 id="3-2-其他操作"><a href="#3-2-其他操作" class="headerlink" title="3.2. 其他操作"></a>3.2. 其他操作</h2><p><strong>快速生成标准类</strong></p><p><code>右键 generate --&gt; getter、setter</code></p><p><strong>获取完整包路径</strong></p><p><code>项目结构中的文件处，右键 copypath</code></p><p><strong>查看pom.xml依赖树</strong></p><p>在<code>pom.xml</code>中右键<code>diagrams--&gt;show dependency</code></p><p><strong>生成JavaDoc文档</strong></p><p><code>打开idea上方工具（Tools) 生成JavaDoc文档（Generate JavaDoc...）</code></p><p>注意 设置编码，防止中文乱码</p><p><strong>生成构造方法</strong></p><p><code>右键 generate --&gt; constructor</code></p><p><strong>重命名变量</strong>（可以一键全部替换）shift+alt+r</p><p><strong>Ctrl + 鼠标滚轮设置字体大小</strong>，按住Ctrl + Shift + A调出搜索框，调出搜索框后搜索关键词 <code>mouse</code> ，设置鼠标相关设置，选择<code>Change font size with Ctrl + Mouse Wheel</code></p><h2 id="3-3-查找"><a href="#3-3-查找" class="headerlink" title="3.3. 查找"></a>3.3. 查找</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>在当前文件进行文本查找</td></tr><tr><td>Ctrl + R</td><td>在当前文件进行文本替换</td></tr><tr><td>Shift + Ctrl + F</td><td>在项目进行文本查找</td></tr><tr><td>Shift + Ctrl + R</td><td>在项目进行文本替换</td></tr><tr><td>Shift + Shift</td><td>快速搜索</td></tr><tr><td>Ctrl + b</td><td>查看方法对应的源代码</td></tr></tbody></table></div><h2 id="3-4-跳转切换"><a href="#3-4-跳转切换" class="headerlink" title="3.4. 跳转切换"></a>3.4. 跳转切换</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + Tab</td><td>切换文件</td></tr><tr><td>Ctrl + Alt + ←/→</td><td>跳转历史光标所在处</td></tr><tr><td>Alt + ←/→ 方向键</td><td>切换子tab</td></tr><tr><td>Ctrl + G</td><td>go to（跳转指定行号）</td></tr></tbody></table></div><h2 id="3-5-编码相关"><a href="#3-5-编码相关" class="headerlink" title="3.5. 编码相关"></a>3.5. 编码相关</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + <code>/</code></td><td>生成注释</td></tr><tr><td>Ctrl + Y</td><td>删除整行</td></tr><tr><td>Ctrl + Z 、Ctrl + Shift + Z</td><td>后悔药，撤销、取消撤销</td></tr><tr><td>Alt + enter</td><td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同</td></tr><tr><td>Alt + ↑/↓</td><td>方法快速跳转</td></tr><tr><td>F2</td><td>跳转到下一个高亮错误 或 警告位置</td></tr><tr><td>Alt + Insert</td><td>代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等</td></tr><tr><td>Ctrl + Shift+Alt + L</td><td>格式化代码</td></tr><tr><td>Shift + F6</td><td>快速修改方法名、变量名、文件名、类名等</td></tr><tr><td>Ctrl + F6</td><td>快速修改方法签名</td></tr><tr><td>Ctrl + shift + u</td><td>字母转大写或小写</td></tr></tbody></table></div><h2 id="3-6-代码阅读相关"><a href="#3-6-代码阅读相关" class="headerlink" title="3.6. 代码阅读相关"></a>3.6. 代码阅读相关</h2><div class="table-container"><table><thead><tr><th>快捷键</th><th>介绍</th></tr></thead><tbody><tr><td>Ctrl + P</td><td>方法参数提示显示</td></tr><tr><td>Ctrl + Shift + i</td><td>就可以在当前类里再弹出一个窗口出来</td></tr><tr><td>Alt + F7</td><td>可以列出变量在哪些地方被使用了</td></tr><tr><td>光标在子类接口名，Ctrl + u</td><td>跳到父类接口</td></tr><tr><td>Ctrl + (Alt) + B</td><td>跳转方法定义/实现</td></tr><tr><td>Ctrl + H</td><td>类的层级关系</td></tr><tr><td>Ctrl + F12</td><td>Show Members 类成员快速显示</td></tr></tbody></table></div><h1 id="4-插件推荐"><a href="#4-插件推荐" class="headerlink" title="4. 插件推荐"></a>4. 插件推荐</h1><p><strong>Alibaba Java Coding Guidelines​​</strong>：阿里巴巴 Java 代码规范</p><p><strong>Rainbow Brackets</strong>：彩虹括号，代码层级变得更加清晰</p><p><strong>CodeGlance</strong>：代码微型地图</p><p><strong>jclasslib</strong>：一款IDEA字节码查看神器</p><p><strong>SequenceDiagram</strong>：一键可以生成时序图</p><p><strong>EasyCode</strong>：可以直接对数据的表生成 entity、controller、service、dao、mapper 无需任何编码</p><p><strong>maven helper</strong>：maven 依赖管理助手 ，解析maven pom结构，分析冲突</p><p><strong>MyBatis Log Plugin</strong>：把 Mybatis 输出的sql日志还原成完整的sql语句，看起来更直观</p><p><strong>String Manipulation</strong>：String相关辅助简化，搭配 CTRL+W 、ALT+J等文本选择快捷键使用</p><p><strong>Visual Studio Code Dark Plus Theme</strong>：一款VSCode风格的主题</p><p><strong>One Dark</strong>：一款优雅暗色风格主题</p><p><strong>Background Image Plus</strong>: 背景图片</p><p><strong>Statistic</strong>：可以非常直观地看到你的项目中所有类型的文件的信息比如数量、大小</p><p><strong>Key Promoter X</strong>：当在 IDE 内部的按钮上使用鼠标时，Key Promoter X 会显示您应该使用的键盘快捷键，有助于过渡到更快的无鼠标开发</p><p><strong>Save Actions</strong>：可以帮助我们在保存文件的时候：优化导入；格式化代码</p><p><strong>Free MyBatis tool</strong></p><ul><li>生成mapper xml文件</li><li>快速从代码跳转到mapper及从mapper返回代码</li><li>mybatis自动补全及语法错误提示</li><li>集成mybatis generator gui界面</li></ul><p><strong>GsonFormatPlus</strong></p><p>根据JSONObject格式的字符串,自动生成实体类参数</p><p><strong>.ignore</strong></p><p>这个插件方便我们在使用版本管理时对一些不想要上传的文件进行管理</p><p><strong>sonarLint</strong></p><p>代码规范性检查</p><p><strong>easy Javadoc</strong></p><p>快速生成类、方法、字段 的注释</p><p><strong>Squaretest</strong></p><p>自动生成单元测试代码，在选中类右键<code>Generate -&gt; Generate Test</code> 后，不光能生成测试类和方法，甚至连Mockito 数据、方法和 Assertions 等都写好了，只需要自己改一改即可。</p><p><strong>diffblue</strong> </p><p>单元测试生成插件</p><h1 id="5-IDEA中使用Git"><a href="#5-IDEA中使用Git" class="headerlink" title="5. IDEA中使用Git"></a>5. IDEA中使用Git</h1><p>克隆、提交、推送、分支、冲突解决、历史查看、版本回退、版本对比</p><p><strong>在IEDA里配置git执行程序的路径</strong></p><p><code>【File】→ 【Settings】→ 【Vwesion Control】→ 【Git】</code>，选择git可执行文件的路径（正确配置的情况下，点击Test会弹出git版本的提示）</p><p><strong>使用IDEA中的Git工具从远程仓库克隆项目</strong></p><p>打开IDEA，选择菜单上的 VCS（版本控制工具），选择【Checkout from Version Control】→【Git】</p><p><strong>添加文件到暂存区</strong></p><p>我们在项目里每添加一个文件，IDEA就会询问我们是否将文件添加到Git，选择【Add】将文件添加进git暂存区，此时git就可以对其文件进行追踪</p><p><strong>提交到本地仓库</strong></p><p>完成代码的开发后，需要将修改和添加的代码或文件提交到本地仓库上（文件已添加至暂存区，受git追踪），选择【VCS】→ 【Commit】</p><p><strong>推送到远程仓库</strong></p><p>把代码推送到远程服务器上，点击项目右键 →【Git】→【 Repositry 】→【Push】</p><p><strong>分支开发（重点掌握）</strong></p><p>假如，现在项目开发完成，需发布1.0版本，然后添加一个1.0的分支</p><ul><li>打开git分支的面板，点击【New Branch】</li><li>输入分支名称，点击【OK】，创建了1.0的分支</li><li>然后切换回主干分支master，进行2.0版本的开发</li></ul><p><strong>分支合并</strong></p><ul><li>在1.0分支上完成BUG修改后，将主分支（master分支）与1.0分支进行合并。需要先切换到master分支，然后进行操作</li><li>选择合并的分支（remote/orgin/1.0-提交到远程服务器上的1.0版本），填写合并的消息，点击【Merge】</li><li>合并后，就把 master分支推上服务器。然后再从 mater 中创建2.0分支，那么 master 就是3.0版本了</li></ul><p><strong>冲突解决</strong></p><p>冲突的场景</p><ul><li>多个分支合并的时候</li><li>在一个分支上拉取或推送远程文件时</li></ul><p><strong>提交历史记录查看</strong></p><p>查看文件或项目提交的历史记录：点击文件右键菜单 → 【Git】→ 【Show History】</p><p><strong>回退上一个版本</strong></p><p>打开文件的历史提交记录（在上边的第10点），选择回退的版本 → 【Get】</p><h1 id="6-Debug（重点）"><a href="#6-Debug（重点）" class="headerlink" title="6. Debug（重点）"></a>6. Debug（重点）</h1><p>重点：在断点调试过程中，是运行状态，对象是运行类型，不是编译类型</p><h2 id="6-1-什么是断点调试"><a href="#6-1-什么是断点调试" class="headerlink" title="6.1. 什么是断点调试"></a>6.1. 什么是断点调试</h2><p>断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个Bug</p><h2 id="6-2-断点调试快捷键"><a href="#6-2-断点调试快捷键" class="headerlink" title="6.2. 断点调试快捷键"></a>6.2. 断点调试快捷键</h2><p>idea支持debug过程中动态设置断点</p><ul><li>F7：跳入方法内（alt + shift + F7 强制进入JDK源码）</li><li>F8：逐行执行代码</li><li>shift + F8：跳出方法</li><li>F9：执行到下一个断点</li></ul><h1 id="7-自动格式化代码"><a href="#7-自动格式化代码" class="headerlink" title="7. 自动格式化代码"></a>7. 自动格式化代码</h1><p>安装 google-java-format插件 + Save Actions 插件</p><p>重启idea</p><p>启用google-java-format，<code>other setting -&gt; google-java-format -&gt; 勾选 enable Google-Java-format</code></p><p>启用Save Actions，<code>other setting -&gt; Save Actions -&gt; 勾选 active save action on save、勾选organize import、勾选reformat file</code></p><h1 id="8-当关闭IDEA时，提示“Closing-project”"><a href="#8-当关闭IDEA时，提示“Closing-project”" class="headerlink" title="8. 当关闭IDEA时，提示“Closing project”"></a>8. 当关闭IDEA时，提示“Closing project”</h1><p><code>菜单 -&gt; Help -&gt; Find Action -&gt; 输入“Registry” -&gt; 在提示结果点击“Registry..”</code> </p><p>去掉<code>“ide.await.scope.completion”</code>的勾选</p>]]></content>
      
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-07-Maven/"/>
      <url>/2024/10/28/2023-01-07-Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Maven简介"><a href="#1-Maven简介" class="headerlink" title="1. Maven简介"></a>1. Maven简介</h1><p>Maven是一个项目管理工具，可以对Java项目进行自动化的构建和依赖管理。</p><p><img src="F:\笔记\博客\文章图片\QQ截图20230107090232.png" alt="QQ截图20230107090232"></p><h2 id="1-1-Maven作用"><a href="#1-1-Maven作用" class="headerlink" title="1.1. Maven作用"></a>1.1. Maven作用</h2><p><strong>项目构建</strong>：提供标准的，跨平台的自动化构建项目的方式</p><p><strong>依赖管理</strong>：方便快捷的管理项目依赖的资源（jar包），避免资源间的版本冲突等问题</p><p><strong>统一开发结构</strong>：提供标准的，统一的项目开发结构，如图</p><p><img src="F:\笔记\博客\文章图片\QQ截图20230107090429.png" alt="QQ截图20230107090429"></p><p>下载地址（版本需不低于3.6）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://maven.apache.org/download.cgi</span><br></pre></td></tr></table></figure><p>下载后解压的目录对应的含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bin目录：maven的运行文件。mvn.cmd正常运行mvn，mvnDebug.cmd已debug方式运行maven。  </span><br><span class="line">boot目录：maven运行需要类加载器。  </span><br><span class="line">conf目录：maven的配置文件目录，核心配置文件为其中的setting.xml。  </span><br><span class="line">lib目录：maven所需要的jar包。</span><br></pre></td></tr></table></figure><h2 id="1-2-Maven仓库"><a href="#1-2-Maven仓库" class="headerlink" title="1.2. Maven仓库"></a>1.2. Maven仓库</h2><p><a href="https://mvnrepository.com/">https://mvnrepository.com/</a></p><p>运行Maven的时候，Maven 所需要的任何构件都是直接从本地仓库获取的。如果本地仓库没有，它会首先尝试从远程仓库下载构件至本地仓库。</p><p><strong>本地仓库</strong></p><p>默认位置是用户目录下的<code>.m2</code>文件夹</p><p>修改maven安装包中的<code>conf/settings.xml</code>文件，指定本地仓库位置。位于localRepository字段处</p><p><strong>远程仓库</strong></p><p>maven默认连接的远程仓库位置并不在国内，下载速度非常慢，我们可以配置一个国内站点镜像，可用于加速下载资源。位于mirrors字段处</p><p>如阿里云镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyunmaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun_maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-3-Maven指令"><a href="#1-3-Maven指令" class="headerlink" title="1.3. Maven指令"></a>1.3. Maven指令</h2><p><code>mvn -v</code> 查看maven版本  </p><p><code>mvn compile</code> 用来将src/main/java下的文件编译为class文件，并输出到target中</p><p><code>mvn test test</code> 用来将src/main/test下的文件进行编译，同时执行一次 </p><p><code>mvn package</code> 打包，将项目进行打包，如果是jar打包为jar，war打包为war</p><p><code>mvn clean</code> 删除编译产生的target文件夹  </p><p><code>mvn install</code> 安装jar包到本地仓库中</p><h2 id="1-4-Maven插件"><a href="#1-4-Maven插件" class="headerlink" title="1.4. Maven插件"></a>1.4. Maven插件</h2><p>maven-compiler-plugin： 用于编译 Java 代码。</p><p>maven-surefire-plugin： 用于运行单元测试。</p><p>maven-jar-plugin： 用于打包 JAR 文件。</p><p>maven-war-plugin： 用于打包 WAR 文件。</p><p>maven-install-plugin： 用于将项目安装到本地 Maven 仓库中。</p><p>maven-deploy-plugin： 用于将项目部署到远程 Maven 仓库中。</p><p>maven-release-plugin： 用于发布项目的正式版本。</p><p>maven-site-plugin： 用于生成项目文档网站。</p><p>maven-dependency-plugin： 用于管理项目的依赖项。</p><p>maven-clean-plugin： 用于清理项目的目录。</p><h1 id="2-settings-xml"><a href="#2-settings-xml" class="headerlink" title="2. settings.xml"></a>2. settings.xml</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span></span><br><span class="line">描述: 指定 Maven 本地仓库的路径。</span><br><span class="line">作用: 当 Maven 需要下载依赖时,会优先从本地仓库查找,如果没有找到才会从远程仓库下载。</span><br><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">描述: 配置Maven的镜像仓库。</span><br><span class="line">作用: 当访问中央仓库比较慢时,可以配置一个镜像仓库,如阿里云的仓库,从而加快下载速度。</span><br><span class="line"><span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">描述: 配置访问远程仓库的认证信息。</span><br><span class="line">作用: 如果远程仓库需要用户名和密码来访问,就需要在这里进行配置。</span><br><span class="line"><span class="tag">&lt;<span class="name">proxies</span>&gt;</span></span><br><span class="line">描述: 配置代理服务器信息。</span><br><span class="line">作用: 如果需要通过代理服务器访问远程仓库,可以在这里进行配置。</span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">描述: 配置项目构建时使用的 profile。</span><br><span class="line">作用: 可以针对不同的环境(如开发、测试、生产)设置不同的配置信息。</span><br><span class="line"><span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">描述: 指定默认激活的 profile。</span><br><span class="line">作用: 当 Maven 构建项目时,会自动激活这里配置的 profile。</span><br><span class="line"><span class="tag">&lt;<span class="name">pluginGroups</span>&gt;</span></span><br><span class="line">描述: 配置默认加载的插件组。</span><br><span class="line">作用: 当在命令行使用插件时,可以不用输入完整的坐标。</span><br></pre></td></tr></table></figure><p><strong>配置阿里云镜像和私服镜像, 并且先从阿里云下载，下载不到的再去私服下载</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 本地仓库的位置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>.../repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- Apache Maven 配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginGroups</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">proxies</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 私服发布的用户名密码 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>mvn-public<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxb-88809<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">username</span>&gt;</span>mvn-public<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">password</span>&gt;</span>xxb-88809<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servers</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 阿里云镜像 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 影响下载顺序的是profiles标签的配置顺序(后面配置的ali仓库先下载), 而不是activeProfiles的顺序 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Nexus私服配置: 第三方jar包下载, 比如oracle的jdbc驱动等 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!-- 阿里云配置: 提高国内的jar包下载速度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>ali<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 激活配置 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeProfile</span>&gt;</span>ali<span class="tag">&lt;/<span class="name">activeProfile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activeProfiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-nexus仓库管理器"><a href="#3-nexus仓库管理器" class="headerlink" title="3. nexus仓库管理器"></a>3. nexus仓库管理器</h1><p>Nexus 是一个强大的 Maven 私有仓库管理工具,它提供了以下主要功能:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">私有仓库管理:</span><br><span class="line">可以在 Nexus 中配置多个私有仓库,用于存放组织内部开发的 Artifact。</span><br><span class="line">可以设置访问权限,控制哪些用户/角色可以访问特定仓库。</span><br><span class="line">代理远程仓库:</span><br><span class="line">Nexus 可以代理官方的 Maven 中央仓库,以及其他公共仓库,加快 Artifact 的下载速度。</span><br><span class="line">可以对下载的 Artifact 进行缓存,减少重复下载。</span><br><span class="line">仓库组管理:</span><br><span class="line">可以将多个仓库聚合成一个仓库组,以便统一管理。</span><br><span class="line">客户端可以统一访问仓库组,无需关心具体的仓库位置。</span><br><span class="line">构建集成:</span><br><span class="line">Nexus 可以与持续集成工具(如 Jenkins)集成,用于管理构建产物。</span><br><span class="line">可以自动部署构建产物到 Nexus 仓库中。</span><br><span class="line">用户权限管理:</span><br><span class="line">Nexus 提供了丰富的用户权限管理功能,可以细粒度地控制用户对仓库的访问权限。</span><br><span class="line">支持通过 LDAP 等外部身份验证系统进行集成。</span><br><span class="line">仓库运维:</span><br><span class="line">Nexus 提供了强大的仓库管理界面,可以方便地查看仓库状态、监控仓库使用情况等。</span><br><span class="line">支持仓库的备份和还原操作。</span><br></pre></td></tr></table></figure><h1 id="4-在IDEA中配置maven"><a href="#4-在IDEA中配置maven" class="headerlink" title="4. 在IDEA中配置maven"></a>4. 在IDEA中配置maven</h1><p>打开settings，搜索maven即可</p><h1 id="5-pom-xml文件"><a href="#5-pom-xml文件" class="headerlink" title="5. pom.xml文件"></a>5. pom.xml文件</h1><p><code>pom.xml</code>文件是Maven 项目管理工具中使用的项目对象模型（Project Object Model）文件，通常简称为 POM 文件。它是 Maven 项目的核心文件之一，用于描述项目的基本信息、依赖关系、构建选项、插件配置等。</p><p>每个Maven项目都应该包含一个 POM 文件，以便 Maven 能够正确地构建该项目。POM 文件通常位于项目的根目录下，文件名为 <code>pom.xml</code>。</p><p>POM 文件由 XML 编写，其中包含了一些元素和属性，用于描述项目的各个方面。例如，POM 文件中通常包含以下信息：</p><p>项目的坐标（groupId、artifactId、version）、依赖关系、构建选项和插件配置、开发者信息、许可证信息等。通过这些信息，Maven 可以自动下载依赖项、编译代码、运行测试、打包构建结果等</p><h2 id="5-1-基础配置"><a href="#5-1-基础配置" class="headerlink" title="5.1. 基础配置"></a>5.1. 基础配置</h2><p>一个典型的pom.xml文件配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--  POM 模型的版本号 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.baidu，maven会将该项目打成的jar包放本地路径：/com/baidu --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baidu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 本项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dorm-repair<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 本项目目前所处的版本号 SNAPSHOT 表示快照版本，RELEASE 表示正式版本--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 打包的机制，如pom,jar, maven-plugin, ejb, war, ear, rar, par，默认为jar --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 对于聚合模块来说，其打包方式必须为pom，否则无法构建 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 一般不用。帮助定义构件输出的一些附属构件,附属构件与主构件对应，有时候需要加上classifier才能唯一的确定该构件 不能直接定义项目的classifer,因为附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>...<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 定义本项目的依赖关系 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!-- 每个dependency都对应这一个jar包 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--一般情况下，maven是通过groupId、artifactId、version这三个元素值（俗称坐标）来检索该构件， 然后引入你的工程。如果别人想引用你现在开发的这个项目（前提是已开发完毕并发布到了远程仓库），--&gt;</span>   </span><br><span class="line">            <span class="comment">&lt;!--就需要在他的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入， maven就会把你上传的jar包下载到他的本地 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.winner.trade<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>trade-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- maven认为，程序对外部的依赖会随着程序的所处阶段和应用场景而变化，所以maven中的依赖关系有作用域(scope)的限制。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--scope包含如下的取值：compile（编译范围）、provided（已提供范围）、runtime（运行时范围）、test（测试范围）、system（系统范围） --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- 设置指依赖是否可选，默认为false,即子项目默认都继承:为true,则子项目必需显示的引入，与dependencyManagement里定义的依赖类似  --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>false<span class="tag">&lt;/<span class="name">optional</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- 屏蔽依赖关系。 比如项目中使用的libA依赖某个库的1.0版，libB依赖某个库的2.0版，现在想统一使用2.0版，就应该屏蔽掉对1.0版的依赖 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 为pom定义一些常量，在pom中的其它地方可以直接引用 使用方式 如下 ：$&#123;file.encoding&#125; --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">file.encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">file.encoding</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.source.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.source.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.target.version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">java.target.version</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    ...  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-2-构建配置"><a href="#5-2-构建配置" class="headerlink" title="5.2. 构建配置"></a>5.2. 构建配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>myPorjectName<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 构建产生的所有文件存放的目录,默认为$&#123;basedir&#125;/target，即项目根目录下的target --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--当项目没有规定目标（Maven2叫做阶段（phase））时的默认值， --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--必须跟命令行上的参数相同例如jar:jar，或者与某个阶段（phase）相同例如install、compile等 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--项目配置信息中诸如$&#123;spring.version&#125;之类的占位符会被属性文件中的实际值替换掉 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">filters</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span>&gt;</span>../filter.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">filters</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--举个例子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven/messages。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>resources<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--包含的模式列表 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--排除的模式列表 如果&lt;include&gt;与&lt;exclude&gt;划定的范围存在冲突，以&lt;exclude&gt;为准 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>jdbc.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--单元测试相关的所有资源路径，配制方法与resources类似 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">testResource</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">sourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\main\java<span class="tag">&lt;/<span class="name">sourceDirectory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目脚本源码目录，该目录和源码目录不同， &lt;!-- 绝大多数情况下，该目录下的内容会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">scriptSourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\main\scripts  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">scriptSourceDirectory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>$&#123;basedir&#125;\src\test\java<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;basedir&#125;\target\classes<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">testOutputDirectory</span>&gt;</span>$&#123;basedir&#125;\target\test-classes  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testOutputDirectory</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目的一系列构建扩展,它们是一系列build过程中要使用的产品，会包含在running bulid‘s classpath里面。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--他们可以开启extensions，也可以通过提供条件来激活plugins。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--简单来讲，extensions是在build过程被激活的产品 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--例如，通常情况下，程序开发完成后部署到线上Linux服务器，可能需要经历打包、 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--将包文件传到服务器、SSH连上服务器、敲命令启动程序等一系列繁琐的步骤。 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--实际上这些步骤都可以通过Maven的一个插件 wagon-maven-plugin 来自动完成 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--下面的扩展插件wagon-ssh用于通过SSH的方式连接远程服务器， --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--类似的还有支持ftp方式的wagon-ftp插件 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">extension</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.wagon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>wagon-ssh<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">extension</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span><span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--配置的执行目标 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>  </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--作为DOM对象的配置,配置项因插件而异 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;finalName&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">appendAssemblyId</span>&gt;</span>false<span class="tag">&lt;/<span class="name">appendAssemblyId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器）， --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--由于性能原因，只有在真需要下载时，该元素才被设置成true。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--主要定义插件的共同元素、扩展元素集合，类似于dependencyManagement， --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--所有继承于此项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>...<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-3-分发配置"><a href="#5-3-分发配置" class="headerlink" title="5.3. 分发配置"></a>5.3. 分发配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号），还是每次都使用相同的版本号 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueVersion</span>&gt;</span>true<span class="tag">&lt;/<span class="name">uniqueVersion</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--构件的快照部署到哪里,如果没有配置该元素，默认部署到repository元素配置的仓库 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">site</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> site-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--部署位置的名称 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> site-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">site</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--如果构件有了新的groupID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">relocation</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--构件新的group ID --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--构件新的artifact ID --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--构件新的版本号 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">message</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。 --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--有效的值有：none（默认），converted（仓库管理员从Maven 1 POM转换过来）， --&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部署），verified（被核实时正确的和最终的）。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">status</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-4-仓库配置"><a href="#5-4-仓库配置" class="headerlink" title="5.4. 仓库配置"></a>5.4. 仓库配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--这里的选项是：always（一直），daily（默认，每日）， --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做： --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置， --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--例如，可能有人会决定只为开发目的开启对快照版本下载的支持 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> repo-id <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--远程仓库名称 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> repo-name<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--Maven 2为其仓库提供了一个默认的布局； --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--然而，Maven1.x有一种不同的布局。 --&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span>&gt;</span> default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepository</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-5-profile配置"><a href="#5-5-profile配置" class="headerlink" title="5.5. profile配置"></a>5.5. profile配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--profile默认是否激活的标识 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>false<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--activation有一个内建的java版本检测，如果检测到jdk版本与期待的一样，profile被激活。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">os</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的操作系统所属家族(如 &#x27;windows&#x27;) --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">os</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- 如果值字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">exists</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/<span class="tag">&lt;/<span class="name">missing</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">file</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">build</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">modules</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repositories</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepositories</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">reporting</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencyManagement</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">distributionManagement</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-6-报表配置"><a href="#5-6-报表配置" class="headerlink" title="5.6. 报表配置"></a>5.6. 报表配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--描述使用报表插件产生报表的规范,特定的maven 插件能输出相应的定制和配置报表. --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--当用户执行“mvn site”，这些报表就会运行,在页面导航栏能看到所有报表的链接。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">reporting</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--true，则网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">links</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">link</span>&gt;</span>http://java.sun.com/j2se/1.5.0/docs/api/<span class="tag">&lt;/<span class="name">link</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">links</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。 --&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!--1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>sunlink<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                    <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">reports</span>&gt;</span>  </span><br><span class="line">                        <span class="tag">&lt;<span class="name">report</span>&gt;</span>javadoc<span class="tag">&lt;/<span class="name">report</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reports</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">reporting</span>&gt;</span>     </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-7-环境配置"><a href="#5-7-环境配置" class="headerlink" title="5.7. 环境配置"></a>5.7. 环境配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span>&gt;</span> jira <span class="tag">&lt;/<span class="name">system</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://jira.clf.com/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目持续集成信息 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">notifier</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--传送通知的途径 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">address</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!--扩展配置项 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span>  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-8-项目信息配置"><a href="#5-8-项目信息配置" class="headerlink" title="5.8. 项目信息配置"></a>5.8. 项目信息配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.clf.com/ <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目的详细描述, Maven 产生的文档用 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven. <span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">maven</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--邮件的名称 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> Demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">post</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span> clf@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span> http:/hi.clf.com/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目开发者列表 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">developers</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span> HELLO WORLD <span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者的全名 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> banseon <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者的email --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span>&gt;</span> banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">roles</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">role</span>&gt;</span> Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect <span class="tag">&lt;/<span class="name">role</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">roles</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">organization</span>&gt;</span> demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.clf.com/ <span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dept</span>&gt;</span> No <span class="tag">&lt;/<span class="name">dept</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">timezone</span>&gt;</span> -5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">developers</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">contributors</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">contributor</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">email</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">organization</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">roles</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">contributors</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--该元素描述了项目所有License列表。应该只列出该项目的license列表，不要列出依赖项目的license列表。 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">licenses</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span> Apache 2 <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.clf.com/LICENSE-2.0.txt <span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">distribution</span>&gt;</span> repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!--关于license的补充信息 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">comments</span>&gt;</span> Abusiness-friendly OSS license <span class="tag">&lt;/<span class="name">comments</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">license</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">licenses</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">scm</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/<span class="tag">&lt;/<span class="name">connection</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:svn:http://svn.baidu.com/banseon/maven/  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">tag</span> /&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">scm</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">organization</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--组织的全名 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span> demo <span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--组织主页的URL --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span> http://www.clf.com/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">organization</span>&gt;</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-9-maven依赖范围"><a href="#5-9-maven依赖范围" class="headerlink" title="5.9. maven依赖范围"></a>5.9. maven依赖范围</h2><div class="table-container"><table><thead><tr><th>scope</th><th>编译</th><th>测试</th><th>运行</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>test</td><td></td><td>Y</td><td></td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td></td></tr><tr><td>runtime</td><td></td><td>Y</td><td>Y</td></tr><tr><td>system</td><td>Y</td><td>Y</td></tr></tbody></table></div><h2 id="5-10-maven继承（重点）"><a href="#5-10-maven继承（重点）" class="headerlink" title="5.10. maven继承（重点）"></a>5.10. maven继承（重点）</h2><p>当一个Java项目包含多个maven模块时，往往多个模块有相同的groupId、version，或者有相同的依赖，为了减少pom文件的配置，跟我们的项目中类的继承一样，在父工程中配置了pom，子项目中的pom可以继承</p><p>当一个父项目下的多个模块中有相同的依赖时，我们可以将这些依赖提取出来，统一在父POM中声明，这样可以简化子模块的配置，但是这样还是存在问题，当想在父项目中加入一些，不需要这么多依赖的模块，如果让这个模块也依赖那些不需要的依赖，显然不合理。</p><p><strong>Maven提供的dependentcyManagement元素，其下的依赖声明既不会给项目引入依赖，也不会给它的子模块引入依赖，就是定义了依赖的版本，对版本进行统一管理，避免发生多个子模块使用依赖版本不一致的情况，降低依赖冲突的几率</strong></p><p><strong>dependencyManagement声明的依赖真正地引入到项目中是在子项目的pom文件中进行定义声明的</strong></p><h2 id="5-11-maven聚合（重点）"><a href="#5-11-maven聚合（重点）" class="headerlink" title="5.11. maven聚合（重点）"></a>5.11. maven聚合（重点）</h2><p>把整个项目的所有模块聚合到一起</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>e3-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.e3mall<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cn-manager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">module</span>&gt;</span>e3-manager-pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">module</span>&gt;</span>e3-manager-dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">module</span>&gt;</span>e3-manager-interface<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">module</span>&gt;</span>e3-manager-service<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">module</span>&gt;</span>e3-manager-web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>一个特殊的地方就是packaging，其值为pom，如果没有声明的话，默认为jar，对于聚合模块来说，其打包方式必须为pom，否则无法构建。</strong></p><p><strong>modules里的每一个module都可以用来指定一个被聚合模块，这里每个module的值都是一个当前pom的相对位置。</strong></p><h2 id="5-12-常用标签"><a href="#5-12-常用标签" class="headerlink" title="5.12. 常用标签"></a>5.12. 常用标签</h2><hr><p><code>&lt;project&gt;</code> 标签： pom.xml 文件的根元素，它包含了整个项目的配置信息。</p><p><code>&lt;modelVersion&gt;</code> 标签： 指定 POM 文件所使用的项目对象模型（Project Object Model）的版本号。在当前版本的 Maven 中，POM 模型的版本号为 4.0.0。</p><p><code>&lt;parent&gt;</code> 标签： 指定当前项目的父项目，它通常用于继承父项目的配置和依赖项。</p><p><code>&lt;groupId&gt;</code> 标签： 指定项目的组 ID，通常使用倒置的域名（例如 com.example）。</p><p><code>&lt;artifactId&gt;</code> 标签： 指定项目的 artifact ID，通常是项目名称的小写形式（例如 my-project）。</p><p><code>&lt;version&gt;</code> 标签： 指定项目的版本号，通常使用 Semantic Versioning 规范（例如 1.0.0）。</p><p><code>&lt;name&gt;</code> 标签： 指定项目的人类可读名称。</p><p><code>&lt;description&gt;</code> 标签： 指定项目的描述信息，通常是一个简短的描述，用于描述项目的目的和功能。</p><p><code>&lt;packaging&gt;</code> 标签： 指定项目的打包类型，通常是 jar 或 war、pom</p><p><code>&lt;properties&gt;</code> 标签： 指定项目的属性，可以在项目中通过 ${propertyName} 的形式来引用这些属性。</p><hr><p><code>&lt;dependencyManagement&gt;</code> 标签用于统一管理项目的依赖版本号和依赖范围，避免版本冲突。它可以让子模块继承父模块的依赖信息。这个标签通常被放在父项目的 pom.xml 文件中，子项目可以通过继承父项目的 pom.xml 文件来继承父项目的 <code>&lt;dependencyManagement&gt;</code> 标签中定义的依赖版本号和依赖范围。</p><p><code>&lt;dependencies&gt;</code> 标签用于指定项目的依赖列表，其中每个依赖项都是通过一个 <code>&lt;dependency&gt;</code> 标签来定义的。这个标签通常被放在项目的 pom.xml 文件中，用于声明项目的依赖，以便 Maven 能够自动下载所需的依赖并将其添加到项目构建路径中。</p><p><code>&lt;dependency&gt;</code> 标签用于定义一个具体的依赖项，包括依赖的组织、名称、版本号、依赖范围等信息。这个标签通常被定义在 <code>&lt;dependencies&gt;</code> 标签内部，用于声明项目的具体依赖。</p><p><code>&lt;dependency&gt;</code> 标签中的 <code>&lt;scope&gt;</code> 元素： 指定依赖项的作用域，例如 compile、test、provided 等。</p><p><code>&lt;exclusions&gt;</code> 标签： 在依赖项中排除一些不需要的传递性依赖项。</p><p><code>&lt;exclusion&gt;</code> 标签用于排除传递性依赖中的某些依赖项。在 Maven 项目中，一个依赖项可能会依赖其他的依赖项，这些依赖项被称为传递性依赖。</p><hr><p><code>&lt;modules&gt;</code> 标签： 指定项目的模块，通常用于多模块项目中，每个模块都用一个 <code>&lt;module&gt;</code> 标签来描述。</p><hr><p><code>&lt;build&gt;</code> 标签： 指定项目的构建选项。其中包括源代码目录、资源目录、构建插件等信息。</p><p><code>&lt;plugins&gt;</code> 标签： 指定项目所使用的 Maven 插件。每个插件都用 <code>&lt;plugin&gt;</code> 标签来描述，其中包括插件的组 ID、artifact ID 和版本号等信息。</p><hr><p><code>&lt;distributionManagement&gt;</code> 标签用于指定项目的发布配置信息，包括发布到哪个仓库、以何种方式发布。包含两个子元素 <code>&lt;repository&gt;</code> 和 <code>&lt;snapshotRepository&gt;</code>，分别用于配置正式版本和快照版本的发布仓库信息。</p><hr><p><code>&lt;repositories&gt;</code> 标签： 指定项目所使用的远程仓库。每个远程仓库都用 </p><p><code>&lt;repository&gt;</code> 标签来描述，其中包括仓库的 URL 和 ID 等信息。</p><p><code>&lt;repository&gt;</code> 标签中的 <code>&lt;snapshots&gt;</code> 元素： 指定是否从远程仓库下载快照版本的依赖项。</p><hr><p><code>&lt;pluginRepositories&gt;</code> 标签指定项目中使用的插件仓库</p><hr><p><code>&lt;profiles&gt;</code> 标签： 指定项目的配置文件。每个配置文件都用 <code>&lt;profile&gt;</code> 标签来描述，其中包括配置文件的 ID、激活条件等信息。</p><p>标准模板</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>  </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!--  POM 模型的版本号 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定当前项目的父项目，用于自动继承父项目的依赖项、插件、资源等配置信息--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yatoil<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yt-dorm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 设置 pom，代表打包类型为 pom --&gt;</span>    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>yt-dorm project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定项目的属性，可以在项目中通过 $&#123;propertyName&#125; 的形式来引用这些属性 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">yt-dorm.version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">yt-dorm.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">swagger.version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">swagger.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">jwt.version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">jwt.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- Swagger2 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">                <span class="comment">&lt;!-- 排除传递性依赖  </span></span><br><span class="line"><span class="comment">                &lt;exclusions&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;io.swagger&lt;/groupId&gt;                        &lt;artifactId&gt;swagger-models&lt;/artifactId&gt;                    &lt;/exclusion&gt;                    &lt;exclusion&gt;                        &lt;groupId&gt;io.swagger&lt;/groupId&gt;                        &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;                    &lt;/exclusion&gt;                &lt;/exclusions&gt; --&gt;</span>            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;swagger.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- jjwt生成token --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jwt.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- web服务入口 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yatoil<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dorm-admin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yt-dorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- 通用工具模块 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yatoil<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dorm-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yt-dorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">&lt;!-- 宿舍管理模块 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yatoil<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dorm-dormitory<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;yt-dorm.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定项目的子模块 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dorm-admin<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dorm-common<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>dorm-dormitory<span class="tag">&lt;/<span class="name">module</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定项目的构建选项。源代码目录、资源目录、构建插件等信息 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 指定项目所使用的 Maven 插件 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">            <span class="comment">&lt;!-- 插件功能：用于编译项目源码并生成对应的字节码文件 --&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">source</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">target</span>&gt;</span>  </span><br><span class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>$&#123;project.build.sourceEncoding&#125;<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定了项目的发布配置信息，包括发布到哪个仓库、以何种方式发布 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Release Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定项目所使用的远程仓库 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!-- 公司内部仓库 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">&lt;!-- 阿里云仓库 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 指定项目中使用的插件仓库 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus Plugin Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://library.yatoil.com:8081/repository/maven-public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun-repos<span class="tag">&lt;/<span class="name">id</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-20-Docker%E7%90%86%E8%AE%BA/"/>
      <url>/2024/10/28/2023-01-20-Docker%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR </span><br><span class="line">docker --&gt; docker-ce社区免费版</span><br><span class="line">docker --&gt; docker-ee企业收费版</span><br><span class="line">docker-ce社区免费版 --&gt; docker-compose管理多个Docker容器的工具</span><br><span class="line">docker-ce社区免费版 --&gt; Kubernetes管理大规模容器集群的容器编排平台</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="2-Docker-是什么"><a href="#2-Docker-是什么" class="headerlink" title="2. Docker 是什么"></a>2. Docker 是什么</h1><p>Docker容器对进程封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程</p><p>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像</p><p>Docker镜像中包含完整运行环境， 包括系统函数库（仅依赖系统的Linux内核），因此可以在任意Linux操作系统上运行</p><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。而<strong>容器内的应用进程直接运行于宿主的内核</strong>，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</p><h1 id="3-为什么要用-Docker"><a href="#3-为什么要用-Docker" class="headerlink" title="3. 为什么要用 Docker"></a>3. 为什么要用 Docker</h1><ul><li>高效利用系统资源</li><li>快速的启动时间</li><li>一致的运行环境。避免由于开发环境、测试环境、生产环境不一致，导致的 bug </li><li>持续交付和部署。一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。使用Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件。</li><li>更轻松的维护和扩展。<code>Docker</code> 使用的分层存储以及镜像的技术，使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。<a href="https://hub.docker.com/search/?type=image&amp;image_filter=official&amp;q=">官网镜像库</a></li></ul><h1 id="4-Docker-基本组成"><a href="#4-Docker-基本组成" class="headerlink" title="4. Docker 基本组成"></a>4. Docker 基本组成</h1><p><strong>镜像、容器、仓库</strong> 这三个概念，涵盖了 Docker 的整个生命周期</p><h2 id="4-1-镜像"><a href="#4-1-镜像" class="headerlink" title="4.1. 镜像"></a>4.1. 镜像</h2><p>Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含任何动态数据</strong>，其内容在构建之后也不会被改变</p><h3 id="4-1-1-分层存储（重点）"><a href="#4-1-1-分层存储（重点）" class="headerlink" title="4.1.1. 分层存储（重点）"></a>4.1.1. 分层存储（重点）</h3><p>Docker 镜像构建时，会一层一层地构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>eg：删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h2 id="4-2-容器"><a href="#4-2-容器" class="headerlink" title="4.2. 容器"></a>4.2. 容器</h2><p>镜像是静态的定义，<strong>容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等</p><p><strong>容器的实质是进程</strong>，但与直接在宿主执行的进程不同，<strong>容器进程运行于属于自己的独立的命名空间</strong>（ the same namespace for a set of resources and processes, but those namespaces refer to distinct resources. Resources may exist in multiple spaces）</p><p>Docker 不是虚拟机，<strong>容器中的应用都应该以前台执行</strong>，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，<strong>容器内没有后台服务的概念</strong>。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p><h3 id="4-2-1-容器存储层（不推荐）"><a href="#4-2-1-容器存储层（不推荐）" class="headerlink" title="4.2.1. 容器存储层（不推荐）"></a>4.2.1. 容器存储层（不推荐）</h3><p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层（为容器运行时读、写而准备的存储层）</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡</p><p><strong>Docker 最佳实践</strong>的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><h2 id="4-3-仓库"><a href="#4-3-仓库" class="headerlink" title="4.3. 仓库"></a>4.3. 仓库</h2><p>镜像构建完成后，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p><p>一个 Docker Registry 中可以包含多个仓库。每个仓库可以包含多个标签（Tag）。每个标签对应一个镜像。</p><p>通常，一个仓库包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest 作为默认标签。</p><h3 id="4-3-1-公开-Docker-Registry"><a href="#4-3-1-公开-Docker-Registry" class="headerlink" title="4.3.1. 公开 Docker Registry"></a>4.3.1. 公开 Docker Registry</h3><p>一般这类公开服务允许用户免费上传、下载公开的镜像</p><p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official">官方镜像</a>。除此以外，还有 Red Hat 的 <a href="https://quay.io/repository/">Quay.io</a>；Google 的 <a href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a href="https://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a href="https://github.com">GitHub</a> 推出的 <a href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a></p><h3 id="4-3-2-私有-Docker-Registry"><a href="#4-3-2-私有-Docker-Registry" class="headerlink" title="4.3.2. 私有 Docker Registry"></a>4.3.2. 私有 Docker Registry</h3><p>用户还可以在本地搭建私有 Docker Registry</p><h1 id="5-安装Docker"><a href="#5-安装Docker" class="headerlink" title="5. 安装Docker"></a>5. 安装Docker</h1><h2 id="5-1-官方脚本自动安装（推荐）"><a href="#5-1-官方脚本自动安装（推荐）" class="headerlink" title="5.1. 官方脚本自动安装（推荐）"></a>5.1. 官方脚本自动安装（推荐）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>官方被封了，用这个</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure><h2 id="5-2-启动"><a href="#5-2-启动" class="headerlink" title="5.2. 启动"></a>5.2. 启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h2 id="5-3-建立-docker-用户组"><a href="#5-3-建立-docker-用户组" class="headerlink" title="5.3. 建立 docker 用户组"></a>5.3. 建立 docker 用户组</h2><p>默认情况下，<strong>docker命令会使用 Unix socket 与 Docker 引擎通讯</strong>。而只有root用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是<strong>将需要使用 docker 的用户加入 docker 用户组</strong></p><p>建立docker组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure><p>将当前用户加入 docker 组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><h2 id="5-4-测试-Docker-是否安装正确"><a href="#5-4-测试-Docker-是否安装正确" class="headerlink" title="5.4. 测试 Docker 是否安装正确"></a>5.4. 测试 Docker 是否安装正确</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm hello-world</span><br></pre></td></tr></table></figure><h2 id="5-5-镜像加速"><a href="#5-5-镜像加速" class="headerlink" title="5.5. 镜像加速"></a>5.5. 镜像加速</h2><p>查看是否在 <code>docker.service</code> 文件中配置过镜像地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat docker | grep &#x27;\-\-registry\-mirror&#x27;</span><br></pre></td></tr></table></figure><p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p><p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1panel.live&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://huecker.io&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>重新启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>检查加速器是否生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><h1 id="6-Docker-架构（重点）"><a href="#6-Docker-架构（重点）" class="headerlink" title="6. Docker 架构（重点）"></a>6. Docker 架构（重点）</h1><h2 id="6-1-客户端"><a href="#6-1-客户端" class="headerlink" title="6.1. 客户端"></a>6.1. 客户端</h2><p>通过命令或Docker API 向Docker服务端发送指令。可以在本地或远程向服务端发送指令</p><h2 id="6-2-服务端"><a href="#6-2-服务端" class="headerlink" title="6.2. 服务端"></a>6.2. 服务端</h2><p><strong>服务端=Docker引擎=Docker守护进程</strong>， 负责处理Docker指令，管理镜像、容器等</p><h1 id="7-Docker-镜像操作"><a href="#7-Docker-镜像操作" class="headerlink" title="7. Docker 镜像操作"></a>7. Docker 镜像操作</h1><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像</p><h2 id="7-1-获取镜像"><a href="#7-1-获取镜像" class="headerlink" title="7.1. 获取镜像"></a>7.1. 获取镜像</h2><p>访问DockerHub搜索镜像，<a href="https://hub.docker.com/">https://hub.docker.com/</a></p><p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 <code>docker.io</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure><h2 id="7-2-运行"><a href="#7-2-运行" class="headerlink" title="7.2. 运行"></a>7.2. 运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure><p>通过 <code>exit</code> 退出容器</p><h2 id="7-3-列出镜像"><a href="#7-3-列出镜像" class="headerlink" title="7.3. 列出镜像"></a>7.3. 列出镜像</h2><p>查看本地镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure><p>查看镜像、容器、数据卷所占用的空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure><p>同时显示依赖的中间层镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure><h2 id="7-4-导出导入"><a href="#7-4-导出导入" class="headerlink" title="7.4. 导出导入"></a>7.4. 导出导入</h2><p>导出镜像到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;保存的文件名&gt;.tar &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/myimage.tar</span><br></pre></td></tr></table></figure><p>这将在另一台机器上导入名为<code>myimage</code>的镜像</p><h2 id="7-5-删除镜像"><a href="#7-5-删除镜像" class="headerlink" title="7.5. 删除镜像"></a>7.5. 删除镜像</h2><p><code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure><p><strong>Untagged 和 Deleted</strong></p><p>删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像</p><h2 id="7-6-Dockerfile定制镜像（重点）"><a href="#7-6-Dockerfile定制镜像（重点）" class="headerlink" title="7.6. Dockerfile定制镜像（重点）"></a>7.6. Dockerfile定制镜像（重点）</h2><p>定制镜像，是以一个镜像为基础，在其上进行定制</p><p>镜像的定制实际上就是<strong>定制每一层所添加的配置、文件</strong>。我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile</p><p>注：禁止使用 docker commit定制镜像，使用 docker commit 意味着除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），<strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建</p><p>建立一个文本文件，并命名为 Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure><h3 id="7-6-1-Dockerfile指令"><a href="#7-6-1-Dockerfile指令" class="headerlink" title="7.6.1. Dockerfile指令"></a>7.6.1. Dockerfile指令</h3><p><a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile最佳实践</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM python:3.8.10</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 将项目下的requirements.txt文件复制到 /app目录</span><br><span class="line">COPY ./requirements.txt .</span><br><span class="line"># 执行命令pip install --no-cache-dir -r requirements.txt 安装项目依赖</span><br><span class="line">RUN pip install --no-cache-dir -r requirements.txt</span><br><span class="line"># 将Flask 项目复制到容器中的 /app 目录</span><br><span class="line">COPY . .</span><br><span class="line"># 容器向外暴露5000端口</span><br><span class="line">EXPOSE 5000</span><br><span class="line"># 在容器启动时运行 app.py 脚本</span><br><span class="line">CMD [ &quot;python&quot;, &quot;app.py&quot; ]</span><br></pre></td></tr></table></figure><p><strong>FROM 命令</strong></p><p><strong>指定基础镜像，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令</strong></p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础</p><p><strong>RUN 命令</strong></p><p><code>RUN</code> 指令用来执行命令行的命令，其格式有两种：</p><ul><li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样</li><li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</li></ul><p><strong>Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式</strong></p><p>此外，通常要在一组命令的最后添加清理工作的命令 <code>apt-get purge -y --auto-remove $buildDeps</code>，删除为了编译构建所需要的软件，清理所有下载、展开的文件，并且清理 <code>apt</code> 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉</p><p><strong>COPY</strong></p><p>将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件或目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。<code>COPY &lt;源路径&gt; &lt;目标路径&gt;</code></p><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>需要注意，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用</p><p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</p><p><strong>COPY 命令的源路径是相对于构建上下文（即通过 <code>docker build</code> 命令传递给 Docker 的目录或文件）</strong></p><p><strong>ADD</strong></p><p>与COPY类似，但还支持从URL中下载文件，并且可以自动解压压缩文件。</p><p>Dockerfile <strong>最佳实践</strong>中要求，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p><strong>WORKDIR</strong></p><p>设置工作目录，改变以后各层的工作目录的位置。<code>WORKDIR &lt;工作目录路径&gt;</code></p><p>如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p><strong>工作目录就是容器运行时所用的根目录</strong></p><p><strong>EXPOSE</strong></p><p>声明容器运行时需要开放的端口。<code>EXPOSE &lt;端口&gt;</code></p><p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p><p>在 Dockerfile 中使用 EXPOSE 声明的好处是在容器运行时，使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p><strong>ENV</strong></p><p>设置环境变量。</p><p>定义了环境变量，无论是后面的其它指令，还是运行时的应用，都可以直接使用定义的环境变量。</p><p>通过环境变量，可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><p><strong>CMD</strong></p><p>设置容器启动后默认执行的命令。</p><p><strong>ENTRYPOINT</strong></p><p>设置容器启动后默认执行的命令，与CMD不同的是，ENTRYPOINT指定的命令不会被覆盖。</p><p><strong>USER</strong></p><p>设置容器中执行命令的用户。</p><p><strong>VOLUME</strong></p><p>声明持久化数据的目录，可以在容器中挂载主机的目录。<code>VOLUME &lt;路径&gt;</code></p><p>容器运行时应该尽量保持容器存储层不发生写操作，在 <code>Dockerfile</code> 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p><p><strong>ARG</strong></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p><h3 id="7-6-2-构建镜像"><a href="#7-6-2-构建镜像" class="headerlink" title="7.6.2. 构建镜像"></a>7.6.2. 构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure><h3 id="7-6-3-镜像构建上下文（重点）"><a href="#7-6-3-镜像构建上下文（重点）" class="headerlink" title="7.6.3. 镜像构建上下文（重点）"></a>7.6.3. 镜像构建上下文（重点）</h3><p><code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，<code>docker build</code> 命令构建镜像，并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。<strong>当构建的时候，用户会指定构建镜像上下文的路径</strong>，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p><strong>一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</strong></p><h3 id="7-6-4-多阶段构建"><a href="#7-6-4-多阶段构建" class="headerlink" title="7.6.4. 多阶段构建"></a>7.6.4. 多阶段构建</h3><p>…<br>…</p><h1 id="8-Docker-容器操作"><a href="#8-Docker-容器操作" class="headerlink" title="8. Docker 容器操作"></a>8. Docker 容器操作</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境</p><h2 id="8-1-启动"><a href="#8-1-启动" class="headerlink" title="8.1. 启动"></a>8.1. 启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><h3 id="8-1-1-新建并启动"><a href="#8-1-1-新建并启动" class="headerlink" title="8.1.1. 新建并启动"></a>8.1.1. 新建并启动</h3><p>命令主要为 <code>docker run</code></p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-   检查本地是否存在指定的镜像，不存在就从仓库下载</span><br><span class="line"></span><br><span class="line">-   利用镜像创建并启动一个容器</span><br><span class="line"></span><br><span class="line">-   分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</span><br><span class="line"></span><br><span class="line">-   从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</span><br><span class="line"></span><br><span class="line">-   从地址池配置一个 ip 地址给容器</span><br><span class="line"></span><br><span class="line">-   执行用户指定的应用程序</span><br><span class="line"></span><br><span class="line">-   执行完毕后容器被终止</span><br></pre></td></tr></table></figure><h3 id="8-1-2-启动已终止容器"><a href="#8-1-2-启动已终止容器" class="headerlink" title="8.1.2. 启动已终止容器"></a>8.1.2. 启动已终止容器</h3><p>利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p><h2 id="8-2-守护态运行"><a href="#8-2-守护态运行" class="headerlink" title="8.2. 守护态运行"></a>8.2. 守护态运行</h2><p>更多的时候，需要<strong>让 Docker 在后台运行</strong>，而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现 <code>docker run -d</code></p><p><strong>注：</strong> 容器是否会长久运行和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关</p><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息</p><h2 id="8-3-终止"><a href="#8-3-终止" class="headerlink" title="8.3. 终止"></a>8.3. 终止</h2><p>使用 <code>docker container stop</code> 来终止一个运行中的容器</p><p>注：当 Docker 容器中指定的应用终结时，容器也自动终止</p><h2 id="8-4-进入容器"><a href="#8-4-进入容器" class="headerlink" title="8.4. 进入容器"></a>8.4. 进入容器</h2><p>推荐 <code>docker exec</code> 命令，<code>docker exec</code> command allows you to run commands inside a Docker container</p><p>使用<code>-it</code> 参数，可以看到我们熟悉的 Linux 命令提示符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg：docker exec -it container-name bash</span><br></pre></td></tr></table></figure><h2 id="8-5-导出导入"><a href="#8-5-导出导入" class="headerlink" title="8.5. 导出导入"></a>8.5. 导出导入</h2><p>导出容器快照到本地 <code>tar</code>文件，可以使用 <code>docker export</code> 命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [CONTAINER ID] &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p><p>导入容器可以使用<code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code> 来导入一个容器快照到本地镜像库</p><p><strong>镜像与容器快照的区别</strong></p><p>容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息</p><h2 id="8-6-删除"><a href="#8-6-删除" class="headerlink" title="8.6. 删除"></a>8.6. 删除</h2><p>使用 <code>docker container rm</code> 来删除一个处于终止状态的容器</p><p>要删除一个运行中的容器，可以添加 <code>-f</code> 参数</p><p>清理掉所有处于终止状态的容器<code>docker container prune</code></p><h1 id="9-Docker-仓库"><a href="#9-Docker-仓库" class="headerlink" title="9. Docker 仓库"></a>9. Docker 仓库</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方</p><h2 id="9-1-Docker-Hub"><a href="#9-1-Docker-Hub" class="headerlink" title="9.1. Docker Hub"></a>9.1. Docker Hub</h2><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="9-2-私有仓库"><a href="#9-2-私有仓库" class="headerlink" title="9.2. 私有仓库"></a>9.2. 私有仓库</h2><p>一个本地仓库供私人使用</p><p>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库</p><h1 id="10-Docker-数据管理"><a href="#10-Docker-数据管理" class="headerlink" title="10. Docker 数据管理"></a>10. Docker 数据管理</h1><p>在Docker 内部以及容器之间管理数据。在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><h2 id="10-1-数据卷（重点）"><a href="#10-1-数据卷（重点）" class="headerlink" title="10.1. 数据卷（重点）"></a>10.1. 数据卷（重点）</h2><p>在 Docker 中，数据卷（volume）是一种用于在容器和宿主机之间共享数据的机制</p><p>数据卷在 Docker 中是一种特殊的文件系统，它可以映射到宿主机上的一个目录或者一个 Docker 管理的卷（volume）上。<strong>数据卷本身并不属于宿主机</strong>。数据卷是由 Docker 管理的，它存储在 Docker 数据目录下的某个位置，而不是存储在宿主机上的普通文件或目录中。因此，删除容器或删除数据卷映射并不会删除数据卷本身，数据卷可以被多个容器共享，并且可以在宿主机和容器之间方便地移动和复制</p><p>当一个数据卷被映射到一个目录上时，这个目录会成为该数据卷的挂载点，并且可以在容器中访问该目录下的所有内容</p><p>当一个数据卷被映射到一个 Docker 管理的卷上时，这个卷会成为该数据卷的挂载点，并且可以在多个容器之间共享</p><h3 id="10-1-1-数据卷特点"><a href="#10-1-1-数据卷特点" class="headerlink" title="10.1.1. 数据卷特点"></a>10.1.1. 数据卷特点</h3><p>数据卷可以在容器之间共享和重用，方便容器间传递数据</p><p>对数据卷内数据的修改会立马生效（无论是容器内操作还是本地操作）</p><p>对数据卷的更新不会影响镜像，解耦开应用和数据</p><p>数据卷可以独立于容器存在（数据卷默认会一直存在，即使容器被删除）</p><h3 id="10-1-2-数据卷操作命令"><a href="#10-1-2-数据卷操作命令" class="headerlink" title="10.1.2. 数据卷操作命令"></a>10.1.2. 数据卷操作命令</h3><p>数据卷操作的基本语法为：<code>docker volume [COMMAND]</code>，其中COMMAND是某个具体的命令</p><p><strong>创建一个数据卷</strong></p><p><code>docker volume create my-vol</code></p><p><strong>列出所有的数据卷</strong></p><p><code>docker volume ls</code></p><p><strong>查看指定数据卷的信息</strong> </p><p><code>docker volume inspect my-vol</code></p><p><strong>挂载数据卷到某容器（重点）</strong></p><p>使用 <code>docker run</code> 命令的 <code>-v</code> 将数据卷挂载到容器中的某个目录下，从而<strong>实现容器中的应用程序对宿主机上的数据进行读写</strong>。在一次 <code>docker run</code> 中可以挂载多个数据卷（在linux的docker主机中创建一个卷时， 其在宿主机对应的目录或挂载点路径为<code>/var/lib/docker/volumes/卷名/_ data</code>）</p><p><strong>删除指定的数据卷</strong> </p><p><code>docker volume rm my-vol</code></p><p><strong>在删除容器的同时移除数据卷</strong></p><p>数据卷是用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p><strong>删除未使用的数据卷</strong></p><p><code>docker volume prune</code></p><h2 id="10-2-挂载主机目录"><a href="#10-2-挂载主机目录" class="headerlink" title="10.2. 挂载主机目录"></a>10.2. 挂载主机目录</h2><p><strong>将宿主机上的目录直接挂载到容器中</strong>，容器中的数据改变会直接影响宿主机上的数据，而且需要手动管理数据的备份和恢复等工作</p><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录或文件到容器中去</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code></p><p>需要在容器中访问宿主机上的文件系统，建议使用挂载主机目录</p><h1 id="11-Docker-网络通信"><a href="#11-Docker-网络通信" class="headerlink" title="11. Docker 网络通信"></a>11. Docker 网络通信</h1><p>Docker 允许通过外部访问容器、容器互联的方式来提供网络服务</p><h2 id="11-1-外部访问容器"><a href="#11-1-外部访问容器" class="headerlink" title="11.1. 外部访问容器"></a>11.1. 外部访问容器</h2><p>使用 <code>-P</code> 标记时，Docker 会随机映射一个本地端口到内部容器的端口。让外部也可以访问容器应用</p><p><code>-P</code> 标记支持的格式 <code>ip:hostPort:containerPort</code> 、<code>ip::containerPort</code> 、 `hostPort:containerPort</p><p>注：在一个指定端口上只可以绑定一个容器</p><p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</p><p> <code>-p</code> 标记可以多次使用来绑定多个端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 443:443 \</span><br><span class="line">nginx:alpine</span><br></pre></td></tr></table></figure><h2 id="11-2-容器互联"><a href="#11-2-容器互联" class="headerlink" title="11.2. 容器互联"></a>11.2. 容器互联</h2><p>强烈建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。如：要想从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了</p><p><strong>新建网络</strong></p><p><code>docker network create -d bridge my-net</code>，<code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 、<code>overlay</code></p><p><strong>连接容器</strong></p><p>运行一个容器并连接到新建的 <code>my-net</code> 网络，打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络。通过 <code>ping</code> 来证明容器与容器间建立了互联关系</p><p><strong>查看网络列表</strong></p><p><code>docker network ls</code> </p><h2 id="11-3-配置-DNS"><a href="#11-3-配置-DNS" class="headerlink" title="11.3. 配置 DNS"></a>11.3. 配置 DNS</h2><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code></p><h1 id="12-Docker-Compose（重点）"><a href="#12-Docker-Compose（重点）" class="headerlink" title="12. Docker Compose（重点）"></a>12. Docker Compose（重点）</h1><h2 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1. 简介"></a>12.1. 简介</h2><p>Docker Compose 负责实现对 Docker 容器集群的快速编排，可以把项目的多个服务集合到一起，一键运行。</p><p>如：要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p><p>Docker Compose 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p><p>Docker Compose 中有两个重要的概念：</p><ul><li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li><li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li></ul><p>Docker Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</p><h2 id="12-2-安装与卸载"><a href="#12-2-安装与卸载" class="headerlink" title="12.2. 安装与卸载"></a>12.2. 安装与卸载</h2><p><strong>docker-compose和docker compose的区别</strong></p><p>Compose分为V1和V2版本，安装方式分为两种，一种是独立安装（standalone），一种是插件安装（plugin），所以有四种组合方式：</p><div class="table-container"><table><thead><tr><th></th><th>V1</th><th>V2</th></tr></thead><tbody><tr><td>standalone（独立式安装）</td><td>docker-compose</td><td>docker-compose</td></tr><tr><td>plugin（插件式安装）</td><td>不支持插件式安装</td><td>docker compose</td></tr></tbody></table></div><p>插件安装的Compose，在V2版本，指令是docker compose（中间是空格），最新版的docker安装时会自动以插件的形式安装docker compose</p><p>支持同时采用两种方式安装Compose，安装后可以同时使用docker-compose和docker compose</p><p><strong>独立式安装</strong></p><p>在 Linux 64 位系统上直接下载对应的二进制包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/2.17.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 国内用户可以使用以下方式加快下载</span><br><span class="line">$ sudo curl -L https://get.daocloud.io/docker/compose/releases/download/2.17.2/docker-compose-`uname -s-uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"># 给脚本执行权限</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>运行<code>docker-compose --version</code>检查是否安装成功</p><p>卸载：如果是二进制包方式安装的，删除二进制文件即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><h2 id="12-3-Compose-模板文件"><a href="#12-3-Compose-模板文件" class="headerlink" title="12.3. Compose 模板文件"></a>12.3. Compose 模板文件</h2><p>默认的模板文件名称为 <code>docker-compose.yml</code></p><p>参考文档：<a href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build: ./</span><br><span class="line">    ports:</span><br><span class="line">      - 80:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/app</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:5.0.13</span><br><span class="line">    volumes:</span><br><span class="line">      - redis:/data</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  redis:</span><br></pre></td></tr></table></figure><blockquote><p>容器默认时间不是北京时间，增加 TZ=Asia/Shanghai 可以改为北京时间</p></blockquote><h2 id="12-4-常用命令"><a href="#12-4-常用命令" class="headerlink" title="12.4. 常用命令"></a>12.4. 常用命令</h2><p>docker compose命令的运行需要docker-compose.yml文件的支持，可以指定文件位置，也可以在文件同目录运行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">## 构建镜像并启动文件内配置的所有容器</span><br><span class="line">docker compose up</span><br><span class="line"></span><br><span class="line">## 构建镜像并启动所有容器，后台运行</span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line">## 停止并删除所有容器</span><br><span class="line">docker compose down</span><br><span class="line"></span><br><span class="line">## 重启单个服务</span><br><span class="line">docker-compose restart service-name</span><br><span class="line"></span><br><span class="line">## 重启所有服务</span><br><span class="line">docker compose restart</span><br><span class="line"></span><br><span class="line">## 启动服务</span><br><span class="line">docker compose start</span><br><span class="line"></span><br><span class="line">## 停止服务</span><br><span class="line">docker compose stop</span><br><span class="line"></span><br><span class="line">## 展示当前docker compose编排过并运行的所有容器（在docker-compose.yml文件同目录下运行）</span><br><span class="line">docker compose ps</span><br><span class="line"></span><br><span class="line">## 检查docker-compose.yml文件</span><br><span class="line">docker compose config</span><br><span class="line"></span><br><span class="line">## 检查docker-compose.yml文件，有问题就输出</span><br><span class="line">docker compose config -q</span><br><span class="line"></span><br><span class="line">## 进入容器命令行</span><br><span class="line">docker-compose exec service-name sh</span><br><span class="line"></span><br><span class="line">## 查看容器运行log</span><br><span class="line">docker-compose logs [service-name]</span><br></pre></td></tr></table></figure><h1 id="13-Docker-GUI-管理"><a href="#13-Docker-GUI-管理" class="headerlink" title="13. Docker GUI 管理"></a>13. Docker GUI 管理</h1><p>推荐使用<a href="https://docs.portainer.io/start/install-ce/server/docker/linux">Portainer</a>（Portainer-CE社区版） 作为容器的 GUI 管理方案</p><h2 id="13-1-单机版运行"><a href="#13-1-单机版运行" class="headerlink" title="13.1. 单机版运行"></a>13.1. 单机版运行</h2><p>如果仅有一个docker宿主机，则可使用单机版运行</p><p>在Docker中创建一个数据卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure><p>该命令的作用是在Docker中创建一个名为portainer_data的数据卷，用于挂载到Portainer容器中的/data目录以保存Portainer的数据</p><p>访问<code>https://ip:9443</code>，首次登陆需要注册用户，给admin用户设置密码：<code>adminadminadmin</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></p><p>具体参数的含义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-d: 让容器在后台以守护进程方式运行</span><br><span class="line">-p 8000:8000: 将主机的8000端口映射到容器的8000端口，这样可以通过访问主机的8000端口来访问Portainer的Web界面</span><br><span class="line">-p 9443:9443: 将主机的9443端口映射到容器的9443端口，这样可以通过访问主机的9443端口来访问Portainer的Web界面（使用HTTPS）</span><br><span class="line">--name portainer: 为容器指定一个名称，这里指定为portainer</span><br><span class="line">--restart=always: 让Docker在启动时自动重新启动容器，即使容器因为某种原因而停止了</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock: 将主机上的/var/run/docker.sock文件映射到容器内的同一文件，这样Portainer就可以通过Docker API与主机上的Docker守护程序进行交互</span><br><span class="line">-v portainer_data:/data: 将名为portainer_data的Docker卷挂载到容器的/data目录，这样Portainer就可以将其数据保存在该卷中</span><br><span class="line">portainer/portainer-ce:latest: 运行的镜像名称和标签，这里使用的是Portainer社区版的最新版本。</span><br></pre></td></tr></table></figure><h2 id="13-2-集群版运行"><a href="#13-2-集群版运行" class="headerlink" title="13.2. 集群版运行"></a>13.2. 集群版运行</h2><p>…<br>…</p><h1 id="14-Docker-的目录结构"><a href="#14-Docker-的目录结构" class="headerlink" title="14. Docker 的目录结构"></a>14. Docker 的目录结构</h1><p>Docker 安装目录：这是 Docker 引擎的安装目录，通常包括二进制文件、配置文件和其他相关文件等。在 Linux 系统中，默认安装目录为 <code>/usr/bin/docker</code></p><p>Docker 数据目录：这是 Docker 引擎用于存储容器、映像和其他数据的目录。在 Linux 系统中，默认数据目录为 <code>/var/lib/docker</code>。Docker 数据目录下通常包括以下几个子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containers：存储容器的相关数据，包括容器文件系统、元数据和日志等。</span><br><span class="line">image：存储 Docker 镜像的相关数据，包括镜像文件、元数据和缓存等。</span><br><span class="line">volumes：存储 Docker 数据卷的相关数据，包括数据卷文件和元数据等。</span><br><span class="line">networks：存储 Docker 网络的相关数据，包括网络配置和元数据等。</span><br></pre></td></tr></table></figure><p>Docker 配置目录：这是 Docker 引擎的配置目录，通常包括一些配置文件和证书等。在 Linux 系统中，默认配置目录为 <code>/etc/docker</code></p><p>Docker 日志目录：这是 Docker 引擎的日志目录，通常包括 Docker 引擎和容器的日志文件。在 Linux 系统中，默认日志目录为 <code>/var/log/docker</code></p><p>Docker 工作目录：这是 Docker 引擎的工作目录，通常用于存储一些临时文件和脚本等。在 Linux 系统中，默认工作目录为 <code>/var/lib/docker/tmp</code></p><h1 id="15-Docker命令"><a href="#15-Docker命令" class="headerlink" title="15. Docker命令"></a>15. Docker命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Common Commands:</span><br><span class="line">  run         Create and run a new container from an image</span><br><span class="line">  exec        Execute a command in a running container</span><br><span class="line">  ps          List containers</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  pull        Download an image from a registry</span><br><span class="line">  push        Upload an image to a registry</span><br><span class="line">  images      List images</span><br><span class="line">  login       Log in to a registry</span><br><span class="line">  logout      Log out from a registry</span><br><span class="line">  search      Search Docker Hub for images</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  info        Display system-wide information</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  buildx*     Docker Buildx (Docker Inc., v0.11.1)</span><br><span class="line">  compose*    Docker Compose (Docker Inc., v2.19.1)</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  image       Manage images</span><br><span class="line">  manifest    Manage Docker image manifests and manifest lists</span><br><span class="line">  network     Manage networks</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Swarm Commands:</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;/root/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to connect to the daemon (overrides</span><br><span class="line">                           DOCKER_HOST env var and default context set with &quot;docker context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level (&quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;)</span><br><span class="line">                           (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default &quot;/root/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-12-JavaScript%E5%85%A5%E9%97%A8/"/>
      <url>/2024/10/28/2023-01-12-JavaScript%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。</p><p>JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供。</p><p>JavaScript 的核心语法部分相当精简，只包括两个部分：基本的语法构造（比如操作符、控制结构、语句）和标准库（就是一系列具有各种功能的对象比如<code>Array</code>、<code>Date</code>、<code>Math</code>等）。除此之外，各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">6grakaltl9jqgu5q1820p7ut6h[&quot;JavaScript&quot;] --&gt; 2dok06kmcti4t73ggilg6292qm[&quot;ECMAScript（描述了JS的语法和基本对象）&quot;]</span><br><span class="line">2dok06kmcti4t73ggilg6292qm --&gt; 0d0cagmk0dqfb1m6urujak5gnf[&quot;语法（如操作符、控制结构、语句）&quot;]</span><br><span class="line">2dok06kmcti4t73ggilg6292qm --&gt; 50dp4b935o9ovkf5qm7tfpnuc0[&quot;标准库（一系列具有各种功能的对象比如Array、Date、Math等）&quot;]</span><br><span class="line">6grakaltl9jqgu5q1820p7ut6h --&gt; 0r92lojgefbeumnadaoojsndbb[&quot;各种宿主环境提供额外的 API&quot;]</span><br><span class="line">0r92lojgefbeumnadaoojsndbb --&gt; 390qch630a7p93m86rr91g0rsi[&quot;浏览器&quot;]</span><br><span class="line">390qch630a7p93m86rr91g0rsi --&gt; 1jp4p38kq31jrecdi8m3hfm3vn[&quot;DOM类（DOM 是文档对象模型，DOM是为方便js操作html的，看起来就是html标签，js中通过document.get(...)获取dom节点的对象，再继续操作）&quot;]</span><br><span class="line">390qch630a7p93m86rr91g0rsi --&gt; 2br19pl5qsiks1cu6s5sfkih8s[&quot;BOM类（BOM 是浏览器对象模型，是用于操作浏览器而出现的API）&quot;]</span><br><span class="line">390qch630a7p93m86rr91g0rsi --&gt; 64oiq7o1akd77l89j6voh2m8nf[&quot;Web类（实现互联网的各种功能）&quot;]</span><br><span class="line">0r92lojgefbeumnadaoojsndbb --&gt; 6397lnesa4ndt98f7ui9ii1bho[&quot;服务器&quot;]</span><br><span class="line">6397lnesa4ndt98f7ui9ii1bho --&gt; 1lorm9132cuh1rkug4lbtd8lvj[&quot;node（各种操作系统的 API，比如文件操作 API、网络通信 API等等）&quot;]</span><br></pre></td></tr></table></figure><h1 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h1><ul><li>JavaScript 的所有值都是对象</li><li>是一种解释型语言，但是在现代浏览器中，JavaScript 都是编译后运行</li><li>JavaScript 程序可以采用事件驱动（event-driven）和非阻塞式（non-blocking）设计</li></ul><h1 id="3-作用域"><a href="#3-作用域" class="headerlink" title="3. 作用域"></a>3. 作用域</h1><p>ES5只有全局作用域和函数作用域，没有块级作用域</p><h1 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h1><p>命名规则：不能数字开头、不能以保留字命名、驼峰式命名法（第一个字母应小写，此后每一个单词中的第一个字母当为大写）</p><p><code>let</code>、<code>const</code>和<code>var</code>都是JavaScript中用于声明变量的关键字，但它们的行为和作用域规则有所不同。</p><p><strong>var</strong></p><p>这是最早的JavaScript变量声明方式，它的作用域是函数级的。如果在函数外部声明，它将成为全局变量。<code>var</code>声明的变量会被提升到它们所在的函数或全局作用域的顶部。在es6的语法中，已经不建议使用</p><p><strong>let</strong></p><p>这是ES6引入的新的变量声明方式，所声明的变量，只在<code>let</code>命令所在的代码块内有效（一个花括号内为一个代码块）</p><p><strong>const</strong></p><p>这也是ES6引入的，用于声明常量的关键字，它的作用域也是块级的。一旦被赋值，就不能改变。</p><p>在现代JavaScript开发中，建议尽可能使用<code>let</code>和<code>const</code>，因为它们的块级作用域规则更易于理解和管理。使用<code>const</code>可以明确表示变量的值不应该改变，这可以帮助防止在代码中意外地修改这个值。当你需要一个可以改变的变量时，使用<code>let</code>。尽量避免使用<code>var</code>，除非你有特定的理由需要函数级作用域或变量提升。</p><h1 id="5-数据类型"><a href="#5-数据类型" class="headerlink" title="5. 数据类型"></a>5. 数据类型</h1><p><strong>基础数据类型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String字符串</span><br><span class="line"></span><br><span class="line">Number数值型</span><br><span class="line"></span><br><span class="line">Boolean布尔型</span><br><span class="line"></span><br><span class="line">Null空值：使用typeof检测类型时，输出object型</span><br><span class="line"></span><br><span class="line">Undefined未定义型</span><br></pre></td></tr></table></figure><p><strong>引用数据类型</strong></p><p>Object对象</p><h1 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6. 运算符"></a>6. 运算符</h1><p>算术运算符：加、减、乘、<code>/</code> 除、<code>%</code> 取余</p><p>关系运算符：<code>==</code>、<code>===</code>恒等、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code></p><p>赋值运算符：<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></p><p>一元运算符：a++、++a</p><p>逻辑运算符：逻辑与 <code>&amp;&amp;</code>、逻辑或 <code>||</code>、逻辑非 <code>！</code>（<code>&amp;&amp;</code>优先于<code>||</code>）</p><h1 id="7-类型"><a href="#7-类型" class="headerlink" title="7. 类型"></a>7. 类型</h1><h2 id="7-1-相等与比较"><a href="#7-1-相等与比较" class="headerlink" title="7.1. 相等与比较"></a>7.1. 相等与比较</h2><h3 id="7-1-1-等于操作符"><a href="#7-1-1-等于操作符" class="headerlink" title="7.1.1. 等于操作符"></a>7.1.1. 等于操作符</h3><p>等于操作符由两个等号组成：<code>==</code></p><p>JavaScript 是弱类型语言，这就意味着，等于操作符会为了比较两个值而进行强制类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>           ==   <span class="string">&quot;0&quot;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ==   <span class="string">&quot;&quot;</span>            <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span>            ==   <span class="string">&quot;0&quot;</span>           <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="string">&quot;false&quot;</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="string">&quot;0&quot;</span>           <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ==   <span class="literal">null</span>          <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>         ==   <span class="literal">undefined</span>     <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot; ...&quot;</span>    ==   <span class="number">0</span>             <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的表格展示了强制类型转换，这也是使用 <code>==</code> 被广泛认为是不好编程习惯的主要原因， 由于它的复杂转换规则，会导致难以跟踪的问题。</p><p>此外，强制类型转换也会带来性能消耗，比如一个字符串为了和一个数字进行比较，必须事先被强制转换为数字。</p><h3 id="7-1-2-严格等于操作符"><a href="#7-1-2-严格等于操作符" class="headerlink" title="7.1.2. 严格等于操作符"></a>7.1.2. 严格等于操作符</h3><p>不像普通的等于操作符，严格等于操作符不会进行强制类型转换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>           ===   <span class="string">&quot;0&quot;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ===   <span class="string">&quot;&quot;</span>            <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span>            ===   <span class="string">&quot;0&quot;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="string">&quot;false&quot;</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="string">&quot;0&quot;</span>           <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span>        ===   <span class="literal">null</span>          <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span>         ===   <span class="literal">undefined</span>     <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot; ...&quot;</span>    ===   <span class="number">0</span>             <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面的结果更加清晰并有利于代码的分析。如果两个操作数类型不同就肯定不相等也有助于性能的提升。</p><h3 id="7-1-3-比较对象"><a href="#7-1-3-比较对象" class="headerlink" title="7.1.3. 比较对象"></a>7.1.3. 比较对象</h3><p>这里等于操作符比较的<strong>不是</strong>值是否相等，而是是否属于同一个<strong>身份</strong>；也就是说，只有对象的同一个实例才被认为是相等的。 这有点像 Python 中的 <code>is</code> 和 C 中的指针比较。</p><h2 id="7-2-typeof-操作符"><a href="#7-2-typeof-操作符" class="headerlink" title="7.2. typeof 操作符"></a>7.2. <code>typeof</code> 操作符</h2><p><code>typeof</code> 只有一个实际的应用（这个实际应用是用来检测一个对象是否已经定义或者是否已经赋值）， 而这个应用却<strong>不是</strong>用来检查对象的类型</p><h3 id="7-2-1-对象的类定义"><a href="#7-2-1-对象的类定义" class="headerlink" title="7.2.1. 对象的类定义"></a>7.2.1. 对象的类定义</h3><p>JavaScript 标准文档只给出了一种获取 <code>[[Class]]</code> 值的方法，那就是使用 <code>Object.prototype.toString</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"><span class="comment">// 通过 `slice` 截取指定位置的字符串</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(a).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>))</span><br></pre></td></tr></table></figure><h3 id="7-2-2-测试未定义变量"><a href="#7-2-2-测试未定义变量" class="headerlink" title="7.2.2. 测试未定义变量"></a>7.2.2. 测试未定义变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> foo !== <span class="string">&#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure><p>上面代码会检测 <code>foo</code> 是否已经定义；如果没有定义而直接使用会导致 <code>ReferenceError</code> 的异常。 这是 <code>typeof</code> 唯一有用的地方。</p><h2 id="7-3-instanceof-操作符"><a href="#7-3-instanceof-操作符" class="headerlink" title="7.3. instanceof 操作符"></a>7.3. <code>instanceof</code> 操作符</h2><p><code>instanceof</code> 操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义</p><h2 id="7-4-类型转换"><a href="#7-4-类型转换" class="headerlink" title="7.4. 类型转换"></a>7.4. 类型转换</h2><p>JavaScript 是弱类型语言，如果对数据类型有要求应该使用<strong>强制类型转换</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>()：转为整型</span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>()：转为浮点型</span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>()：转为数值型</span><br><span class="line"></span><br><span class="line"><span class="title class_">String</span>()：转为字符串型</span><br><span class="line"></span><br><span class="line"><span class="title class_">Boolean</span>()：转换为布尔型，转为<span class="literal">false</span>（<span class="number">0</span>、空），其余都会转为<span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="8-数组"><a href="#8-数组" class="headerlink" title="8. 数组"></a>8. 数组</h1><p>由于 <code>for in</code> 循环会枚举原型链上的所有属性，唯一过滤这些属性的方式是使用 hasOwnProperty 函数， 因此会比普通的 <code>for</code> 循环慢上好多倍。</p><h2 id="8-1-数组遍历与属性"><a href="#8-1-数组遍历与属性" class="headerlink" title="8.1. 数组遍历与属性"></a>8.1. 数组遍历与属性</h2><h3 id="8-1-1-遍历"><a href="#8-1-1-遍历" class="headerlink" title="8.1.1. 遍历"></a>8.1.1. 遍历</h3><p>为了达到遍历数组的最佳性能，推荐使用经典的 for 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, ...... <span class="number">100000000</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>, l = list.<span class="property">length</span>; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(list[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码有一个处理，就是通过 l = list.length 来缓存数组的长度。</p><p>虽然 length 是数组的一个属性，但是在每次循环中访问它还是有性能开销。</p><h3 id="8-1-2-length-属性"><a href="#8-1-2-length-属性" class="headerlink" title="8.1.2. length 属性"></a>8.1.2. <code>length</code> 属性</h3><p><code>length</code> 属性的 <em>getter</em> 方式会简单的返回数组的长度，而 <em>setter</em> 方式会<strong>截断</strong>数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]; </span><br><span class="line">foo.<span class="property">length</span> = <span class="number">3</span>; </span><br><span class="line">foo; <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="8-2-Array-构造函数"><a href="#8-2-Array-构造函数" class="headerlink" title="8.2. Array 构造函数"></a>8.2. <code>Array</code> 构造函数</h2><p>由于 <code>Array</code> 的构造函数在如何处理参数时有点模棱两可，因此总是推荐使用数组的字面语法 <code>[]</code>  来创建数组</p><h1 id="9-函数"><a href="#9-函数" class="headerlink" title="9. 函数"></a>9. 函数</h1><h2 id="9-1-函数声明与表达式"><a href="#9-1-函数声明与表达式" class="headerlink" title="9.1. 函数声明与表达式"></a>9.1. 函数声明与表达式</h2><p>函数是 JavaScript 中的一种对象，这意味着可以把函数像值一样传递。 一个常见的用法是把匿名函数作为回调函数传递到异步函数中。</p><h3 id="9-1-1-函数声明"><a href="#9-1-1-函数声明" class="headerlink" title="9.1.1. 函数声明"></a>9.1.1. 函数声明</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><p>上面的方法会在执行前被 解析 (hoisted)，因此它存在于当前上下文的任意一个地方， 即使在函数定义体的上面被调用也是对的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 正常运行，因为foo在代码运行前已经被创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="9-1-2-匿名函数赋值表达式"><a href="#9-1-2-匿名函数赋值表达式" class="headerlink" title="9.1.2. 匿名函数赋值表达式"></a>9.1.2. 匿名函数赋值表达式</h3><p>把一个匿名的函数赋值给变量 <code>foo</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><p>错误方式<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo; <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// 出错：TypeError</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br></pre></td></tr></table></figure><br>由于 var 定义了一个声明语句，对变量 foo 的解析是在代码运行之前，因此 foo 变量在代码运行时已经被定义过了。</p><p>但是由于赋值语句只在运行时执行，因此在相应代码执行之前， foo 的值缺省为 undefined。</p><h2 id="9-2-this-的工作原理（重点）"><a href="#9-2-this-的工作原理（重点）" class="headerlink" title="9.2. this 的工作原理（重点）"></a>9.2. <code>this</code> 的工作原理（重点）</h2><p><strong>谁调用了函数，this就指向谁</strong></p><p>JavaScript 有一套完全不同于其它语言的对 <code>this</code> 的处理机制。 在不同的情况下 ，<code>this</code> 指向的各不相同</p><p><strong>全局范围内</strong></p><p>当在全局范围内使用 <code>this</code>，它将会指向全局对象。在浏览器中运行的 JavaScript 脚本，这个全局对象是 <code>window</code></p><p><strong>通过<code>函数名()</code> 直接调用</strong></p><p>这里 <code>this</code> 也会指向全局对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;  </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="title function_">func</span>();<span class="comment">//this指向window</span></span><br></pre></td></tr></table></figure></p><blockquote><p><strong>ES5 注意:</strong> 在严格模式下（strict mode），不存在全局变量。 这种情况下 <code>this</code> 将会是 <code>undefined</code>。</p></blockquote><p><strong>方法调用：<code>对象.函数名()</code> 调用</strong></p><p>this指向这个对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="title function_">func</span>(); </span><br></pre></td></tr></table></figure></p><p><strong>调用构造函数</strong></p><p>函数作为构造函数，用new关键字调用，this指向新new出的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obg = <span class="keyword">new</span> <span class="title function_">func</span>();<span class="comment">//this指向new出的新obg</span></span><br></pre></td></tr></table></figure><p><strong>函数作为数组的一个元素，通过数组下标调用 —-&gt; this指向数组</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [func,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];  </span><br><span class="line">arr[<span class="number">0</span>]();<span class="comment">//this指向arr</span></span><br></pre></td></tr></table></figure></p><p><strong>函数作为window内置函数的回调函数调用 —-&gt; this指向window</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(func,<span class="number">1000</span>);<span class="comment">//this指向window</span></span><br></pre></td></tr></table></figure></p><h2 id="9-3-闭包和引用"><a href="#9-3-闭包和引用" class="headerlink" title="9.3. 闭包和引用"></a>9.3. 闭包和引用</h2><p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域<strong>总是</strong>能够访问外部作用域中的变量。 因为 函数 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p><h2 id="9-4-arguments-对象"><a href="#9-4-arguments-对象" class="headerlink" title="9.4. arguments 对象"></a>9.4. <code>arguments</code> 对象</h2><p>JavaScript 中每个函数内都能访问一个特别变量 <code>arguments</code>。这个变量维护着所有传递到这个函数中的参数列表</p><p>注意: 由于 arguments 已经被定义为函数内的一个变量。 因此通过 var 关键字定义 arguments 或者将 arguments 声明为一个形式参数， 都将导致原生的 arguments 不会被创建。</p><p>arguments 变量不是一个数组（Array），实际上它是一个对象（Object）。因此，无法对 arguments 变量使用标准的数组方法</p><p><strong>转化为数组</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br></pre></td></tr></table></figure><p><strong>自动更新</strong></p><p><code>arguments</code> 对象为其内部属性以及函数形式参数创建 <em>getter</em> 和 <em>setter</em> 方法</p><p>因此，改变形参的值会影响到 <code>arguments</code> 对象的值，反之亦然</p><p><strong>ES5 提示:</strong> 这些 <em>getters</em> 和 <em>setters</em> 在严格模式下（strict mode）不会被创建。</p><h2 id="9-5-作用域与命名空间"><a href="#9-5-作用域与命名空间" class="headerlink" title="9.5. 作用域与命名空间"></a>9.5. 作用域与命名空间</h2><p>尽管 JavaScript 支持一对花括号创建的代码段，但是并不支持块级作用域； 而仅仅支持 <em>函数作用域</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123; <span class="comment">// 一个作用域</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123; <span class="comment">// 不是一个作用域</span></span><br><span class="line">        <span class="comment">// count</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>隐式的全局变量</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本 A</span></span><br><span class="line">foo = <span class="string">&#x27;42&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 脚本 B</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;42&#x27;</span></span><br></pre></td></tr></table></figure><p>脚本 A 在全局作用域内定义了变量 <code>foo</code>，而脚本 B 在当前作用域内定义变量 <code>foo</code>。</p><p>再次强调，上面的效果<strong>完全不同</strong>，不使用 <code>var</code> 声明变量将会导致隐式的全局变量产生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 局部作用域</span></span><br><span class="line"></span><br><span class="line">    foo = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo); <span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>在函数 <code>test</code> 内不使用 <code>var</code> 关键字声明 <code>foo</code> 变量将会覆盖外部的同名变量。 起初这看起来并不是大问题，但是当有成千上万行代码时，不使用 <code>var</code> 声明变量将会带来难以跟踪的 BUG</p><p><strong>局部变量</strong></p><p>JavaScript 中局部变量只可能通过两种方式声明，一个是作为函数参数，另一个是通过 <code>var</code> 关键字声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">i</span>) &#123;</span><br><span class="line">    <span class="comment">// 函数 test 内的局部作用域</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line">    bar = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><code>foo</code> 和 <code>i</code> 是函数 <code>test</code> 内的局部变量，而对 <code>bar</code> 的赋值将会覆盖全局作用域内的同名变量。</p><p><strong>名称解析顺序</strong></p><p>当访问函数内的 foo 变量时，JavaScript 会按照下面顺序查找：</p><ol><li>当前作用域内是否有 var foo 的定义。</li><li>函数形式参数是否有使用 foo 名称的。</li><li>函数自身是否叫做 foo。</li><li>回溯到上一级作用域，然后从 <code>#1</code> 重新开始。</li></ol><p><strong>命名空间</strong></p><p>推荐使用匿名包装器（也就是自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突， 而且有利于程序的模块化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( <span class="comment">// 小括号内的函数首先被执行</span></span><br><span class="line"><span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">) <span class="comment">// 并且返回函数对象</span></span><br><span class="line">() <span class="comment">// 调用上面的执行结果，也就是函数对象</span></span><br></pre></td></tr></table></figure><p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外两种方式</span></span><br><span class="line">+<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;();</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;());</span><br></pre></td></tr></table></figure></p><h1 id="10-对象"><a href="#10-对象" class="headerlink" title="10. 对象"></a>10. 对象</h1><h2 id="10-1-对象和属性"><a href="#10-1-对象和属性" class="headerlink" title="10.1. 对象和属性"></a>10.1. 对象和属性</h2><p>JavaScript 中所有变量都可以当作对象使用，除了两个例外 null 和 undefined</p><p>一个常见的误解是数字的字面值（literal）不能当作对象使用。这是因为 JavaScript 解析器的一个错误， 它试图将点操作符解析为浮点数字面值的一部分。有很多变通方法可以让数字的字面值看起来像对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>.<span class="title function_">toString</span>(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .<span class="title function_">toString</span>(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).<span class="title function_">toString</span>(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure><h3 id="10-1-1-对象作为数据类型"><a href="#10-1-1-对象作为数据类型" class="headerlink" title="10.1.1. 对象作为数据类型"></a>10.1.1. 对象作为数据类型</h3><p>JavaScript 的对象可以作为哈希表使用，主要用来保存命名的键与值的对应关系</p><p>使用对象的字面语法  <code>&#123;&#125;</code>  可以创建一个简单对象，没有任何自定义属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;&#125;; <span class="comment">// 一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个新对象，拥有一个值为12的自定义属性&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">var</span> bar = &#123;<span class="attr">test</span>: <span class="number">12</span>&#125;; </span><br></pre></td></tr></table></figure><h3 id="10-1-2-访问属性"><a href="#10-1-2-访问属性" class="headerlink" title="10.1.2. 访问属性"></a>10.1.2. 访问属性</h3><p>有两种方式来访问对象的属性，点操作符或者中括号操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">name</span>: <span class="string">&#x27;kitten&#x27;</span>&#125;</span><br><span class="line">foo.<span class="property">name</span>; <span class="comment">// kitten</span></span><br><span class="line">foo[<span class="string">&#x27;name&#x27;</span>]; <span class="comment">// kitten</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> get = <span class="string">&#x27;name&#x27;</span>;</span><br><span class="line">foo[get]; <span class="comment">// kitten</span></span><br><span class="line"></span><br><span class="line">foo<span class="number">.1234</span>; <span class="comment">// SyntaxError</span></span><br><span class="line">foo[<span class="string">&#x27;1234&#x27;</span>]; <span class="comment">// works</span></span><br></pre></td></tr></table></figure><p>两种语法是等价的，点操作符是推荐做法，但是中括号操作符在下面两种情况下依然有效</p><ul><li>动态设置属性</li><li>属性名不是一个有效的变量名（比如属性名中包含空格，或者属性名是 JS 的关键词）</li></ul><h3 id="10-1-3-删除属性"><a href="#10-1-3-删除属性" class="headerlink" title="10.1.3. 删除属性"></a>10.1.3. 删除属性</h3><p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性， 而<strong>仅仅</strong>是移除了属性和值的关联</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="property">bar</span> = <span class="literal">undefined</span>;</span><br><span class="line">obj.<span class="property">foo</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">baz</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(i)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i, <span class="string">&#x27;&#x27;</span> + obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-1-4-属性名的语法"><a href="#10-1-4-属性名的语法" class="headerlink" title="10.1.4. 属性名的语法"></a>10.1.4. 属性名的语法</h3><p>对象的属性名可以使用字符串或者普通字符声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    <span class="string">&#x27;case&#x27;</span>: <span class="string">&#x27;I am a keyword so I must be notated as a string&#x27;</span>,</span><br><span class="line">    <span class="attr">delete</span>: <span class="string">&#x27;I am a keyword too so me&#x27;</span> <span class="comment">// 出错：SyntaxError</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的第二种声明方式在 ECMAScript 5 之前会抛出 SyntaxError 的错误。</p><p>这个错误的原因是 delete 是 JavaScript 语言的一个关键词；因此为了在更低版本的 JavaScript 引擎下也能正常运行， 必须使用字符串字面值声明方式。</p><h2 id="10-2-原型"><a href="#10-2-原型" class="headerlink" title="10.2. 原型"></a>10.2. 原型</h2><p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员必修的功课。 要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。 更进一步，绝对不要扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p><h2 id="10-3-for-in-循环"><a href="#10-3-for-in-循环" class="headerlink" title="10.3. for in 循环"></a>10.3. <code>for in</code> 循环</h2><p><strong>对象的遍历</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(键 <span class="keyword">in</span> 对象)&#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(对象名[键]);&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-常用封装对象"><a href="#10-4-常用封装对象" class="headerlink" title="10.4. 常用封装对象"></a>10.4. 常用封装对象</h2><p><strong>数学对象Math</strong></p><p>取绝对值 <code>.abs()</code>、取随机数 <code>.random()</code>、向下取整<code>.rnd()</code></p><p><strong>时间对象Date</strong></p><p>JS中获取的时间是计算本地时间</p><p>实例化构造函数获取时间对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> da = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br></pre></td></tr></table></figure><p>获取小时 <code>.getHours()</code></p><p>获取年 <code>.getFullYear()</code></p><p>获取月份   <code>.getMonth()</code></p><p>JS中月份的数组是从0开始的</p><p>获取日期 <code>.getDate()</code></p><p><strong>数组对象<code>[]</code></strong></p><p>获取数组长度<code>.length</code></p><p>插入元素 <code>.push(元素)</code></p><p>删除最后一个元素<code>.pop()</code></p><p><strong>字符串对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>  n = <span class="string">&#x27;JavaScript&#x27;</span></span><br></pre></td></tr></table></figure><p>将字符串全转为小写 <code>.toLowerCase()</code></p><p>将字符串全转为大写 <code>.toUpperCase()</code></p><h1 id="11-核心"><a href="#11-核心" class="headerlink" title="11. 核心"></a>11. 核心</h1><h2 id="11-1-不要使用-eval"><a href="#11-1-不要使用-eval" class="headerlink" title="11.1. 不要使用 eval"></a>11.1. 不要使用 <code>eval</code></h2><p><code>eval</code> 函数会在当前作用域中执行一段 JavaScript 代码字符串。在<strong>任何情况下</strong>我们都应该避免使用 <code>eval</code> 函数。99.9% 使用 <code>eval</code> 的场景都有<strong>不使用</strong> <code>eval</code> 的解决方案</p><h2 id="11-2-undefined-和-null"><a href="#11-2-undefined-和-null" class="headerlink" title="11.2. undefined 和 null"></a>11.2. <code>undefined</code> 和 <code>null</code></h2><p>JavaScript 有两个表示<code>空</code>的值，其中比较有用的是 <code>undefined</code></p><p>下面的情况会返回 undefined 值：</p><ul><li>访问未修改的全局变量 undefined。</li><li>由于没有定义 return 表达式的函数隐式返回。</li><li>return 表达式没有显式的返回任何内容。</li><li>访问不存在的属性。</li><li>函数参数没有被显式的传递值。</li><li>任何被设置为 undefined 值的变量。</li></ul><h2 id="11-3-自动分号插入"><a href="#11-3-自动分号插入" class="headerlink" title="11.3. 自动分号插入"></a>11.3. 自动分号插入</h2><p>尽管 JavaScript 有 C 的代码风格，但是它不强制要求在代码中使用分号，实际上可以省略它们。</p><p>JavaScript 不是一个没有分号的语言，恰恰相反上它需要分号来就解析源代码。 因此 JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会自动在源代码中插入分号。</p><p>建议绝对不要省略分号，同时也提倡将花括号和相应的表达式放在一行， 对于只有一行代码的 if 或者 else 表达式，也不应该省略花括号。 这些良好的编程习惯不仅可以提到代码的一致性，而且可以防止解析器改变代码行为的错误处理。</p><h1 id="12-事件"><a href="#12-事件" class="headerlink" title="12. 事件"></a>12. 事件</h1><h2 id="12-1-何为事件"><a href="#12-1-何为事件" class="headerlink" title="12.1. 何为事件"></a>12.1. 何为事件</h2><p>用户鼠标的点击，键盘某个按键的点击</p><h2 id="12-2-基本交互方法"><a href="#12-2-基本交互方法" class="headerlink" title="12.2. 基本交互方法"></a>12.2. 基本交互方法</h2><p>输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(内容)</span><br></pre></td></tr></table></figure><p>信息对话框：alert(内容)，接收到的是字符串值</p><p>选择对话框：confirm(内容)，接收一个参数，并转为字符串显示，返回一个值，true或false</p><p>显示提示的对话框：prompt(提示文本内容，文本输入框为默认文本)，接收两个参数，第二个参数可不填，只返回一个值，用户点击取消时，返回null</p><h1 id="13-ES6"><a href="#13-ES6" class="headerlink" title="13. ES6"></a>13. ES6</h1><p>ECMAScript 6.0（以下简称 ES6）。ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的</p><p><strong>最常用的ES6特性</strong></p><p><code>let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments</code>  这些是ES6最常用的几个语法</p><h2 id="13-1-let-和-const"><a href="#13-1-let-和-const" class="headerlink" title="13.1. let 和 const"></a>13.1. let 和 const</h2><p><strong>使用 let 声明变量</strong></p><p><code>let</code>实际上为JavaScript新增了块级作用域。用它所声明的变量，只在<code>let</code>命令所在的代码块内有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let name = &#x27;zach&#x27;</span><br><span class="line"></span><br><span class="line">while (true) &#123;</span><br><span class="line">    let name = &#x27;obama&#x27;</span><br><span class="line">    console.log(name)  //obama</span><br><span class="line">    break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(name)  //zach</span><br></pre></td></tr></table></figure><p><strong>使用 const 声明常量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const PI = Math.PI</span><br></pre></td></tr></table></figure><p>const有一个很好的应用场景，就是当我们引用第三方库的时候，用const来声明可以避免未来不小心重命名而导致出现bug：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const monent = require(&#x27;moment&#x27;)</span><br></pre></td></tr></table></figure><h2 id="13-2-class-extends-super"><a href="#13-2-class-extends-super" class="headerlink" title="13.2. class, extends, super"></a>13.2. class, extends, super</h2><p>这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…，ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &#x27;animal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        console.log(this.type + &#x27; says &#x27; + say)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let animal = new Animal()</span><br><span class="line">animal.says(&#x27;hello&#x27;) //animal says hello</span><br><span class="line"></span><br><span class="line">class Cat extends Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super()</span><br><span class="line">        this.type = &#x27;cat&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cat = new Cat()</span><br><span class="line">cat.says(&#x27;hello&#x27;) //cat says hello</span><br></pre></td></tr></table></figure><p>上面代码首先用<code>class</code>定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。简单地说，<code>constructor</code>内定义的方法和属性是实例对象自己的，而<code>constructor</code>外定义的方法和属性则是所有实例对象可以共享的。</p><p>Class之间可以通过<code>extends</code>关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过<code>extends</code>关键字，继承了Animal类的所有属性和方法。</p><p><code>super</code>关键字，它指代父类的实例（即父类的this对象）。子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><p>ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><p>P.S 如果你写react的话，就会发现以上三个东西在最新版React中出现得很多。创建的每个component都是一个继承<code>React.Component</code>的类</p><h2 id="13-3-arrow-function（箭头函数）"><a href="#13-3-arrow-function（箭头函数）" class="headerlink" title="13.3. arrow function（箭头函数）"></a>13.3. arrow function（箭头函数）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function(i)&#123; return i + 1; &#125; //ES5</span><br><span class="line">(i) =&gt; i + 1 //ES6</span><br></pre></td></tr></table></figure><p>如果方程比较复杂，则需要用<code>&#123;&#125;</code>把代码包起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function(x, y) &#123; //ES5</span><br><span class="line">    x++;</span><br><span class="line">    y--;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">(x, y) =&gt; &#123;x++; y--; return x+y&#125; //ES6</span><br></pre></td></tr></table></figure><p><strong>arrow function还有一项超级无敌的功能</strong></p><p>当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &#x27;animal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout(function()&#123;</span><br><span class="line">            console.log(this.type + &#x27; says &#x27; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&#x27;hi&#x27;)  //undefined says hi</span><br></pre></td></tr></table></figure><p>运行上面的代码会报错，这是因为<code>setTimeout</code>中的<code>this</code>指向的是全局对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        this.type = &#x27;animal&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    says(say)&#123;</span><br><span class="line">        setTimeout( () =&gt; &#123;</span><br><span class="line">            console.log(this.type + &#x27; says &#x27; + say)</span><br><span class="line">        &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> var animal = new Animal()</span><br><span class="line"> animal.says(&#x27;hi&#x27;)  //animal says hi</span><br></pre></td></tr></table></figure><h2 id="13-4-template-string（模板字符串）"><a href="#13-4-template-string（模板字符串）" class="headerlink" title="13.4. template string（模板字符串）"></a>13.4. template string（模板字符串）</h2><p>这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦</p><p>用反引号 ` 来包裹，用<code>$&#123;&#125;</code>来引用变量，而且所有的空格和缩进都会被保留在输出之中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Alice&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`Hello, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">     name&#125;</span>!</span></span><br><span class="line"><span class="string">This is a multiline string.`</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br></pre></td></tr></table></figure><h2 id="13-5-destructuring（解构）"><a href="#13-5-destructuring（解构）" class="headerlink" title="13.5. destructuring（解构）"></a>13.5. destructuring（解构）</h2><p>ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构</p><p>看下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cat = &#x27;ken&#x27;</span><br><span class="line">let dog = &#x27;lili&#x27;</span><br><span class="line">let zoo = &#123;cat: cat, dog: dog&#125;</span><br><span class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</span><br></pre></td></tr></table></figure><p>用ES6完全可以像下面这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let cat = &#x27;ken&#x27;</span><br><span class="line">let dog = &#x27;lili&#x27;</span><br><span class="line">let zoo = &#123;cat, dog&#125;</span><br><span class="line">console.log(zoo)  //Object &#123;cat: &quot;ken&quot;, dog: &quot;lili&quot;&#125;</span><br></pre></td></tr></table></figure><p>反过来可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let dog = &#123;type: &#x27;animal&#x27;, many: 2&#125;</span><br><span class="line">let &#123; type, many&#125; = dog</span><br><span class="line">console.log(type, many)   //animal 2</span><br></pre></td></tr></table></figure><p><code>const &#123; printName &#125; = logger</code> 等于<code>const printName = logger.printName</code></p><h2 id="13-6-default（默认值）"><a href="#13-6-default（默认值）" class="headerlink" title="13.6. default（默认值）"></a>13.6. default（默认值）</h2><p>在函数定义时为参数指定默认值，简化函数调用时的参数传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">greet</span>(<span class="params">name = <span class="string">&#x27;World&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hello, <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="subst"><span class="string">       name&#125;</span>!`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">greet</span>(); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">  <span class="title function_">greet</span>(<span class="string">&#x27;Alice&#x27;</span>); <span class="comment">// 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure><h2 id="13-7-运算符"><a href="#13-7-运算符" class="headerlink" title="13.7. ...运算符"></a>13.7. <code>...</code>运算符</h2><p><strong>函数 <code>rest</code> 参数的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f(a, ...b) &#123;</span><br><span class="line">    console.log(a, b)</span><br><span class="line">&#125;</span><br><span class="line">f(1,2,3,4,5) // 1 [2,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>数组拆解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const a = [1,2,3]</span><br><span class="line">const b = [4,5,6]</span><br><span class="line">const c = [...a, ...b]</span><br><span class="line">c // [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure><p><strong>对象拆解</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; a: 111, b:222 &#125;</span><br><span class="line">const copyObj = &#123; ...obj, c: 333 &#125;</span><br><span class="line">copyObj // &#123; a: 111, b:222, c: 333 &#125;</span><br></pre></td></tr></table></figure><h2 id="13-8-import和export"><a href="#13-8-import和export" class="headerlink" title="13.8. import和export"></a>13.8. import和export</h2><p>这两个对应的就是es6自己的<code>module</code>功能。ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</p><h3 id="13-8-1-传统的写法"><a href="#13-8-1-传统的写法" class="headerlink" title="13.8.1. 传统的写法"></a>13.8.1. 传统的写法</h3><p>首先我们回顾下require.js的写法。假设我们有两个js文件: <code>index.js</code>和<code>content.js</code>,现在我们想要在<code>index.js</code>中使用<code>content.js</code>返回的结果，我们要怎么做呢？</p><p>首先定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line">define(&#x27;content.js&#x27;, function()&#123;</span><br><span class="line">    return &#x27;A cat&#x27;;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后require：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">require([&#x27;./content.js&#x27;], function(animal)&#123;</span><br><span class="line">    console.log(animal);   //A cat</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那CommonJS是怎么写的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">var animal = require(&#x27;./content.js&#x27;)</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">module.exports = &#x27;A cat&#x27;</span><br></pre></td></tr></table></figure><h3 id="13-8-2-ES6的写法"><a href="#13-8-2-ES6的写法" class="headerlink" title="13.8.2. ES6的写法"></a>13.8.2. ES6的写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line">import animal from &#x27;./content&#x27;</span><br><span class="line"></span><br><span class="line">//content.js</span><br><span class="line">export default &#x27;A cat&#x27;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>export default</code> 用于导出一个默认的模块，而 <code>export &#123;&#125;</code> 用于导出多个模块。区别在导入时，<code>export default</code>导出的不要使用大括号引入，而 <code>export &#123;&#125;</code>导出的需要使用大括号并指定导出的模块名称</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 导出</span><br><span class="line">export default Index;</span><br><span class="line">// 导入</span><br><span class="line">import Index</span><br><span class="line"></span><br><span class="line">// 导出</span><br><span class="line">export &#123;Index&#125;;</span><br><span class="line">// 导入</span><br><span class="line">import &#123;Index&#125;</span><br></pre></td></tr></table></figure><h2 id="13-9-ES6-module的其他高级用法"><a href="#13-9-ES6-module的其他高级用法" class="headerlink" title="13.9. ES6 module的其他高级用法"></a>13.9. ES6 module的其他高级用法</h2><h3 id="13-9-1-输出输入多个变量"><a href="#13-9-1-输出输入多个变量" class="headerlink" title="13.9.1. 输出输入多个变量"></a>13.9.1. 输出输入多个变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//content.js</span><br><span class="line"></span><br><span class="line">export default &#x27;A cat&#x27;    </span><br><span class="line">export function say()&#123;</span><br><span class="line">    return &#x27;Hello!&#x27;</span><br><span class="line">&#125;    </span><br><span class="line">export const type = &#x27;dog&#x27; </span><br></pre></td></tr></table></figure><p>上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import &#123; say, type &#125; from &#x27;./content&#x27;  </span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;type&#125; says $&#123;says&#125;`)  //The dog says Hello</span><br></pre></td></tr></table></figure><p>这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。</p><p>如果还希望输入content.js中输出的默认值(default), 可以写在大括号外面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, &#123; say, type &#125; from &#x27;./content&#x27;  </span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;type&#125; says $&#123;says&#125; to $&#123;animal&#125;`)  </span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><h3 id="13-9-2-修改变量名"><a href="#13-9-2-修改变量名" class="headerlink" title="13.9.2. 修改变量名"></a>13.9.2. 修改变量名</h3><p>此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用<code>as</code>实现一键换名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, &#123; say, type as animalType &#125; from &#x27;./content&#x27;  </span><br><span class="line">let says = say()</span><br><span class="line">console.log(`The $&#123;animalType&#125; says $&#123;says&#125; to $&#123;animal&#125;`)  </span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><h3 id="13-9-3-模块的整体加载"><a href="#13-9-3-模块的整体加载" class="headerlink" title="13.9.3. 模块的整体加载"></a>13.9.3. 模块的整体加载</h3><p>除了指定加载某个输出值，还可以使用整体加载，即用星号（<code>*</code>）指定一个对象，所有输出值都加载在这个对象上面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//index.js</span><br><span class="line"></span><br><span class="line">import animal, * as content from &#x27;./content&#x27;  </span><br><span class="line">let says = content.say()</span><br><span class="line">console.log(`The $&#123;content.type&#125; says $&#123;says&#125; to $&#123;animal&#125;`)  </span><br><span class="line">//The dog says Hello to A cat</span><br></pre></td></tr></table></figure><p>通常星号<code>*</code>结合<code>as</code>一起使用比较合适。</p><h2 id="13-10-Promise"><a href="#13-10-Promise" class="headerlink" title="13.10. Promise"></a>13.10. Promise</h2><p>一种用来处理异步操作的对象，它可以让异步操作更加简洁、可读和可维护</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fetchData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 异步操作</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;Data fetched successfully.&#x27;</span>);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;first&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">fetchData</span>()</span><br><span class="line">    .<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(data))</span><br><span class="line">    .<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">error</span>(error));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端三大件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2023-01-26-python%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/10/28/2023-01-26-python%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-python3-x特性"><a href="#1-python3-x特性" class="headerlink" title="1. python3.x特性"></a>1. python3.x特性</h1><h2 id="1-1-python编码问题"><a href="#1-1-python编码问题" class="headerlink" title="1.1. python编码问题"></a>1.1. python编码问题</h2><ul><li>python3.x 默认的内部编码是Unicode，默认的文件编码是utf-8</li></ul><ul><li>代码中的字符串的默认编码与代码文件本身的编码是一致的</li><li><strong>python的内部编码为unicode，与文件本身的编码无关</strong></li></ul><h3 id="1-1-1-声明文件编码"><a href="#1-1-1-声明文件编码" class="headerlink" title="1.1.1. 声明文件编码"></a>1.1.1. 声明文件编码</h3><ul><li><code># -*- coding: UTF-8 -*-</code> </li><li><code>#coding=utf-8</code></li></ul><h3 id="1-1-2-文件编码"><a href="#1-1-2-文件编码" class="headerlink" title="1.1.2. 文件编码"></a>1.1.2. 文件编码</h3><p>文件本身的编码指的是<strong>文件保存在磁盘上时所使用的字符编码</strong>，通常使用UTF-8编码或其他编码方式</p><h3 id="1-1-3-内部编码"><a href="#1-1-3-内部编码" class="headerlink" title="1.1.3. 内部编码"></a>1.1.3. 内部编码</h3><p>内部编码指的是<strong>Python解释器在内存中使用的字符编码</strong>，也是默认的字符串编码方式。Python 3.x 中默认的内部编码是Unicode（UTF-8编码的一种），所以支持多种语言和字符集。当我们读取文件或从其他数据源中获取数据时，Python会自动将其转换为内部编码，当我们将数据写入文件或在屏幕上输出时，Python也会自动将其转换为指定的编码方式。</p><p>这一点和 Java 一样</p><h2 id="1-2-其他特性"><a href="#1-2-其他特性" class="headerlink" title="1.2. 其他特性"></a>1.2. 其他特性</h2><ul><li>python对大小写敏感</li><li>python通过缩进来控制结构层次（通常4个空格为一个标准缩进）</li><li>使用斜杠<code>\</code> 实现换行代码的衔接</li><li>id() 获取内存地址</li><li>type()  获取数据类型 </li><li>help(方法名称)  查看某方法的使用</li><li>import + 库名 导入库</li><li>库名.方法名  调用库中某方法</li><li>python库安装和卸载</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">安装：pip install 库名 -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">卸载： pip uninstall 库名</span><br></pre></td></tr></table></figure><ul><li>更新pip</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd下运行python -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><h1 id="2-python编写规范"><a href="#2-python编写规范" class="headerlink" title="2. python编写规范"></a>2. python编写规范</h1><p><a href="https://legacy.python.org/dev/peps/pep-0008/">Python PEP8 编码规范</a></p><h1 id="3-python编译"><a href="#3-python编译" class="headerlink" title="3. python编译"></a>3. python编译</h1><p><code>.pyc</code>文件是py文件编译后生成的字节码文件(byte code)。pyc文件经过python解释器最终会生成机器码运行。所以pyc文件是可以跨平台部署的，类似Java的.class文件。</p><p><strong>生成单个pyc文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m foo.py</span><br></pre></td></tr></table></figure><p><strong>批量生成pyc文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m compileall &lt;dir&gt;</span><br></pre></td></tr></table></figure><h1 id="4-交互式编程"><a href="#4-交互式编程" class="headerlink" title="4. 交互式编程"></a>4. 交互式编程</h1><p>即直接在终端（如 cmd ）中运行解释器，而不使用文件名的方式来执行文件。这种交互式的编程环境，我们也可以称之为REPL，即读取(Read)输入的内容，执行(Eval)用户输入的指令，打印(Print)执行结果，然后进行循环(Loop)，Python支持交互式编程</p><p><code>ipython</code>是一个<code>python</code>的交互式<code>shell</code>，比默认的<code>python shell</code>好用得多，支持变量自动补全，自动缩进，支持<code>bash shell</code>命令，内置了许多很有用的功能和函数</p><h1 id="5-注释符"><a href="#5-注释符" class="headerlink" title="5. 注释符"></a>5. 注释符</h1><p><code>#</code></p><h1 id="6-变量"><a href="#6-变量" class="headerlink" title="6. 变量"></a>6. 变量</h1><p>只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要开发者主动的去说明它的类型，系统会自动辨别。<strong>变量没有类型，数据才有类型</strong></p><p>同时为多个变量赋值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Cherry&quot;</span></span><br></pre></td></tr></table></figure><p>交换a b的值  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b=b,a </span><br></pre></td></tr></table></figure><p><code>+</code>号连接字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;awesome&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python is &quot;</span> + x)</span><br></pre></td></tr></table></figure><p><code>*</code>重复多次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x= <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x*<span class="number">2</span>)</span><br><span class="line"><span class="comment">#结果为 abcabc</span></span><br></pre></td></tr></table></figure><h1 id="7-数据类型"><a href="#7-数据类型" class="headerlink" title="7. 数据类型"></a>7. 数据类型</h1><h2 id="7-1-数字类型（Number）"><a href="#7-1-数字类型（Number）" class="headerlink" title="7.1. 数字类型（Number）"></a>7.1. 数字类型（Number）</h2><p>包括整型、浮点型、复数等</p><h2 id="7-2-字符串类型（String）"><a href="#7-2-字符串类型（String）" class="headerlink" title="7.2. 字符串类型（String）"></a>7.2. 字符串类型（String）</h2><p>用于表示文本数据，可以使用单引号、双引号或三引号来定义字符串</p><h2 id="7-3-列表类型（List）"><a href="#7-3-列表类型（List）" class="headerlink" title="7.3. 列表类型（List）"></a>7.3. 列表类型（List）</h2><p>用于存储一组有序的元素，可以包含不同类型的元素，通过索引访问元素。</p><h2 id="7-4-元组类型（Tuple）"><a href="#7-4-元组类型（Tuple）" class="headerlink" title="7.4. 元组类型（Tuple）"></a>7.4. 元组类型（Tuple）</h2><p>类似于列表，但是元组中的元素不可修改，通常用于存储不可变的数据。</p><h2 id="7-5-集合类型（Set）"><a href="#7-5-集合类型（Set）" class="headerlink" title="7.5. 集合类型（Set）"></a>7.5. 集合类型（Set）</h2><p>用于存储一组不重复的元素，可以进行交、并、差等集合运算。</p><h2 id="7-6-字典类型（Dictionary）"><a href="#7-6-字典类型（Dictionary）" class="headerlink" title="7.6. 字典类型（Dictionary）"></a>7.6. 字典类型（Dictionary）</h2><p>用于存储键值对，可以通过键来访问对应的值，键必须是不可变的类型。</p><h2 id="7-7-布尔类型（Boolean）"><a href="#7-7-布尔类型（Boolean）" class="headerlink" title="7.7. 布尔类型（Boolean）"></a>7.7. 布尔类型（Boolean）</h2><p>用于表示真（True）和假（False）两种状态。</p><p><strong>不可变数据（3 个）</strong>：Number（数字）、String（字符串）、Tuple（元组）</p><p><strong>可变数据（3 个）</strong>：List（列表）、Dictionary（字典）、Set（集合）</p><h2 id="7-8-常用运算"><a href="#7-8-常用运算" class="headerlink" title="7.8. 常用运算"></a>7.8. 常用运算</h2><p><strong>科学计数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">科学计数法：</span><br><span class="line"><span class="number">1.5</span> x <span class="number">10</span>^<span class="number">11</span>表示为：</span><br><span class="line"></span><br><span class="line"><span class="number">1.5e11</span></span><br><span class="line">这里e和E不区分大小写</span><br></pre></td></tr></table></figure><p><strong>复数</strong></p><p>复数由实数部分和虚数部分组成，实数部分和虚数部分都是浮点型，虚数部分必须有后缀j或J</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> (<span class="number">64.375</span>+<span class="number">1j</span>)</span><br><span class="line">结果为<span class="number">64.375</span>+<span class="number">1j</span></span><br></pre></td></tr></table></figure><h2 id="7-9-类型转换"><a href="#7-9-类型转换" class="headerlink" title="7.9. 类型转换"></a>7.9. 类型转换</h2><ul><li>set(s) 转换为可变集合 </li><li>int() 转换为整型</li><li>str() 转换为字符型</li><li>float() 转换为浮点型</li><li>bool(x)  布尔型转换</li></ul><p>在python3中，只有空字符串<code>&#39;&#39;</code>、<code>&quot;&quot;</code> 、数字0、空字典<code>&#123;&#125;</code>、空列表<code>[]</code>、空元组<code>()</code>、空数据None会被转换成为False，其他的都会被转换成为True</p><ul><li>unichr(x)  ASCII码转为Unicode单字符串</li><li>abs()   取绝对值</li><li>round 四舍五入保留指定小数位</li><li>sum 求和</li><li>type() 查看数据的类型</li></ul><h1 id="8-标识符"><a href="#8-标识符" class="headerlink" title="8. 标识符"></a>8. 标识符</h1><p>标识符是用户编程时使用的名字，用于给变量、常量、函数、语句块等命名</p><h2 id="8-1-标识符命名"><a href="#8-1-标识符命名" class="headerlink" title="8.1. 标识符命名"></a>8.1. 标识符命名</h2><ul><li><p>由字母、下划线和数字组成，且数字不能开头</p></li><li><p>严格区分大小写</p></li><li><p>不能使用关键字</p></li></ul><h2 id="8-2-驼峰命名法"><a href="#8-2-驼峰命名法" class="headerlink" title="8.2. 驼峰命名法"></a>8.2. 驼峰命名法</h2><ul><li><p>大驼峰命名法：FirstName、LastName</p></li><li><p>小驼峰命名法：myName、aDog</p></li></ul><p><strong>注意</strong></p><ul><li>变量名，函数名和文件名全小写，使用下划线连接</li><li>类名遵守大驼峰命名法</li><li>常量名全大写</li></ul><h1 id="9-关键字"><a href="#9-关键字" class="headerlink" title="9. 关键字"></a>9. 关键字</h1><p>一些具有特殊功能的标识符</p><h1 id="10-输入输出"><a href="#10-输入输出" class="headerlink" title="10. 输入输出"></a>10. 输入输出</h1><h2 id="10-1-输入（input）"><a href="#10-1-输入（input）" class="headerlink" title="10.1. 输入（input）"></a>10.1. 输入（input）</h2><h3 id="10-1-1-语法"><a href="#10-1-1-语法" class="headerlink" title="10.1.1. 语法"></a>10.1.1. 语法</h3><p>返回字符串类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;提示信息&#x27;</span>)</span><br></pre></td></tr></table></figure><p>同时输入多个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a,b,c=<span class="built_in">input</span>().split(<span class="string">&#x27; &#x27;</span>)  <span class="comment">#输入a，b，c时 将a、b、c用空格隔开 </span></span><br></pre></td></tr></table></figure><h2 id="10-2-输出-print"><a href="#10-2-输出-print" class="headerlink" title="10.2. 输出(print)"></a>10.2. 输出(print)</h2><h3 id="10-2-1-语法"><a href="#10-2-1-语法" class="headerlink" title="10.2.1. 语法"></a>10.2.1. 语法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(value,sep,end)</span><br></pre></td></tr></table></figure><h3 id="10-2-2-参数"><a href="#10-2-2-参数" class="headerlink" title="10.2.2. 参数"></a>10.2.2. 参数</h3><p><strong>sep</strong></p><p>输出时，每个值使用哪种符号分割，默认使用空格</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">123</span>,<span class="number">789</span>,sep=<span class="string">&#x27;----&#x27;</span>)</span><br><span class="line"><span class="comment">#结果是 123----789</span></span><br></pre></td></tr></table></figure><p><strong>end</strong></p><p>执行完一个print语句后，接下来要输出的字符，默认是<code>\n</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">123</span>,<span class="number">789</span>,end=<span class="string">&#x27;????&#x27;</span>)</span><br><span class="line"><span class="comment">#结果是 123 789????</span></span><br></pre></td></tr></table></figure><h3 id="10-2-3-格式化输出"><a href="#10-2-3-格式化输出" class="headerlink" title="10.2.3. 格式化输出"></a>10.2.3. 格式化输出</h3><div class="table-container"><table><thead><tr><th>格式符号</th><th>转换</th></tr></thead><tbody><tr><td><code>%%</code></td><td>输出 <code>%</code> 号</td></tr><tr><td><code>%s</code></td><td>字符串</td></tr><tr><td><code>%d</code></td><td>有符号十进制整数</td></tr><tr><td><code>%f</code></td><td>浮点数</td></tr><tr><td><code>%c</code></td><td>字符</td></tr><tr><td><code>%u</code></td><td>无符号十进制整数</td></tr><tr><td><code>%o</code></td><td>八进制整数</td></tr><tr><td><code>%x</code></td><td>十六进制整数(小写字母<code>0x</code>)</td></tr><tr><td><code>%X</code></td><td>十六进制整数(大写字母<code>0X</code>)</td></tr><tr><td><code>%e</code></td><td>科学计数法(小写<code>e</code>)</td></tr><tr><td><code>%E</code></td><td>科学计数法(大写<code>E</code>)</td></tr><tr><td><code>%g</code></td><td><code>％f</code>和<code>％e</code> 的简写</td></tr><tr><td><code>%G</code></td><td><code>％f</code>和<code>％E</code>的简写</td></tr></tbody></table></div><p><strong>格式化操作符辅助指令</strong></p><div class="table-container"><table><thead><tr><th><strong>符号</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>*</td><td>定义宽度或者小数点精度</td></tr><tr><td>-</td><td>用做左对齐</td></tr><tr><td>+</td><td>在正数前面显示加号( + )</td></tr><tr><td><code>&lt;sp&gt;</code></td><td>在正数前面显示空格</td></tr><tr><td><code>#</code></td><td>在八进制数前面显示零<code>0</code>，在十六进制前面显示<code>0x</code>或者<code>0X</code></td></tr><tr><td>0</td><td>显示的数字前面填充’0’而不是默认的空格</td></tr><tr><td>(var)</td><td>映射变量(字典参数)</td></tr><tr><td>m.n</td><td>m 是显示的最小总宽度,n 是小数点后的位数</td></tr></tbody></table></div><h1 id="11-进制"><a href="#11-进制" class="headerlink" title="11. 进制"></a>11. 进制</h1><h2 id="11-1-进制的表示"><a href="#11-1-进制的表示" class="headerlink" title="11.1. 进制的表示"></a>11.1. 进制的表示</h2><ul><li>二进制<code>0b</code>开头</li><li>八进制<code>0o</code>开头</li><li>十六进制<code>0x</code>开头</li></ul><h2 id="11-2-进制转换"><a href="#11-2-进制转换" class="headerlink" title="11.2. 进制转换"></a>11.2. 进制转换</h2><ul><li>hex(x)</li></ul><p>将一个整数转换为一个十六进制字符串</p><ul><li>oct(x) </li></ul><p>将一个整数转换为一个八进制字符串</p><ul><li>bin(x)</li></ul><p>整型转为二进制字符串</p><ul><li>int(x,base)</li></ul><p>将字符串，转为指定进制(base)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;21&#x27;</span></span><br><span class="line">x = <span class="built_in">int</span>(x,<span class="number">8</span>)<span class="comment">#转为 8 进制</span></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#结果为 17</span></span><br><span class="line"></span><br><span class="line">y = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">y = <span class="built_in">int</span>(y,<span class="number">16</span>)<span class="comment">#转为 16 进制</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment">#结果为 2748</span></span><br></pre></td></tr></table></figure><h1 id="12-运算符"><a href="#12-运算符" class="headerlink" title="12. 运算符"></a>12. 运算符</h1><h2 id="12-1-赋值运算符"><a href="#12-1-赋值运算符" class="headerlink" title="12.1. 赋值运算符"></a>12.1. 赋值运算符</h2><p> <strong><code>=</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,*y = <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment"># * 设置y的长度可变</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment">#结果是 [3,4,5,6]</span></span><br></pre></td></tr></table></figure><h2 id="12-2-算术运算符"><a href="#12-2-算术运算符" class="headerlink" title="12.2. 算术运算符"></a>12.2. 算术运算符</h2><ul><li>除<code>/</code>  </li><li>乘<code>*</code></li><li>减<code>-</code></li><li>加<code>+</code></li><li>取余<code>%</code></li><li>幂次<code>**</code></li><li><code>//</code></li></ul><p>返回商的整数部分，向下取整，如，<code>5//2</code>，得2</p><ul><li><code>()</code>提高运算优先级</li></ul><h2 id="12-3-关系运算符"><a href="#12-3-关系运算符" class="headerlink" title="12.3. 关系运算符"></a>12.3. 关系运算符</h2><ul><li><code>&gt;</code></li><li><code>&lt;</code></li><li><code>&gt;=</code></li><li><code>&lt;=</code></li><li><code>!=</code></li><li><code>==</code></li></ul><p>比较内存地址</p><h3 id="12-3-1-字符串使用关系运算符"><a href="#12-3-1-字符串使用关系运算符" class="headerlink" title="12.3.1. 字符串使用关系运算符"></a>12.3.1. 字符串使用关系运算符</h3><ul><li>数字和字符串做<code>==</code> 运算，结果是 false</li><li>数字和字符串做除了<code>==</code>以外的逻辑运算时，会直接报错</li><li>两个字符串进行比较，会将每个字符都转换成对应的ASCII编码，然后逐一进行对比</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">if</span> y&gt;=x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;大&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="12-4-逻辑运算符"><a href="#12-4-逻辑运算符" class="headerlink" title="12.4. 逻辑运算符"></a>12.4. 逻辑运算符</h2><p><strong>and</strong></p><p>只要有一个运算数是False，结果就是False</p><p>只有所有的运算数都为True时，结果才是True</p><p>做取值运算时，取第一个为False的值，如果所<br>有的值都为True，取最后一个值</p><p><strong>or</strong> </p><p>只要有一个运算数是True，结果就是True</p><p>只有所有的运算数都为False时，结果才是<br>False</p><p>做取值运算时，取第一个为True的值，如果所<br>有的值都为False，取最后一个值</p><p><strong>not</strong></p><p>取反</p><h2 id="12-5-成员运算符"><a href="#12-5-成员运算符" class="headerlink" title="12.5. 成员运算符"></a>12.5. 成员运算符</h2><p>用来判断一个东西(比如变量)是不是在另一个范围(比如列表/字典/元组)里面，若是返回True 否则返回False</p><ul><li>in</li><li>not in</li></ul><h2 id="12-6-身份运算符"><a href="#12-6-身份运算符" class="headerlink" title="12.6. 身份运算符"></a>12.6. 身份运算符</h2><ul><li>is</li></ul><p>判断两个对象是否是同一个对象</p><h2 id="12-7-布尔类型"><a href="#12-7-布尔类型" class="headerlink" title="12.7. 布尔类型"></a>12.7. 布尔类型</h2><ul><li>True </li><li>False</li></ul><h2 id="12-8-位运算符"><a href="#12-8-位运算符" class="headerlink" title="12.8. 位运算符"></a>12.8. 位运算符</h2><p>按位运算符是把数字看作二进制来进行计算的</p><p><strong><code>&amp;</code>  按位与</strong></p><p>两个相应位都为1，则该位的结果为1，否则为0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0b110</span></span><br><span class="line">b = <span class="number">0b111</span></span><br><span class="line"><span class="built_in">print</span>(a&amp;b)</span><br><span class="line"><span class="comment">#结果为 6</span></span><br></pre></td></tr></table></figure><p> <strong><code>|</code> 按位或</strong></p><p>两个相应位相同为0，不同为1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0b110</span></span><br><span class="line">b = <span class="number">0b111</span></span><br><span class="line"><span class="built_in">print</span>(a|b)</span><br><span class="line"><span class="comment">#结果为 7</span></span><br></pre></td></tr></table></figure><p> <strong><code>^</code> 按位异或</strong></p><p>两个相应位相异时，结果为1，否则为 0 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0b110</span></span><br><span class="line">b = <span class="number">0b111</span></span><br><span class="line"><span class="built_in">print</span>(a^b)</span><br><span class="line"><span class="comment">#结果为 1</span></span><br></pre></td></tr></table></figure><p> <strong><code>~</code> 按位取反</strong></p><p>对数据的每个二进制位取反，把1变为0，把0变为1</p><p><code>~x</code> 类似于 <code>-x-1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">0b111</span></span><br><span class="line"><span class="built_in">print</span>(~b)</span><br><span class="line"><span class="comment">#结果为 -8</span></span><br></pre></td></tr></table></figure><p><strong><code>&lt;&lt;</code> 左移动运算</strong></p><p>运算数的各二进位全部左移若干位，由 <code>&lt;&lt;</code> 右边的数字指定移动的位数，高位丢弃，低位补0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">0b1</span></span><br><span class="line"><span class="built_in">print</span>(b&lt;&lt;<span class="number">3</span>)</span><br><span class="line"><span class="comment">#结果为 8</span></span><br></pre></td></tr></table></figure><p><strong><code>&gt;&gt;</code> 右移动运算</strong></p><p>运算数的各二进位全部右移若干位，由 <code>&gt;&gt;</code> 左边的数字指定移动的位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">0b100</span></span><br><span class="line"><span class="built_in">print</span>(b&gt;&gt;<span class="number">2</span>)</span><br><span class="line"><span class="comment">#结果为 1</span></span><br></pre></td></tr></table></figure><h1 id="13-字符串"><a href="#13-字符串" class="headerlink" title="13. 字符串"></a>13. 字符串</h1><h2 id="13-1-表示方式"><a href="#13-1-表示方式" class="headerlink" title="13.1. 表示方式"></a>13.1. 表示方式</h2><ul><li>使用<code>&#39;</code>或<code>&quot;</code>来创建字符串</li><li>三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符</li></ul><h2 id="13-2-转义"><a href="#13-2-转义" class="headerlink" title="13.2. 转义"></a>13.2. 转义</h2><p>python用反斜杠<code>\</code>转义字符</p><div class="table-container"><table><thead><tr><th><code>\</code>(在行尾时)</th><th>续行符</th></tr></thead><tbody><tr><td><code>\\</code></td><td>反斜杠符号</td></tr><tr><td><code>\&#39;</code></td><td>单引号</td></tr><tr><td><code>\&quot;</code></td><td>双引号</td></tr><tr><td><code>\a</code></td><td>响铃</td></tr><tr><td><code>\b</code></td><td>退格(Backspace)</td></tr><tr><td><code>\e</code></td><td>转义</td></tr><tr><td><code>\000</code></td><td>空</td></tr><tr><td><code>\n</code></td><td>换行</td></tr><tr><td><code>\v</code></td><td>纵向制表符</td></tr><tr><td><code>\t</code></td><td>横向制表符</td></tr><tr><td><code>\r</code></td><td>回车</td></tr><tr><td><code>\f</code></td><td>换页</td></tr><tr><td><code>\oyy</code></td><td>八进制数，yy代表的字符，例如：\o12代表换行</td></tr><tr><td><code>\xyy</code></td><td>十六进制数，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td><code>\other</code></td><td>其它的字符以普通格式输出</td></tr></tbody></table></div><h2 id="13-3-索引"><a href="#13-3-索引" class="headerlink" title="13.3. 索引"></a>13.3. 索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[i]</span><br></pre></td></tr></table></figure><ul><li><p>返回s中的第i个元素，i是序列的序号</p></li><li><p>正下标正向找，负下标逆向找</p></li></ul><h2 id="13-4-切片"><a href="#13-4-切片" class="headerlink" title="13.4. 切片"></a>13.4. 切片</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[start:end:step]</span><br></pre></td></tr></table></figure><ul><li><p>返回序列s中第start到end-1 以step 为步长的元素子序列</p></li><li><p>step若为负数，表示倒数(倒数是从第0个开始的)</p></li><li><p>start和end若为负数，表示从右边数</p></li><li><p>倒序 <code>y = s[::-1]</code> </p></li><li><p>倒数第4个 到 倒数第1个<code>y = s[-4:-1]</code></p></li><li><p>从下标为7的元素开始包含下标为7的元素，倒着取到下标为2的元素不包括下标为2的元素<code>s[7:2:-1]</code></p></li></ul><p>注：切片时必须在最后字符后再加1，因为python只会截取到最后字符的前一个字符</p><h2 id="13-5-常用方法"><a href="#13-5-常用方法" class="headerlink" title="13.5. 常用方法"></a>13.5. 常用方法</h2><p><strong>获取长度</strong></p><p>len()</p><p><strong>查找</strong></p><ul><li><p>find() </p><p>查找指定内容在字符串中是否存在，如果存在就返回该内容在字符串中第一次出现的开始位置索引值，如果不存在，则返回-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.find(sub[, start[, end]])</span><br></pre></td></tr></table></figure><ul><li><p>index 跟find()方法一样，只不过，未找到时，会报异常</p></li><li><p>rfind 是从右边开始查找的</p></li><li><p>rindex 是从右边开始查找的</p></li></ul></li></ul><p><strong>判断</strong></p><ul><li><p>startswith 判断字符串是否以指定内容开始</p></li><li><p>endswith 判断字符串是否以指定内容结束</p></li><li><p>isalpha 判断字符串是否是纯字母</p></li><li><p>isdigit 判断一个字符串是否是纯数字</p></li><li><p>isalnum 判断是否由数字和字母组成</p></li><li><p>isspace 只包含空格，则返回 True，否则返回 False</p></li></ul><p><strong>出现的次数</strong></p><p>count()</p><p><strong>替换</strong></p><p>replace()<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.replace(&#x27;被替换的&#x27;,&#x27;替换的&#x27;)</span><br></pre></td></tr></table></figure></p><p><strong>切割字符串</strong></p><p>如果 maxsplit 有指定值，则仅分隔 maxsplit + 1 个子字符串</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.split(<span class="string">&#x27;分割字符&#x27;</span>,maxsplit)</span><br><span class="line">s.split(<span class="string">&#x27;-&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li><p>split 以指定字符串为分隔符切片，返回的结果是一个列表</p></li><li><p>rsplit 从右往左分隔</p></li><li><p>splitlines 按照行分隔，返回一个包含各行作为元素的列表</p></li><li><p>partition 把字符串分割成三部分，str前，str和str后，三部分组成一个元组</p></li><li><p>rpartition 从右边开始</p></li></ul><p><strong>大小写</strong></p><ul><li><p>capitalize 第一个单词的首字母大写</p></li><li><p>title 每个单词的首字母大写</p></li><li><p>lower 所有都变成小写</p></li><li><p>upper 所有都变成大写</p></li></ul><p><strong>空格处理</strong></p><ul><li><p>ljust</p><p>返回指定长度的字符串，并在右侧使用空白字符补全(左对齐)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">str</span>.ljust(<span class="number">10</span>))</span><br></pre></td></tr></table></figure></li><li><p>rjust</p><p>返回指定长度的字符串，并在左侧使用空白字符补全(右对齐)</p></li><li><p>center</p><p>返回指定长度的字符串，并在两端使用空白字符补全(居中对齐)</p></li><li><p>lstrip</p><p>删除字符串左边的空白字符</p></li><li><p>rstrip</p><p>删除字符串右边的空白字符</p></li><li><p>strip</p><p>删除字符串两边的空白字符</p></li></ul><p><strong>字符串拼接</strong></p><p>把参数进行遍历，取出参数里的每一项，然后再在后面加上字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S.join(iterable)</span><br></pre></td></tr></table></figure><p>作用：可以把列表或者元组快速的转变成为字符串，并且以指定的字符分隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(x.join([<span class="string">&#x27;abc&#x27;</span>,<span class="string">&#x27;dcdf&#x27;</span>]))</span><br><span class="line"><span class="comment">#结果是 abc-dcdf</span></span><br></pre></td></tr></table></figure><h2 id="13-6-字符串运算符"><a href="#13-6-字符串运算符" class="headerlink" title="13.6. 字符串运算符"></a>13.6. 字符串运算符</h2><p>下表实例变量a值为字符串”Hello”，b变量值为”Python”</p><div class="table-container"><table><thead><tr><th><strong>操作符</strong></th><th><strong>描述</strong></th><th><strong>实例</strong></th></tr></thead><tbody><tr><td><code>+</code></td><td>字符串连接</td><td><code>a + b 输出结果： HelloPython</code></td></tr><tr><td><code>*</code></td><td>重复输出字符串</td><td><code>a*2 输出结果：HelloHello</code></td></tr><tr><td><code>in</code></td><td>如果字符串中包含给定的字符返回 True</td><td><code>H in a 输出结果 1</code></td></tr><tr><td><code>not in</code></td><td>如果字符串中不包含给定的字符返回 True</td><td><code>M not in a 输出结果 1</code></td></tr><tr><td><code>r、R</code></td><td>原生字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法</td><td><code>print r&#39;\n&#39; 输出 \n 和 print R&#39;\n&#39;输出 \n</code></td></tr></tbody></table></div><h2 id="13-7-字符集"><a href="#13-7-字符集" class="headerlink" title="13.7. 字符集"></a>13.7. 字符集</h2><h3 id="13-7-1-字符和编码相互转换"><a href="#13-7-1-字符和编码相互转换" class="headerlink" title="13.7.1. 字符和编码相互转换"></a>13.7.1. 字符和编码相互转换</h3><ul><li>chr(x) 将一个ASCII转换为一个字符</li><li>ord(x) 将一个字符转换为它的ASCII值</li></ul><h3 id="13-7-2-编码规则"><a href="#13-7-2-编码规则" class="headerlink" title="13.7.2. 编码规则"></a>13.7.2. 编码规则</h3><p>按照一定的编码规则对Unicode数字进行计算，得出新的编码。在中国常用的字符编码有 GBK，Big5，utf8三种编码规则</p><ul><li>encode方法</li></ul><p>可以将字符串按照指定的编码格式转换为二进制</p><ul><li>decode方法</li></ul><p>可以将一个二进制数据按照指定的编码格式转换成为字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">b&#x27;\xe4\xbd\xa0&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><ul><li>Unicode 字符串</li></ul><p>引号前小写的”u”表示这里创建的是一个 Unicode 字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s=<span class="string">u&quot;hello word&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>默认字符串是Unicode类型，该类型字符串只能保存在内存中</p></li><li><p>bytes类型字符串，可以保存在磁盘和网络间数据传输</p></li><li><p>字符串从Unicode到bytes，需要编码：<code>str.enconde(&quot;utf-8&quot;)</code></p></li><li><p>字符串从bytes到Unicode，需要解码：<code>str.decode(&quot;utf-8&quot;)</code></p></li></ul><h2 id="13-8-格式化输出"><a href="#13-8-格式化输出" class="headerlink" title="13.8. 格式化输出"></a>13.8. 格式化输出</h2><ul><li><code>%</code>占位符，格式化一个字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">16</span></span><br><span class="line">b = <span class="string">&#x27;zhao&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my age is %d my  name is %s&#x27;</span>%(a,b))</span><br><span class="line"><span class="comment">#结果为 my age is 16 my  name is zhao</span></span><br></pre></td></tr></table></figure><ul><li><code>&#123;&#125;</code>占位符，格式化一个字符串</li></ul><p><code>&#123;&#125;</code>中什么都不写，会读取后面的内容，一一对应填充</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为 my name is 123 my age is 456</span></span><br></pre></td></tr></table></figure><p><code>&#123;数字&#125;</code>数字就是值的下标(从0开始)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;1&#125; my age is &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为 my name is 456 my age is 123</span></span><br></pre></td></tr></table></figure><p><code>&#123;变量名&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;name&#125; my age is &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(name = <span class="string">&#x27;123&#x27;</span>,age = <span class="string">&#x27;456&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为 my name is 123 my age is 456</span></span><br></pre></td></tr></table></figure><p><code>&#123;数字&#125;</code>和<code>&#123;变量&#125;</code>混合使用</p><p><code>&#123;&#125;</code>和列表使用</p><p>使用<code>*列表名</code>传参，<code>&#123;&#125;</code>中什么都不填</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="string">&#x27;bv&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*a))</span><br><span class="line"><span class="comment">#结果为 my name is 1 my age is 5</span></span><br></pre></td></tr></table></figure><p><code>&#123;&#125;</code>和字典使用</p><p>使用<code>**字典名</code>传参，<code>&#123;&#125;</code>中填写字典中的键名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhao&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>,<span class="string">&#x27;high&#x27;</span>:<span class="number">180</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(*b)</span><br><span class="line"><span class="comment">#结果为 name age high</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;name&#125; my age is &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(**b))</span><br><span class="line"><span class="comment">#结果为 my name is zhao my age is 16</span></span><br></pre></td></tr></table></figure><h2 id="13-9-拆包"><a href="#13-9-拆包" class="headerlink" title="13.9. 拆包"></a>13.9. 拆包</h2><p><code>*</code>加一个序列（列表、元组等）表示拆包，即将一个数据拆成多个数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*a))</span><br><span class="line"><span class="comment">#结果是 my name is 1 my age is 2</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果是 (1, 2, 3, 5)</span></span><br><span class="line"><span class="built_in">print</span>(*a)</span><br><span class="line"><span class="comment">#结果是 1 2 3 5</span></span><br></pre></td></tr></table></figure><h1 id="14-列表（list）"><a href="#14-列表（list）" class="headerlink" title="14. 列表（list）"></a>14. 列表（list）</h1><ul><li>格式 <code>[]</code>  </li><li>列表的数据项不需要具有相同的类型，无论那是字符、字符串或者是另个列表</li><li>是有序的</li></ul><ul><li>索引从0开始计数</li></ul><h2 id="14-1-切片"><a href="#14-1-切片" class="headerlink" title="14.1. 切片"></a>14.1. 切片</h2><ul><li>格式：<code>[start:end:step]</code>，第一个参数，是开始切割的位置，第二个参数，是结束切割的位置，第三个参数，是步长</li><li>倒序：<code>[::-1]</code></li></ul><h2 id="14-2-列表运算符"><a href="#14-2-列表运算符" class="headerlink" title="14.2. 列表运算符"></a>14.2. 列表运算符</h2><p><code>+</code></p><p>将两个列表合并</p><h2 id="14-3-列表推导式"><a href="#14-3-列表推导式" class="headerlink" title="14.3. 列表推导式"></a>14.3. 列表推导式</h2><p>指的是轻量级循环创建列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">数字型</span><br><span class="line">a=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br><span class="line"><span class="comment">#语法，我们使用了一个临时声明的变量x，x后面跟了一个for循环，使用range迭代返回的每一个值。这些东西都被放进了列表里</span></span><br><span class="line">字符型</span><br><span class="line">b=[<span class="string">&#x27;NAme&#x27;</span>,<span class="string">&#x27;Is&#x27;</span>]</span><br><span class="line">b=[x.lower() <span class="keyword">for</span> x <span class="keyword">in</span> b]</span><br></pre></td></tr></table></figure><h2 id="14-4-列表的复制"><a href="#14-4-列表的复制" class="headerlink" title="14.4. 列表的复制"></a>14.4. 列表的复制</h2><ul><li><p>直接使用<code>=</code>，得到的两个列表指向同一个地址</p></li><li><p>copy()方法</p></li></ul><p>得到的两个列表指向不同的地址</p><ul><li>copy模块<ul><li>浅拷贝</li><li>深拷贝</li></ul></li></ul><h2 id="14-5-列表的遍历"><a href="#14-5-列表的遍历" class="headerlink" title="14.5. 列表的遍历"></a>14.5. 列表的遍历</h2><p>enumerate()</p><p>带下标的遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">84</span>,<span class="number">55</span>,<span class="number">12</span>,<span class="number">2</span>]</span><br><span class="line">en = <span class="built_in">enumerate</span>(test)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> en:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">   </span><br><span class="line"><span class="comment">#结果是</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">84</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">55</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">12</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i,e <span class="keyword">in</span> en:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;第%d个元素是%d&#x27;</span>%(i,e))</span><br><span class="line">    </span><br><span class="line"><span class="comment">#结果是</span></span><br><span class="line">第<span class="number">0</span>个元素是<span class="number">84</span></span><br><span class="line">第<span class="number">1</span>个元素是<span class="number">55</span></span><br><span class="line">第<span class="number">2</span>个元素是<span class="number">12</span></span><br><span class="line">第<span class="number">3</span>个元素是<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="14-6-修改列表元素"><a href="#14-6-修改列表元素" class="headerlink" title="14.6. 修改列表元素"></a>14.6. 修改列表元素</h2><p>通过遍历整个列表，修改值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num  =<span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span>  item <span class="keyword">in</span> num:</span><br><span class="line">item = item*<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以上代码无法修改列表中的元素，因为原因item 的id(地址)  已经不是原来的id(地址)</span></span><br></pre></td></tr></table></figure><p>正确方法，使用带下标的遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">range</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i, item  <span class="keyword">in</span>  <span class="built_in">enumerate</span>(num):</span><br><span class="line">num[i] =num[i]*<span class="number">2</span></span><br></pre></td></tr></table></figure><h2 id="14-7-常用方法"><a href="#14-7-常用方法" class="headerlink" title="14.7. 常用方法"></a>14.7. 常用方法</h2><p><strong>将元组转换为列表</strong></p><p>list(seq)</p><p><strong>添加元素</strong></p><ul><li>append()</li></ul><p>接收一个参数。把接收到的参数放在列表的末尾</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;w&#x27;</span>]</span><br><span class="line">a.append(<span class="string">&#x27;q&#x27;</span>)</span><br><span class="line">a.append(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#结果为[&#x27;a&#x27;, &#x27;d&#x27;, &#x27;w&#x27;, &#x27;q&#x27;, 1]</span></span><br></pre></td></tr></table></figure><ul><li>insert(index,object)</li></ul><p>接收两个参数，index参数表示在列表的哪个索引位置上进行插入，object表示要插入的值</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;w&#x27;</span>]</span><br><span class="line">a.insert(<span class="number">2</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="comment">#结果为[&#x27;a&#x27;, &#x27;d&#x27;, &#x27;1&#x27;, &#x27;w&#x27;]</span></span><br></pre></td></tr></table></figure><ul><li>extend(seq)</li></ul><p>在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">a.extend(b)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p><strong>删除元素</strong></p><ul><li><p>remove()</p><p>删除特定的值(列表中第一次出现的)，并不能根据我们给定的索引进行删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">a.remove(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment">#结果为[&#x27;d&#x27;, &#x27;w&#x27;, &#x27;a&#x27;, &#x27;g&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>del()</p><p>删除指定索引位的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;w&#x27;</span>]</span><br><span class="line"><span class="keyword">del</span>(a[<span class="number">2</span>])</span><br><span class="line"><span class="comment">#结果为[&#x27;a&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>pop()</p><p>移除列表中指定索引位的值，并且返回该元素的值，默认删除最后一个元素</p></li><li><p>clear()</p><p>清空一个列表</p></li></ul><p><strong>查询元素</strong></p><p>运算符 in</p><p><strong>列表元素个数</strong></p><p>len()</p><p><strong>找最大最小值</strong></p><ul><li>max()</li><li>min()</li></ul><p><strong>统计某个元素在列表中出现的次数</strong></p><p>count()</p><p><strong>从列表中找出某个值第一个匹配项的索引位置</strong></p><p>index()</p><p><strong>元素反转</strong></p><p>reverse()</p><p><strong>排序</strong></p><ul><li>sorted()</li></ul><p>排序内置函数，不会改变原有数据，而是排序后返回一个有序的列表</p><ul><li>sort(cmp=None, key=None, reverse=False)</li></ul><p>对原列表进行排序，reverse=False正序排，reverse=True逆序排</p><p>key的参数类型是函数，需要传递参数key来确定排序规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对列表中的字典元素进行排序，因为字典有多个参数，那么根据哪一个参数进行排序呢？？</span></span><br><span class="line">student = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">14</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">98</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lier&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">17</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">68</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoshi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">78</span>&#125;</span><br><span class="line">     ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">a</span>):<span class="comment">#可以打印，看一下a的值</span></span><br><span class="line">    <span class="keyword">return</span> a[<span class="string">&#x27;age&#x27;</span>]<span class="comment">#通过返回值告诉sort排序规则，这里是按照age排序</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">student.sort()<span class="comment">#直接进行排序会报错：TypeError: &#x27;&lt;&#x27; not supported between instances of &#x27;dict&#x27; and &#x27;dict&#x27; </span></span><br><span class="line"><span class="built_in">print</span>(student)<span class="comment">#说明字典间无法直接比较，无法排序</span></span><br><span class="line">    </span><br><span class="line">student.sort(key=foo)<span class="comment">#给key传一个函数，在sort函数内部会调用foo函数</span></span><br><span class="line"><span class="built_in">print</span>(student)</span><br><span class="line"></span><br><span class="line"><span class="comment">#foo函数还可以直接写在sort的参数中，student.sort(key=lambda x:x[&#x27;age&#x27;])</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="15-元组-（tuple）"><a href="#15-元组-（tuple）" class="headerlink" title="15. 元组 （tuple）"></a>15. 元组 （tuple）</h1><ul><li>格式<code>()</code> </li><li>只能读不能写的列表</li><li><p><strong>定义只有一个元素的元组时，要在一个元素后加逗号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="string">&#x27;3&#x27;</span>,)  <span class="comment">#类型为元组</span></span><br><span class="line">a=(<span class="string">&#x27;3&#x27;</span>)   <span class="comment">#类型为字符</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="15-1-常用方法"><a href="#15-1-常用方法" class="headerlink" title="15.1. 常用方法"></a>15.1. 常用方法</h2><ul><li>tuple(seq)</li></ul><p>将列表转换为元组</p><ul><li>index()</li><li>count()</li></ul><p><strong>注意</strong></p><p>元组的增删查改是基于整个元组改变的，而若想改变里面的元素，应该用列表（list）</p><h1 id="16-字典（-dict）"><a href="#16-字典（-dict）" class="headerlink" title="16. 字典（ dict）"></a>16. 字典（ dict）</h1><ul><li>格式 <code>&#123; : &#125;</code> 键值对</li><li>字典的值可以是任意类型的数据</li></ul><h2 id="16-1-字典推导式"><a href="#16-1-字典推导式" class="headerlink" title="16.1. 字典推导式"></a>16.1. 字典推导式</h2><h2 id="16-2-常用操作"><a href="#16-2-常用操作" class="headerlink" title="16.2. 常用操作"></a>16.2. 常用操作</h2><ul><li><p>查看元素</p><ul><li>提取出字典中的值</li></ul><p><code>字典名[&#39;键名&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoshi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="comment">#结果为 zhaoshi</span></span><br></pre></td></tr></table></figure><ul><li>.get()</li></ul><p>提取出字典中的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a.get(<span class="string">&#x27;name&#x27;</span>))</span><br><span class="line"><span class="comment">#结果为 value</span></span><br></pre></td></tr></table></figure></li><li><p>添加元素</p></li></ul><p><code>字典名[&#39;键名&#39;] = 添加的值</code>，如果这个值在字典中，不存在，那么就会新增这个元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;</span><br><span class="line">a[<span class="string">&#x27;age&#x27;</span>] = <span class="number">12</span></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 &#123;&#x27;name&#x27;: &#x27;value&#x27;, &#x27;age&#x27;: 12&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>删除元素</p><ul><li>pop()</li></ul><p>删除键名对应的键值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">b = a.pop(<span class="string">&#x27;name&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 &#123;&#x27;age&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure><ul><li>popitem()</li></ul></li></ul><ul><li><p>del</p><p><code>del 字典名[&#39;键名&#39;]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line"><span class="keyword">del</span>(a[<span class="string">&#x27;name&#x27;</span>])</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 &#123;&#x27;age&#x27;: 16&#125;</span></span><br></pre></td></tr></table></figure><p><code>del 字典名</code></p><p>删除整个字典</p></li><li><p>clear()</p><p>清空整个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">a.clear()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 &#123;&#125;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="16-3-常用方法"><a href="#16-3-常用方法" class="headerlink" title="16.3. 常用方法"></a>16.3. 常用方法</h2><ul><li>str()</li></ul><p>将字典以字符串表示</p><ul><li>.keys()</li></ul><p>显示字典里的所有键名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">b = a.keys()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#结果为 </span></span><br><span class="line"><span class="comment"># name</span></span><br><span class="line"><span class="comment"># age</span></span><br></pre></td></tr></table></figure><ul><li>.values()</li></ul><p>显示所有的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">b = a.values()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment">#结果为 </span></span><br><span class="line"><span class="comment"># value</span></span><br><span class="line"><span class="comment"># 16</span></span><br></pre></td></tr></table></figure><ul><li>.items()</li></ul><p>显示所有的关键字和他们的值(同时显示)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">b = a.items()</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> b:</span><br><span class="line">    <span class="built_in">print</span>(i,j)</span><br><span class="line"><span class="comment">#结果为</span></span><br><span class="line"><span class="comment"># name value</span></span><br><span class="line"><span class="comment"># age 16</span></span><br></pre></td></tr></table></figure><ul><li>update()</li></ul><p>在字典末尾一次性追加另一个字典(用新字典扩展原来的字典)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;value&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line">c = &#123;<span class="string">&#x27;test&#x27;</span>:<span class="number">123</span>&#125;</span><br><span class="line">a.update(c)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 &#123;&#x27;name&#x27;: &#x27;value&#x27;, &#x27;age&#x27;: 16, &#x27;test&#x27;: 123&#125;</span></span><br></pre></td></tr></table></figure><h1 id="17-集合-（set-）"><a href="#17-集合-（set-）" class="headerlink" title="17. 集合 （set ）"></a>17. 集合 （set ）</h1><ul><li>格式<code>&#123;&#125;</code> </li><li>不能有重复元素</li><li>只读不写</li><li>无序</li><li>空集合 <code>set()</code></li></ul><h2 id="17-1-操作"><a href="#17-1-操作" class="headerlink" title="17.1. 操作"></a>17.1. 操作</h2><h3 id="17-1-1-更新集合"><a href="#17-1-1-更新集合" class="headerlink" title="17.1.1. 更新集合"></a>17.1.1. 更新集合</h3><ul><li><code>.add(elem)</code></li></ul><p>将元素 elem添加到集合中</p><ul><li><code>.pop()</code></li></ul><p>随机删除一个元素</p><ul><li><p><code>.update()</code></p><p>A.update(B)`B拼接到A里</p></li><li><p><code>.remove(elem)</code></p></li></ul><p>删除elem元素</p><p>如果元素不存在，则会发生错误</p><ul><li><code>discard(elem)</code></li></ul><p>如果元素不存在，不会发生错误</p><ul><li><code>.clear()</code> </li></ul><p>清空集合</p><h3 id="17-1-2-联合"><a href="#17-1-2-联合" class="headerlink" title="17.1.2. 联合|"></a>17.1.2. 联合<code>|</code></h3><p>与集合的OR操作其实等价的，联合符号有个等价的方法，union()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1=<span class="built_in">set</span>(<span class="string">&#x27;abcdde&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s2=<span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">s4=s1|s2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> s4</span><br><span class="line">结果为&#123;<span class="string">&#x27;e&#x27;</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="17-1-3-交集-amp"><a href="#17-1-3-交集-amp" class="headerlink" title="17.1.3. 交集&amp;"></a>17.1.3. 交集<code>&amp;</code></h3><p>与集合AND等价，交集符号的等价方法是intersection()</p><h3 id="17-1-4-差集"><a href="#17-1-4-差集" class="headerlink" title="17.1.4. 差集-"></a>17.1.4. 差集<code>-</code></h3><p>等价方法是difference()</p><h3 id="17-1-5-异或"><a href="#17-1-5-异或" class="headerlink" title="17.1.5. 异或^"></a>17.1.5. 异或<code>^</code></h3><p>求两集合差集的并集</p><h1 id="18-序列的转换"><a href="#18-序列的转换" class="headerlink" title="18. 序列的转换"></a>18. 序列的转换</h1><h2 id="18-1-set"><a href="#18-1-set" class="headerlink" title="18.1. set()"></a>18.1. set()</h2><h2 id="18-2-list"><a href="#18-2-list" class="headerlink" title="18.2. list()"></a>18.2. list()</h2><h2 id="18-3-tuple"><a href="#18-3-tuple" class="headerlink" title="18.3. tuple()"></a>18.3. tuple()</h2><h2 id="18-4-eval"><a href="#18-4-eval" class="headerlink" title="18.4. eval()"></a>18.4. eval()</h2><p>称为评估函数，作用是去掉参数中最外层引号并执行剩余语句</p><p>可转换序列的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;465&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))<span class="comment"># 字符串类型</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(a)))<span class="comment"># int类型</span></span><br></pre></td></tr></table></figure><p>多被用来执行字符串里的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;input(&quot;请输入&quot;)&#x27;</span><span class="comment">#字符串</span></span><br><span class="line"><span class="built_in">eval</span>(a)<span class="comment">#执行字符串里的代码</span></span><br></pre></td></tr></table></figure><h2 id="18-5-转JSON"><a href="#18-5-转JSON" class="headerlink" title="18.5. 转JSON"></a>18.5. 转JSON</h2><ul><li>引入json模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure><ul><li><code>.dumps()</code>方法</li></ul><p><code>.dumps()</code>将字典、列表、集合等转换为JSON字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;</span><br><span class="line">m = json.dumps(person)</span><br><span class="line"><span class="built_in">print</span>(m)</span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line"><span class="comment"># &#x27;&#123;&quot;name&quot;: &quot;zhangsan&quot;, &quot;age&quot;: 18&#125;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>.loads()</code>方法</li></ul><p>将JSON字符串转换为python对应的类型，字典、列表等</p><h1 id="19-流程控制"><a href="#19-流程控制" class="headerlink" title="19. 流程控制"></a>19. 流程控制</h1><h2 id="19-1-条件判断"><a href="#19-1-条件判断" class="headerlink" title="19.1. 条件判断"></a>19.1. 条件判断</h2><p>If</p><p>else</p><p>elif</p><p>如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">if</span> a==<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=1&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> a==<span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=2&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="19-2-循环结构"><a href="#19-2-循环结构" class="headerlink" title="19.2. 循环结构"></a>19.2. 循环结构</h2><h3 id="19-2-1-相关函数"><a href="#19-2-1-相关函数" class="headerlink" title="19.2.1. 相关函数"></a>19.2.1. 相关函数</h3><ul><li>range()</li></ul><p>range函数可以有三个参数，第一个参数作为下界，第二个参数作为上界，第三个参数为步长，返回一个含有数值类型的列表</p><p>如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line">b=<span class="built_in">list</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#结果为[1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure><ul><li>len()</li></ul><p>返回变量的长度，无论这个变量是string类型，list类型亦或是dictionary类型</p><h3 id="19-2-2-for"><a href="#19-2-2-for" class="headerlink" title="19.2.2. for"></a>19.2.2. for</h3><p> 一般用于循环次数可知</p><h3 id="19-2-3-while"><a href="#19-2-3-while" class="headerlink" title="19.2.3. while"></a>19.2.3. while</h3><p>一般用于循环次数未知</p><h3 id="19-2-4-结束循环"><a href="#19-2-4-结束循环" class="headerlink" title="19.2.4. 结束循环"></a>19.2.4. 结束循环</h3><ul><li>BREAK ，用于跳出最近的一级for或while循环</li><li>CONTINUE，表示结束本次循环，继续执行下一次迭代</li><li>PASS，用于那些语法上必须要有什么语句，但程序什么也不做的场合。通常我们使用pass语句来进行占位</li></ul><h1 id="20-函数"><a href="#20-函数" class="headerlink" title="20. 函数"></a>20. 函数</h1><h2 id="20-1-全局变量"><a href="#20-1-全局变量" class="headerlink" title="20.1. 全局变量"></a>20.1. 全局变量</h2><p>在函数外声明的变量，可以在脚本程序的任意位置调用这个变量</p><h3 id="20-1-1-global"><a href="#20-1-1-global" class="headerlink" title="20.1.1. global"></a>20.1.1. global</h3><p>用来在函数内部<strong>修改</strong>全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">50</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#改变的是局部变量x，外部x不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">global</span> x</span><br><span class="line">    x = <span class="number">2</span></span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    </span><br><span class="line">func()</span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#注意：当x被定义为全局变量时，x就不能被当作形参传入函数中</span></span><br></pre></td></tr></table></figure><h3 id="20-1-2-相关函数"><a href="#20-1-2-相关函数" class="headerlink" title="20.1.2. 相关函数"></a>20.1.2. 相关函数</h3><p>内置函数</p><ul><li>globals()    查看全局变量</li><li>locals()       查看局部变量</li></ul><h2 id="20-2-局部变量"><a href="#20-2-局部变量" class="headerlink" title="20.2. 局部变量"></a>20.2. 局部变量</h2><p>在函数里声明的变量，只能在函数内部被调用而不能在函数外部调用</p><p>注：如果在函数范围内定义了具有相同名称的变量，那么它将仅打印函数内给出的值而不是全局值</p><h2 id="20-3-函数名"><a href="#20-3-函数名" class="headerlink" title="20.3. 函数名"></a>20.3. 函数名</h2><p>函数名相当于变量，指向函数体中的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输出a&quot;</span>);</span><br><span class="line">b = a;<span class="comment">#相当于给函数起个别名</span></span><br><span class="line"></span><br><span class="line">b();<span class="comment">#结果是 输出a</span></span><br></pre></td></tr></table></figure><h2 id="20-4-函数的回调"><a href="#20-4-函数的回调" class="headerlink" title="20.4. 函数的回调"></a>20.4. 函数的回调</h2><p>把该函数当作参数传给另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运算 a b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b,fun</span>):</span><br><span class="line">    c = fun(a,b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jian</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment">#把函数名当作参数传递给另一个函数，就可以在另一个函数中调用</span></span><br><span class="line">calc(<span class="number">5</span>,<span class="number">2</span>,add)<span class="comment">#调用加法函数</span></span><br><span class="line">calc(<span class="number">5</span>,<span class="number">2</span>,jian)<span class="comment">#调用减法函数</span></span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h2 id="20-5-def声明函数"><a href="#20-5-def声明函数" class="headerlink" title="20.5. def声明函数"></a>20.5. def声明函数</h2><h3 id="20-5-1-调用函数"><a href="#20-5-1-调用函数" class="headerlink" title="20.5.1. 调用函数"></a>20.5.1. 调用函数</h3><ul><li><code>函数名(参数)</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">greet();</span><br></pre></td></tr></table></figure><h2 id="20-6-传参"><a href="#20-6-传参" class="headerlink" title="20.6. 传参"></a>20.6. 传参</h2><h3 id="20-6-1-缺省参数"><a href="#20-6-1-缺省参数" class="headerlink" title="20.6.1. 缺省参数"></a>20.6.1. 缺省参数</h3><p>形参中默认有值的参数</p><p>有默认值的参数，一定要位于参数列表的最后面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">5</span></span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#是有效的，但是</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=<span class="number">5</span>, b</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#是无效的</span></span><br></pre></td></tr></table></figure><h3 id="20-6-2-关键字传参"><a href="#20-6-2-关键字传参" class="headerlink" title="20.6.2. 关键字传参"></a>20.6.2. 关键字传参</h3><p>此方法，不必担心参数的顺序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x=<span class="number">2</span>,y=<span class="number">3</span></span>):</span><br><span class="line">    z=x+y</span><br><span class="line">    <span class="built_in">print</span>(z)</span><br><span class="line"></span><br><span class="line">func(y=<span class="number">1</span>,x=<span class="number">3</span>)</span><br><span class="line"><span class="comment">#尽管函数定义中，x在y之前定义，我们仍然可以在x之前指定参数y的值。</span></span><br></pre></td></tr></table></figure><h3 id="20-6-3-传多个参数"><a href="#20-6-3-传多个参数" class="headerlink" title="20.6.3. 传多个参数"></a>20.6.3. 传多个参数</h3><p>将多个数据捆绑到一个列表、字典、元组中等，传入函数中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#求多个数的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">num</span>):</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">        x+=i</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">        </span><br><span class="line">num = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(add(num))</span><br></pre></td></tr></table></figure><h3 id="20-6-4-可变参数"><a href="#20-6-4-可变参数" class="headerlink" title="20.6.4. 可变参数"></a>20.6.4. 可变参数</h3><p>可变参数允许传入在函数声明时，没有命名的参数</p><ul><li><code>*args</code></li></ul><p>表示可变位置参数(一般的参数)，多出来的参数会以元组的形式保存到args里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,*args</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;arg = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args))</span><br><span class="line">    </span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">#结果是 arg = (4, 5, 6, 7)</span></span><br></pre></td></tr></table></figure><ul><li><code>**kwargs</code></li></ul><p>表示可变关键字参数，多出来的参数会以字典的形式保存到kwargs里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,**kwargs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kwargs = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,x = <span class="number">4</span>,y = <span class="number">5</span>)</span><br><span class="line"><span class="comment">#结果是  kwargs = &#123;&#x27;x&#x27;: 4, &#x27;y&#x27;: 5&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="20-6-5-参数的顺序"><a href="#20-6-5-参数的顺序" class="headerlink" title="20.6.5. 参数的顺序"></a>20.6.5. 参数的顺序</h3><p><code>一般参数，*args，缺省参数，**kwargs</code></p><h2 id="20-7-return"><a href="#20-7-return" class="headerlink" title="20.7. return"></a>20.7. return</h2><p>如果一个函数没有返回值，它的返回值就是None</p><h3 id="20-7-1-返回多个值"><a href="#20-7-1-返回多个值" class="headerlink" title="20.7.1. 返回多个值"></a>20.7.1. 返回多个值</h3><p>将多个数据捆绑到一个列表、字典、元组中等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a,b</span>):</span><br><span class="line">x = a//b</span><br><span class="line">    y = a%b</span><br><span class="line">    <span class="keyword">return</span> [x,y]</span><br><span class="line"><span class="keyword">return</span> x,y<span class="comment">#默认返回的是元组</span></span><br><span class="line">    </span><br><span class="line">result = test(<span class="number">10</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(result[<span class="number">0</span>],result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="20-8-函数的文档说明"><a href="#20-8-函数的文档说明" class="headerlink" title="20.8. 函数的文档说明"></a>20.8. 函数的文档说明</h2><p>三个双引号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">说明内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h2 id="20-9-lambda匿名函数"><a href="#20-9-lambda匿名函数" class="headerlink" title="20.9. lambda匿名函数"></a>20.9. lambda匿名函数</h2><ul><li>格式： lambda 参数 ：参数的运算式</li><li>lambda表达式必须被赋值给某个变量才能发挥作用</li><li>作用：用来表达一个简单的函数，调用次数很少</li></ul><h3 id="20-9-1-调用函数"><a href="#20-9-1-调用函数" class="headerlink" title="20.9.1. 调用函数"></a>20.9.1. 调用函数</h3><ul><li>给函数命名(使用较少)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f=<span class="keyword">lambda</span> x,y : x+y</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(f(<span class="number">1</span>, <span class="number">2</span>))  <span class="comment">#计算两数之和，输出：3</span></span><br></pre></td></tr></table></figure><ul><li>函数回调</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b,fun</span>):</span><br><span class="line">    c = fun(a,b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line">x1 = calc(<span class="number">5</span>,<span class="number">2</span>,<span class="keyword">lambda</span> x,y:x+y)<span class="comment">#计算加法</span></span><br><span class="line"></span><br><span class="line">x2 = calc(<span class="number">5</span>,<span class="number">2</span>,<span class="keyword">lambda</span> x,y:x-y)<span class="comment">#计算减法</span></span><br><span class="line"></span><br><span class="line">x3 = calc(<span class="number">5</span>,<span class="number">2</span>,<span class="keyword">lambda</span> x,y:x/y)<span class="comment">#计算除法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x1)</span><br></pre></td></tr></table></figure><h3 id="20-9-2-lambda操作符"><a href="#20-9-2-lambda操作符" class="headerlink" title="20.9.2. lambda操作符"></a>20.9.2. lambda操作符</h3><ul><li>fliter()</li></ul><p>对可迭代对象进行过滤</p><p>可以被用来过滤原有的list，并把过滤结果放进新的list里。filter接受两个参数，第一个是lambda表达式提供的过滤条件，第二个是要进行过滤的现有列表。最后，filter返回一个符合条件的列表类型</p><p>如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> fliter</span><br><span class="line">a=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">b=<span class="built_in">filter</span>(<span class="keyword">lambda</span> i:i%<span class="number">2</span>==<span class="number">0</span>,a)<span class="comment">#将列表中符合条件的值，过滤出来</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#结果为[2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure><ul><li>map()</li></ul><p>可以同时对list里的所有元素进行操作，并以列表方式给出返回值</p><p>如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> <span class="built_in">map</span></span><br><span class="line">a=[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">b=<span class="built_in">map</span>(<span class="keyword">lambda</span> i:i**<span class="number">2</span>,a)<span class="comment">#将列表里的内容都平方</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><ul><li>reduce()</li></ul><p>可以对列表顺序执行算术运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line">b = reduce(<span class="keyword">lambda</span> x,y:x+y,a)<span class="comment">#将列表里的内容相加，具体过程：x = 1,y = 4;x = 1 + 4,y = 9;x = 1+ 4 + 9..</span></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment">#结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure><p>高级操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对列表中字典元素的年龄进行求和，因为字典有多个参数，那么如何让年龄求和呢？？</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">student = [</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhangsan&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">14</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">98</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;lier&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">17</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">68</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoshi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">19</span>,<span class="string">&#x27;score&#x27;</span>:<span class="number">78</span>&#125;</span><br><span class="line">     ]</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bar</span>(<span class="params">x,y</span>):</span><br><span class="line">    </span><br><span class="line">b = reduce(bar,student,<span class="number">0</span>)<span class="comment">#定义一个bar函数实现，列表内字典元素的相加，并给x一个初始值 0</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 50</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="20-10-常用内置函数"><a href="#20-10-常用内置函数" class="headerlink" title="20.10. 常用内置函数"></a>20.10. 常用内置函数</h2><ul><li>dir()</li></ul><p>列出对象的所有方法</p><ul><li>isinstance</li></ul><p>判断一个对象是否由一个类创建出来</p><ul><li>issubclass</li></ul><p>判断一个类是否为另一个类的子类</p><ul><li>iter</li></ul><p>获取可迭代对象的迭代器</p><ul><li>sorted</li></ul><p>排序</p><h2 id="20-11-高阶函数"><a href="#20-11-高阶函数" class="headerlink" title="20.11. 高阶函数"></a>20.11. 高阶函数</h2><ul><li>将函数作为另一个函数的返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">old</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我被old调用了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> old</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我被new掉调用了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return old()</span></span><br><span class="line">    <span class="keyword">return</span> old<span class="comment">#将函数名作为返回值</span></span><br><span class="line"></span><br><span class="line">a = new()</span><br><span class="line">a()<span class="comment">#调用返回的函数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>函数中定义函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    m = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        n = <span class="number">90</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是inner&#x27;</span>)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;我是outer&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner<span class="comment">#返回函数名</span></span><br><span class="line"></span><br><span class="line">outer()<span class="comment">#调用outer函数</span></span><br><span class="line">outer()()<span class="comment">#先调用outer后调用inner</span></span><br></pre></td></tr></table></figure><ul><li>闭包</li></ul><p>在内部函数里对外部函数的变量进行调用</p><p>在内部函数里对外部函数的变量进行修改，需要用<code>nonlocal</code>声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    m = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> m<span class="comment">#nonlocal，进行声明</span></span><br><span class="line">        m = <span class="number">50</span><span class="comment">#修改外部函数变量的值</span></span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">        inner()</span><br><span class="line">    <span class="built_in">print</span>(m)<span class="comment">#前面如果不用nonlocal声明，这里将打印 10而不是50</span></span><br></pre></td></tr></table></figure><h1 id="21-装饰器"><a href="#21-装饰器" class="headerlink" title="21. 装饰器"></a>21. 装饰器</h1><p>用<code>@</code>声明一个装饰器</p><p>给某个函数加装饰器，在该函数的前一行，声明装饰器即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_time</span>(<span class="params">fun</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;外部函数被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        start = time.time()</span><br><span class="line">        fun()</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;本次程序耗时&#x27;</span>,end-start)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@cal_time   </span><span class="comment">#相当于cal_time(demo)</span></span><br><span class="line">   <span class="comment">#装饰器</span></span><br><span class="line">            <span class="comment">#第一件事，调用cal_time</span></span><br><span class="line">            <span class="comment">#第二件事，把装饰器的函数传递给fun</span></span><br><span class="line">            <span class="comment">#第三件事，再次调用demo时，执行的已经不是以前的demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo</span>():</span><br><span class="line">    x = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">100000</span>):</span><br><span class="line">        x+=i</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;demo被执行&#x27;</span>)</span><br><span class="line"></span><br><span class="line">demo()<span class="comment">#执行的已经不是以前的demo，而是cal_time函数内的inner函数,通过inner函数来调用demo函数</span></span><br></pre></td></tr></table></figure><h2 id="21-1-被修饰的函数无参数"><a href="#21-1-被修饰的函数无参数" class="headerlink" title="21.1. 被修饰的函数无参数"></a>21.1. 被修饰的函数无参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_time</span>(<span class="params">action</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;check_time被调用&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_action</span>():</span><br><span class="line">        action()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;do_action被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_action</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_time</span><span class="comment">#会调用check_time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_to_bad</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;上床睡觉&#x27;</span>)</span><br><span class="line"></span><br><span class="line">go_to_bad()<span class="comment">#实际上调用的是do_action</span></span><br></pre></td></tr></table></figure><h2 id="21-2-被修饰的函数有参数"><a href="#21-2-被修饰的函数有参数" class="headerlink" title="21.2. 被修饰的函数有参数"></a>21.2. 被修饰的函数有参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_time</span>(<span class="params">action</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;check_time被调用&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_action</span>(<span class="params">name</span>):</span><br><span class="line">        action(name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;do_action被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_action</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_to_bad</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;上床睡觉&#x27;</span>.<span class="built_in">format</span>(name))</span><br><span class="line"></span><br><span class="line">go_to_bad(<span class="string">&#x27;张三&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="21-3-被修饰的函数有不定长参数"><a href="#21-3-被修饰的函数有不定长参数" class="headerlink" title="21.3. 被修饰的函数有不定长参数"></a>21.3. 被修饰的函数有不定长参数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_time</span>(<span class="params">action</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;check_time被调用&#x27;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">do_action</span>(<span class="params">*args</span>):</span><br><span class="line">        action(*args)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;do_action被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> do_action</span><br><span class="line"></span><br><span class="line"><span class="meta">@check_time</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">go_to_bad</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">sum</span> +=x</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>)</span><br><span class="line"></span><br><span class="line">go_to_bad(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="21-4-装饰器中的return"><a href="#21-4-装饰器中的return" class="headerlink" title="21.4. 装饰器中的return"></a>21.4. 装饰器中的return</h2><h1 id="22-模块（module）"><a href="#22-模块（module）" class="headerlink" title="22. 模块（module）"></a>22. 模块（module）</h1><ul><li>python里，一个<code>.py</code>文件就是一个模块</li><li><code>.py</code>文件的命名必须遵守规则：由字母、数字、下划线构成，不能以数字开头</li></ul><h2 id="22-1-导入模块"><a href="#22-1-导入模块" class="headerlink" title="22.1. 导入模块"></a>22.1. 导入模块</h2><ul><li><code>import 模块名</code></li></ul><p>直接导入一个模块</p><ul><li><code>from 模块名 import 函数名</code></li></ul><p>导入一个模块里的方法或变量</p><ul><li><code>from 模块名 import *</code></li></ul><p>导入这个模块的所有方法和变量(不是所有)，使用该方法导入一个模块里所有的内容时，本质上是去查找这个模块的<code>__all__</code>属性，将<code>__all__</code>属性里声明的所有内容导入。如果这个模块里没有设置<code>__all__</code>属性，此时才会导入这个模块里的所有内容</p><ul><li><code>import 模块名 as 别名</code></li></ul><p>导入一个模块并为其起别名</p><ul><li><code>from 模块名 import 函数名 as 别名</code></li></ul><h2 id="22-2-pip"><a href="#22-2-pip" class="headerlink" title="22.2. pip"></a>22.2. pip</h2><ul><li>pip install 模块名</li></ul><p>下载第三方模块</p><ul><li>pip uninstall 模块名</li></ul><p>卸载第三方模块</p><ul><li>pip freeze</li></ul><p>列出当前环境安装模块名和版本号</p><ul><li>pip freeze &gt; filename</li></ul><p>将安装的模块名和版本号重定向输出到指定的文件</p><ul><li>pip install -r filename</li></ul><p>读取文件中的模块名和版本号并安装。该方法常用于将代码部署到服务器时，给服务器的python安装模块</p><ul><li>pip install 模块名 -i 源的地址</li></ul><p>(临时的)更改模块的下载源</p><ul><li>永久更改源地址</li></ul><p>在当前用户目录下(<code>C:\Users\用户名</code>)创建一个pip的文件夹，然后再在文件夹里创建pip.ini文件并输入以下内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url=https://pypi.douban.com/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.douban.com</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#国内镜像</span></span><br><span class="line"><span class="comment">#阿里云 https://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="comment">#中国科技⼤大学 https://pypi.mirrors.ustc.edu.cn/simple/</span></span><br><span class="line"><span class="comment">#豆瓣(douban) https://pypi.douban.com/simple/</span></span><br><span class="line"><span class="comment">#清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line"><span class="comment">#中国科学技术大学 https://pypi.mirrors.ustc.edu.cn/simple/</span></span><br></pre></td></tr></table></figure><h2 id="22-3-模块里的私有成员"><a href="#22-3-模块里的私有成员" class="headerlink" title="22.3. 模块里的私有成员"></a>22.3. 模块里的私有成员</h2><p>模块里以一个下划线 <code>_</code>开始的变量和函数，是模块里的私有成员，当模块被导入时，以 <code>_</code>开头的变量默认不会被导入。但是它不具有强制性，如果一个代码强行使用以 <code>_</code>开头的变量，有时也可以。但是强烈不建议这样使用，因为有可能会出问题</p><h2 id="22-4-all"><a href="#22-4-all" class="headerlink" title="22.4. __all__"></a>22.4. <code>__all__</code></h2><p>一个存放模块变量和方法的列表</p><h2 id="22-5-name"><a href="#22-5-name" class="headerlink" title="22.5. __name__"></a>22.5. <code>__name__</code></h2><p>Python中，当直接运行一个py文件时，这个py文件里的<code>__name__</code>值是 <code>__main__</code>，当这个py文件被当作模块导入时<code>__name__</code>的值是文件名 ，据此可以判断一个py文件是被直接执行还是以模块的形式被导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;This program is being run by itself&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;I am being imported from another module&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="23-包"><a href="#23-包" class="headerlink" title="23. 包"></a>23. 包</h1><p>一般把 Python 里的一个代码文件夹称为一个包，并在包里创建<code>__init__.py</code> 文件</p><p><strong>导包</strong></p><p>以项目根目录为准，输入目标模块 或 包的路径： <code>from spiders._tools import xxx</code></p><h1 id="24-python面向对象编程"><a href="#24-python面向对象编程" class="headerlink" title="24. python面向对象编程"></a>24. python面向对象编程</h1><p>可以使用<code>dir</code>内置函数来查看一个对象里的方法</p><h2 id="24-1-定义类"><a href="#24-1-定义类" class="headerlink" title="24.1. 定义类"></a>24.1. 定义类</h2><p>方法里的第一个参数必须是<code>self</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法1</span>(<span class="params">self,参数列表</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">方法2</span>(<span class="params">self,参数列表</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="24-2-创建实例对象"><a href="#24-2-创建实例对象" class="headerlink" title="24.2. 创建实例对象"></a>24.2. 创建实例对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象变量名 = 类名()</span><br><span class="line"><span class="comment">#如</span></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        self.name = x</span><br><span class="line">        self.age = y</span><br><span class="line">        self.height = z</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在跑步&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;自动调用print&#x27;</span></span><br><span class="line"></span><br><span class="line">s1 = People(<span class="string">&#x27;小明&#x27;</span>,<span class="number">16</span>,<span class="number">180</span>)    <span class="comment">#这段代码做了</span></span><br><span class="line">                            <span class="comment">#调用__new__方法用来申请内存空间</span></span><br><span class="line">                            <span class="comment">#调用__init__方法，并让self指向申请好的那段内存空间，填充数据</span></span><br><span class="line">                            <span class="comment">#让s1也指向那段内存空间</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1)</span><br><span class="line"><span class="comment">#结果：自动调用print</span></span><br></pre></td></tr></table></figure><h2 id="24-3-self的使用"><a href="#24-3-self的使用" class="headerlink" title="24.3. self的使用"></a>24.3. self的使用</h2><ul><li>给对象添加属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        self.name = x <span class="comment">#添加属性</span></span><br><span class="line">        self.age = y</span><br><span class="line">        self.height = z</span><br></pre></td></tr></table></figure><ul><li>python支持动态属性，当一个对象创建好了以后，直接使用<code>对象.属性名 = 属性值</code>就可以很方便的给对象添加一个属性。但是，不建议使用这种方式给对象添加属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tom = Cat()</span><br><span class="line">tom.name = <span class="string">&#x27;Tom&#x27;</span>  <span class="comment"># 可以直接给 tom 对象添加⼀一个 name 属性</span></span><br></pre></td></tr></table></figure><h3 id="24-3-1-self概念"><a href="#24-3-1-self概念" class="headerlink" title="24.3.1. self概念"></a>24.3.1. self概念</h3><p>哪个对象调用了方法，方法里的<code>self</code>指的就是谁。通过<code>self.属性名</code>可以访问到这个对象的属性。通过<code>self.方法名()</code> 可以调用这个对象的方法</p><h2 id="24-4-魔术方法"><a href="#24-4-魔术方法" class="headerlink" title="24.4. 魔术方法"></a>24.4. 魔术方法</h2><ul><li>特点</li></ul><p>两个下划线开始，两个下划线结束的方法</p><p>魔术方法在恰当的时候就会被激活，自动执行</p><ul><li><code>__init__</code>方法</li></ul><p>该方法在创建对象时，会默认被调用</p><p>方法里的self参数，在创建对象时不需要传递参数，python解释器会把创建好的对象引<br>用直接赋值给self</p><p>在类的内部，可以使用self来使用属性和调用方法。在类的外部，需要使用对象名来使用属性和调用方法</p><p>如果有多个对象，每个对象的属性是各自保存的，都有各自独立的地址</p><p>方法是所有对象共享的，只占用一份内存空间，方法被调用时会通过self来判断是哪个对象调用了实例方法</p><ul><li><code>__del__</code>方法</li></ul><p>该方法在删除对象时，会默认被调用</p><ul><li><code>__str__</code>方法</li></ul><p>返回对象的描述信息，使用<code>print()</code>函数打印对象时，其实调用的就是这个对象的 <code>__str__</code>方法</p><p>如果想要修改对象的输出的结果，可以重写<code>__str__</code>方法</p><ul><li><code>__repr__</code>方法</li></ul><p><code>__repr__</code>方法和 <code>__str__</code>方法功能类似，都是用来修改一个对象的默认打印内容。</p><p>在打印一个对象时，如果没有重写<code>__str__</code>方法，它会自动来查找<code>__repr__</code>方法。</p><p>如果这两个方法都没有，会直接打印这个对象的内存地址。</p><p>如果这两个方法都有，会调用<code>__str__</code>方法</p><ul><li><code>__call__</code></li></ul><p>对象后面加括号，触发执⾏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        self.name = x</span><br><span class="line">        self.age = y</span><br><span class="line">        self.height = z</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在跑步&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call方法被调用&quot;</span>)</span><br><span class="line"></span><br><span class="line">s1 = People(<span class="string">&#x27;小明&#x27;</span>,<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line">                        </span><br><span class="line">s1()<span class="comment">#调用__call__方法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,x,y,z</span>):</span><br><span class="line">        self.name = x</span><br><span class="line">        self.age = y</span><br><span class="line">        self.height = z</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在跑步&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在吃东西&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self,*args,**kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;__call方法被调用&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(args))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line">        fun = kwargs[<span class="string">&#x27;fn&#x27;</span>]</span><br><span class="line">        <span class="built_in">print</span>(fun(args[<span class="number">0</span>], args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = People(<span class="string">&#x27;小明&#x27;</span>,<span class="number">16</span>,<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line">s1(<span class="number">1</span>,<span class="number">2</span>,fn = <span class="keyword">lambda</span> x,y:x+y)</span><br></pre></td></tr></table></figure><ul><li><code>__eq__</code></li></ul><p><code>==</code>默认调用对象的<code>__eq__</code>方法，获取该方法的返回值。若<code>__eq__</code>方法不重写，则默认比较内存地址</p><p>身份运算符<code>is</code>用来判断两个对象是否是同一个对象</p><h2 id="24-5-对象的内置属性"><a href="#24-5-对象的内置属性" class="headerlink" title="24.5. 对象的内置属性"></a>24.5. 对象的内置属性</h2><ul><li><code>__slots__</code>属性</li></ul><p>防止通过动态属性，直接给对象添加属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)<span class="comment">#限制了动态属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p.name = <span class="string">&#x27;李李四&#x27;</span></span><br><span class="line">p.height = <span class="number">180</span><span class="comment">#报错</span></span><br><span class="line"><span class="comment"># 对象p只能设置name和age属性，不能再动态添加属性 p.height = 180</span></span><br></pre></td></tr></table></figure><ul><li><code>__doc__</code></li></ul><p>表示类的描述信息，获取类中的文档说明<code>&#39;&#39;&#39;中的内容&#39;&#39;&#39;</code>，可以<code>类名.__doc__</code>也可以<code>__对象名.__doc__</code>调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;一些介绍&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__doc__)<span class="comment">#结果：一些介绍</span></span><br></pre></td></tr></table></figure><ul><li><code>__module__</code></li></ul><p>表示当前操作的对象在那个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;一些介绍&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__module__)<span class="comment">#结果是 __main__</span></span><br></pre></td></tr></table></figure><ul><li><code>__class__</code></li></ul><p>表示当前操作的对象的类是什么</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;一些介绍&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__class__)<span class="comment">#结果是 &lt;class &#x27;__main__.Person&#x27;&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>__dict__</code></li></ul><p>以字典的形式，显示对象所有的属性和方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;一些介绍&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.__dict__)<span class="comment">#结果是 &#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure><h2 id="24-6-类属性和对象属性"><a href="#24-6-类属性和对象属性" class="headerlink" title="24.6. 类属性和对象属性"></a>24.6. 类属性和对象属性</h2><ul><li>类属性可以通过类对象或者实例对象访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    number = <span class="string">&#x27;06&#x27;</span><span class="comment">#类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.number)<span class="comment">#通过实例对象访问类属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.number)<span class="comment">#通过类对象访问类属性</span></span><br></pre></td></tr></table></figure><ul><li>如果有同名实例属性和类属性，实例对象会优先访问实例属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    number = <span class="string">&#x27;06&#x27;</span><span class="comment">#类属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age,number</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.number = number<span class="comment">#同名属性</span></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>,<span class="string">&#x27;08&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(p.number)<span class="comment">#结果为08，实例对象会优先访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(Person.number)<span class="comment">##结果为06</span></span><br></pre></td></tr></table></figure><ul><li>类属性只能通过类对象修改，不能通过实例对象修改</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    number = <span class="string">&#x27;06&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">p.number = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Person.number)<span class="comment">#结果为06</span></span><br><span class="line">Person.number = <span class="string">&#x27;01&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Person.number)<span class="comment">#结果为01</span></span><br></pre></td></tr></table></figure><ul><li>类属性也可以设置为私有，前边添加两个下划线</li></ul><h2 id="24-7-私有属性和方法"><a href="#24-7-私有属性和方法" class="headerlink" title="24.7. 私有属性和方法"></a>24.7. 私有属性和方法</h2><p>对象的属性或者方法只可以在对象的内部使用，在外部不能被访问</p><h3 id="24-7-1-定义"><a href="#24-7-1-定义" class="headerlink" title="24.7.1. 定义"></a>24.7.1. 定义</h3><p>在定义属性或方法时，在属性名或者方法名前增加两个下划线 <code>__</code>，定义的就是私有属性或方法</p><h3 id="24-7-2-访问私有"><a href="#24-7-2-访问私有" class="headerlink" title="24.7.2. 访问私有"></a>24.7.2. 访问私有</h3><ul><li>直接访问</li></ul><p>在私有属性名或方法名前添加<code>_类名</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__money = <span class="number">800</span><span class="comment">#私有属性</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p._Person__money)<span class="comment">#直接访问私有属性</span></span><br></pre></td></tr></table></figure><ul><li>定义方法访问</li></ul><p>可以通过定义<code>get</code> 和 <code>set</code> 方法来实现访问私有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.__money = <span class="number">800</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.__money</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set</span>(<span class="params">self,money</span>):</span><br><span class="line">        self.__money = money</span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(p.get())<span class="comment">#结果是 800</span></span><br><span class="line">p.<span class="built_in">set</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(p.get())<span class="comment">#结果是 2</span></span><br></pre></td></tr></table></figure><h2 id="24-8-类方法"><a href="#24-8-类方法" class="headerlink" title="24.8. 类方法"></a>24.8. 类方法</h2><ul><li>对象方法可以使用<code>实例对象名.方法(参数)</code>调用，该方法不需要为<code>self</code>传参，会自动为<code>self</code>传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">self,number</span>):<span class="comment">#类方法</span></span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;学号是&#x27;</span> + number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p.demo(<span class="string">&#x27;01&#x27;</span>)<span class="comment">#通过对象调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#结果 张三学号是01</span></span><br></pre></td></tr></table></figure><ul><li>对象方法还可以使用<code>类名.方法(参数)</code>调用，该方法不会自动为<code>self</code>传参，需要手动指定<code>self</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">demo</span>(<span class="params">self,number</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name + <span class="string">&#x27;学号是&#x27;</span> + number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">Person.demo(p,<span class="string">&#x27;02&#x27;</span>)<span class="comment">#通过类调用</span></span><br><span class="line"><span class="comment">#结果 张三学号是02</span></span><br></pre></td></tr></table></figure><h2 id="24-9-继承"><a href="#24-9-继承" class="headerlink" title="24.9. 继承"></a>24.9. 继承</h2><ul><li>在Python中，继承可以分为单继承、多继承和多层继承</li><li>定义类时，在类名的括号后面传入父类的类名，表示子类继承父类</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;动物类&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sleep</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正在睡觉&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):    <span class="comment">#继承于Animal类</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Dog类继承于Animal类&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">dog = Dog()</span><br><span class="line">dog.sleep()</span><br></pre></td></tr></table></figure><h2 id="24-10-多态"><a href="#24-10-多态" class="headerlink" title="24.10. 多态"></a>24.10. 多态</h2><h1 id="25-文件操作"><a href="#25-文件操作" class="headerlink" title="25. 文件操作"></a>25. 文件操作</h1><h2 id="25-1-手动文件I-O操作"><a href="#25-1-手动文件I-O操作" class="headerlink" title="25.1. 手动文件I/O操作"></a>25.1. 手动文件I/O操作</h2><h3 id="25-1-1-写文件"><a href="#25-1-1-写文件" class="headerlink" title="25.1.1. 写文件"></a>25.1.1. 写文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">file.write(<span class="string">&#x27;内容&#x27;</span>)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="25-1-2-读文件"><a href="#25-1-2-读文件" class="headerlink" title="25.1.2. 读文件"></a>25.1.2. 读文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">file.read()</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><p>注意：定要记得把文件关上。如果不关闭文件，就会导致一些错误，文件也可能会被损坏。</p><h2 id="25-2-自动文件I-O操作"><a href="#25-2-自动文件I-O操作" class="headerlink" title="25.2. 自动文件I/O操作"></a>25.2. 自动文件I/O操作</h2><p>用with关键字和as关键字来打开和关闭文件。会自动关闭文件，不需要close()函数</p><h3 id="25-2-1-写文件"><a href="#25-2-1-写文件" class="headerlink" title="25.2.1. 写文件"></a>25.2.1. 写文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> 变量名:</span><br><span class="line">    变量名.write(<span class="string">&#x27;内容&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="25-2-2-读文件"><a href="#25-2-2-读文件" class="headerlink" title="25.2.2. 读文件"></a>25.2.2. 读文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> 变量名:</span><br><span class="line">    变量名.read()</span><br></pre></td></tr></table></figure><h2 id="25-3-相关函数"><a href="#25-3-相关函数" class="headerlink" title="25.3. 相关函数"></a>25.3. 相关函数</h2><p><strong>open()</strong></p><p>open(file,mode,encoding)</p><ul><li>file 文件路径(相对或者绝对路径)</li></ul><p>windows中使用<code>\</code>分隔路径，但python中<code>\</code>表示转义符</p><p>python中可以使用<code>\\</code>或<code>/</code>分割路径，也可以使用<code>r&#39;路径&#39;</code>表示(即在路径前加r)</p><ul><li>encoding 打开文件时的编码方式</li></ul><p>windows中默认使用<code>gbk</code>编码读写文件</p><ul><li><p>mode 文件打开模式</p><p><code>r</code> </p><p>只读(默认模式)，如果文件不存在会报错</p><p><code>w</code> </p><p>打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</p><p><code>a</code></p><p>追加，新内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入</p><p><code>r+</code> </p><p>打开一个文件用于读或写</p><p><code>w+</code></p><p>打开一个文件用于读或写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</p><p><code>a+</code></p><p>打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写</p><p><code>rb</code>  </p><p>以二进制方式读文件</p><p><code>wb</code>   </p><p>以二进制方式写文件，如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</p><p><code>ab</code></p><p>追加，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入</p><p><code>rb+</code></p><p>以二进制格式打开一个文件用于读写</p><p><code>wb+</code></p><p>以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件</p><p><code>ab+</code></p><p>以二进制格式打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写</p></li></ul><p><strong>read()</strong></p><p>read(num)，num表示要从文件中读取的数据的长度(单位是字节)，如果没有传入num，那么就表示读取文件中所有的数据，返回的数据类型是一个字符串</p><p><strong>readline()</strong></p><p>每次读出一行内容，包括 <code>\n</code>字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法1</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    content = file.readline()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line">    <span class="keyword">if</span> content ==<span class="string">&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#方法2</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(<span class="string">&#x27;文件名&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(line)</span><br></pre></td></tr></table></figure><p><strong>readlines()</strong></p><p>读取整个文件所有行，保存在一个列表中，每行作为一个元素</p><p><strong>strip()</strong></p><p>使用strip去掉每行结束的<code>\n</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> file.readlines():</span><br><span class="line"></span><br><span class="line">line=line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>write()</strong></p><p>写数据，只能写入字符串和二进制</p><p><strong>writelines()</strong></p><p>写行数据，只能写入字符串和二进制</p><p>将多个值同时写入一行中</p><h2 id="25-4-文件指针"><a href="#25-4-文件指针" class="headerlink" title="25.4. 文件指针"></a>25.4. 文件指针</h2><ul><li>tell()</li><li>seek()</li></ul><h2 id="25-5-CSV文件的读写"><a href="#25-5-CSV文件的读写" class="headerlink" title="25.5. CSV文件的读写"></a>25.5. CSV文件的读写</h2><p>Comma-Separated Values，中文叫逗号分隔值或者字符分割值，其文件以纯文本的形式存储表格数据。可以把它理解为一个表格，只不过这个表格是以纯文本的形式显示的，单元格与单元格之间，默认使用逗号进行分隔，每行数据之间，使用换行进行分隔</p><h3 id="25-5-1-CSV文件的写⼊"><a href="#25-5-1-CSV文件的写⼊" class="headerlink" title="25.5.1. CSV文件的写⼊"></a>25.5.1. CSV文件的写⼊</h3><p>使用csv模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 以写⼊入⽅式打开⼀个csv⽂件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="comment"># 调⽤用writer⽅法，传⼊csv⽂件对象，得到的结果是⼀个CSVWriter对象</span></span><br><span class="line">writer = csv.writer(file)</span><br><span class="line"><span class="comment"># 调⽤CSVWriter对象的writerow⽅法，⼀行一行的写⼊数据</span></span><br><span class="line">writer.writerow([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;score&#x27;</span>])</span><br><span class="line"><span class="comment"># 还可以调⽤writerows⽅法，⼀次性写⼊多行数据</span></span><br><span class="line">writer.writerows([[<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;18&#x27;</span>, <span class="string">&#x27;98&#x27;</span>],[<span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;20&#x27;</span>, <span class="string">&#x27;99&#x27;</span>], [<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;17&#x27;</span>, <span class="string">&#x27;90&#x27;</span>], [<span class="string">&#x27;jerry&#x27;</span>, <span class="string">&#x27;19&#x27;</span>, <span class="string">&#x27;95&#x27;</span>]])</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="25-5-2-CSV文件的读取"><a href="#25-5-2-CSV文件的读取" class="headerlink" title="25.5.2. CSV文件的读取"></a>25.5.2. CSV文件的读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment"># 以读取⽅式打开⼀个csv⽂件</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># 调⽤csv模块的reader⽅法，得到的结果是⼀个可迭代对象reader = csv.reader(file)</span></span><br><span class="line"><span class="comment"># 对结果进行遍历，获取到结果里的每⼀⾏数据</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h2 id="25-6-内存中写入数据"><a href="#25-6-内存中写入数据" class="headerlink" title="25.6. 内存中写入数据"></a>25.6. 内存中写入数据</h2><p>StringIO和BytesIO</p><h2 id="25-7-序列化和反序列化"><a href="#25-7-序列化和反序列化" class="headerlink" title="25.7. 序列化和反序列化"></a>25.7. 序列化和反序列化</h2><p>通过文件操作，我们可以将字符串写入到一个本地文件。但是，如果是一个对象(如列表、字典、元组等)，就无法直接写入到一个文件里，需要对这个对象进行序列化，然后才能写入到文件里</p><h3 id="25-7-1-JSON模块"><a href="#25-7-1-JSON模块" class="headerlink" title="25.7.1. JSON模块"></a>25.7.1. JSON模块</h3><p>JSON的本质是字符串</p><p>反序列化</p><ul><li>json.loads()</li></ul><p>将已编码的 JSON 字符串解码为 Python 对象</p><ul><li>json.load()</li></ul><p>读取文件，把读取的JSON内容解码为 Python 对象</p><p>序列化</p><ul><li>json.dumps() </li></ul><p>将 Python 对象编码成 JSON 字符串，不会将数据保存到文件里</p><ul><li>json.dump()</li></ul><p><code>json.dump(数据,file)</code></p><p>将 Python 对象编码成 JSON 字符串，同时将数据保存到指定文件里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoshi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">file.write(pickle.dumps(a))</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h3 id="25-7-2-pickle模块"><a href="#25-7-2-pickle模块" class="headerlink" title="25.7.2. pickle模块"></a>25.7.2. pickle模块</h3><p>将对象转换成为二进制(只有python能识别的二进制)</p><p>反序列化</p><ul><li>pickle.loads()</li></ul><p>将二进制解码为 Python 对象</p><ul><li>pickle.load()</li></ul><p>读取文件，把读取的二进制内容解码为 Python 对象</p><p>序列化</p><ul><li>pickle.dumps() </li></ul><p>将 Python 对象编码成二进制，不会将数据保存到文件里</p><ul><li>pickle.dump()</li></ul><p><code>json.dump(数据,file)</code></p><p>将 Python 对象编码成二进制，同时将数据保存到指定文件里</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">a = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhaoshi&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">file.write(pickle.dumps(a))</span><br><span class="line">file.close()</span><br><span class="line"></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>)</span><br><span class="line">x = file.read()</span><br><span class="line"><span class="built_in">print</span>(pickle.loads(x))</span><br></pre></td></tr></table></figure><h3 id="25-7-3-对比"><a href="#25-7-3-对比" class="headerlink" title="25.7.3. 对比"></a>25.7.3. 对比</h3><ul><li>pickle</li></ul><p>pickle序列化是将对象按照一定的规则转换成为二进制保存，它不能跨平台传递数据</p><p>pickle的序列化会将对象的所有数据都保存</p><ul><li>json</li></ul><p>将对象转换成为字符串，json就是用来在不同平台间传递数据的</p><p>不是所有的对象都可以直接转换成为一个字符串</p><div class="table-container"><table><thead><tr><th>python</th><th>JSON</th></tr></thead><tbody><tr><td>dict</td><td>object</td></tr><tr><td>list、tuple</td><td>array</td></tr><tr><td>str</td><td>string</td></tr><tr><td>int、float</td><td>number</td></tr><tr><td>True</td><td>true</td></tr><tr><td>False</td><td>false</td></tr><tr><td>None</td><td>null</td></tr></tbody></table></div><h1 id="26-异常处理"><a href="#26-异常处理" class="headerlink" title="26. 异常处理"></a>26. 异常处理</h1><p>增加程序的稳定性(健壮性)，我们应该尽可能的考虑可能发生错误的点以及用户的使用方式，以使得程序不会轻易的崩溃</p><h2 id="26-1-try-except"><a href="#26-1-try-except" class="headerlink" title="26.1. try+except"></a>26.1. try+except</h2><p>except可以专门处理单一的错误或异常，也可以处理一组在元组中的错误/异常。如果没有给出错误或异常的名称，它会处理所有的错误和异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">可能会出现异常的代码块</span><br><span class="line"><span class="keyword">except</span> 异常的类型:</span><br><span class="line">出现异常以后的处理理语句</span><br></pre></td></tr></table></figure><h2 id="26-2-try-except-else"><a href="#26-2-try-except-else" class="headerlink" title="26.2. try+except+else"></a>26.2. try+except+else</h2><p>如果没有捕获到异常，那么就执行else中的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;产⽣生错误了了:%s&#x27;</span>%e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有捕获到异常，真⾼高兴&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="26-3-try-finally"><a href="#26-3-try-finally" class="headerlink" title="26.3. try+finally"></a>26.3. try+finally</h2><p>在程序中，如果一段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally，比如 文件关闭，释放锁，把数据库连接返还给连接池</p><p>如果函数里有finally，finally里的返回值会覆盖之前的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x = a/b</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;没有捕获到异常，真⾼兴&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(div(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment">#结果为 没有捕获到异常，真⾼兴</span></span><br></pre></td></tr></table></figure><h2 id="26-4-自定义异常"><a href="#26-4-自定义异常" class="headerlink" title="26.4. 自定义异常"></a>26.4. 自定义异常</h2><p>用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类</p><p>常用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br></pre></td></tr></table></figure><p>高级</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortInputException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;⾃定义的异常类&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, length, atleast</span>):</span><br><span class="line">    <span class="comment">#super().__init__()</span></span><br><span class="line">        self.length = length</span><br><span class="line">        self.atleast = atleast</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;输入的长度是 %d,长度至少应是 %d&#x27;</span>% (self.length, self.atleast)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        s = <span class="built_in">input</span>(<span class="string">&#x27;请输入 --&gt; &#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">3</span>:</span><br><span class="line">    <span class="comment"># raise 引发一个自定义的异常</span></span><br><span class="line">            <span class="keyword">raise</span> ShortInputException(<span class="built_in">len</span>(s), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">except</span> ShortInputException <span class="keyword">as</span> result: <span class="comment"># x这个变量被绑定到了错误的实例</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ShortInputException:&#x27;</span> % result)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没有异常发生.&#x27;</span>)</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><h2 id="26-5-异常获取"><a href="#26-5-异常获取" class="headerlink" title="26.5. 异常获取"></a>26.5. 异常获取</h2><ul><li>str(e)</li></ul><p>返回字符串类型，只给出异常信息，不包括异常信息的类型，如1/0的异常信息</p><p>‘integer division or modulo by zero’</p><ul><li>repr(e)</li></ul><p>给出较全的异常信息，包括异常信息的类型，如1/0的异常信息</p><p>“ZeroDivisionError(‘integer division or modulo by zero’,)”</p><ul><li>e.message</li></ul><p>获得的信息同str(e)</p><ul><li>采用traceback模块</li></ul><p>需要导入traceback模块，此时获取的信息最全，与python命令行运行程序出现错误信息一致。使用<code>traceback.print_exc()</code>打印异常信息到标准错误，就像没有获取一样，或者使用<code>traceback.format_exc()</code>将同样的输出获取为字符串。你可以向这些函数传递各种各样的参数来限制输出，或者重新打印到像文件类型的对象</p><p>注意：</p><p>在 Python 3 Exception 的 except 子句中，不支持使用逗号 <code>,</code>分隔 Exception 和 e，所以需要采用 as 关键词进行替换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以 1/0 异常处理为例</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;str(Exception):\t&#x27;</span>, e.message)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;str(e):\t\t&#x27;</span>, <span class="built_in">str</span>(e))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;repr(e):\t&#x27;</span>, <span class="built_in">repr</span>(e))</span><br></pre></td></tr></table></figure><p>与 Python 2 Exception 类相比，Python 3 Exception 类没有 message 成员变量。针对这个问题，可以采用 <code>sys.exc_info()</code>方法获取得到相关的异常信息。 <code>sys.exc_info</code>方法可以获取 except 子句正在处理的异常，其返回值为一个tuple类型的三元组<code>(exc_type, exc_value, exc_traceback)</code>，其中，<code>exc_type</code>为获取到的异常类型；<code>exc_value</code>为该异常类型对象；<code>exc_traceback</code>为一个 traceback 对象，包含异常最初发生的调用栈信息。</p><p> 程序中的变量 e 和 exc_value 是同一个异常类型实例对象</p><h1 id="27-with关键字"><a href="#27-with关键字" class="headerlink" title="27. with关键字"></a>27. with关键字</h1><p>对于系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭(断开)该资源，with关键字就是用来自动关闭资源的</p><p>with语句实质上是一个上下文管理器，with语句后的对象都会有<code>__enter__()</code>和<code>__exit__()</code> 方法。在进入到上下文时，会自动调用<code>__enter__()</code> 方法，程序正常执行完成，或者出现异常中断的时候，都会调用<code>__exit__()</code>方法</p><p>如 </p><p>用with关键字打开文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;路径&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> 变量名:</span><br></pre></td></tr></table></figure><h1 id="28-高级装饰器"><a href="#28-高级装饰器" class="headerlink" title="28. 高级装饰器"></a>28. 高级装饰器</h1><h1 id="29-迭代器"><a href="#29-迭代器" class="headerlink" title="29. 迭代器"></a>29. 迭代器</h1><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不能后退</p><h2 id="29-1-迭代对象-Iterable"><a href="#29-1-迭代对象-Iterable" class="headerlink" title="29.1. 迭代对象(Iterable)"></a>29.1. 迭代对象(Iterable)</h2><ul><li>本质</li></ul><p>一个具备了<code>__iter__</code> 方法的对象，就是一个可迭代对象</p><ul><li>判断</li></ul><p>使用 <code>isinstance()</code>判断一个对象是否是 Iterable 对象</p><h2 id="29-2-迭代器-Iterator"><a href="#29-2-迭代器-Iterator" class="headerlink" title="29.2. 迭代器(Iterator)"></a>29.2. 迭代器(Iterator)</h2><ul><li>本质</li></ul><p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器</p><ul><li>判断</li></ul><p>调用一个对象的<code>__iter__</code> 方法，或者调用<code>iter()</code>内置函数，可以获取到一个可迭代对象的迭代器，然后使用<code>isinstance()</code>判断一个对象是否是 Iterator 对象</p><h1 id="30-生成器"><a href="#30-生成器" class="headerlink" title="30. 生成器"></a>30. 生成器</h1><p>生成器是一类特殊的迭代器</p><h1 id="31-时间戳转日期"><a href="#31-时间戳转日期" class="headerlink" title="31. 时间戳转日期"></a>31. 时间戳转日期</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 获得当前时间时间戳</span></span><br><span class="line">now = <span class="built_in">int</span>(time.time())</span><br><span class="line"><span class="comment">#转换为其他日期格式,如:&quot;%Y-%m-%d %H:%M:%S&quot;</span></span><br><span class="line">timeArray = time.localtime(now)</span><br><span class="line">otherStyleTime = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, timeArray)</span><br><span class="line"><span class="built_in">print</span>(otherStyleTime)</span><br></pre></td></tr></table></figure><h1 id="32-linux下的py"><a href="#32-linux下的py" class="headerlink" title="32. linux下的py"></a>32. linux下的py</h1><h2 id="32-1-代码执行"><a href="#32-1-代码执行" class="headerlink" title="32.1. 代码执行"></a>32.1. 代码执行</h2><ul><li>用python指令执行</li><li>用shebang，Shebang（也称为Hashbang）是一个由井号和叹号构成的字符序列<code>#!</code>，shebang符号可以在脚本内部指定解释器路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;hahah&#x27;</span></span><br><span class="line"></span><br><span class="line">先赋予这个脚本文件执行权限</span><br><span class="line">然后`./脚本名称`，即可运行</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-04-25-Python%E4%B9%8B%E6%97%85%E4%B8%8B/"/>
      <url>/2024/10/28/2022-04-25-Python%E4%B9%8B%E6%97%85%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类"><a href="#1-类" class="headerlink" title="1. 类"></a>1. 类</h1><h2 id="1-1-类和实例"><a href="#1-1-类和实例" class="headerlink" title="1.1. 类和实例"></a>1.1. 类和实例</h2><ul><li>类是具有相同<strong>属性</strong>和<strong>方法</strong>的一组对象的集合，实例是一个个具体的对象。</li><li>方法是与实例绑定的函数。</li><li>获取对象信息可使用下面方法：<ul><li><code>type(obj)</code>：来获取对象的相应类型；</li><li><code>isinstance(obj, type)</code>：判断对象是否为指定的 type 类型的实例；</li><li><code>hasattr(obj, attr)</code>：判断对象是否具有指定属性/方法；</li><li><code>getattr(obj, attr[, default])</code> 获取属性/方法的值, 要是没有对应的属性则返回 default 值（前提是设置了 default），否则会抛出 AttributeError 异常；</li><li><code>setattr(obj, attr, value)</code>：设定该属性/方法的值，类似于 obj.attr=value；</li><li><code>dir(obj)</code>：可以获取相应对象的<strong>所有</strong>属性和方法名的列表：</li></ul></li></ul><h2 id="1-2-继承和多态"><a href="#1-2-继承和多态" class="headerlink" title="1.2. 继承和多态"></a>1.2. 继承和多态</h2><ul><li>继承可以拿到父类的所有数据和方法，子类可以重写父类的方法，也可以新增自己特有的方法。</li><li>有了继承，才有了多态，不同类的对象对同一消息会作出不同的相应</li></ul><h2 id="1-3-类方法和静态方法"><a href="#1-3-类方法和静态方法" class="headerlink" title="1.3. 类方法和静态方法"></a>1.3. 类方法和静态方法</h2><ul><li>类方法使用 <code>@classmethod</code> 装饰器，可以使用类（也可使用实例）来调用方法。</li><li>静态方法使用 <code>@staticmethod</code> 装饰器，它是跟类有关系但在运行时又不需要实例和类参与的方法，可以使用类和实例来调用。</li></ul><h2 id="1-4-定制类和魔法方法"><a href="#1-4-定制类和魔法方法" class="headerlink" title="1.4. 定制类和魔法方法"></a>1.4. 定制类和魔法方法</h2><ul><li><code>__new__</code> 在 <code>__init__</code> 之前被调用，用来创建实例。</li><li><code>__str__</code> 是用 print 和 str 显示的结果，<code>__repr__</code> 是直接显示的结果。</li><li><code>__getitem__</code> 用类似 <code>obj[key]</code> 的方式对对象进行取值</li><li><code>__getattr__</code> 用于获取不存在的属性 obj.attr</li><li><p><code>__call__</code> 使得可以对实例进行调用</p><h2 id="1-5-slots魔法"><a href="#1-5-slots魔法" class="headerlink" title="1.5. slots魔法"></a>1.5. slots魔法</h2></li><li><p><strong>slots</strong> 魔法：限定允许绑定的属性.</p></li><li><code>__slots__</code> 设置的属性仅对当前类有效，对继承的子类不起效，除非子类也定义了 slots，这样，子类允许定义的属性就是自身的 slots 加上父类的 slots。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>)<span class="comment">#限制了动态属性</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">p = Person(<span class="string">&#x27;张三&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">p.name = <span class="string">&#x27;李李四&#x27;</span></span><br><span class="line">p.height = <span class="number">180</span><span class="comment">#报错</span></span><br></pre></td></tr></table></figure><p>对象p只能设置name和age属性，不能再动态添加属性 p.height = 180</p><h2 id="1-6-使用-property"><a href="#1-6-使用-property" class="headerlink" title="1.6. 使用@property"></a>1.6. 使用@property</h2><ul><li><code>@property</code> 把方法『变成』了属性。</li></ul><h2 id="1-7-super"><a href="#1-7-super" class="headerlink" title="1.7. super"></a>1.7. super</h2><ul><li>事实上，<code>super</code> 和父类没有实质性的关联。</li><li><code>super(cls, inst)</code> 获得的是 cls 在 inst 的 MRO 列表中的下一个类。</li></ul><h2 id="1-8-metaclass"><a href="#1-8-metaclass" class="headerlink" title="1.8. metaclass"></a>1.8. metaclass</h2><p>Python 中的元类（metaclass）是一个深度魔法，平时我们可能比较少接触到元类</p><ul><li>在 Python 中，类也是一个对象。</li><li>类创建实例，元类创建类。</li><li>元类主要做了三件事：<ul><li>拦截类的创建</li><li>修改类的定义</li><li>返回修改后的类</li></ul></li><li>当你创建类时，解释器会调用元类来生成它，定义一个继承自 object 的普通类意味着调用 type 来创建它。</li></ul><h1 id="2-python面向对象编程"><a href="#2-python面向对象编程" class="headerlink" title="2. python面向对象编程"></a>2. python面向对象编程</h1><h2 id="2-1-定义类"><a href="#2-1-定义类" class="headerlink" title="2.1. 定义类"></a>2.1. 定义类</h2><p>方法里的第一个参数必须是<code>self</code></p><p>class 类名:<br>    def 方法1(self,参数列表):<br>        pass<br>    def 方法2(self,参数列表):<br>        pass</p><h2 id="2-2-创建实例对象"><a href="#2-2-创建实例对象" class="headerlink" title="2.2. 创建实例对象"></a>2.2. 创建实例对象</h2><p>对象变量名 = 类名()</p><h1 id="如"><a href="#如" class="headerlink" title="如"></a>如</h1><p>a = A()</p><p>class People:<br>    def <strong>init</strong>(self,x,y,z):<br>        self.name = x<br>        self.age = y<br>        self.height = z<br>    def run(self):<br>        print(“正在跑步”)</p><pre><code>def eat(self):    print(&quot;正在吃东西&quot;)def __str__(self):    return &#39;自动调用print&#39;    </code></pre><p>s1 = People(‘小明’,16,180)    #这段代码做了</p><pre><code>                        #调用__new__方法用来申请内存空间                        #调用__init__方法，并让self指向申请好的那段内存空间，填充数据                        #让s1也指向那段内存空间</code></pre><p>print(s1)</p><h1 id="结果：自动调用print"><a href="#结果：自动调用print" class="headerlink" title="结果：自动调用print"></a>结果：自动调用print</h1><h2 id="2-3-self的使用"><a href="#2-3-self的使用" class="headerlink" title="2.3. self的使用"></a>2.3. self的使用</h2><ul><li>给对象添加属性</li></ul><p>class People:<br>    def <strong>init</strong>(self,x,y,z):<br>        self.name = x #添加属性<br>        self.age = y<br>        self.height = z</p><ul><li>python支持动态属性，当一个对象创建好了以后，直接使用<code>对象.属性名 = 属性值</code>就可以很方便的给对象添加一个属性。但是，不建议使用这种方式给对象添加属性</li></ul><p>tom = Cat()<br>tom.name = ‘Tom’  # 可以直接给 tom 对象添加⼀一个 name 属性</p><h3 id="2-3-1-self概念"><a href="#2-3-1-self概念" class="headerlink" title="2.3.1. self概念"></a>2.3.1. self概念</h3><p>哪个对象调用了方法，方法里的<code>self</code>指的就是谁。通过<code>self.属性名</code>可以访问到这个对象的属性。通过<code>self.方法名()</code> 可以调用这个对象的方法</p><h2 id="2-4-魔术方法"><a href="#2-4-魔术方法" class="headerlink" title="2.4. 魔术方法"></a>2.4. 魔术方法</h2><ul><li>特点</li></ul><p>两个下划线开始，两个下划线结束的方法</p><p>魔术方法在恰当的时候就会被激活，自动执行</p><ul><li><code>__init__</code>方法</li></ul><p>该方法在创建对象时，会默认被调用</p><p>方法里的self参数，在创建对象时不需要传递参数，python解释器会把创建好的对象引 用直接赋值给self</p><p>在类的内部，可以使用self来使用属性和调用方法。在类的外部，需要使用对象名来使用属性和调用方法</p><p>如果有多个对象，每个对象的属性是各自保存的，都有各自独立的地址</p><p>方法是所有对象共享的，只占用一份内存空间，方法被调用时会通过self来判断是哪个对象调用了实例方法</p><ul><li><code>__del__</code>方法</li></ul><p>该方法在删除对象时，会默认被调用</p><ul><li><code>__str__</code>方法</li></ul><p>返回对象的描述信息，使用<code>print()</code>函数打印对象时，其实调用的就是这个对象的 <code>__str__</code>方法</p><p>如果想要修改对象的输出的结果，可以重写<code>__str__</code>方法</p><ul><li><code>__repr__</code>方法</li></ul><p><code>__repr__</code>方法和 <code>__str__</code>方法功能类似，都是用来修改一个对象的默认打印内容。</p><p>在打印一个对象时，如果没有重写<code>__str__</code>方法，它会自动来查找<code>__repr__</code>方法。</p><p>如果这两个方法都没有，会直接打印这个对象的内存地址。</p><p>如果这两个方法都有，会调用<code>__str__</code>方法</p><ul><li><code>__call__</code></li></ul><p>对象后面加括号，触发执⾏</p><p>class People:<br>    def <strong>init</strong>(self,x,y,z):<br>        self.name = x<br>        self.age = y<br>        self.height = z<br>    def run(self):<br>        print(“正在跑步”)</p><pre><code>def eat(self):    print(&quot;正在吃东西&quot;)def __call__(self):    print(&quot;__call方法被调用&quot;)</code></pre><p>s1 = People(‘小明’,16,180)</p><p>s1()    #调用<strong>call</strong>方法</p><p>class People:<br>    def <strong>init</strong>(self,x,y,z):<br>        self.name = x<br>        self.age = y<br>        self.height = z<br>    def run(self):<br>        print(“正在跑步”)</p><pre><code>def eat(self):    print(&quot;正在吃东西&quot;)def __call__(self,*args,**kwargs):    print(&quot;__call方法被调用&quot;)    print(&quot;&#123;&#125;\n&quot;.format(args))    print(&quot;&#123;&#125;\n&quot;.format(kwargs))    fun = kwargs[&#39;fn&#39;]    print(fun(args[0], args[1]))</code></pre><p>s1 = People(‘小明’,16,180)</p><p>s1(1,2,fn = lambda x,y:x+y)</p><ul><li><code>__eq__</code></li></ul><p><code>==</code>默认调用对象的<code>__eq__</code>方法，获取该方法的返回值。若<code>__eq__</code>方法不重写，则默认比较内存地址</p><p>身份运算符<code>is</code>用来判断两个对象是否是同一个对象</p><ul><li><code>__doc__</code></li></ul><p>表示类的描述信息，获取类中的文档说明<code>&#39;&#39;&#39;中的内容&#39;&#39;&#39;</code>，可以<code>类名.__doc__</code>也可以<code>__对象名.__doc__</code>调用</p><p>class Person:<br>    ‘’’一些介绍’’’<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>print(p.<strong>doc</strong>)    #结果：一些介绍</p><ul><li><code>__module__</code></li></ul><p>表示当前操作的对象在那个模块</p><p>class Person:<br>    ‘’’一些介绍’’’<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>print(p.<strong>module</strong>)    #结果是 <strong>main</strong></p><ul><li><code>__class__</code></li></ul><p>表示当前操作的对象的类是什么</p><p>class Person:<br>    ‘’’一些介绍’’’<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>print(p.<strong>class</strong>)    #结果是 <class '__main__.Person'></p><ul><li><code>__dict__</code></li></ul><p>以字典的形式，显示对象所有的属性和方法</p><p>class Person:<br>    ‘’’一些介绍’’’<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>print(p.<strong>dict</strong>)    #结果是 {‘name’: ‘张三’, ‘age’: 18}</p><h2 id="2-5-类属性和对象属性"><a href="#2-5-类属性和对象属性" class="headerlink" title="2.5. 类属性和对象属性"></a>2.5. 类属性和对象属性</h2><ul><li>类属性可以通过类对象或者实例对象访问</li></ul><p>class Person:<br>    number = ‘06’    #类属性<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>print(p.number)    #通过实例对象访问类属性<br>print(Person.number)    #通过类对象访问类属性</p><ul><li>如果有同名实例属性和类属性，实例对象会优先访问实例属性</li></ul><p>class Person:<br>    number = ‘06’    #类属性<br>    def <strong>init</strong>(self, name, age,number):<br>        self.name = name<br>        self.age = age<br>        self.number = number    #同名属性</p><p>p = Person(‘张三’, 18,’08’)</p><p>print(p.number)    #结果为08，实例对象会优先访问实例属性<br>print(Person.number)    ##结果为06</p><ul><li>类属性只能通过类对象修改，不能通过实例对象修改</li></ul><p>class Person:<br>    number = ‘06’<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)</p><p>p.number = ‘01’<br>print(Person.number)    #结果为06<br>Person.number = ‘01’<br>print(Person.number)    #结果为01</p><ul><li>类属性也可以设置为私有，前边添加两个下划线</li></ul><h2 id="2-6-私有属性和方法"><a href="#2-6-私有属性和方法" class="headerlink" title="2.6. 私有属性和方法"></a>2.6. 私有属性和方法</h2><p>对象的属性或者方法只可以在对象的内部使用，在外部不能被访问</p><h3 id="2-6-1-定义"><a href="#2-6-1-定义" class="headerlink" title="2.6.1. 定义"></a>2.6.1. 定义</h3><p>在定义属性或方法时，在属性名或者方法名前增加两个下划线 <code>__</code>，定义的就是私有属性或方法</p><h3 id="2-6-2-访问私有"><a href="#2-6-2-访问私有" class="headerlink" title="2.6.2. 访问私有"></a>2.6.2. 访问私有</h3><ul><li>直接访问</li></ul><p>在私有属性名或方法名前添加<code>_类名</code></p><p>class Person:<br>    def <strong>init</strong>(self, name, age):<br>        self.__money = 800    #私有属性<br>        self.name = name<br>        self.age = age</p><p>p = Person(‘张三’, 18)<br>print(p._Person__money)    #直接访问私有属性</p><ul><li>定义方法访问</li></ul><p>可以通过定义<code>get</code> 和 <code>set</code> 方法来实现访问私有</p><p>class Person:<br>    def <strong>init</strong>(self, name, age):<br>        self.__money = 800<br>        self.name = name<br>        self.age = age</p><pre><code>def get(self):    return self.__moneydef set(self,money):    self.__money = money</code></pre><p>p = Person(‘张三’, 18)<br>print(p.get())    #结果是 800<br>p.set(2)<br>print(p.get())    #结果是 2</p><h2 id="2-7-类方法"><a href="#2-7-类方法" class="headerlink" title="2.7. 类方法"></a>2.7. 类方法</h2><ul><li>对象方法可以使用<code>实例对象名.方法(参数)</code>调用，该方法不需要为<code>self</code>传参，会自动为<code>self</code>传参</li></ul><p>class Person:<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age<br>    def demo(self,number):    #类方法<br>        print(self.name + ‘学号是’ + number)</p><p>p = Person(‘张三’, 18)<br>p.demo(‘01’)    #通过对象调用</p><h1 id="结果-张三学号是01"><a href="#结果-张三学号是01" class="headerlink" title="结果 张三学号是01"></a>结果 张三学号是01</h1><ul><li>对象方法还可以使用<code>类名.方法(参数)</code>调用，该方法不会自动为<code>self</code>传参，需要手动指定<code>self</code></li></ul><p>class Person:</p><pre><code>def __init__(self, name, age):    self.name = name    self.age = agedef demo(self,number):    print(self.name + &#39;学号是&#39; + number)</code></pre><p>p = Person(‘张三’, 18)<br>Person.demo(p,’02’)    #通过类调用</p><h1 id="结果-张三学号是02"><a href="#结果-张三学号是02" class="headerlink" title="结果 张三学号是02"></a>结果 张三学号是02</h1><h2 id="2-8-继承"><a href="#2-8-继承" class="headerlink" title="2.8. 继承"></a>2.8. 继承</h2><ul><li><p>在Python中，继承可以分为单继承、多继承和多层继承</p></li><li><p>定义类时，在类名的括号后面传入父类的类名，表示子类继承父类</p></li></ul><p>class Animal:<br>    def <strong>init</strong>(self):<br>        pass<br>        ‘’’动物类’’’</p><pre><code>def sleep(self):    print(&#39;正在睡觉&#39;)</code></pre><p>class Dog(Animal):    #继承于Animal类<br>    ‘’’Dog类继承于Animal类’’’<br>    def <strong>init</strong>(self):<br>        pass</p><p>dog = Dog()<br>dog.sleep()</p><h1 id="3-高级特性"><a href="#3-高级特性" class="headerlink" title="3. 高级特性"></a>3. 高级特性</h1><h2 id="3-1-迭代器"><a href="#3-1-迭代器" class="headerlink" title="3.1. 迭代器"></a>3.1. 迭代器</h2><p>迭代是访问集合元素的一种方式。迭代器是一个可以记住遍历的位置的对象。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不能后退</p><p><strong>迭代对象(Iterable)</strong></p><p>含有 <code>__iter__()</code> 方法或 <code>__getitem__()</code> 方法的对象称之为可迭代对象</p><p>使用 Python 内置的 <code>hasattr()</code> 函数来判断一个对象是不是可迭代的，也可以使用 <code>isinstance()</code> 进行判断</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>([], <span class="string">&#x27;__iter__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>([], Iterable)</span><br></pre></td></tr></table></figure><p><strong>迭代器(Iterator)</strong></p><p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器，其中，<code>__iter()__</code> 方法返回迭代器对象本身，<code>next()</code> 方法返回容器的下一个元素，在没有后续元素时抛出 <code>StopIteration</code> 异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;__iter__&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">isinstance</span>([], Iterator)</span><br></pre></td></tr></table></figure><p>虽然元组、列表和字典等对象是可迭代的，但它们却不是迭代器！对于这些可迭代对象，可以使用 Python 内置的 <code>iter()</code> 函数获得它们的迭代器对象</p><p>Python 的 <code>for</code> 循环实质上是先通过内置函数 <code>iter()</code> 获得一个迭代器，然后再不断调用 <code>next()</code> 函数实现的</p><h2 id="3-2-生成器"><a href="#3-2-生成器" class="headerlink" title="3.2. 生成器"></a>3.2. 生成器</h2><p>生成器（generator）也是一种迭代器，在每次迭代时返回一个值，直到抛出 <code>StopIteration</code> 异常。它有两种构造方式：</p><ul><li>生成器表达式</li><li>生成器函数</li></ul><p><strong>生成器表达式</strong></p><p>和列表推导式的定义类似，生成器表达式使用 <code>()</code> 而不是 <code>[]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment"># 注意是()，而不是[]</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line"><span class="built_in">print</span> num</span><br></pre></td></tr></table></figure><p><strong>生成器函数</strong></p><p>含有 <code>yield</code> 关键字的函数，调用该函数时会返回一个生成器</p><ul><li>yield 把函数变成了一个生成器。</li><li>生成器函数的执行过程看起来就是不断地 <code>执行-&gt;中断-&gt;执行-&gt;中断</code> 的过程。<ul><li>一开始，调用生成器函数的时候，函数不会立即执行，而是返回一个生成器对象；</li><li>然后，当我们使用 <code>next()</code> 作用于它的时候，它开始执行，遇到 <code>yield</code> 语句的时候，执行被中断，并返回当前的迭代值，要注意的是，此刻会记住中断的位置和所有的数据，也就是执行时的上下文环境被保留起来；</li><li>当再次使用 <code>next()</code> 的时候，从原来中断的地方继续执行，直至遇到 <code>yield</code>，如果没有 <code>yield</code>，则抛出异常。</li></ul></li></ul><h2 id="3-3-上下文管理器"><a href="#3-3-上下文管理器" class="headerlink" title="3.3. 上下文管理器"></a>3.3. 上下文管理器</h2><ul><li>上下文管理器是支持上下文管理协议的对象，也就是实现了 <code>__enter__</code> 和 <code>__exit__</code> 方法。</li><li>通常，我们使用 <code>with</code> 语句调用上下文管理器。with 语句尤其适用于对资源进行访问的场景，确保执行过程中出现异常情况时也可以对资源进行回收，比如自动关闭文件等。</li><li><code>__enter__</code> 方法在 with 语句体执行前调用，with 语句将该方法的返回值赋给 as 字句中的变量，如果有 as 字句的话。</li><li><code>__exit__</code> 方法在退出<code>运行时上下文</code>时被调用，它负责执行『清理』工作，比如关闭文件，释放资源等。如果退出时没有发生异常，则 <code>__exit__</code> 的三个参数，即 type, value 和 traceback 都为 None。如果发生异常，返回 True 表示不处理异常，否则会在退出该方法后重新抛出异常以由 with 语句之外的代码逻辑进行处理</li></ul><h1 id="4-模块（module）"><a href="#4-模块（module）" class="headerlink" title="4. 模块（module）"></a>4. 模块（module）</h1><ul><li><p>python里，一个<code>.py</code>文件就是一个模块</p></li><li><p><code>.py</code>文件的命名必须遵守规则：由字母、数字、下划线构成，不能以数字开头</p></li></ul><h2 id="4-1-导入模块"><a href="#4-1-导入模块" class="headerlink" title="4.1. 导入模块"></a>4.1. 导入模块</h2><ul><li><code>import 模块名</code></li></ul><p>直接导入一个模块</p><ul><li><code>from 模块名 import 函数名</code></li></ul><p>导入一个模块里的方法或变量</p><ul><li><code>from 模块名 import *</code></li></ul><p>导入这个模块的所有方法和变量(不是所有)，使用该方法导入一个模块里所有的内容时，本质上是去查找这个模块的<code>__all__</code>属性，将<code>__all__</code>属性里声明的所有内容导入。如果这个模块里没有设置<code>__all__</code>属性，此时才会导入这个模块里的所有内容</p><ul><li><code>import 模块名 as 别名</code></li></ul><p>导入一个模块并为其起别名</p><ul><li><code>from 模块名 import 函数名 as 别名</code></li></ul><h2 id="4-2-pip"><a href="#4-2-pip" class="headerlink" title="4.2. pip"></a>4.2. pip</h2><ul><li>pip install 模块名</li></ul><p>下载第三方模块</p><ul><li>pip uninstall 模块名</li></ul><p>卸载第三方模块</p><ul><li>pip freeze</li></ul><p>列出当前环境安装模块名和版本号</p><ul><li>pip freeze &gt; filename</li></ul><p>将安装的模块名和版本号重定向输出到指定的文件</p><ul><li>pip install -r filename</li></ul><p>读取文件中的模块名和版本号并安装。该方法常用于将代码部署到服务器时，给服务器的python安装模块</p><ul><li>pip install 模块名 -i 源的地址</li></ul><p>(临时的)更改模块的下载源</p><ul><li>永久更改源地址</li></ul><p>在当前用户目录下(<code>C:\Users\用户名</code>)创建一个pip的文件夹，然后再在文件夹里创建pip.ini文件并输入以下内容</p><p>[global]<br>index-url=<a href="https://pypi.douban.com/simple">https://pypi.douban.com/simple</a><br>[install]<br>trusted-host=pypi.douban.com</p><h1 id="国内镜像"><a href="#国内镜像" class="headerlink" title="国内镜像"></a>国内镜像</h1><h1 id="阿里云-https-mirrors-aliyun-com-pypi-simple"><a href="#阿里云-https-mirrors-aliyun-com-pypi-simple" class="headerlink" title="阿里云 https://mirrors.aliyun.com/pypi/simple/"></a>阿里云 <a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></h1><h1 id="中国科技⼤大学-https-pypi-mirrors-ustc-edu-cn-simple"><a href="#中国科技⼤大学-https-pypi-mirrors-ustc-edu-cn-simple" class="headerlink" title="中国科技⼤大学 https://pypi.mirrors.ustc.edu.cn/simple/"></a>中国科技⼤大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></h1><h1 id="豆瓣-douban-https-pypi-douban-com-simple"><a href="#豆瓣-douban-https-pypi-douban-com-simple" class="headerlink" title="豆瓣(douban) https://pypi.douban.com/simple/"></a>豆瓣(douban) <a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a></h1><h1 id="清华大学-https-pypi-tuna-tsinghua-edu-cn-simple"><a href="#清华大学-https-pypi-tuna-tsinghua-edu-cn-simple" class="headerlink" title="清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/"></a>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></h1><h1 id="中国科学技术大学-https-pypi-mirrors-ustc-edu-cn-simple"><a href="#中国科学技术大学-https-pypi-mirrors-ustc-edu-cn-simple" class="headerlink" title="中国科学技术大学 https://pypi.mirrors.ustc.edu.cn/simple/"></a>中国科学技术大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a></h1><h2 id="4-3-模块里的私有成员"><a href="#4-3-模块里的私有成员" class="headerlink" title="4.3. 模块里的私有成员"></a>4.3. 模块里的私有成员</h2><p>模块里以一个下划线 <code>_</code>开始的变量和函数，是模块里的私有成员，当模块被导入时，以 <code>_</code>开头的变量默认不会被导入。但是它不具有强制性，如果一个代码强行使用以 <code>_</code>开头的变量，有时也可以。但是强烈不建议这样使用，因为有可能会出问题</p><h2 id="4-4-all"><a href="#4-4-all" class="headerlink" title="4.4. __all__"></a>4.4. <code>__all__</code></h2><p>一个存放模块变量和方法的列表</p><h2 id="4-5-name"><a href="#4-5-name" class="headerlink" title="4.5. __name__"></a>4.5. <code>__name__</code></h2><p>Python中，当直接运行一个py文件时，这个py文件里的<code>__name__</code>值是 <code>__main__</code>，当这个py文件被当作模块导入时<code>__name__</code>的值是文件名 ，据此可以判断一个py文件是被直接执行还是以模块的形式被导入。</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    print ‘This program is being run by itself’<br>else:<br>    print ‘I am being imported from another module’</p><h1 id="5-包"><a href="#5-包" class="headerlink" title="5. 包"></a>5. 包</h1><p>一般把 Python 里的一个代码文件夹称为一个包，并在包里创建<code>__init__.py</code> 文件</p><p><strong>导包</strong></p><p>以项目根目录为准，输入目标模块 或 包的路径： <code>from spiders._tools import xxx</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-05-23-PythonSocket/"/>
      <url>/2024/10/28/2022-05-23-PythonSocket/</url>
      
        <content type="html"><![CDATA[<h1 id="1-C-S问题"><a href="#1-C-S问题" class="headerlink" title="1. C/S问题"></a>1. C/S问题</h1><ul><li>服务器和客户端都有收发功能</li><li>这个过程中，一定要注意，收发是一一对应的，有发就要有收，并且<code>recv()</code>方法默认是阻塞的</li></ul><h1 id="2-服务器问题"><a href="#2-服务器问题" class="headerlink" title="2. 服务器问题"></a>2. 服务器问题</h1><ul><li>server = socket.socket() </li><li>server.bind() </li><li>server.listen()          </li></ul><p>以上3个方法，在整个socket期间均有效，不需要死循环</p><ul><li>服务器端运行到accept()方法时，程序阻塞等待客户端的连接，当客户端连接成功时，服务器端代码继续往下执行</li><li>服务器端运行到 recv()方法时，程序阻塞等待接收客户端发来的信息，当接收成功时，服务器端代码继续运行</li><li>若程序需要一直接收请求和接收数据，accept()和recv()方法，必须死循环</li></ul><p>参考代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=gbk</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;began listening...&#x27;</span>)</span><br><span class="line">ip_addr = (<span class="string">&quot;192.168.204.131&quot;</span>, <span class="number">9990</span>)  <span class="comment"># 绑定本地IP地址</span></span><br><span class="line">server = socket.socket()</span><br><span class="line">server.bind(ip_addr)</span><br><span class="line">server.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ser, addr = server.accept()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># ser.send((bytes(json.dumps(12345678),encoding = &#x27;gbk&#x27;)))</span></span><br><span class="line">            msg = ser.recv(<span class="number">1024</span>)</span><br><span class="line">            msg_data = json.loads(msg.decode(<span class="string">&#x27;gbk&#x27;</span>))</span><br><span class="line">            <span class="built_in">print</span>(msg_data)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">            <span class="comment"># print(123)</span></span><br><span class="line">            <span class="comment"># time.sleep(2)</span></span><br><span class="line">            <span class="comment"># msg = conn.recv(1024)</span></span><br><span class="line">            <span class="comment"># msg_data = json.loads(msg.decode(&#x27;gbk&#x27;))</span></span><br><span class="line">            <span class="comment"># print(msg_data)</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h1 id="3-客户端问题"><a href="#3-客户端问题" class="headerlink" title="3. 客户端问题"></a>3. 客户端问题</h1><ul><li>connect方法</li></ul><p>发送连接请求，只需使用一次，即可建立连接，不需要死循环</p><h1 id="4-分类"><a href="#4-分类" class="headerlink" title="4. 分类"></a>4. 分类</h1><h2 id="4-1-阻塞"><a href="#4-1-阻塞" class="headerlink" title="4.1. 阻塞"></a>4.1. 阻塞</h2><h2 id="4-2-非阻塞"><a href="#4-2-非阻塞" class="headerlink" title="4.2. 非阻塞"></a>4.2. 非阻塞</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-06-30-SpringData/"/>
      <url>/2024/10/28/2022-06-30-SpringData/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><h2 id="1-1-ORM"><a href="#1-1-ORM" class="headerlink" title="1.1. ORM"></a>1.1. ORM</h2><p>ORM（Object Relational Mapping）对象关系映射，ORM的目的是使数据操作能像操作对象那样方便，让程序员能够运用过面向对象的思想来操作数据对象，通常ORM框架会做到将数据库表映射成对象，封装一些基本的数据操作。</p><p>在实际开发时可以选择使用ORM框架，也可以使用直接的数据库操作，有时候因为性能要求只能直接操作数据。 </p><h2 id="1-2-JDBC和JPA"><a href="#1-2-JDBC和JPA" class="headerlink" title="1.2. JDBC和JPA"></a>1.2. JDBC和JPA</h2><p><strong>JDBC</strong></p><p>JDBC（Java Database Connectivity），JDBC是Java标准库提供的一组API，用于与关系型数据库进行直接交互。它提供了一种底层的、面向数据库的编程模型，开发人员需要手动编写SQL语句来执行数据库的操作，开发人员需要自己处理数据库连接管理、事务管理等方面的细节</p><p><strong>JPA</strong></p><p>JPA（Java Persistence API），JPA是一套基于ORM的规范。JPA通过对象和关系数据库之间的映射，将面向对象的编程模型与关系数据库进行交互。开发人员可以通过定义实体类和注解来描述对象与数据库表之间的映射关系，JPA框架会自动处理数据库的操作，如插入、更新、删除等。JPA提供了对象查询语言（JPQL）来执行数据库查询操作，可以更方便地进行面向对象的查询。</p><p>JPA并未提供ORM实现，它只是制订了一些规范</p><p><strong>JDBC和JPA的区别</strong></p><ul><li>不同标准：jdbc是Java操作数据库的统一接口标准；jpa是orm框架的统一接口标准。</li><li>用法区别：jdbc更注重数据库，orm则更注重于java代码，但是实际上jpa实现的框架底层还是用jdbc去和数据库打交道</li></ul><h1 id="2-多个数据访问框架的区别"><a href="#2-多个数据访问框架的区别" class="headerlink" title="2. 多个数据访问框架的区别"></a>2. 多个数据访问框架的区别</h1><p>Hibernate：是JPA的一种实现，是一个框架  </p><p>Spring Data JPA：对JPA规范的再次抽象，底层使用Hibernate实现  </p><p>Spring Data JDBC： jdbcTemplate模板数据库简化对数据库的操作，相比传统JDBC而言省去了，数<br>据库驱动，连接等无关配置，只需要写sql，设置参数  </p><p>Mybatis：是一个持久化框架，但不完全是一个orm框架，不是依照的jpa规范，它需要些sql语句，半ORM。</p><p><img src="F:\笔记\博客\文章图片\1495620-20201123154300030-967427760.jpg" alt="1495620-20201123154300030-967427760"></p><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h1><p>对于数据访问，无论是SQL（关系型数据库）还是NoSQL（非关系型数据库），Spring Boot底层都是采用Spring Data的方式进行统一处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">  A(Spring Data) --&gt;B(SQL);</span><br><span class="line">  A --&gt;C(NoSQL);</span><br><span class="line">  B--&gt; B.1(JDBC);</span><br><span class="line">  B.1--&gt;B.1.1(全ORM);</span><br><span class="line">  B.1--&gt;B.1.2(半ORM);</span><br><span class="line">  B.1.2--&gt;B.1.2.1(MyBatis);</span><br><span class="line">  B.1.1--&gt;B.1.1.1(JPA);</span><br><span class="line">  B.1.1.1--&gt;B.1.1.1.1(Hibernate);</span><br><span class="line">  C--&gt;C.1(spring-boot-starter-data-mongodb);</span><br><span class="line">  C--&gt;C.2(spring-boot-starter-data-redis);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-06-30-MyBatis/"/>
      <url>/2024/10/28/2022-06-30-MyBatis/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Mybatis简介"><a href="#1-Mybatis简介" class="headerlink" title="1. Mybatis简介"></a>1. <a href="https://mybatis.org/mybatis-3/zh">Mybatis</a>简介</h1><p><strong>MyBatis是对JDBC的封装</strong></p><p>MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录</p><p>MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架</p><p>MyBatis支持的数据库类型包括：Oracle、MySQL、SQL Server、DB2</p><h1 id="2-搭建MyBatis"><a href="#2-搭建MyBatis" class="headerlink" title="2. 搭建MyBatis"></a>2. 搭建MyBatis</h1><h2 id="2-1-开发环境"><a href="#2-1-开发环境" class="headerlink" title="2.1. 开发环境"></a>2.1. 开发环境</h2><p>JDK：1.8</p><p>构建工具：maven 3.5.4  </p><p>MySQL版本：MySQL 5.7  </p><p>MyBatis版本：MyBatis 3.5.7</p><h2 id="2-2-创建maven工程"><a href="#2-2-创建maven工程" class="headerlink" title="2.2. 创建maven工程"></a>2.2. 创建maven工程</h2><p>打包方式：jar</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Mybatis核心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- MySQL驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 为了实现使用注解代替实体Bean的getter and setter等..... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-创建MyBatis的核心配置文件"><a href="#2-3-创建MyBatis的核心配置文件" class="headerlink" title="2.3. 创建MyBatis的核心配置文件"></a>2.3. 创建MyBatis的核心配置文件</h2><blockquote><p>习惯上命名为<code>mybatis-config.xml</code>，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，操作时可以直接复制、粘贴（了解即可）<br>核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息<br>核心配置文件存放的位置是<code>src/main/resources</code>目录下</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--设置连接数据库的环境--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--开发环境的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!--生产环境的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;produce&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--引入映射文件--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;mappers/UserMapper.xml&quot;</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- 全局参数 --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">settings</span>&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!-- 使全局的映射器启用或禁用缓存 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span>             <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>   /&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!-- 允许JDBC 支持自动生成主键 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span>         <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>   /&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!-- 配置默认的执行器.SIMPLE就是普通执行器;REUSE执行器会重用预处理语句(prepared statements);BATCH执行器将重用语句并执行批量更新 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span>      <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span> /&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- 指定 MyBatis 所用日志的具体实现 --&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span>                  <span class="attr">value</span>=<span class="string">&quot;SLF4J&quot;</span>  /&gt;</span>  </span><br><span class="line">       <span class="comment">&lt;!-- 使用驼峰命名法转换字段 --&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!-- &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; --&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-4-创建mapper接口"><a href="#2-4-创建mapper接口" class="headerlink" title="2.4. 创建mapper接口"></a>2.4. 创建mapper接口</h2><blockquote><p>MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.offcn.mybatis.mapper;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserMapper</span> &#123;  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* 添加用户信息  </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="type">int</span> <span class="title function_">insertUser</span><span class="params">()</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-创建MyBatis的映射文件"><a href="#2-5-创建MyBatis的映射文件" class="headerlink" title="2.5. 创建MyBatis的映射文件"></a>2.5. 创建MyBatis的映射文件</h2><p><strong>相关概念</strong>：ORM（Object Relationship Mapping）对象关系映射。  </p><ul><li>对象：Java的实体类对象  </li><li>关系：关系型数据库  </li><li>映射：二者之间的对应关系</li></ul><div class="table-container"><table><thead><tr><th>Java概念</th><th>数据库概念</th></tr></thead><tbody><tr><td>类</td><td>表</td></tr><tr><td>属性</td><td>字段/列</td></tr><tr><td>对象</td><td>记录/行</td></tr></tbody></table></div><p><strong>映射文件的命名规则</strong></p><ul><li>表所对应的实体类的类名+Mapper.xml</li><li>例如：表user，映射的实体类为User，所对应的映射文件为UserMapper.xml </li><li>因此一个映射文件对应一个实体类，对应一张表的操作</li><li>MyBatis映射文件用于编写SQL，访问以及操作表中的数据</li><li>MyBatis映射文件存放的位置目录必须和接口所在包一毛一样。  接口: com.hy.mapper.UserMapper.java ，目录: com/hy/mapper/UserMapper.xml</li></ul><p><strong>MyBatis中可以面向接口操作数据，要保证两个一致</strong></p><ul><li>mapper接口的全类名和映射文件的命名空间（namespace）保持一致</li><li>mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致</li></ul><p><strong>配置xml模板参考</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span>  </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span>  </span></span><br><span class="line"><span class="meta"><span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span>  </span></span><br><span class="line"><span class="meta"><span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.hy.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--id表示接口当中定义的方法. resultType,表示数据库查询的结果.--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hy.entity.Student&quot;</span>&gt;</span></span><br><span class="line">        select * from student;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="3-核心配置文件详解（重点）"><a href="#3-核心配置文件详解（重点）" class="headerlink" title="3. 核心配置文件详解（重点）"></a>3. 核心配置文件详解（重点）</h1><blockquote><p>核心配置文件中的标签必须按照固定的顺序（有的标签可以不写，但顺序一定不能乱）：<br>properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers</p><p>重点配置有：properties、settings、typeAliases、environments、mappers</p><p>Mybatis默认的事务管理器就是JDBC。连接池：POOLED</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//MyBatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入properties文件，此时就可以$&#123;属性名&#125;的方式访问属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--将表中字段的下划线自动转换为驼峰--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.offcn.mybatis.bean&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            transactionManager：设置事务管理方式</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理</span></span><br><span class="line"><span class="comment">            type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">            属性：</span></span><br><span class="line"><span class="comment">            type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">            type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引入映射文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">        注意：</span></span><br><span class="line"><span class="comment">1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下</span></span><br><span class="line"><span class="comment">2. mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.offcn.mybatis.mapper&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-1-动态配置属性值"><a href="#3-1-动态配置属性值" class="headerlink" title="3.1. 动态配置属性值"></a>3.1. 动态配置属性值</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">引入db.properties文件，此时可用 $&#123;属性名&#125; 的方式访问属性值</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">如</span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-2-设置多个数据库环境"><a href="#3-2-设置多个数据库环境" class="headerlink" title="3.2. 设置多个数据库环境"></a>3.2. 设置多个数据库环境</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">   environments：设置多个连接数据库的环境</span></span><br><span class="line"><span class="comment">            default：设置默认使用的环境的id</span></span><br><span class="line"><span class="comment">            environment：设置具体的连接数据库的环境信息</span></span><br><span class="line"><span class="comment">            id：设置环境的唯一标识</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">如</span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql_test&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-3-设置数据源"><a href="#3-3-设置数据源" class="headerlink" title="3.3. 设置数据源"></a>3.3. 设置数据源</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            dataSource：设置数据源</span></span><br><span class="line"><span class="comment">        type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot;</span></span><br><span class="line"><span class="comment">        type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">如</span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置驱动类的全类名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的连接地址--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的用户名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置连接数据库的密码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-4-类型别名"><a href="#3-4-类型别名" class="headerlink" title="3.4. 类型别名"></a>3.4. 类型别名</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--   </span></span><br><span class="line"><span class="comment">        typeAlias：给类起别名</span></span><br><span class="line"><span class="comment">        type：需要设置别名的类的全类名</span></span><br><span class="line"><span class="comment">        alias：设置的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">如</span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>= <span class="string">&quot;com.hy.Author&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--以包为单位，设置该包下所有的类都拥有默认的别名，即类名，且不区分大小写--&gt;</span></span><br><span class="line">如</span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.hy.entity&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5-引入映射文件"><a href="#3-5-引入映射文件" class="headerlink" title="3.5. 引入映射文件"></a>3.5. 引入映射文件</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入单个映射文件</span></span><br><span class="line"><span class="comment">&lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; </span></span><br><span class="line"><span class="comment">或</span></span><br><span class="line"><span class="comment">&lt;mapper class=&quot;com.hy.UserMapper&quot;/&gt;  注解和xml可同时生效</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">如</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;UserMapper.xml&quot;</span>/&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     以包为单位，将包下所有的映射文件引入核心配置文件</span></span><br><span class="line"><span class="comment">   注意：</span></span><br><span class="line"><span class="comment">   MyBatis映射文件存放的位置目录必须和接口所在包一毛一样</span></span><br><span class="line"><span class="comment">   mapper接口要和mapper映射文件的名字一致</span></span><br><span class="line"><span class="comment">   接口: com.hy.mapper.UserMapper.java </span></span><br><span class="line"><span class="comment">   目录: com/hy/mapper/UserMapper.xml</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">如：</span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.hy.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-6-设置"><a href="#3-6-设置" class="headerlink" title="3.6. 设置"></a>3.6. 设置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，此时字段名就会转换为userName</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-7-生命周期"><a href="#3-7-生命周期" class="headerlink" title="3.7. 生命周期"></a>3.7. 生命周期</h2><p>这三个组件共同构成了 MyBatis 的核心机制，用于实现数据库操作的配置、创建和执行。<code>SqlSessionFactoryBuilder</code> 用于创建 <code>SqlSessionFactory</code>，而 <code>SqlSessionFactory</code> 用于创建 <code>SqlSession</code>，最终通过 <code>SqlSession</code> 执行具体的数据库操作</p><p><strong>SqlSessionFactoryBuilder</strong></p><p>读取配置文件或配置对象，并根据这些配置创建一个<code>SqlSessionFactory</code> 实例</p><p><strong>SqlSessionFactory</strong></p><p><code>SqlSessionFactory</code> 的创建是一个耗费资源的过程，因此在应用程序启动时通常只会创建一个 <code>SqlSessionFactory</code> 实例，并在整个应用程序生命周期中重复使用。<code>SqlSessionFactory</code> 可以根据配置信息创建和管理数据库连接，同时也负责加载映射文件或注解，并将其转化为可执行的 SQL 语句</p><p><strong>SqISession</strong></p><p><code>SqlSession</code> 是与数据库交互的主要接口。它提供了执行 SQL 语句、管理事务和与映射器（Mapper）交互的方法。通过 <code>SqlSessionFactory</code> 的 <code>openSession()</code> 方法可以创建 <code>SqlSession</code> 实例。每个数据库操作通常需要一个新的 <code>SqlSession</code> 实例。完成数据库操作后，应该及时关闭 <code>SqlSession</code>，以释放相关资源</p><h1 id="4-MyBatis的CRUD"><a href="#4-MyBatis的CRUD" class="headerlink" title="4. MyBatis的CRUD"></a>4. MyBatis的CRUD</h1><h2 id="4-1-模糊查询的三种姿势"><a href="#4-1-模糊查询的三种姿势" class="headerlink" title="4.1. 模糊查询的三种姿势"></a>4.1. 模糊查询的三种姿势</h2><ul><li>concat函数拼接<code>%</code></li><li>手动拼接<code>%%</code></li><li>慎用 <code>$&#123;&#125;</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> username <span class="keyword">like</span> concat(<span class="string">&#x27;%&#x27;</span>,#&#123;mohu&#125;,<span class="string">&#x27;%&#x27;</span>) </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">&#x27;%$&#123;mohu&#125;%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_user <span class="keyword">where</span> username <span class="keyword">like</span> &quot;%&quot;#&#123;mohu&#125;&quot;%&quot;</span><br></pre></td></tr></table></figure><h2 id="4-2-批量操作"><a href="#4-2-批量操作" class="headerlink" title="4.2. 批量操作"></a>4.2. 批量操作</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;deleteByFlag&quot; parameterType<span class="operator">=</span>&quot;String&quot;<span class="operator">&gt;</span>  </span><br><span class="line">    <span class="keyword">update</span> dorm_electric <span class="keyword">set</span> del_flag <span class="operator">=</span> <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">where</span> electric_id <span class="keyword">in</span>  </span><br><span class="line">    <span class="operator">&lt;</span>foreach item<span class="operator">=</span>&quot;electricId&quot; collection<span class="operator">=</span>&quot;array&quot; separator<span class="operator">=</span>&quot;,&quot;<span class="operator">&gt;</span>  </span><br><span class="line">        #&#123;electricId&#125;  </span><br><span class="line">    <span class="operator">&lt;</span><span class="operator">/</span>foreach<span class="operator">&gt;</span>  </span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h1 id="5-Mapper-XML文件中的参数传递"><a href="#5-Mapper-XML文件中的参数传递" class="headerlink" title="5. Mapper XML文件中的参数传递"></a>5. Mapper XML文件中的参数传递</h1><p><strong>获取参数值必须使用 #{}</strong></p><p><code>$&#123;&#125;</code>：静态sql，本质就是字符串拼接，有sql注入风险，不会自动添加单引号</p><p><code>#&#123;&#125;</code>：预编译sql，本质就是占位符赋值，用<code>?</code>占位，会自动添加单引号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;long&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">getUserById</span><span class="params">(<span class="type">long</span> id)</span>;</span><br></pre></td></tr></table></figure><p>SQL标签中的parameterType属性值是SQL语句中需要接收的参数的类型。可以是类型的完全限定名或别名，如<code>int 或 java.lang.Integer</code>、<code>hashmap 或 java.util.HashMap</code>，可以是实体类名</p><h2 id="5-1-单个参数"><a href="#5-1-单个参数" class="headerlink" title="5.1. 单个参数"></a>5.1. 单个参数</h2><p>若mapper接口中的方法参数为单个时，可以使用<code>$&#123;&#125;、#&#123;&#125;</code>获取参数的值，注意<code>$&#123;&#125;</code>需要手动加单引号（因为本质是字符串拼接）</p><ul><li>基本数据类型（如<code>int</code>、<code>long</code>、<code>String</code>等）。</li><li>包装类（如<code>Integer</code>、<code>Long</code>、<code>String</code>等）。</li><li>自定义Java对象。</li></ul><h2 id="5-2-多个参数"><a href="#5-2-多个参数" class="headerlink" title="5.2. 多个参数"></a>5.2. 多个参数</h2><p>若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">默认以arg0,arg1...为键，以参数为值</span><br><span class="line">或</span><br><span class="line">以param1,param2...为键，以参数为值</span><br></pre></td></tr></table></figure><br>可以使用<code>$&#123;&#125;、#&#123;&#125;</code>访问map集合的键来获取相对应的值，注意<code>$&#123;&#125;</code>需要手动加单引号。使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的</p><p>也可以在对应的mapper方法中使用<code>@Param</code>注解给每个参数指定名称，在XML中使用<code>#&#123;指定名称&#125;</code>来引用参数。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    UPDATE user SET name = #&#123;name&#125;, age = #&#123;age&#125; WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对应的mapper方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">updateUser</span><span class="params">(<span class="meta">@Param(&quot;id&quot;)</span> <span class="type">long</span> id, <span class="meta">@Param(&quot;name&quot;)</span> String name, <span class="meta">@Param(&quot;age&quot;)</span> <span class="type">int</span> age)</span>;</span><br></pre></td></tr></table></figure></p><h2 id="5-3-参数对象"><a href="#5-3-参数对象" class="headerlink" title="5.3. 参数对象"></a>5.3. 参数对象</h2><p>将参数封装为一个Java对象，并指定对象的类型</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertUser&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    INSERT INTO user (name, age) VALUES (#&#123;name&#125;, #&#123;age&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的mapper方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">insertUser</span><span class="params">(User user)</span>;</span><br></pre></td></tr></table></figure></p><h2 id="5-4-Map类型"><a href="#5-4-Map类型" class="headerlink" title="5.4. Map类型"></a>5.4. Map类型</h2><p>使用<code>java.util.Map</code>作为参数类型，在XML中使用<code>#&#123;key&#125;</code>来引用Map中的值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.Map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><br>对应的mapper方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User <span class="title function_">getUserById</span><span class="params">(Map&lt;String, Object&gt; params)</span>;</span><br></pre></td></tr></table></figure></p><h2 id="5-5-List类型"><a href="#5-5-List类型" class="headerlink" title="5.5. List类型"></a>5.5. List类型</h2><p>使用<code>java.util.List</code>作为参数类型，在XML中通过遍历来使用List中的值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUsersByIdList&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.util.List&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id IN</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;list&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">        #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的mapper方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; <span class="title function_">getUsersByIdList</span><span class="params">(List&lt;Long&gt; idList)</span>;</span><br></pre></td></tr></table></figure></p><h1 id="6-Mapper-XML文件中执行结果的映射方式"><a href="#6-Mapper-XML文件中执行结果的映射方式" class="headerlink" title="6. Mapper XML文件中执行结果的映射方式"></a>6. Mapper XML文件中执行结果的映射方式</h1><p><strong>MyBatis中xml标签的返回值</strong></p><ul><li>select 返回查询结果，返回的结果是多种多样的</li><li>update 返回更新的记录的条数</li><li>insert 返回插入的记录的条数</li><li>delete 返回删除的记录的条数</li></ul><h2 id="6-1-resultType映射"><a href="#6-1-resultType映射" class="headerlink" title="6.1. resultType映射"></a>6.1. resultType映射</h2><ul><li>返回结果是基本类型：resultType=基本类型  </li><li>返回结果是List类型：resultType=List中元素的类型  </li><li>返回结果是Map类型：resultType =map（适用于单条记录和多条记录）</li></ul><p>如果返回值为map单条记录，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getUser&quot; resultType<span class="operator">=</span>&quot;java.util.Map&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> id <span class="operator">=</span> #&#123;userId&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>如果返回值为map多条记录，比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">select</span> id<span class="operator">=</span>&quot;getCars&quot; resultType<span class="operator">=</span>&quot;java.util.Map&quot;<span class="operator">&gt;</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cars</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">select</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><p>通过使用<code>@MapKey</code>注解（ 在mapper接口的方法上添加），可以在返回多条记录的Map时，指定自定义的属性作为键，提供更灵活的结果映射方式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&quot;SELECT * FROM hotels&quot;)</span><br><span class="line"><span class="variable">@MapKey</span>(&quot;hotelName&quot;)</span><br><span class="line">Map<span class="operator">&lt;</span>String, Hotel<span class="operator">&gt;</span> getHotels();</span><br></pre></td></tr></table></figure><p>在上述代码中，查询结果中的<code>hotelName</code>列将被用作<code>Map</code>的键，而<code>Hotel</code>对象将作为对应的值。最终返回的<code>Map</code>对象的键将是<code>hotelName</code>的值，值将是对应的<code>Hotel</code>对象。</p><h2 id="6-2-resultMap映射"><a href="#6-2-resultMap映射" class="headerlink" title="6.2. resultMap映射"></a>6.2. resultMap映射</h2><p>resultMap 用于复杂的结果映射场景，可以定义多个映射规则，支持嵌套查询和关联关系的映射。resultMap 需要在映射文件中定义，并且可以重复使用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- resultMap 结果集映射</span></span><br><span class="line"><span class="comment"> id：表示自定义映射的唯一标识，不能重复</span></span><br><span class="line"><span class="comment"> type：查询的数据要映射的实体类的类型  </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;empResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Emp&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--column数据库中的字段，property实体类中的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;eid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;pwd&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--select标签中resultMap属性的值为前面 resultMap标签中id的值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getAllEmp&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;empResultMap&quot;</span>&gt;</span></span><br><span class="line">select * from t_emp;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-1-多对一映射处理"><a href="#6-2-1-多对一映射处理" class="headerlink" title="6.2.1. 多对一映射处理"></a>6.2.1. 多对一映射处理</h3><p>查询学生信息以及学生所对应的老师信息，多个学生可能对应同一个老师</p><p>思路：查询所有学生信息，再根据查出来的学生的tid，寻找对应老师</p><p>学生实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 学生关联一个老师</span></span><br><span class="line">    <span class="keyword">private</span> Teacher teacher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按查询嵌套处理</strong></p><p>相当于MySQL中子查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- association：处理多对一的映射关系</span><br><span class="line">- property：需要处理多对一的映射关系的属性名</span><br><span class="line">- javaType：该属性的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">select * from student;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单独处理：嵌套子查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacherById&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">select * from teacher where id = #&#123;tid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>按结果嵌套处理</strong></p><p>相当于MySQL中联表查询</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- association：处理多对一的映射关系</span><br><span class="line">- property：需要处理多对一的映射关系的属性名</span><br><span class="line">- javaType：该属性的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getStudent&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;StudentTeacher&quot;</span>&gt;</span></span><br><span class="line">    select s.id as sid,s.name as sname,t.id as tid,t.name as tname </span><br><span class="line">    from student as s,teacher as t </span><br><span class="line">    where s.tid=t.id;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;StudentTeacher&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂属性，单独处理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="6-2-2-一对多映射处理"><a href="#6-2-2-一对多映射处理" class="headerlink" title="6.2.2. 一对多映射处理"></a>6.2.2. 一对多映射处理</h3><p>查询老师信息以及老师所对应的学生信息，一个老师同时对应多个学生</p><p>思路：查询老师信息，再根据查出来的老师的id，寻找对应的学生</p><p>老师实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// 一个老师关联多个学生</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>按查询嵌套处理</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- collection：用来处理一对多的映射关系</span><br><span class="line">- ofType：表示该属性对应的集合中存储的数据的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select * from teacher where id=#&#123;tid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单独处理：嵌套子查询--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;ArrayList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getTeacherById&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacherById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">    select * from student where tid=#&#123;tid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>按结果嵌套处理</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- collection：用来处理一对多的映射关系</span><br><span class="line">- ofType：表示该属性对应的集合中存储的数据的类型</span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getTeacher&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;TeacherStudent&quot;</span>&gt;</span></span><br><span class="line">    select s.id as sid,s.name as sname,t.name as tname,t.id as tid</span><br><span class="line">    from student as s,teacher as t</span><br><span class="line">    where s.tid = t.id and t.id = #&#123;tid&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;TeacherStudent&quot;</span> <span class="attr">type</span>=<span class="string">&quot;Teacher&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--复杂属性，单独处理--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;students&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span> <span class="attr">column</span>=<span class="string">&quot;sname&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;tid&quot;</span> <span class="attr">column</span>=<span class="string">&quot;tid&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>对比</strong></p><div class="table-container"><table><thead><tr><th>嵌套查询</th><th>嵌套结果</th></tr></thead><tbody><tr><td>嵌套查询是在查询 SQL 后再进行一个（子）查询</td><td>嵌套结果是一个多表查询的 SQL 语句</td></tr><tr><td>会执行多条 SQL 语句</td><td>只有一条复杂的 SQL 语句（多表连接）</td></tr><tr><td>SQL语句编写较为简单</td><td>SQL语句编写较为复杂</td></tr><tr><td>单表查询用</td><td>多表联表查询用</td></tr></tbody></table></div><h2 id="6-3-驼峰映射"><a href="#6-3-驼峰映射" class="headerlink" title="6.3. 驼峰映射"></a>6.3. 驼峰映射</h2><p>Mybatis提供的驼峰命名映射的方式，如数据库中的<code>s_name</code>字段，能够自动映射到Java实体类中的<code>sName</code>属性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByname&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.hy.entity.Student&quot;</span>&gt;</span>  </span><br><span class="line">    select s_name from student;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>SpringBoot整合Mybatis后开启有两种方式，一个是配置文件中开启，一个是配置类开启</p><p>在<code>application.properties</code>配置文件中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span>  </span><br><span class="line">  <span class="attr">configuration:</span>  </span><br><span class="line">    <span class="attr">map-underscore-to-camel-case:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="7-延迟加载"><a href="#7-延迟加载" class="headerlink" title="7. 延迟加载"></a>7. 延迟加载</h1><p>MyBatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用全局延迟加载 <code>lazyLoadingEnabled=true|false</code>，当开启时，所有关联对象都会延迟加载  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><p>MyBatis延迟加载是通过在查询结果中返回代理对象来实现的。当查询结果中的代理对象被访问时，MyBatis会自动加载关联对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userResultMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;posts&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">select</span>=<span class="string">&quot;getPostByUserId&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserById&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userResultMap&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM users WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getPostByUserId&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;Post&quot;</span>&gt;</span></span><br><span class="line">  SELECT * FROM posts WHERE user_id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们首先定义了一个resultMap，它将User对象映射到数据库表中的行，并使用collection元素来定义User对象的posts属性。我们将fetchType属性设置为”lazy”，以启用延迟加载。注：<code>fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot;</code></p><p>然后，我们定义了一个getUserById查询，它使用userResultMap来映射查询结果。当查询结果中的User对象被访问时，MyBatis会自动加载与该User对象关联的Post对象。</p><p>最后，我们定义了一个getPostByUserId查询，它返回与给定用户ID关联的所有Post对象。当getUserById查询返回User对象时，MyBatis会自动加载与该User对象关联的Post对象</p><p><strong>使用场景</strong>：在对应的四种表关系中，一对多、多对多通常情况下采用延迟加载，多对一、一对一通常情况下采用立即加载</p><p>MyBatis 延迟加载的主要应用场景是在处理大量数据时，可以通过只在需要时加载数据来提高性能和减少内存占用。例如，如果你有一个包含大量订单的数据库表，而每个订单都有一个关联的用户，你可以使用延迟加载来避免在检索订单时同时加载所有相关的用户数据</p><h1 id="8-分页（重点）"><a href="#8-分页（重点）" class="headerlink" title="8. 分页（重点）"></a>8. 分页（重点）</h1><p>后端的分页应该使用物理分页</p><h2 id="8-1-RowBounds类"><a href="#8-1-RowBounds类" class="headerlink" title="8.1. RowBounds类"></a>8.1. RowBounds类</h2><p>属于逻辑分页。它是在 SQL 查询出所有结果的基础上截取数据的，数据量大时不适用</p><h2 id="8-2-数据库原生limit"><a href="#8-2-数据库原生limit" class="headerlink" title="8.2. 数据库原生limit"></a>8.2. 数据库原生limit</h2><p>属于物理分页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> limit #&#123;startIndex&#125;,#&#123;pageSize&#125;;</span><br></pre></td></tr></table></figure><h2 id="8-3-pagehelper插件（推荐）"><a href="#8-3-pagehelper插件（推荐）" class="headerlink" title="8.3. pagehelper插件（推荐）"></a>8.3. pagehelper插件（推荐）</h2><p>属于物理分页。分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数</p><h1 id="9-用注解实现CRUD（不推荐）"><a href="#9-用注解实现CRUD（不推荐）" class="headerlink" title="9. 用注解实现CRUD（不推荐）"></a>9. 用注解实现CRUD（不推荐）</h1><p>注解在接口上实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">List&lt;User&gt; <span class="title function_">getUsers</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>在mybatis-config.xml中绑定接口</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/hy/mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>本质：反射机制</p><p>底层：动态代理</p><h1 id="10-插入数据后主键回填（重点）"><a href="#10-插入数据后主键回填（重点）" class="headerlink" title="10. 插入数据后主键回填（重点）"></a>10. 插入数据后主键回填（重点）</h1><p>数据库的id（主键）字段设置为自增时，代码层面可以在每次新增完一条记录后，获取新增的记录的id（主键值）</p><p><strong>JDBC的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造PreparedStatement时添加一个参数：PreparedStatement.RETURN_GENERATED_KEYS</span></span><br><span class="line">ps = con.prepareStatement(<span class="string">&quot;INSERT INTO person(username,password,money) VALUES(?,?,?)&quot;</span>, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">ps.setObject(<span class="number">1</span>, person.getUsername());</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ps.executeUpdate();</span><br><span class="line"><span class="comment">// 在更新操作执行完成之后，调用 getGeneratedKeys ，然后又会获取到一个 ResultSet 对象，从这个游标集中就可以获取到刚刚插入数据的id。</span></span><br><span class="line">rs = ps.getGeneratedKeys();</span><br><span class="line"><span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">    id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyBatis的实现（推荐）</strong></p><p>在Mapper XML文件中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBook&quot;</span> <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span> </span><br><span class="line">insert into book (name,author) values (#&#123;name&#125;,#&#123;author&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>useGeneratedKeys = true</code>告诉MyBatis使用数据库自动生成的主键，并将其回填到keyProperty指定的id属性中</p><p>必须确保数据库表中的主键字段配置为自动生成，并且与实体类的属性名称匹配</p><p><strong>MySQL的实现</strong></p><p>利用MySQL自带的 <code>last_insert_id()</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insertBook&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        SELECT LAST_INSERT_ID()</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into t_book (b_name,author) values (#&#123;name&#125;,#&#123;author&#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="11-连接池替换"><a href="#11-连接池替换" class="headerlink" title="11. 连接池替换"></a>11. 连接池替换</h1><p>用第三方数据库连接池（Druid）替换MyBatis默认的连接池POOLED</p><h1 id="12-动态SQL（重点）"><a href="#12-动态SQL（重点）" class="headerlink" title="12. 动态SQL（重点）"></a>12. 动态SQL（重点）</h1><p>根据不同的条件生成不同的SQL语句</p><p>MyBatis的动态SQL本质上是通过拼接SQL语句来实现的，默认情况下 MySQL 可执行的最大 SQL 语句大小为 4194304 即 4MB，如果动态 SQL 拼接后的大小远大于默认值，则会报错。</p><p>如 实现查询功能，不给查询条件，则查询所有，给指定查询条件，则根据条件来查询，总之给不给条件都可以实现查询功能</p><h2 id="12-1-if"><a href="#12-1-if" class="headerlink" title="12.1. if"></a>12.1. if</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Blog&gt; queryBlog(Map map) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogIF&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">            and title=#&#123;title&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">            and author=#&#123;author&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-2-choose、when、otherwise"><a href="#12-2-choose、when、otherwise" class="headerlink" title="12.2. choose、when、otherwise"></a>12.2. choose、when、otherwise</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- List&lt;Blog&gt; queryBlogChoose(Map map) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryBlogChoose&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;blog&quot;</span>&gt;</span></span><br><span class="line">    select * from blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">                and title=#&#123;title&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">                and author=#&#123;author&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                and views = #&#123;views&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-3-trim、where、set"><a href="#12-3-trim、where、set" class="headerlink" title="12.3. trim、where、set"></a>12.3. trim、where、set</h2><p><strong>where标签</strong></p><p>插入where子句，若子句的开头为 “AND” 或 “OR”，where 标签也会将它们去除</p><p><strong>set</strong></p><p>set标签会动态前置SET关键字，同时也会删掉无关的逗号</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- int updateBlog(Map map) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;updateBlog&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">    update blog</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">            title = #&#123;title&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">            author = #&#123;author&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-4-SQL片段"><a href="#12-4-SQL片段" class="headerlink" title="12.4. SQL片段"></a>12.4. SQL片段</h2><p>使用 sql标签将SQL语句中用到的公共部分的SQL语句抽取出来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">id：唯一标识一个sql标签</span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;title !=null&quot;</span>&gt;</span></span><br><span class="line">        title = #&#123;title&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;author !=null&quot;</span>&gt;</span></span><br><span class="line">        author = #&#123;author&#125;,</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 include标签引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">refid：对应sql片段的唯一标识</span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;if-title-author&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="12-5-foreach"><a href="#12-5-foreach" class="headerlink" title="12.5. foreach"></a>12.5. foreach</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">collection：集合名</span><br><span class="line">item：集合中每个元素的命名</span><br><span class="line">open：以什么开始</span><br><span class="line">close：以什么结束</span><br><span class="line">separator：以什么分割</span><br><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">open</span>=<span class="string">&quot;and (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;or&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="13-缓存（了解）"><a href="#13-缓存（了解）" class="headerlink" title="13. 缓存（了解）"></a>13. 缓存（了解）</h1><p>提高查询效率，将用户经常查询的数据放在缓存（内存）中</p><p>频繁读，少量写的数据适合放在缓存</p><p>频繁写，少量读的数据不适合放在缓存</p><p>MyBatis系统中默认定义了两级缓存：一级缓存和二级缓存</p><p>默认情况下，只有一级缓存开启（SqlSession级别的缓存， 也称为本地缓存）</p><p>二级缓存需要手动开启和配置（namespace级别的缓存，也称为全局缓存）</p><p>为了提高扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存</p><h2 id="13-1-一级缓存"><a href="#13-1-一级缓存" class="headerlink" title="13.1. 一级缓存"></a>13.1. 一级缓存</h2><p><strong>缓存失效的情况</strong></p><p>查询不同的内容</p><p>增删改操作，可能会改变原来的数据，所以必定会刷新缓存</p><p>查询不同Mapper.xml</p><p>手动清理缓存 sqlSession.clearCache()</p><p><strong>小结</strong></p><p>一级缓存默认是开启的，只在一次SqISession中有效，也就是从拿到连接到关闭连接这个区间段</p><h2 id="13-2-二级缓存"><a href="#13-2-二级缓存" class="headerlink" title="13.2. 二级缓存"></a>13.2. 二级缓存</h2><p>一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中</p><p>如果当前会话关闭了，这个会话对应的一级缓存就没了，但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中，当新的会话查询信息时，就可以从二级缓存中获取内容</p><p><strong>开启全局缓存</strong></p><p>在 mybatis-config.xml 核心配置文件中，显式开启 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>    </span><br></pre></td></tr></table></figure><p>在相应的Mapper.xml中使用二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span></span></span><br><span class="line"><span class="tag"><span class="attr">eviction</span>=<span class="string">&quot;FIFO&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">flushInterval</span>=<span class="string">&quot; 60000&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">readOnly</span>= <span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>小结</strong></p><p>所有的数据都会先放在一级缓存中</p><p>只有当会话提交，或者关闭的时候，才会提交到二级缓冲中</p><h2 id="13-3-缓存原理"><a href="#13-3-缓存原理" class="headerlink" title="13.3. 缓存原理"></a>13.3. 缓存原理</h2><p>缓存顺序<br>1.先看级缓存中有没有<br>2.再看一级缓存中有没有<br>3.查询数据库</p><h2 id="13-4-自定义缓存Ehcache"><a href="#13-4-自定义缓存Ehcache" class="headerlink" title="13.4. 自定义缓存Ehcache"></a>13.4. 自定义缓存Ehcache</h2><p>Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存</p><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用自定义cache</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-08-03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/"/>
      <url>/2024/10/28/2022-08-03-%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="1-软件设计原则"><a href="#1-软件设计原则" class="headerlink" title="1. 软件设计原则"></a>1. 软件设计原则</h1><p><strong>抽象化与逐步求精</strong>：抽象的过程是从特殊到一般的过程. 上层概念是下层概念的抽象,下层概念是上层概念的精化和细化。</p><p><strong>逐步求精</strong>：把问题的求解过程分解成若干步骤或阶段，每步都比上步更精化,更接近问题的解法</p><p><strong>模块化</strong>:即把软件按照规定原则,划分为一个个较小的,相互独立的但又相互关联的部件。</p><p><strong>信息隐藏</strong>:每个模块的实现细节对于其它模块来说应该是隐蔽的</p><p><strong>模块独立</strong>:模块完成独立的功能并且与其他模块的接口简单符合信息隐蔽和信息局部化原则,模块间关联和依赖程度尽可能小</p><h1 id="2-软件生存周期"><a href="#2-软件生存周期" class="headerlink" title="2. 软件生存周期"></a>2. 软件生存周期</h1><p>计算机系统工程：包括计算机硬件、软件，以及使用计算机系统的人。数据库、文档、规程等系统元素</p><p><strong>需求分析</strong></p><p>主要解决“做什么”的问题</p><p><strong>设计</strong></p><p>主要解决“怎样做”的问题</p><p><strong>编码</strong></p><p>代码实现</p><p><strong>测试</strong></p><p>发现并纠正软件错误</p><p>编写单元测试用例，尽量覆盖每一个场景</p><p><strong>运行与维护</strong></p><p>在软件交付使用后对系统进行纠错和完善的过程。</p><h1 id="3-代码规范"><a href="#3-代码规范" class="headerlink" title="3. 代码规范"></a>3. 代码规范</h1><p><strong>遵循相关技术的最佳实践要求</strong></p><p>如Java的《阿里Java开发手册》、python的《Python PEP8 编码规范》</p><p><strong>版本控制</strong></p><p>统一开发环境和版本，统一开发工具和版本<br>使用Git控制代码版本的迭代</p><p><strong>编码控制</strong></p><p>编码统一（utf-8）</p><h1 id="4-编写README"><a href="#4-编写README" class="headerlink" title="4. 编写README"></a>4. 编写README</h1><p><strong>为什么要写README文件</strong></p><p>目的是能简要描述该项目的信息，让读者快速了解这个项目。</p><p><strong>它需要说明以下几个事项</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">软件定位，软件的基本功能</span><br><span class="line"> </span><br><span class="line">运行代码的方法：安装环境，启动命令等</span><br><span class="line"> </span><br><span class="line">简要的使用说明</span><br><span class="line"> </span><br><span class="line">代码目录结构说明，更详细点可以说明软件的基本原理</span><br><span class="line"> </span><br><span class="line">常见问题说明</span><br></pre></td></tr></table></figure></p><p><strong>包含的内容</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">项目和所有子模块和库的名称（对于新用户，有时不同命名会导致混乱）</span><br><span class="line"> </span><br><span class="line">对所有项目，和所有子模块和库的描述</span><br><span class="line"> </span><br><span class="line">如何使用 5-line code（如果是一个库）</span><br><span class="line"> </span><br><span class="line">版权和许可信息（或阅读许可证）</span><br><span class="line"> </span><br><span class="line">抓取文档指令</span><br><span class="line"> </span><br><span class="line">安装、配置和运行程序的指导</span><br><span class="line"> </span><br><span class="line">抓取最新代码和构建它们的说明（或快速概述和「阅读 Install」）</span><br><span class="line"> </span><br><span class="line">作者列表或「Read AUTHORS」</span><br><span class="line"> </span><br><span class="line">提交bug，功能要求，提交补丁，加入邮件列表，得到通知，或加入用户或开发开发区群的介绍</span><br><span class="line"> </span><br><span class="line">其他联系信息（电子邮件地址，网站，公司名称，地址等）</span><br><span class="line"> </span><br><span class="line">一个简短的历史记录（更改，替换或者其他）</span><br><span class="line"> </span><br><span class="line">法律声明</span><br></pre></td></tr></table></figure></p><h1 id="5-其他注意点"><a href="#5-其他注意点" class="headerlink" title="5. 其他注意点"></a>5. 其他注意点</h1><ul><li>没有版本控制，代码库和开发环境混乱</li><li>到处都用全局变量，可变范围太大，会导致程序后期不好维护</li><li>不做压力测试，到实际环境中往往就会出现更多的跟环境和性能相关的问题</li><li>没有很好的bug管理规范和系统，往往用word、email、excel等文本方式来管理bug</li></ul><h1 id="6-管理方面"><a href="#6-管理方面" class="headerlink" title="6. 管理方面"></a>6. 管理方面</h1><ul><li>项目内部定期开会，负责人检查各成员任务完成情况，解决遇到的问题，分配新的任务，务必保证每周要有进度。</li><li>组内分工要合理，以MVC为例，谁负责M，谁负责V，谁负责C</li><li>内部沟通的及时性，有问题及时向负责人反映，避免到期任务没完成的各种借口</li></ul><h1 id="7-软件效果"><a href="#7-软件效果" class="headerlink" title="7. 软件效果"></a>7. 软件效果</h1><p>往俗的说五点：管用、好看、省事、便利、好使</p>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-05-11-pyinstaller%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/10/28/2022-05-11-pyinstaller%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>安装pyinstaller 库</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyinstaller</span><br></pre></td></tr></table></figure><p><strong>打包命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller options ~/myproject/source/myscript.py</span><br></pre></td></tr></table></figure><p><strong>缩短命令</strong></p><p> in GNU/Linux:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --noconfirm --log-level=WARN \</span><br><span class="line">    --onefile --nowindow \</span><br><span class="line">    --add-data=&quot;README:.&quot; \</span><br><span class="line">    --add-data=&quot;image1.png:img&quot; \</span><br><span class="line">    --add-binary=&quot;libfoo.so:lib&quot; \</span><br><span class="line">    --hidden-import=secret1 \</span><br><span class="line">    --hidden-import=secret2 \</span><br><span class="line">    --upx-dir=/usr/local/share/ \</span><br><span class="line">    myscript.spec</span><br></pre></td></tr></table></figure><p>in Windows</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pyinstaller --noconfirm --log-level=WARN ^</span><br><span class="line">    --onefile --nowindow ^</span><br><span class="line">    --add-data=&quot;README;.&quot; ^</span><br><span class="line">    --add-data=&quot;image1.png;img&quot; ^</span><br><span class="line">    --add-binary=&quot;libfoo.so;lib&quot; ^</span><br><span class="line">    --hidden-import=secret1 ^</span><br><span class="line">    --hidden-import=secret2 ^</span><br><span class="line">    --icon=..\MLNMFLCN.ICO ^</span><br><span class="line">    myscript.spec</span><br></pre></td></tr></table></figure><h1 id="1-常规选项"><a href="#1-常规选项" class="headerlink" title="1. 常规选项"></a>1. 常规选项</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-h , --helpshow this help message and exit</span><br><span class="line"></span><br><span class="line">-v , --versionShow program version info and exit.</span><br><span class="line"></span><br><span class="line">--distpath DIRWhere to put the bundled app (default: ./dist)</span><br><span class="line"></span><br><span class="line">--workpath WORKPATH</span><br><span class="line"> Where to put all the temporary work files, .log, .pyz and etc. (default: ./build)</span><br><span class="line"> </span><br><span class="line">-y , --noconfirm</span><br><span class="line"> Replace output directory (default: SPECPATH/dist/SPECNAME) without asking for confirmation</span><br><span class="line"> </span><br><span class="line">--upx-dir UPX_DIR</span><br><span class="line"> Path to UPX utility (default: search the execution path)</span><br><span class="line"> </span><br><span class="line">-a , --asciiDo not include unicode encoding support (default: included if available)</span><br><span class="line"></span><br><span class="line">--cleanClean PyInstaller cache and remove temporary files before building.</span><br><span class="line"></span><br><span class="line">--log-level LEVEL</span><br><span class="line"> Amount of detail in build-time console messages. LEVEL may be one of TRACE, DEBUG, INFO, WARN, ERROR, CRITICAL (default: INFO).</span><br></pre></td></tr></table></figure><h1 id="2-要生成什么"><a href="#2-要生成什么" class="headerlink" title="2. 要生成什么"></a>2. 要生成什么</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-D , --onedirCreate a one-folder bundle containing an executable (default)</span><br><span class="line"></span><br><span class="line">-F , --onefileCreate a one-file bundled executable.</span><br><span class="line"></span><br><span class="line">--specpath DIRFolder to store the generated spec file (default: current directory)</span><br><span class="line"></span><br><span class="line">-n NAME , --name NAME</span><br><span class="line"> Name to assign to the bundled app and spec file (default: first script’s basename)</span><br></pre></td></tr></table></figure><h1 id="3-捆绑选项"><a href="#3-捆绑选项" class="headerlink" title="3. 捆绑选项"></a>3. 捆绑选项</h1><p>引用了哪些外部文件，他们在哪里</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">--add-data &lt;SRC;DEST or SRC:DEST&gt;</span><br><span class="line"> Additional non-binary files or folders to be added to the executable. The path separator is platform specific, os.pathsep (which is ; 在 Windows and : on most unix systems) is used. This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--add-binary &lt;SRC;DEST or SRC:DEST&gt;</span><br><span class="line"> Additional binary files to be added to the executable. 见 --add-data option for more details. This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">-p DIR , --paths DIR</span><br><span class="line"> A path to search for imports (like using PYTHONPATH). Multiple paths are allowed, separated by ‘:’, or use this option multiple times</span><br><span class="line"> </span><br><span class="line">--hidden-import MODULENAME , --hiddenimport MODULENAME</span><br><span class="line"> Name an import not visible in the code of the script(s). This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--additional-hooks-dir HOOKSPATH</span><br><span class="line"> An additional path to search for hooks. This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--runtime-hook RUNTIME_HOOKS</span><br><span class="line"> Path to a custom runtime hook file. A runtime hook is code that is bundled with the executable and is executed before any other code or module to set up special features of the runtime environment. This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--exclude-module EXCLUDES</span><br><span class="line"> Optional module or package (the Python name, not the path name) that will be ignored (as though it was not found). This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--key KEYThe key used to encrypt Python bytecode.</span><br></pre></td></tr></table></figure><h1 id="4-怎么生成"><a href="#4-怎么生成" class="headerlink" title="4. 怎么生成"></a>4. 怎么生成</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-d &lt;all,imports,bootloader,noarchive&gt; , --debug &lt;all,imports,bootloader,noarchive&gt;</span><br><span class="line"> </span><br><span class="line">Provide assistance with debugging a frozen application. This argument may be provided multiple times to select several of the following options.</span><br><span class="line"></span><br><span class="line">all: All three of the following options.</span><br><span class="line">imports: specify the -v option to the underlying Python interpreter, causing it to print a message each time a module is initialized, showing the place (filename or built-in module) from which it is loaded. See https://docs.python.org/3/using/cmdline.html#id4 .</span><br><span class="line">bootloader: tell the bootloader to issue progress messages while initializing and starting the bundled app. Used to diagnose problems with missing imports.</span><br><span class="line">noarchive: instead of storing all frozen Python source files as an archive inside the resulting executable, store them as files in the resulting output directory.</span><br><span class="line"></span><br><span class="line">-s , --stripApply a symbol-table strip to the executable and shared libs (not recommended for Windows)</span><br><span class="line"></span><br><span class="line">--noupxDo not use UPX even if it is available (works differently between Windows and *nix)</span><br><span class="line"></span><br><span class="line">--upx-exclude FILE</span><br><span class="line"> Prevent a binary from being compressed when using upx. This is typically used if upx corrupts certain binaries during compression. FILE is the filename of the binary without path. This option can be used multiple times.</span><br></pre></td></tr></table></figure><h1 id="5-win和mac的特殊选项"><a href="#5-win和mac的特殊选项" class="headerlink" title="5. win和mac的特殊选项"></a>5. win和mac的特殊选项</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c , --console , --nowindowed</span><br><span class="line"> Open a console window for standard i/o (default). On Windows this option will have no effect if the first script is a ‘.pyw’ file.</span><br><span class="line"> </span><br><span class="line">-w , --windowed , --noconsole</span><br><span class="line"> Windows and Mac OS X: do not provide a console window for standard i/o. On Mac OS X this also triggers building an OS X .app bundle. On Windows this option will be set if the first script is a ‘.pyw’ file. This option is ignored in *NIX systems.</span><br><span class="line"> </span><br><span class="line">-i &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt; , --icon &lt;FILE.ico or FILE.exe,ID or FILE.icns&gt;</span><br><span class="line"> FILE.ico: apply that icon to a Windows executable. FILE.exe,ID, extract the icon with ID from an exe. FILE.icns: apply the icon to the .app bundle on Mac OS X</span><br></pre></td></tr></table></figure><h1 id="6-win的特殊选项"><a href="#6-win的特殊选项" class="headerlink" title="6. win的特殊选项"></a>6. win的特殊选项</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">--version-file FILE</span><br><span class="line"> add a version resource from FILE to the exe</span><br><span class="line"> </span><br><span class="line">-m &lt;FILE or XML&gt; , --manifest &lt;FILE or XML&gt;</span><br><span class="line"> add manifest FILE or XML to the exe</span><br><span class="line"> </span><br><span class="line">-r RESOURCE , --resource RESOURCE</span><br><span class="line"> Add or update a resource to a Windows executable. The RESOURCE is one to four items, FILE[,TYPE[,NAME[,LANGUAGE]]]. FILE can be a data file or an exe/dll. For data files, at least TYPE and NAME must be specified. LANGUAGE defaults to 0 or may be specified as wildcard * to update all resources of the given TYPE and NAME. For exe/dll files, all resources from FILE will be added/updated to the final executable if TYPE, NAME and LANGUAGE are omitted or specified as wildcard *.This option can be used multiple times.</span><br><span class="line"> </span><br><span class="line">--uac-adminUsing this option creates a Manifest which will request elevation upon application restart.</span><br><span class="line"></span><br><span class="line">--uac-uiaccessUsing this option allows an elevated application to work with Remote Desktop.</span><br></pre></td></tr></table></figure><h1 id="7-将资源文件一起打包进exe"><a href="#7-将资源文件一起打包进exe" class="headerlink" title="7. 将资源文件一起打包进exe"></a>7. 将资源文件一起打包进exe</h1><p>基本原理：Pyinstaller 可以将资源文件一起bundle到exe中，当exe在运行时，会生成一个临时文件夹，程序可通过<code>sys._MEIPASS</code>访问临时文件夹中的资源</p><p><strong>建立资源文件夹</strong></p><p>把用到的外部资源png、txt等其他文件放到一个文件夹下</p><p><strong>修改主程序py</strong></p><p>修改主程序中读取资源数据路径部分的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成资源文件目录访问路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">resource_path</span>(<span class="params">relative_path</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getattr</span>(sys, <span class="string">&#x27;frozen&#x27;</span>, <span class="literal">False</span>): <span class="comment">#是否Bundle Resource</span></span><br><span class="line">        base_path = sys._MEIPASS</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        base_path = os.path.abspath(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> os.path.join(base_path, relative_path)</span><br><span class="line"></span><br><span class="line"><span class="comment">#访问res文件夹下数据.txt的内容</span></span><br><span class="line">filename = resource_path(os.path.join(<span class="string">&quot;res&quot;</span>,<span class="string">&quot;数据.txt&quot;</span>))</span><br></pre></td></tr></table></figure><p><strong>打包exe</strong></p><p>打包py程序</p><p><strong>修改spec</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">修改前datas=[]</span><br><span class="line">修改后datas=[(&#x27;res&#x27;,&#x27;res&#x27;)]</span><br><span class="line">意思是</span><br><span class="line">将主程序当前目录下的res目录（及其目录中的文件）加入目标exe中，在运行时放在零时文件的根目录下，名称为res</span><br><span class="line"></span><br><span class="line">datas[]列表里面是元组，左边是你要添加的filename（相对路径即可），右边是拷贝到项目中之后的文件夹名字。</span><br><span class="line"></span><br><span class="line">比如：(‘res/bg.jpg’, ‘res’) 中的 ‘res/bg.jpg’ 表示工程根目录下res文件夹下有bg.jpg图片，拷贝到项目之后的res文件夹。</span><br><span class="line">(‘exam.db’, ‘.’) 中的’exam.db’是工程根目录下的文件，’.&#x27;表示根目录，即拷贝到项目中的根目录下。</span><br></pre></td></tr></table></figure><p><strong>再次打包exe</strong></p><p>打包spec文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-08-17-Web%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%91%E5%B1%95/"/>
      <url>/2024/10/28/2022-08-17-Web%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8F%91%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本术语"><a href="#1-基本术语" class="headerlink" title="1. 基本术语"></a>1. 基本术语</h1><h2 id="1-1-什么是认证（Authentication）"><a href="#1-1-什么是认证（Authentication）" class="headerlink" title="1.1. 什么是认证（Authentication）"></a>1.1. 什么是认证（Authentication）</h2><p>通俗地讲就是<strong>验证当前用户的身份</strong>，证明你是你自己</p><p>互联网中的认证：</p><ul><li>用户名密码登录</li><li>邮箱发送登录链接</li><li>手机号接收验证码</li></ul><h2 id="1-2-什么是授权（Authorization）"><a href="#1-2-什么是授权（Authorization）" class="headerlink" title="1.2. 什么是授权（Authorization）"></a>1.2. 什么是授权（Authorization）</h2><p><strong>用户授予第三方应用访问该用户某些资源的权限</strong></p><ul><li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li><li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li><li>实现授权的方式有：Cookie、Session、token、OAuth</li></ul><h2 id="1-3-什么是凭证（Credentials）"><a href="#1-3-什么是凭证（Credentials）" class="headerlink" title="1.3. 什么是凭证（Credentials）"></a>1.3. 什么是凭证（Credentials）</h2><p><strong>实现认证和授权的前提</strong>是需要一种<strong>媒介（证书）</strong> 来标记访问者的身份</p><ul><li>通过身份证，我们可以办理手机卡/银行卡/个人贷款/交通出行等等，这就是<strong>认证的凭证</strong></li><li>在互联网应用中，一般网站会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞/收藏/分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li></ul><h2 id="1-4-什么是单点登录（Single-Sign-On，简称SSO）"><a href="#1-4-什么是单点登录（Single-Sign-On，简称SSO）" class="headerlink" title="1.4. 什么是单点登录（Single Sign-On，简称SSO）"></a>1.4. 什么是单点登录（Single Sign-On，简称SSO）</h2><p>单点登录，是指在多个关联的应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统</p><p>用户在首次登录时进行身份验证，并在成功后获得一个令牌（通常是加密的）。该令牌然后可以被传递给其他关联的应用程序，以证明用户的身份。其他应用程序会接受并验证令牌，从而允许用户访问应用程序。</p><h2 id="1-5-什么是源、站"><a href="#1-5-什么是源、站" class="headerlink" title="1.5. 什么是源、站"></a>1.5. 什么是源、站</h2><p><strong>一个URL的基本组成部分</strong></p><ul><li>协议（Protocol）：协议指定了访问 Web 资源所使用的通信协议，例如 HTTP 或 HTTPS。协议部分以冒号和两个斜杠开头，如 <code>http://</code> 或 <code>https://</code></li><li>域名（Domain Name）：域名是用于标识一个网站或服务器的名称。它可以是一个主机名（如 “example.com”）或者是一个 IP 地址（如 “192.0.2.1”）。域名部分跟在协议之后，并以斜杠或端口号（如果有的话）结尾。</li><li>端口号（Port Number）：端口号是用于标识网络通信中的特定应用程序或服务的数字。它通常是可选的，如果未指定，默认使用协议的默认端口号（例如 HTTP 默认端口号为 80，HTTPS 默认端口号为 443）。 </li><li>路径（Path）：路径表示 Web 服务器上特定资源的位置。它指定了服务器上资源的相对路径或绝对路径。路径部分跟在域名之后，以斜杠开头。</li><li>查询参数（Query Parameters）：查询参数用于向服务器传递附加的数据或参数。它们是由一个问号<code>?</code>开头，然后是一系列的键值对<code>key=value</code>，多个键值对之间使用<code>&amp;</code>分隔。</li><li>锚点（Anchor）：锚点用于指定页面内的特定位置或锚点。它以井号<code>#</code>开头，后面是指向页面内的特定元素的标识符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com:8080/path/to/resource?param1=value1&amp;param2=value2#section1</span><br></pre></td></tr></table></figure><p><strong>什么是源</strong></p><p>源 = 协议 + 域名 + 端口</p><p>URL<code>https://www.example.com:443/foo</code>，它的源是<code>https://www.example.com:443</code></p><p><strong>什么是站</strong></p><p>站 = 域名的限定子集：部分域名+顶级域名</p><p>URL<code>https://www.example.com:443/foo</code>，它的站是<code>www.example.com</code></p><p><strong>同源、跨源</strong></p><p>协议、域名、端口相同为同源，其他为跨源</p><p><strong>同站、跨站</strong></p><p>属于子域名下的网站是同站，其他为跨站</p><h2 id="1-6-什么是localStorage"><a href="#1-6-什么是localStorage" class="headerlink" title="1.6. 什么是localStorage"></a>1.6. 什么是localStorage</h2><p><code>localStorage</code>是一种在Web浏览器中存储数据的客户端存储机制</p><h1 id="2-Cookie"><a href="#2-Cookie" class="headerlink" title="2. Cookie"></a>2. Cookie</h1><p>背景：<strong>HTTP 是无状态的协议</strong></p><p>Cookie是一种在用户计算机上存储数据的技术，可以用于保存用户身份验证信息。Web应用可以将用户身份验证信息保存在Cookie中，然后在用户下次访问时从Cookie中读取这些信息。随着Web应用的不断发展，Cookie技术也得到了不断升级，例如HttpOnly、Secure、SameSite等。</p><p>Cookie是服务器发送到用户浏览器并保存在用户本地的一小块数据，它会在浏览器下次向同一服务器（相同域名）再发起请求时被携带并发送到服务器上</p><p>Cookie是不可跨域的，每个 Cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong></p><p><strong>Cookie 重要的属性</strong></p><div class="table-container"><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td><strong>name=value</strong></td><td>键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong>  <br>- 如果值为 Unicode 字符，则需要为字符编码（如utf-8）。  <br>- 如果值为二进制数据，则需要使用 BASE64 编码。</td></tr><tr><td><strong>domain</strong></td><td>指定 Cookie 所属域名，默认是当前域名</td></tr><tr><td><strong>path</strong></td><td><strong>指定 Cookie 在哪个路径（路由）下生效，默认是 ‘/‘</strong>。  <br>如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 Cookie</td></tr><tr><td><strong>maxAge</strong></td><td>Cookie 失效的时间，单位秒。如果为整数，则该 Cookie 在 maxAge 秒后失效。如果为负数，该 Cookie 为临时 Cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 Cookie 。如果为 0，表示删除该 Cookie 。默认为 -1。  <br>- <strong>比 expires 好用</strong>。</td></tr><tr><td><strong>expires</strong></td><td>HTTP响应头中的 “Expires” 字段，用于指定客户端缓存的过期时间，在设置的某个时间点后该 Cookie 就会失效。  <br>一般浏览器的 Cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 Cookie 也就会被删除</td></tr><tr><td><strong>secure</strong></td><td>该 Cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL等，在网络上传输数据之前先将数据加密。默认为false。  <br>当 secure 值为 true 时，Cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td></tr><tr><td><strong>httpOnly</strong></td><td><strong>如果给某个 Cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 Cookie 的信息，但还是能通过 Application 中手动修改 Cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td></tr></tbody></table></div><p><strong>使用 cookie 时需要考虑的问题</strong></p><ul><li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li><li>不要存储敏感数据，比如用户密码，账户余额</li><li>使用 httpOnly 在一定程度上提高安全性</li><li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li><li>设置正确的 domain 和 path，减少数据传输</li><li><strong>cookie 无法跨域</strong></li><li>一个浏览器针对一个网站最多存 20 个Cookie，浏览器一般只允许存放 300 个Cookie</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h1 id="3-Session"><a href="#3-Session" class="headerlink" title="3. Session"></a>3. Session</h1><p>Session是一种在服务器端存储数据的技术，用于保存用户身份验证信息。Web应用可以在用户登录时为其创建一个Session，当用户访问其他页面时，服务器根据由Cookie携带的<code>Session_id</code>从对应的Session中读取用户身份验证信息。Session技术的优点是可以避免用户身份验证信息被窃取，但是它需要占用服务器端的资源。</p><p>Session 是另一种记录服务器和客户端会话状态的机制</p><p>Session 是基于 cookie 实现的，Session 存储在服务器端，SessionId 会被存储到客户端的cookie 中</p><p><strong>Session 认证流程</strong></p><ul><li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li><li>服务器的响应中将此 Session 的唯一标识信息 SessionID 返回给浏览器</li><li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li><li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作</li></ul><p><strong>使用 session 时需要考虑的问题</strong></p><ul><li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li><li>当网站采用<strong>集群部署</strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li><li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li><li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h1 id="4-Session和Cookie的对比"><a href="#4-Session和Cookie的对比" class="headerlink" title="4. Session和Cookie的对比"></a>4. Session和Cookie的对比</h1><p><strong>产生</strong></p><p>Session和Cookie都是由服务器生成的，都是用来存储特定的值（键值对应）</p><p><strong>SessionID</strong></p><p>SessionID是服务器用来识别、操作存储Session值的对象的。在服务器端，Session的存储方式有文件方式、数据库方式，SessionID就是用来识别这个文件的（文件名相关)、识别数据库的某一条记录。SessionID并不是Session值。</p><p><strong>存取值的类型</strong></p><p>Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</p><p><strong>存储大小</strong> </p><p>单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</p><p><strong>生命周期</strong></p><p>客户端（浏览器）在发送请求的时候，会自动将存活、可用的Cookie封装在请求头中和请求一起发送</p><p>Cookie的生命周期由过期时间和持久性两个因素决定。过期时间是指Cookie在用户计算机上保留的时间，持久性是指Cookie是否在浏览器关闭后仍然保留。如果没有指定过期时间和持久性，则Cookie的生命周期默认为会话级别，即在用户关闭浏览器时自动删除。</p><p>Session的生命周期由服务器端的会话管理器控制，一般情况下，Session会在用户登录时创建，并在用户注销或超时后销毁。</p><p><strong>作用域</strong></p><p>Cookie和Session都是有其作用域的</p><p>Cookie的作用域由域名、路径和协议三个因素决定。只有在Cookie的作用域内才能被浏览器发送到服务器。</p><p>Session的作用域仅限于服务器端，客户端无法直接访问Session。Web应用可以通过在Cookie中保存Session ID的方式来跨请求管理Session。</p><p><strong>安全性</strong></p><p>Cookie是存储在客户端的，是可见的，是可以改变的。</p><p>Session是存储在服务器端的，是不可见的，是不可改变的。</p><h1 id="5-Token"><a href="#5-Token" class="headerlink" title="5. Token"></a>5. Token</h1><p>Token是一种短暂的、可撤销的凭证，用于验证用户身份。Web应用可以在用户登录时为其创建一个Token，并在每次请求中将Token传递给服务器，服务器端可以通过验证Token的合法性来验证用户身份。Token技术的优点是可以避免服务器端存储用户身份验证信息，从而减轻服务器端的负担。</p><p>可以把Token 放在Cookie里面自动发送，但是这样不能跨域。更好的做法是放在HTTP请求的头信息Authorization字段里面，单独发送</p><p>Token 一旦生成无法让其失效，必须等到其过期才行</p><p>简单 token 的组成： uid（用户唯一的身份标识）、time（当前时间的时间戳）、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</p><p><strong>token 的身份验证流程</strong></p><ul><li>客户端输入用户名和密码并请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li><li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li></ul><p><strong>使用 token 时需要考虑的问题</strong></p><ul><li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li><li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li><li><strong>token 可以避免 CSRF 攻击（因为不需要 cookie 了）</strong></li><li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li></ul><h1 id="6-Token-和-Session-的对比"><a href="#6-Token-和-Session-的对比" class="headerlink" title="6. Token 和 Session 的对比"></a>6. Token 和 Session 的对比</h1><p>Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利</p><p>Token 提供的是 认证 和 授权 ，认证是针对用户，授权是针对 应用 。其目的是让某 应用 有权利访问某用户的信息</p><p><strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></p><h1 id="7-Token-缺点"><a href="#7-Token-缺点" class="headerlink" title="7. Token 缺点"></a>7. Token 缺点</h1><p><strong>Token 太长了</strong></p><p>Token 是 header, payload 编码后的样式，所以一般要比 SessionId 长很多，很有可能超出 Cookie 的大小限制（Cookie 一般有大小限制的，如 4kb）</p><p><strong>不安全</strong></p><p>Token 是存在浏览器的，它太长放在 Cookie 里可能导致 Cookie 超限，那就只好放在 local storage 里，这样会造成安全隐患，因为 local storage 这类的本地存储是可以被 JS 直接读取的，另外由上文也提到，Token 一旦生成无法让其失效，必须等到其过期才行，这样的话如果服务端检测到了一个安全威胁，也无法使相关的Token 失效。</p><p><strong>所以 token 更适合一次性的命令认证，设置一个比较短的有效期</strong></p><h1 id="8-CSRF-攻击"><a href="#8-CSRF-攻击" class="headerlink" title="8. CSRF 攻击"></a>8. CSRF 攻击</h1><p>攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过（Cookie 里带来 SessionId 等身份认证的信息），所以被访问的网站会认为是真正的用户操作而去运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如用户登录了某银行网站（假设为 http://www.examplebank.com/，并且转账地址为 http://www.examplebank.com/withdraw?amount=1000&amp;transferTo=PayeeName），登录后 Cookie 里会包含登录用户的 Sessionid，攻击者可以在另一个网站上放置如下代码</span><br><span class="line">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</span><br></pre></td></tr></table></figure><p>那么如果正常的用户误点了上面这张图片，<strong>由于相同域名的请求会自动带上 Cookie</strong>，而 Cookie 里带有正常登录用户的 Sessionid，类似上面这样的转账操作在 server 就会成功，会造成极大的安全风险</p><p><strong>CSRF 攻击的根本原因在于对于同样域名的每个请求来说，它的 Cookie 都会被自动带上，这个是浏览器的机制决定的</strong></p><h1 id="9-JWT"><a href="#9-JWT" class="headerlink" title="9. JWT"></a>9. JWT</h1><p>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。是一种<strong>认证授权机制</strong></p><p>JWT 一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</p><p>可以使用 HMAC 算法或者是 RSA 的公/私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的</p><p><strong>JWT 认证流程</strong></p><ul><li>用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT</li><li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li><li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用Bearer 模式添加 JWT，其内容看起来是下面这样<code>Authorization: Bearer &lt;token&gt;</code></li><li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</li><li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li><li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li></ul><p><strong>JWT 的使用方式</strong></p><ul><li>方式一：放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT</li><li>方式二：跨域的时候，可以把 JWT 放在 POST 请求的数据体里</li><li>方式三：通过 URL 传输<code>http://www.example.com/user?token=xxx</code></li></ul><p><strong>使用 JWT 时需要考虑的问题</strong></p><ul><li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li><li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li><li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li><li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li><li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li><li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ul><h1 id="10-Token-和-JWT-的区别"><a href="#10-Token-和-JWT-的区别" class="headerlink" title="10. Token 和 JWT 的区别"></a>10. Token 和 JWT 的区别</h1><p><strong>相同：</strong></p><ul><li>都是访问资源的令牌</li><li>都可以记录用户的信息</li><li>都是使服务端无状态化</li><li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li></ul><p><strong>区别：</strong></p><ul><li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li><li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-09-12-C/"/>
      <url>/2024/10/28/2022-09-12-C/</url>
      
        <content type="html"><![CDATA[<h1 id="1-C程序运行过程"><a href="#1-C程序运行过程" class="headerlink" title="1. C程序运行过程"></a>1. C程序运行过程</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpp 编译-&gt; obj 连接-&gt; exe</span><br></pre></td></tr></table></figure><h1 id="2-其他"><a href="#2-其他" class="headerlink" title="2. 其他"></a>2. 其他</h1><p><strong>sizeof</strong></p><p>sizeof操作符以字节形式给出了其操作数的存储大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C语言中，每个变量和函数都有两个属性：数据类型和数据的存储类别</span><br><span class="line"></span><br><span class="line">把 建立存储空间的声明 称为定义，不需要 建立存储空间的声明 称为为声明</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p>定义了变量的类型后，在程序的输入、输出及数据运算时，一定要注意数据的类型，否则会出现无法预料的错误</p><h2 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1. 变量"></a>2.1. 变量</h2><p>内存中的一段存储空间</p><h3 id="2-1-1-初始化"><a href="#2-1-1-初始化" class="headerlink" title="2.1.1. 初始化"></a>2.1.1. 初始化</h3><p>内存中存在以前其他程序留下的值，即垃圾数据，若不初始化，变量会被填充垃圾数据</p><h3 id="2-1-2-局部与全局"><a href="#2-1-2-局部与全局" class="headerlink" title="2.1.2. 局部与全局"></a>2.1.2. 局部与全局</h3><p>C语言中的变量，按作用域范围可分为两种，即局部变量和全局变量</p><ul><li>局部变量也称为内部变量。局部变量是在函数内作定义说明的。其作用域仅限于函数内， 离开该函数后再使用这种变量是非法的。在复合语句中也可定义变量，其作用域只在复合语句范围内。</li><li>全局变量也称为外部变量，它是在函数外部定义的变量。它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序。</li></ul><p>如果在同一个源文件中，全局变量和局部变量同名，在局部变量的作用范围内，局部变量有效，全局变量被屏蔽，即不起作用</p><p>为了便于区分，习惯将全局变量的第一个字母大写</p><h3 id="2-1-3-变量的周期"><a href="#2-1-3-变量的周期" class="headerlink" title="2.1.3. 变量的周期"></a>2.1.3. 变量的周期</h3><p>C语言根据变量的生存周期来划分，可以分为静态存储方式和动态存储方式</p><ul><li>静态存储方式，是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了在整个程序执行过程中都存在的变量，如全局变量。</li><li>动态存储方式，是指在程序运行期间根据需要进行动态的分配存储空间的方式。动态存储区中存放的变量是根据程序运行的需要而建立和释放的，通常包括：函数形参、自动变量、函数调用时的现场保护和返回地址等</li></ul><h3 id="2-1-4-存储类别"><a href="#2-1-4-存储类别" class="headerlink" title="2.1.4. 存储类别"></a>2.1.4. 存储类别</h3><p>C语言中存储类别又分为四类</p><ul><li>自动（auto）</li></ul><p>用关键字auto定义的变量为自动变量，auto可以省略，属于动态存储方式</p><ul><li>静态（static）</li></ul><p>用static修饰的为静态变量，如果定义在函数内部的，称之为静态局部变量。如果定义在函数外部，称之为静态外部变量。</p><p>静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在程序整个运行期间都不释放。静态局部变量在编译时赋初值，即只赋初值一次。如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0或空字符。</p><p>当我们需要保留函数上一次的运行结果时，可以使用局部静态变量</p><ul><li>寄存器的（register）</li></ul><p>注意：只有局部自动变量和形参可以作为寄存器变量。一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量。局部静态变量不能定义为寄存器变量</p><ul><li>外部的（extern）</li></ul><p>用extern声明的的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量</p><h2 id="2-2-常量"><a href="#2-2-常量" class="headerlink" title="2.2. 常量"></a>2.2. 常量</h2><h3 id="2-2-1-常量在C中的表示"><a href="#2-2-1-常量在C中的表示" class="headerlink" title="2.2.1. 常量在C中的表示"></a>2.2.1. 常量在C中的表示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制</span><br><span class="line">十六进制 前面加 0x</span><br><span class="line">八进制 前面加 0</span><br></pre></td></tr></table></figure><h3 id="2-2-2-常量在计算机中的存储"><a href="#2-2-2-常量在计算机中的存储" class="headerlink" title="2.2.2. 常量在计算机中的存储"></a>2.2.2. 常量在计算机中的存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整数 以补码的形式</span><br><span class="line">实数 以IEEE754标准化存储</span><br><span class="line">字符 本质是整数，转为ASCII码</span><br></pre></td></tr></table></figure><h3 id="2-2-3-字符常量"><a href="#2-2-3-字符常量" class="headerlink" title="2.2.3. 字符常量"></a>2.2.3. 字符常量</h3><p><strong>单个字符</strong></p><p>用<code>&#39;&#39;</code></p><p><strong>字符串</strong></p><p>用<code>&quot;&quot;</code></p><h2 id="2-3-数据类型关键字"><a href="#2-3-数据类型关键字" class="headerlink" title="2.3. 数据类型关键字"></a>2.3. 数据类型关键字</h2><h3 id="2-3-1-基本数据类型"><a href="#2-3-1-基本数据类型" class="headerlink" title="2.3.1. 基本数据类型"></a>2.3.1. 基本数据类型</h3><ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种</li><li>int：整型数据，通常为编译器指定的机器字长</li><li>float：单精度浮点型数据，属于浮点数据的一种</li><li>double：双精度浮点型数据，属于浮点数据的一种</li></ul><h3 id="2-3-2-类型修饰关键字"><a href="#2-3-2-类型修饰关键字" class="headerlink" title="2.3.2. 类型修饰关键字"></a>2.3.2. 类型修饰关键字</h3><ul><li>short：修饰int，短整型数据，可省略被修饰的int。</li><li>long：修饰int，长整形数据，可省略被修饰的int。</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul><h3 id="2-3-3-复杂类型关键字"><a href="#2-3-3-复杂类型关键字" class="headerlink" title="2.3.3. 复杂类型关键字"></a>2.3.3. 复杂类型关键字</h3><ul><li>struct：结构体声明</li><li>union：共用体声明</li><li>enum：枚举声明</li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul><h3 id="2-3-4-存储级别关键字"><a href="#2-3-4-存储级别关键字" class="headerlink" title="2.3.4. 存储级别关键字"></a>2.3.4. 存储级别关键字</h3><ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</li></ul><h2 id="2-4-流程控制关键字"><a href="#2-4-流程控制关键字" class="headerlink" title="2.4. 流程控制关键字"></a>2.4. 流程控制关键字</h2><h3 id="2-4-1-跳转结构"><a href="#2-4-1-跳转结构" class="headerlink" title="2.4.1. 跳转结构"></a>2.4.1. 跳转结构</h3><ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul><h3 id="2-4-2-分支结构"><a href="#2-4-2-分支结构" class="headerlink" title="2.4.2. 分支结构"></a>2.4.2. 分支结构</h3><ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选。</li></ul><h3 id="2-4-3-循环结构"><a href="#2-4-3-循环结构" class="headerlink" title="2.4.3. 循环结构"></a>2.4.3. 循环结构</h3><ul><li>for：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件</li><li>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件</li><li>while：while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件</li></ul><p>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p><h2 id="2-5-数据类型"><a href="#2-5-数据类型" class="headerlink" title="2.5. 数据类型"></a>2.5. 数据类型</h2><h3 id="2-5-1-基本类型"><a href="#2-5-1-基本类型" class="headerlink" title="2.5.1. 基本类型"></a>2.5.1. 基本类型</h3><p><strong>整型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 占4字节</span><br></pre></td></tr></table></figure><p><strong>字符型</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char 占1字节</span><br></pre></td></tr></table></figure><p><strong>实型</strong></p><ul><li>单精度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float 占4字节</span><br></pre></td></tr></table></figure><ul><li>双精度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double 占8字节</span><br></pre></td></tr></table></figure><h3 id="2-5-2-构造类型"><a href="#2-5-2-构造类型" class="headerlink" title="2.5.2. 构造类型"></a>2.5.2. 构造类型</h3><p><strong>枚举类型</strong></p><p><strong>数组类型</strong></p><p><strong>结构体类型</strong></p><p><strong>共用体类型</strong></p><h3 id="2-5-3-指针类型"><a href="#2-5-3-指针类型" class="headerlink" title="2.5.3. 指针类型"></a>2.5.3. 指针类型</h3><h3 id="2-5-4-空类型"><a href="#2-5-4-空类型" class="headerlink" title="2.5.4. 空类型"></a>2.5.4. 空类型</h3><h2 id="2-6-类型转换"><a href="#2-6-类型转换" class="headerlink" title="2.6. 类型转换"></a>2.6. 类型转换</h2><p>强制类型转换<code>(数据类型) (表达式)</code></p><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="type">float</span>)(a)</span><br></pre></td></tr></table></figure><h2 id="2-7-宏定义"><a href="#2-7-宏定义" class="headerlink" title="2.7. 宏定义"></a>2.7. 宏定义</h2><p>宏名一般用大写</p><p><strong>不带参数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 字符串</span></span><br><span class="line">如</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> P 3</span></span><br></pre></td></tr></table></figure><p><strong>带参数</strong></p><p>带参数的宏展开，只是将语句中的宏名后面括号内的实参代替<code>#define</code>命令行中的形参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define S(r) r*r</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">S(a) = a*a</span><br><span class="line">S(a + b) = a + b * a + b 而不是 (a + b)*( a + b)</span><br></pre></td></tr></table></figure><h2 id="2-8-输入输出"><a href="#2-8-输入输出" class="headerlink" title="2.8. 输入输出"></a>2.8. 输入输出</h2><h3 id="2-8-1-输出"><a href="#2-8-1-输出" class="headerlink" title="2.8.1. 输出"></a>2.8.1. 输出</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>格式符</th><th>说明</th></tr></thead><tbody><tr><td><code>%p</code></td><td>将地址以十六进制输出</td></tr><tr><td><code>%d</code></td><td>输出十进制整数</td></tr><tr><td><code>%ld</code></td><td>输出长整型</td></tr><tr><td><code>%f</code></td><td>输出单精度浮点数</td></tr><tr><td><code>%lf</code></td><td>输出双精度浮点数</td></tr><tr><td><code>%c</code></td><td>输出单个字符</td></tr><tr><td><code>%s</code></td><td>输出字符串</td></tr><tr><td><code>%x</code></td><td>输出十六进制</td></tr><tr><td><code>%X</code></td><td>输出十六进制</td></tr><tr><td><code>%#X</code></td><td>输出十六进制，前面带<code>0x</code></td></tr></tbody></table></div><h3 id="2-8-2-输入"><a href="#2-8-2-输入" class="headerlink" title="2.8.2. 输入"></a>2.8.2. 输入</h3><p><code>&amp;</code>地址符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br></pre></td></tr></table></figure><h2 id="2-9-运算符"><a href="#2-9-运算符" class="headerlink" title="2.9. 运算符"></a>2.9. 运算符</h2><h3 id="2-9-1-算术运算符"><a href="#2-9-1-算术运算符" class="headerlink" title="2.9.1. 算术运算符"></a>2.9.1. 算术运算符</h3><ul><li><code>/</code></li></ul><p>如果相除的两个数都是整数的话，则结果也为整数，小数部分省略。如果两数中有一个为小数，结果则为小数</p><ul><li><code>%</code></li></ul><p>取余运算的对象必须是整数</p><h3 id="2-9-2-自增减运算符"><a href="#2-9-2-自增减运算符" class="headerlink" title="2.9.2. 自增减运算符"></a>2.9.2. 自增减运算符</h3><ul><li><code>i++</code></li></ul><p>先取值，再加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a++);</span><br><span class="line"><span class="comment">//结果是 10</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="comment">//结果是 11</span></span><br></pre></td></tr></table></figure><ul><li><code>++i</code></li></ul><p>先加，再取值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,++a);</span><br><span class="line"><span class="comment">//结果是 11</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">++a;</span><br><span class="line"><span class="comment">//结果是 11</span></span><br></pre></td></tr></table></figure><h3 id="2-9-3-赋值运算符"><a href="#2-9-3-赋值运算符" class="headerlink" title="2.9.3. 赋值运算符"></a>2.9.3. 赋值运算符</h3><h3 id="2-9-4-关系运算符"><a href="#2-9-4-关系运算符" class="headerlink" title="2.9.4. 关系运算符"></a>2.9.4. 关系运算符</h3><p>关系表达式的值是<code>真</code>和<code>假</code>，在C程序用整数<code>1</code>和<code>0</code>表示</p><h3 id="2-9-5-逻辑运算符"><a href="#2-9-5-逻辑运算符" class="headerlink" title="2.9.5. 逻辑运算符"></a>2.9.5. 逻辑运算符</h3><ul><li><code>&amp;&amp;</code></li></ul><p>与运算。左边表达式为假时，右边表达式不会执行</p><ul><li><code>||</code></li></ul><p>或运算。左边表达式为真时，右边表达式不被执行</p><ul><li><code>!</code></li></ul><p>非运算。参与运算的变量为真时，结果为假。参与运算量为假时，结果为真。例如 <code>!(5&gt;8)</code>，运算结果为真。</p><h3 id="2-9-6-三目运算符"><a href="#2-9-6-三目运算符" class="headerlink" title="2.9.6. 三目运算符"></a>2.9.6. 三目运算符</h3><p><code>表达式1 ? 表达式2 : 表达式3;</code></p><p>先判断表达式1的值是否为真，如果是真的话执行表达式2，如果是假的话执行表达式3</p><p>如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt;<span class="number">2</span> ? <span class="built_in">printf</span>(<span class="string">&quot;&gt;\n&quot;</span>):<span class="built_in">printf</span>(<span class="string">&quot;&lt;\n&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="2-10-选择结构"><a href="#2-10-选择结构" class="headerlink" title="2.10. 选择结构"></a>2.10. 选择结构</h2><h3 id="2-10-1-if"><a href="#2-10-1-if" class="headerlink" title="2.10.1. if"></a>2.10.1. if</h3><h2 id="2-11-循环结构"><a href="#2-11-循环结构" class="headerlink" title="2.11. 循环结构"></a>2.11. 循环结构</h2><h3 id="2-11-1-for"><a href="#2-11-1-for" class="headerlink" title="2.11.1. for"></a>2.11.1. for</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>)&#123;</span><br><span class="line"><span class="comment">//代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>for循环中的<code>表达式1、2、3</code>均可不写为空，但两个分号<code>;;</code>不能缺省</li><li>省略表达式1（循环变量赋初值），表示不对循环变量赋初始值</li><li>省略表达式2(循环条件)，不做其它处理，循环一直执行死循环</li><li>省略表达式3(循环变量增减量)，不做其他处理，循环一直执行（死循环）</li><li>表达式1可以是设置循环变量的初值的赋值表达式，也可以是其他表达式</li><li>表达式1和表达式3可以是一个简单表达式也可以是多个表达式以逗号分割</li></ul><h3 id="2-11-2-while"><a href="#2-11-2-while" class="headerlink" title="2.11.2. while"></a>2.11.2. while</h3><p>先判断，后执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11-3-do-while"><a href="#2-11-3-do-while" class="headerlink" title="2.11.3. do while"></a>2.11.3. do while</h3><p>先执行，后判断。因此，do while循环至少要执行一次循环语句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>();<span class="comment">//使用do-while结构语句时，while括号后必须有分号</span></span><br></pre></td></tr></table></figure><h2 id="2-12-分支结构"><a href="#2-12-分支结构" class="headerlink" title="2.12. 分支结构"></a>2.12. 分支结构</h2><h3 id="2-12-1-switch"><a href="#2-12-1-switch" class="headerlink" title="2.12.1. switch"></a>2.12.1. switch</h3><ul><li>在case后的各常量表达式的值不能相同，否则会出现错误</li><li>在case子句后如果没有break，那么一旦找到入口，则会一直往后执行。</li><li>switch后面的表达式语句只能是整型或者字符类型</li><li>在case后，允许有多个语句，可以不用<code>&#123;&#125;</code>括起来</li><li>各case和default子句的先后顺序可以变动，而不会影响程序执行结果</li><li><code>default</code>子句可以省略不用</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">1</span> : 执行代码块<span class="number">1</span> ; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">2</span> : 执行代码块<span class="number">2</span> ; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 常量表达式<span class="number">3</span> : 执行代码块<span class="number">3</span> ; <span class="keyword">break</span>;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">default</span> : 执行代码块;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-13-结束语句"><a href="#2-13-结束语句" class="headerlink" title="2.13. 结束语句"></a>2.13. 结束语句</h2><h3 id="2-13-1-break"><a href="#2-13-1-break" class="headerlink" title="2.13.1. break"></a>2.13.1. break</h3><ul><li>break用于循环，则是用来终止循环</li><li>break用于switch，则是用来跳出switch</li><li>break跳出的是最近的那层循环语句或switch语句</li><li>在没有循环结构的情况下，break不能用在单独的if else语句中</li></ul><h3 id="2-13-2-continue"><a href="#2-13-2-continue" class="headerlink" title="2.13.2. continue"></a>2.13.2. continue</h3><ul><li>不终止整个循环，只是提前结束本次循环，接着执行下次循环</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    A;</span><br><span class="line">    B;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A、B会被执行，但 C 不会被执行</span></span><br></pre></td></tr></table></figure><h2 id="2-14-数组"><a href="#2-14-数组" class="headerlink" title="2.14. 数组"></a>2.14. 数组</h2><h3 id="2-14-1-定义"><a href="#2-14-1-定义" class="headerlink" title="2.14.1. 定义"></a>2.14.1. 定义</h3><p>在程序中是一块连续的，大小固定并且里面的数据类型一致的内存空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名称[长度];</span><br></pre></td></tr></table></figure><ul><li>数组的下标均以0开始</li><li>定义数组时，数组长度必须为一个整型常量</li><li><code>数据类型 数组名称[长度n] = &#123;元素1,元素2…元素n&#125;;</code>，采用这种初始化方式，元素个数小于数组的长度时，多余的数组元素初始化为0</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">5</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//数组中所有元素都被初始化为 0 </span></span><br></pre></td></tr></table></figure><h3 id="2-14-2-数组长度"><a href="#2-14-2-数组长度" class="headerlink" title="2.14.2. 数组长度"></a>2.14.2. 数组长度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><h3 id="2-14-3-二维数组"><a href="#2-14-3-二维数组" class="headerlink" title="2.14.3. 二维数组"></a>2.14.3. 二维数组</h3><p>在C语言中，数组在内存中是按行存放的即从左到右一行存完再存下一行，所以二维数组必须指定列数，行数可以省略</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名称[行数][列数];</span><br></pre></td></tr></table></figure><p><strong>赋值</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">2</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;,&#123;<span class="number">8</span>,<span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-15-字符串"><a href="#2-15-字符串" class="headerlink" title="2.15. 字符串"></a>2.15. 字符串</h2><p>C语言中，是没有办法直接定义字符串数据类型的，但是我们可以使用字符数组来定义字符串</p><h3 id="2-15-1-特点"><a href="#2-15-1-特点" class="headerlink" title="2.15.1. 特点"></a>2.15.1. 特点</h3><ul><li>C中字符串以 <code>\0</code> 结尾，ASCII码中为<code>NUL</code>，十进制值是 <code>0</code></li></ul><h3 id="2-15-2-赋值"><a href="#2-15-2-赋值" class="headerlink" title="2.15.2. 赋值"></a>2.15.2. 赋值</h3><ul><li><code>char 字符串名称[长度] = &#123;&#39;字符1&#39;,&#39;字符2&#39;,...,&#39;字符n&#39;,&#39;0&#39;&#125;;</code></li><li><code>char 字符串名称[长度] = &quot;字符串值&quot;;</code>或<code>char 字符串名称[长度] = &#123;&quot;字符串值&quot;&#125;;</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[]中的长度是可以省略不写的</span><br><span class="line">采用第1种方式的时候最后一个元素必须是&#x27;0&#x27;或&#x27;\0&#x27;，表示字符串的结束标志</span><br><span class="line">采用第2种方式的时候，因为使用了双引号&quot;&quot;，所以字符串末尾会自动加入 \0</span><br></pre></td></tr></table></figure><h3 id="2-15-3-输入输出"><a href="#2-15-3-输入输出" class="headerlink" title="2.15.3. 输入输出"></a>2.15.3. 输入输出</h3><ul><li>输入</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);<span class="comment">//使用 %s，不用 &amp;地址符</span></span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,a);</span><br></pre></td></tr></table></figure><ul><li>gets(arr)</li></ul><p>输入一个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>];</span><br><span class="line">gets(a);</span><br></pre></td></tr></table></figure><ul><li>puts()</li></ul><p>输出一个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">puts</span>(a);</span><br></pre></td></tr></table></figure><h3 id="2-15-4-字符串函数"><a href="#2-15-4-字符串函数" class="headerlink" title="2.15.4. 字符串函数"></a>2.15.4. 字符串函数</h3><div class="table-container"><table><thead><tr><th>函数名</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>strlen(s)</td><td>获得字符串的长度(字节为单位)</td><td>strlen(“abc”)，结果为3</td></tr><tr><td>strcmp(s1,s2)</td><td>比较字符串</td><td>strcmp(“abc”,”abc”)，结果为-1</td></tr><tr><td>strcpy(s1,s2)</td><td>字符串拷贝</td><td>strcpy(“abc”,”abc”)</td></tr><tr><td>strcat(s1,s2)</td><td>字符串拼接</td><td>strcat(“abc”,“abc”)</td></tr><tr><td>atoi(s1)</td><td>字符串转为整数</td><td>atoi(“100”)，结果为100</td></tr></tbody></table></div><ul><li>strlen()获取字符串的长度，在字符串长度中是不包括末尾的<code>\0</code>，而且汉字和字母的长度是不一样的</li><li>strcpy()拷贝之后会覆盖原来字符串且不能对字符串常量进行拷贝</li></ul><h2 id="2-16-函数"><a href="#2-16-函数" class="headerlink" title="2.16. 函数"></a>2.16. 函数</h2><h3 id="2-16-1-定义"><a href="#2-16-1-定义" class="headerlink" title="2.16.1. 定义"></a>2.16.1. 定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名(形参列表)&#123;</span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line">    <span class="keyword">return</span> 返回值或表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-16-2-return"><a href="#2-16-2-return" class="headerlink" title="2.16.2. return"></a>2.16.2. return</h3><ul><li>终止被调函数，向主调函数返回值</li><li>没有返回值的函数，返回类型为 <code>void</code></li><li>return 后的语句可为空，可以是具体值，也可以是一个表达式</li><li>函数返回值的类型和函数定义中函数的类型应保持一致，如果两者不一致，则以函数返回类型为准，自动进行类型转换</li></ul><h3 id="2-16-3-函数调用"><a href="#2-16-3-函数调用" class="headerlink" title="2.16.3. 函数调用"></a>2.16.3. 函数调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><h3 id="2-16-4-函数声明"><a href="#2-16-4-函数声明" class="headerlink" title="2.16.4. 函数声明"></a>2.16.4. 函数声明</h3><p>如果自定义的函数放在main函数后面的话，需要在main函数之前先声明自定义函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 函数名(形参列表)</span><br></pre></td></tr></table></figure><h3 id="2-16-5-参数"><a href="#2-16-5-参数" class="headerlink" title="2.16.5. 参数"></a>2.16.5. 参数</h3><ul><li><p>形参只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效</p></li><li><p>实参可以是常量、变量、表达式、函数等</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值，以便把这些值传送给形参。因此应预先用赋值等办法使实参获得确定值。</span><br></pre></td></tr></table></figure><ul><li>在参数传递时，实参和形参在数量上，类型上，顺序上应严格一致，否则会发生类型不匹配的错误</li></ul><ul><li>数组名做参数，C语言并不检查形参数组的大小，只是将实参数组的首元素的地址传给形参数组名</li></ul><h2 id="2-17-指针"><a href="#2-17-指针" class="headerlink" title="2.17. 指针"></a>2.17. 指针</h2><h3 id="2-17-1-定义"><a href="#2-17-1-定义" class="headerlink" title="2.17.1. 定义"></a>2.17.1. 定义</h3><ul><li>指针是一种保存变量在内存中地址的变量</li><li>一个指针变量，无论其所指向的变量占几个字节，指针变量本身只占4个字节</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p;<span class="comment">//声明一个 int 类型的指针 p</span></span><br></pre></td></tr></table></figure><p><code>*</code>的含义，运算符 <code>*</code>是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如</span><br><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;<span class="comment">//将变量a的地址赋值给指针变量p，这时 访问 *p 就是访问变量a</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,*p);</span><br></pre></td></tr></table></figure><h3 id="2-17-2-优点"><a href="#2-17-2-优点" class="headerlink" title="2.17.2. 优点"></a>2.17.2. 优点</h3><ul><li>指针的使用使得不同区域的代码可以轻易的共享内存数据</li><li>C语言中一些复杂的数据结构往往需要使用指针来构建，如链表、二叉树等</li><li>C语言是传值调用，而有些操作传值调用是无法完成的，如通过被调函数修改调用函数的对象，但是这种操作可以由指针来完成，而且并不违背传值调用</li></ul><h3 id="2-17-3-NULL指针"><a href="#2-17-3-NULL指针" class="headerlink" title="2.17.3. NULL指针"></a>2.17.3. NULL指针</h3><p>NULL 指针，表示不指向任何东西。可以通过给一个指针赋一个零值来生成一个 NULL 指针。 </p><p>在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是为操作系统保留的。但是，内存地址 0 有一个特别重要的意义，它表明该指针不指向一个可访问的内存位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//二者等价</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p&quot;</span>,p); <span class="comment">//都是00000000</span></span><br></pre></td></tr></table></figure><h3 id="2-17-4-指针的运算"><a href="#2-17-4-指针的运算" class="headerlink" title="2.17.4. 指针的运算"></a>2.17.4. 指针的运算</h3><ul><li><code>指针 +/- 整数</code></li></ul><p>表示指针所指地址的前进或后退</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);<span class="comment">//是00000000</span></span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>,p);<span class="comment">//是00000004</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//因为 指针变量p是int类型的，所以它的下一个地址要在现有的地址上加 4 </span></span><br></pre></td></tr></table></figure><ul><li><code>指针 - 指针</code></li></ul><p>表示两指针在内存中的距离。前提是两指针指向同一数组中的不同元素，距离的单位是数组元素的长度，不是字节</p><h3 id="2-17-5-指针和数组"><a href="#2-17-5-指针和数组" class="headerlink" title="2.17.5. 指针和数组"></a>2.17.5. 指针和数组</h3><p>数组名代表数组元素的首地址</p><p>数组中的<code>[]</code>本质是变址运算符(形同汇编中)</p><p>要掌握指针指向的数组元素的地址的计算方式</p><p><strong>用指针访问一数组</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line">p = a;</span><br></pre></td></tr></table></figure><ul><li>p不变</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*(p+i)</span><br><span class="line">*(a+<span class="number">1</span>)</span><br><span class="line">a[i]</span><br><span class="line">p[i]</span><br><span class="line">上式等价</span><br></pre></td></tr></table></figure><ul><li>p后移</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p++;</span><br></pre></td></tr></table></figure><p><strong>用指针访问二数组</strong></p><p>一个二维数组<code>a[3][4]</code>可以看做是一个一维数组<code>a</code>，这个一维数组共有3个行元素，只不过这个一维数组<code>a[3]</code>的每个元素又是一个数组，<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>是他们的数组名</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]  ==&gt;  a[<span class="number">0</span>][<span class="number">0</span>] a[<span class="number">0</span>][<span class="number">1</span>] a[<span class="number">0</span>][<span class="number">2</span>] a[<span class="number">0</span>][<span class="number">3</span>] </span><br><span class="line">a[<span class="number">1</span>]  ==&gt;  a[<span class="number">1</span>][<span class="number">0</span>] a[<span class="number">1</span>][<span class="number">1</span>] a[<span class="number">1</span>][<span class="number">2</span>] a[<span class="number">1</span>][<span class="number">3</span>] </span><br><span class="line">a[<span class="number">2</span>]  ==&gt;  a[<span class="number">2</span>][<span class="number">0</span>] a[<span class="number">2</span>][<span class="number">1</span>] a[<span class="number">2</span>][<span class="number">2</span>] a[<span class="number">2</span>][<span class="number">3</span>]  </span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>]  ==&gt;  a[<span class="number">0</span>] + <span class="number">0</span> 代表a[<span class="number">0</span>][<span class="number">0</span>] </span><br><span class="line">a[<span class="number">1</span>]  ==&gt;  a[<span class="number">1</span>] + <span class="number">1</span> 代表a[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">a[<span class="number">2</span>]  ==&gt;  a[<span class="number">2</span>] + <span class="number">2</span> 代表a[<span class="number">2</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>二维数组名<code>a</code>是指向行的，一维数组名<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>是指向列的。所以<code>a</code>代表的是首行的首地址，<code>a[0]</code>代表首行中的第一个元素的地址即<code>a[0][0]</code>的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; </span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, </span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, </span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">4</span>] = a;<span class="comment">// 指针变量p指向包含4个整型元素的一维数组</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,**p);</span><br></pre></td></tr></table></figure><h3 id="2-17-6-指针和字符串"><a href="#2-17-6-指针和字符串" class="headerlink" title="2.17.6. 指针和字符串"></a>2.17.6. 指针和字符串</h3><p>可以不定义字符数组，只定义一个字符指针变量，用它指向字符串常量中的字符。</p><p>注意：C语言中只有字符串常量，没有字符串变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *String = <span class="string">&quot;I Love China&quot;</span>;</span><br><span class="line"><span class="comment">//只是把第一个字符 I 的地址赋值给指针变量 String</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,String);<span class="comment">//输出</span></span><br></pre></td></tr></table></figure><h3 id="2-17-7-void指针类型"><a href="#2-17-7-void指针类型" class="headerlink" title="2.17.7. void指针类型"></a>2.17.7. void指针类型</h3><p>C中允许使用void指针类型，可理解为指向<code>空类型</code>或<code>不指向确定的类型</code>的数据，在将它的值赋给另一指针变量时由系统自动为它进行类型转换</p><h2 id="2-18-动态内存分配"><a href="#2-18-动态内存分配" class="headerlink" title="2.18. 动态内存分配"></a>2.18. 动态内存分配</h2><h3 id="2-18-1-堆"><a href="#2-18-1-堆" class="headerlink" title="2.18.1. 堆"></a>2.18.1. 堆</h3><p>自由存储区，随用随分配。用malloc函数申请，使用完，用free函数释放</p><h3 id="2-18-2-栈"><a href="#2-18-2-栈" class="headerlink" title="2.18.2. 栈"></a>2.18.2. 栈</h3><p>动态存储区，如局部变量、实参传递</p><h3 id="2-18-3-malloc函数"><a href="#2-18-3-malloc函数" class="headerlink" title="2.18.3. malloc函数"></a>2.18.3. malloc函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><p>在堆中分配一个长度为size的连续空间，返回值是所分配区域的第一个字节的地址。如果函数未能执行成功，如内存不足，则返回空指针NULL</p><h3 id="2-18-4-free函数"><a href="#2-18-4-free函数" class="headerlink" title="2.18.4. free函数"></a>2.18.4. free函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *p)</span>;</span><br></pre></td></tr></table></figure><p>释放指针变量p所指向的动态空间</p><h2 id="2-19-结构体"><a href="#2-19-结构体" class="headerlink" title="2.19. 结构体"></a>2.19. 结构体</h2><p>不同类型的数据来构成一个整体</p><p>struct是关键字，是结构体类型的标志</p><h3 id="2-19-1-结构体变量的定义"><a href="#2-19-1-结构体变量的定义" class="headerlink" title="2.19.1. 结构体变量的定义"></a>2.19.1. 结构体变量的定义</h3><p>定义一个名字为Student的结构体类型，并非定义了一个结构体变量，就像int一样，只是一种类型。</p><p>定义结构体类型，只是说明了该类型的组成情况，并没有给它分配存储空间，就像系统不为int类型本身分配空间一样。只有当定义属于结构体类型的变量时，系统才会分配存储空间给该变量</p><p>习惯将结构体名的第一个字母大写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>先定义结构体类型，再定义变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>;</span><span class="comment">//定义了一个结构体变量，变量名为s1。struct和Student是连着使用的。</span></span><br></pre></td></tr></table></figure><ul><li>定义结构体类型的同时定义变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;s2;<span class="comment">//结构体变量名为s2</span></span><br></pre></td></tr></table></figure><ul><li>直接定义结构体类型变量，省略类型名</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;s3;<span class="comment">//结构体变量名为s3</span></span><br></pre></td></tr></table></figure><h3 id="2-19-2-结构体的初始化"><a href="#2-19-2-结构体的初始化" class="headerlink" title="2.19.2. 结构体的初始化"></a>2.19.2. 结构体的初始化</h3><p>只能在定义变量的同时进行初始化赋值，初始化赋值和变量的定义不能分开</p><p>将各成员的初值，按顺序地放在一对大括号<code>&#123;&#125;</code>中，并用逗号分隔，一一对应赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123;<span class="number">18</span>,<span class="number">99</span>,<span class="string">&quot;张三&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-19-3-访问结构体变量的成员"><a href="#2-19-3-访问结构体变量的成员" class="headerlink" title="2.19.3. 访问结构体变量的成员"></a>2.19.3. 访问结构体变量的成员</h3><ul><li><code>结构体变量名.成员名</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123;<span class="number">18</span>,<span class="number">99</span>,<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s2.age);</span><br></pre></td></tr></table></figure><ul><li><code>指针变量名-&gt;成员变量名</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s2</span> =</span> &#123;<span class="number">18</span>,<span class="number">99</span>,<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">s</span> =</span> &amp;s2; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,s-&gt;age);</span><br></pre></td></tr></table></figure><h3 id="2-19-4-指向结构体的指针"><a href="#2-19-4-指向结构体的指针" class="headerlink" title="2.19.4. 指向结构体的指针"></a>2.19.4. 指向结构体的指针</h3><ul><li>定义结构体类型的同时定义指针变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;s2,*s;<span class="comment">//定义了一个结构体变量s2和结构体指针变量s</span></span><br></pre></td></tr></table></figure><ul><li>先定义结构体类型，再定义指针变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="type">char</span> *Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">s</span>;</span> </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-11-14-Windows%E6%9D%83%E9%99%90/"/>
      <url>/2024/10/28/2021-11-14-Windows%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Windows下的权限划分"><a href="#1-Windows下的权限划分" class="headerlink" title="1. Windows下的权限划分"></a>1. Windows下的权限划分</h1><p>windows中，权限指的是不同账户对文件，文件夹，注册表等的访问能力。在windows中，为不同的账户设置权限很重要，可以防止重要文件被其他人所修改，使系统崩溃</p><p>“ 权限”(Permission）是针对资源而言的。也就是说，设置权限只能是以资源为对象，即”设置某个文件夹有哪些用户可以拥有相应的权限”，而不能是以用户为主，即”设置某个用户可以对哪些资源拥有权限”。这就意味着”权限”必须针对”资源”而言，脱离了资源去谈权限毫无意义──在提到权限的具体实施时，”某个资源”是必须存在的。</p><h2 id="1-1-普通权限"><a href="#1-1-普通权限" class="headerlink" title="1.1. 普通权限"></a>1.1. 普通权限</h2><p>默认，系统给用户分了7个组</p><ul><li>管理员组 <code>Administrator</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">administators 组内的用户，都具备系统管理员的权限，它们拥有对这台计算机最大的控制权限，可以执行整台计算机的管理任务。内置的系统管理员账号 Administrator 就是本地组的成员，而且无法将它从该组删除。如果这台计算机已加入域，则域的Domain Admins 会自动地加入到该计算机的Administrators组内。也就是说，域上的系统管理员在这台计算机上也具备着系统管理员的权限</span><br></pre></td></tr></table></figure><ul><li>高级用户组 <code>Power Users</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Power Users 组内的用户具备比Users组更多的权利，但是比Administrators组拥有的权利更少一些，例如，可以：创建、删除、更改本地用户帐户；创建、删除、管理本地计算机内的共享文件夹与共享打印机；自定义系统设置，例如更改计算机时间、关闭计算机等。但是不可以更改Administrators，无法夺取文件的所有权、无法备份与还原文件、无法安装删除与删除设备驱动程序、无法管理安全与审核日志</span><br></pre></td></tr></table></figure><ul><li>普通用户组 <code>Users</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Users 组内的成员只拥有一些基本的权利，例如运行应用程序，但是他们不能修改操作系统的设置、不能更改其它用户的数据、不能关闭服务器级的计算机。所有添加的本地用户帐户者自动属于Users组。如果这台计算机已经加入域，则域的Domain Users会自动地被加入到该计算机的Users组中</span><br></pre></td></tr></table></figure><ul><li>备份操作组 <code>Backup Operators</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Backup Operators 加入改组的成员可以备份和还原服务器上的所有文件，而且不这些文件是否设置有权限</span><br></pre></td></tr></table></figure><ul><li>文件复制组 <code>Replicator</code></li><li>来宾用户组 <code>Guest</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Guests 组是提供给没有用户帐户但是需要访问本地计算机内资源的用户使用，该组的成员无法永久地改变其桌面的工作环境。该组最常见的默认成员为用户帐号Guest</span><br></pre></td></tr></table></figure><ul><li>身份验证用户组 <code>Ahthenticated users</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ahthenticated users 组经过ms验证程序登录的用户都属于该组</span><br></pre></td></tr></table></figure><h2 id="1-2-特殊权限"><a href="#1-2-特殊权限" class="headerlink" title="1.2. 特殊权限"></a>1.2. 特殊权限</h2><p>除了默认的7个用户组，系统中还存在一些特殊权限成员，这些成员是为了特殊用途而设置，这些特殊成员不被任何内置用户组吸纳，属于完全独立出来的账户</p><ul><li>SYSTEM <code>系统</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">真正拥有“完全访问权”的只有一个成员 SYSTEM。这个成员是系统产生的，真正拥有整台计算机管理权限的账户，一般的操作是无法获取与它等价的权限的</span><br></pre></td></tr></table></figure><ul><li>Trustedinstaller <code>信任程序模块</code></li><li>Everyone <code>任何人</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“任何人”权限与普通用户组权限差不多，它的存在是为了让用户能访问被标记为“公有”的文件，这也是一些程序正常运行需要的访问权限——任何人都能正常访问被赋予“Everyone”权限的文件，包括来宾组成员。</span><br></pre></td></tr></table></figure><ul><li>CREATOR OWNER <code>创建者</code></li></ul><p>被标记为 创建者 权限的文件只有建立文件的那个用户才能访问，做到了一定程度的隐私保护。但是所有的文件访问权限均可以被管理员组用户和SYSTEM成员忽略，除非用户使用了NTFS加密。 </p><p>无论是普通权限还是特殊权限，它们都可以“叠加”使用，“叠加”就是指多个权限共同使用，例如一个账户原本属于Users组，而后我们把他加入<code>Administrators</code>组，再加入<code>Trustedinstaller</code>等权限提升，那么现在这个账户便同时拥有两个或多个权限身份，而不是用管理员权限去覆盖原来身份。权限叠加并不是没有意义的，在一些需要特定身份访问的场合，用户只有为自己设置了指定的身份才能访问，这个时候“叠加”的使用就能减轻一部分劳动量了</p><h1 id="2-创建用户并分配用户组"><a href="#2-创建用户并分配用户组" class="headerlink" title="2. 创建用户并分配用户组"></a>2. 创建用户并分配用户组</h1><p>打开 计算机管理-&gt;本地用户和组-&gt;用户，创建用户</p><p>打开 计算机管理-&gt;本地用户和组-&gt;组，将新建的用户加入某个组</p><h1 id="3-管理组成员删除文件还要administrators的权限"><a href="#3-管理组成员删除文件还要administrators的权限" class="headerlink" title="3. 管理组成员删除文件还要administrators的权限"></a>3. 管理组成员删除文件还要administrators的权限</h1><p><strong>情况</strong></p><p>当前登录的用户隶属于Administrators组，但进行操作时还是没有管理员的权限的，一些程序还得通过“以管理员身份运行”才能解决，这个和Administrator不是隶属于同一组吗</p><p><strong>解决</strong></p><p>1、打开计算机管理中的用户和组管理，找到用户administrator，把<code>账户已禁用</code>对勾去掉</p><p>2、通过组策略编辑器（仅适用于专业版或企业版）：</p><ul><li>按 <code>Win + R</code>，输入 <code>gpedit.msc</code> 并按回车。</li><li>导航到 <code>计算机配置 -&gt; Windows 设置 -&gt; 安全设置 -&gt; 本地策略 -&gt; 安全选项</code>。</li><li>找到“用户帐户控制：以管理员批准模式运行所有管理员”，将其设置为“已禁用”。</li></ul><p><strong>原理</strong></p><p>这是因为从 Windows Vista 开始引入了用户帐户控制（User Account Control, UAC）机制，该机制旨在提高系统的安全性。UAC 通过将用户的权限分为标准用户权限和管理员权限来运行程序。即使用户属于 Administrators 组，程序默认也会以标准用户权限运行，除非明确要求以管理员身份运行</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-12-26-%E4%BF%AE%E6%94%B9hosts/"/>
      <url>/2024/10/28/2021-12-26-%E4%BF%AE%E6%94%B9hosts/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Windows下修改hosts不生效的原因"><a href="#1-Windows下修改hosts不生效的原因" class="headerlink" title="1. Windows下修改hosts不生效的原因"></a>1. Windows下修改hosts不生效的原因</h1><ul><li>ip地址与网址间至少要有一空格</li><li><p>另外在最后一行书写映射时一定要加上回车再保存以避免最后一行不生效，如果某条记录暂时不用，只需要在它前面加一个<code>#</code>号即可。　　 </p></li><li><p>遇到修改保存后无效的情况，我们可以使用<code>ipconfig /flushdns</code>命令来刷新dns缓存</p></li><li>在打开浏览器的情况下修改hosts文件时，关闭浏览器时系统才会释放掉hosts文件占用的那部分内存，我们再次打开浏览器访问就发现已经生效了。</li><li>服务器在响应头设置了 <code>Connection: keep-alive</code> （一般的网页都会设置 <code>keep-alive</code>，保持长连接，避免多次连接产生网络消耗）之后，客户端会跟服务器保持长连接，只要长连接不断开，页面在请求的时候就不会重新解析域名！</li></ul><h1 id="2-修改hosts后无法保存"><a href="#2-修改hosts后无法保存" class="headerlink" title="2. 修改hosts后无法保存"></a>2. 修改hosts后无法保存</h1><p> 解除文件只读属性：右键单击hosts文件，选择“属性”，然后取消“只读”选项。然后尝试再次保存更改。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-12-26-Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2024/10/28/2021-12-26-Windows%E4%B8%8B%E5%AE%89%E8%A3%85%E5%8F%8C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><ul><li>已有一个win10系统</li><li>UEFI引导 + 单硬盘</li><li>记得关闭<code>安全模式</code></li></ul><h1 id="2-划分磁盘"><a href="#2-划分磁盘" class="headerlink" title="2. 划分磁盘"></a>2. 划分磁盘</h1><p>为Ubuntu划分磁盘</p><div class="table-container"><table><thead><tr><th>挂载点</th><th>挂载点中文名</th><th>文件系统</th><th>大小</th></tr></thead><tbody><tr><td><code>/</code></td><td>根分区（系统文件和大部分下载的软件会直接在这里）</td><td>EXT4</td><td>60G</td></tr><tr><td><code>/home</code></td><td>家目录（用户平时创建的文件放在这里）</td><td>EXT4</td><td>40G</td></tr><tr><td><code>swap</code></td><td>交换分区（虚拟内存）</td><td>不设置</td><td>10G</td></tr><tr><td><code>/boot</code></td><td>启动（用于启动Ubuntu的目录）</td><td>EXT4</td><td>200M</td></tr></tbody></table></div><p>注意：<code>swap</code>和<code>/boot</code>可以不进行分配，或<code>/boot</code>挂载到<code>EFI</code></p><h1 id="3-U盘装机"><a href="#3-U盘装机" class="headerlink" title="3. U盘装机"></a>3. U盘装机</h1><p>设置从U盘启动，然后开始安装</p><h1 id="4-设置引导"><a href="#4-设置引导" class="headerlink" title="4. 设置引导"></a>4. 设置引导</h1><p>下载EasyUEFI，将Ubuntu放到第一个，即可利用grub引导双系统</p><p><code>bootx64.efi</code>是计算机默认引导文件</p><p><code>bootmgfw.efi</code>是Windows默认引导文件</p><p>CMD下管理员执行<code>bcdedit /set &#123;bootmgr&#125; path \EFI\Microsoft\Boot\bootmgfw.efi</code>设置启动项</p><h1 id="5-删除双系统"><a href="#5-删除双系统" class="headerlink" title="5. 删除双系统"></a>5. 删除双系统</h1><p>先用DiskGenius，删除EFI中的引导项，然后再删除为Ubuntu分配的磁盘即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-12-26-%E5%85%89%E5%BD%B1%E7%B2%BE%E7%81%B55%20U%E7%9B%98%E8%A3%85%E6%9C%BA/"/>
      <url>/2024/10/28/2021-12-26-%E5%85%89%E5%BD%B1%E7%B2%BE%E7%81%B55%20U%E7%9B%98%E8%A3%85%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p><strong>以下教程是给光影精灵5用U盘装机的步骤</strong></p><h1 id="1-制作U盘"><a href="#1-制作U盘" class="headerlink" title="1. 制作U盘"></a>1. 制作U盘</h1><ul><li>使用<code>ventoy</code>一键制作，制作好后将<code>iso</code>文件放到U盘的任意目录中都可以</li><li>装PE，使用<code>WePE</code>导出pe的iso，放入U盘中的任意目录中</li></ul><h1 id="2-设置BIOS"><a href="#2-设置BIOS" class="headerlink" title="2. 设置BIOS"></a>2. 设置BIOS</h1><ul><li>按开机键以后，连续按多次<code>Esc</code>键，直到进入BIOS界面</li><li>进入BIOS后，进入<code>启动选项</code>，关闭<code>安全启动模式</code>，然后设置<code>USB硬盘</code>为第一启动项</li></ul><h1 id="3-从U盘启动"><a href="#3-从U盘启动" class="headerlink" title="3. 从U盘启动"></a>3. 从U盘启动</h1><p>再次开机，连续按<code>delete</code>键，即可从u盘启动</p><h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h1><p>选择要安装的系统镜像，进行安装</p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-12-26-%E8%99%9A%E6%8B%9F%E6%9C%BAping%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2024/10/28/2021-12-26-%E8%99%9A%E6%8B%9F%E6%9C%BAping%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-nat模式ping不通"><a href="#1-nat模式ping不通" class="headerlink" title="1. nat模式ping不通"></a>1. nat模式ping不通</h1><ul><li><p>重置vmware的网络适配器</p></li><li><p>检查防火墙</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Windows XP，Windows Server 2003：</span><br><span class="line">Windows防火墙 --&gt; 高级 --&gt; ICMP --&gt; 设置 --&gt; 把“允许传入回显请求”前打上勾 --&gt; 确定</span><br><span class="line"></span><br><span class="line">Windows 7，Win 2008 R2，2012 R2：</span><br><span class="line">Windows防火墙 --&gt; 高级设置 --&gt; 入站规则 --&gt; 在列表里找到“文件和打印机共享(回显请求 - ICMPv4-In)” --&gt; 右击选择启用规则，并在其属性里设置为‘允许连接&#x27;--&gt; 确定</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-12-31-SQL%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/10/28/2021-12-31-SQL%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>本文的SQL语法以MySQL为例</strong></p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-SQL语言"><a href="#1-1-SQL语言" class="headerlink" title="1.1. SQL语言"></a>1.1. SQL语言</h2><p>SQL，Structured Query Language，结构化查询语言，是一种用于管理和操作关系型数据库的标准化编程语言</p><h2 id="1-2-SQL语法概览"><a href="#1-2-SQL语法概览" class="headerlink" title="1.2. SQL语法概览"></a>1.2. SQL语法概览</h2><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131054025.jpg" alt="sql语法.jpg"></p><h2 id="1-3-SQL语法"><a href="#1-3-SQL语法" class="headerlink" title="1.3. SQL语法"></a>1.3. SQL语法</h2><p>MySQL 语句不区分大小写。但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：SELECT与 select 、Select 是相同的</p><p>多条 SQL 语句必须以分号<code>;</code>分隔</p><p>处理 SQL 语句时，所有空格都被忽略</p><p>SQL 语句可以写成一行，也可以分写为多行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 一行</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span> <span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span> <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"><span class="comment">-- 多行 SQL 语句</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><p><strong>MySQL 支持三种注释</strong></p><ul><li><code>#注释1</code></li><li><code>-- 注释2</code>，<code>--</code>后面是一个空格</li><li><code>/*注释3*/</code></li></ul><p><strong>MySQL中反引号、单引号、双引号的区别</strong></p><p><strong>反引号</strong>：用于引用标识符，如表名、列名等。它的作用是将标识符包裹起来，以便在标识符中包含特殊字符或保留字。使用反引号可以确保MySQL将标识符视为字面值，而不是关键字</p><p><strong>单引号</strong>：用于引用字符串值。字符串值是由单引号括起来的文本</p><p><strong>双引号</strong>：双引号也可以用于引用字符串值，但它不是MySQL的默认字符串引号，需要通过启用ANSI_QUOTES SQL模式来启用。在ANSI_QUOTES模式下，双引号用于引用字符串值，而单引号用于引用字符值</p><h2 id="1-4-SQL分类"><a href="#1-4-SQL分类" class="headerlink" title="1.4. SQL分类"></a>1.4. SQL分类</h2><p><strong>数据操作语言DML</strong></p><p>主要功能是访问数据，因此其语法都是以读写数据库为主</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这四个指令合称 CRUD,即增删改查 */</span></span><br><span class="line"><span class="keyword">UPDATE</span> <span class="operator">-</span> 更新数据库表中的数据</span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">-</span> 从数据库表中删除数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="operator">-</span> 向数据库表中插入数据</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">-</span> 从数据库表中获取数据</span><br></pre></td></tr></table></figure><p><strong>数据定义语言DDL</strong></p><p>主要功能是定义数据库对象</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">-</span> 创建新数据库</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> DATABASE <span class="operator">-</span> 修改数据库</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">-</span> 创建新表</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">-</span> 变更（改变）数据库表</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">-</span> 删除表</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> INDEX <span class="operator">-</span> 创建索引（搜索键）</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> INDEX <span class="operator">-</span> 删除索引</span><br></pre></td></tr></table></figure><p><strong>数据控制语言DCL</strong></p><p>以控制用户的访问权限为主</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 语句给用户增加权限</span><br><span class="line"></span><br><span class="line"><span class="keyword">revoke</span> 语句收回用户权限</span><br></pre></td></tr></table></figure><p><strong>事务控制语言TCL</strong></p><p>用于管理数据库中的事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">commit</span> 语句提交事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span> 语句回滚事务</span><br></pre></td></tr></table></figure><h1 id="2-数据库操作"><a href="#2-数据库操作" class="headerlink" title="2. 数据库操作"></a>2. 数据库操作</h1><h2 id="2-1-操作数据库"><a href="#2-1-操作数据库" class="headerlink" title="2.1. 操作数据库"></a>2.1. 操作数据库</h2><p>选择一个数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><p>创建一个数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> <span class="keyword">exists</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>删除一个数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database if <span class="keyword">exists</span> `数据库名`;</span><br></pre></td></tr></table></figure><p>查询所有数据库名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><h2 id="2-2-数据库的类型"><a href="#2-2-数据库的类型" class="headerlink" title="2.2. 数据库的类型"></a>2.2. 数据库的类型</h2><div class="table-container"><table><thead><tr><th></th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>事务支持</td><td>不支持</td><td>支持</td></tr><tr><td>数据行锁定</td><td>不支持</td><td>支持</td></tr><tr><td>外键约束</td><td>不支持</td><td>支持</td></tr><tr><td>全文索引</td><td>支持</td><td>不支持</td></tr><tr><td>表空间的大小</td><td>较小</td><td>较大，约2倍</td></tr></tbody></table></div><p><strong>数据表在物理空间的位置</strong></p><p>所有的数据库文件都存在data目录下，一个文件夹就对应一个数据库</p><p>MySQL引擎在物理文件上的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InnoDB在数据库表中只有一个 *.frm文件，以及上级目录下的ibdata1文件</span><br><span class="line"></span><br><span class="line">MYISAM对应文件 *.frm表结构的定义文件 、*.MYD数据文件(data)</span><br><span class="line">*.MYI索引文件(index)</span><br></pre></td></tr></table></figure><p><strong>设置数据库表的字符集编码</strong></p><p>不设置的话，会是mysql默认的字符集编码 （不支持中文！）</p><p>MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4（UTF-8 的完整实现，最多支持使用 4 个字节表示字符，因此可以用来存储 emoji 符号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在建表时设置（建议）</span><br><span class="line">CHARSET=utf8mb4</span><br><span class="line">或</span><br><span class="line">在my.ini中配置默认的编码</span><br><span class="line">character-set-server=utf8mb4</span><br></pre></td></tr></table></figure><p><strong>设置数据库表的排序规则</strong></p><p><code>ci</code>（case-insensitive）表示不区分大小写，<code>cs</code>（case-sensitive）表示区分大小写，<code>bin</code>（binary）表示二进制比较</p><p>一般使用 <code>ci</code>即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在建表时设置（建议）</span><br><span class="line">COLLATE utf8mb4_unicode_ci</span><br><span class="line">或</span><br><span class="line">在my.ini中配置</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure><h1 id="3-数据表操作"><a href="#3-数据表操作" class="headerlink" title="3. 数据表操作"></a>3. 数据表操作</h1><h2 id="3-1-数据表的列类型"><a href="#3-1-数据表的列类型" class="headerlink" title="3.1. 数据表的列类型"></a>3.1. 数据表的列类型</h2><p><strong>数值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int 标准整数 4字节，在设计数据表时，所设置的长度，表示该字段可以容纳的最大数字位数</span><br><span class="line">bigint 较大的数据</span><br><span class="line">float 浮点数 4字节</span><br><span class="line">double 浮点数</span><br><span class="line">decimal 字符串形式的浮点数（金融计算一般用这个）</span><br></pre></td></tr></table></figure><p><strong>字符串</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">char 固定占用10个字符的存储空间</span><br><span class="line">varchar 可变长字符串，在设计数据表时，所设置的长度，是指该字段可以容纳的最大字符数</span><br><span class="line">tinytext 微型文本 </span><br><span class="line">text 文本串</span><br></pre></td></tr></table></figure><p><strong>时间日期</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">date YYYY-MM-DD</span><br><span class="line">time HH:mm:ss</span><br><span class="line">datetime YYYY-MM-DD HH:mm:ss （最常用的时间格式）</span><br><span class="line">timestamp 时间戳 1970.1.1到现在的毫秒数（也常用）</span><br><span class="line">year 年份</span><br></pre></td></tr></table></figure><p><strong>null</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">没有值、未知</span><br><span class="line">不要用null进行运算，结果为null</span><br></pre></td></tr></table></figure><h2 id="3-2-数据表的约束"><a href="#3-2-数据表的约束" class="headerlink" title="3.2. 数据表的约束"></a>3.2. 数据表的约束</h2><p>SQL 约束用于规定表中的数据规则</p><p><code>NOT NULL</code> - 指示某列不能存储 NULL 值</p><p><code>UNIQUE</code> - 保证某列的每行必须有唯一的值</p><p><code>PRIMARY KEY</code> - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录</p><p><code>FOREIGN KEY</code> - 保证一个表中的数据匹配另一个表中的值的参照完整性</p><p><code>CHECK</code> - 保证列中的值符合指定的条件</p><p><code>DEFAULT</code> - 规定没有给列赋值时的默认值</p><p><code>Unsigned</code> - 无符号整数</p><p><code>zerofill</code> - 不足的位则用0填充</p><p>自增</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动在上一条记录的基础上＋1</span><br><span class="line">通常用来设计唯一的主键，必须是整数类型</span><br><span class="line">可自定义设计主键自增的起始值和步长</span><br></pre></td></tr></table></figure><h2 id="3-3-操作数据表"><a href="#3-3-操作数据表" class="headerlink" title="3.3. 操作数据表"></a>3.3. 操作数据表</h2><p>直接使用<code>数据库.表名</code>来指定某数据库中的某个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><p>查所有数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p>查表中字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> columns <span class="keyword">from</span> 表名</span><br><span class="line">或</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">describe</span> 表名;</span><br></pre></td></tr></table></figure><p>创建数据表（建议为每个表定义一个主键）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 每张表中都要有一个主键，通常为id</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] `表名` (</span><br><span class="line">`字段名` 列类型 [属性] [索引] [注释]，</span><br><span class="line">`字段名` 列类型 [属性] [索引] [注释]，</span><br><span class="line">`字段名` 列类型 [属性] [索引] [注释],</span><br><span class="line"><span class="keyword">primary</span> key(`id`)</span><br><span class="line">) [表类型] [字符集设置] [注释];</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `student` (</span><br><span class="line">`id` <span class="type">INT</span>(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;学号&#x27;</span>,</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;匿名&#x27;</span> COMMENT <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">`pwd` <span class="type">VARCHAR</span> (<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;123456&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">`sex` <span class="type">VARCHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;女&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>INNODB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>修改表名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 旧表名 rename as 新表名;</span><br></pre></td></tr></table></figure><p>修改表的字段名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change  旧字段名 新字段名 列属性;</span><br></pre></td></tr></table></figure><p>修改表的字段的数据类型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 modify 字段名 数据类型;</span><br></pre></td></tr></table></figure><p>添加表的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 新字段名 列属性;</span><br></pre></td></tr></table></figure><p>删除表的字段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><p>删除数据表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table if exists 表名;</span><br></pre></td></tr></table></figure><h1 id="4-CRUD操作"><a href="#4-CRUD操作" class="headerlink" title="4. CRUD操作"></a>4. CRUD操作</h1><p>所有的创建和删除操作尽量加上判断，以免报错，如 if exists的判断</p><h2 id="4-1-插入"><a href="#4-1-插入" class="headerlink" title="4.1. 插入"></a>4.1. 插入</h2><p><strong>插入查询出来的数据</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username)</span><br><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> account;</span><br></pre></td></tr></table></figure><p><strong>插入行的一部分</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">user</span>(username, password, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"><span class="comment">-- 可以同时插入多条数据，VALUES后面的值使用逗号隔开即可values(),().....</span></span><br></pre></td></tr></table></figure><h2 id="4-2-更新"><a href="#4-2-更新" class="headerlink" title="4.2. 更新"></a>4.2. 更新</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">SET</span> username<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span>, password<span class="operator">=</span><span class="string">&#x27;robot&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;root&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="4-3-删除"><a href="#4-3-删除" class="headerlink" title="4.3. 删除"></a>4.3. 删除</h2><p>delete和truncate都是用于删除数据库表中数据的SQL语句，但是它们有以下几个区别：<br>1 . <strong>对表结构的影响</strong>:</p><ul><li><code>DELETE</code> 语句只删除表中的数据行，而不会删除表的结构（表名、列等）。</li><li><code>TRUNCATE</code> 语句会删除表中的所有数据行，并重置表的自增长列的计数器。同时也会释放表占用的存储空间。</li></ul><p>2 . <strong>执行速度</strong>:</p><ul><li><code>TRUNCATE</code> 语句通常比 <code>DELETE</code> 语句执行得更快，因为它只需要重置表的数据页，而不需要遍历整个表来删除每一行数据。</li></ul><p>3 . <strong>事务日志记录</strong>:</p><ul><li><code>DELETE</code> 语句会将每个被删除的行记录到事务日志中，因此可以进行回滚操作。</li><li><code>TRUNCATE</code> 语句会直接从磁盘中删除数据页，不会记录到事务日志中，因此无法进行回滚。</li></ul><p>4 . <strong>WHERE 子句</strong>:</p><ul><li><code>DELETE</code> 语句可以使用 <code>WHERE</code> 子句来有选择地删除满足条件的行。</li><li><code>TRUNCATE</code> 语句无法使用 <code>WHERE</code> 子句，它会删除整个表的所有数据行。</li></ul><p>总的来说，如果需要删除表中的全部数据，并且不需要保留删除记录，那么使用 <code>TRUNCATE</code> 语句更加高效。如果需要有选择地删除部分数据行，并且需要保留删除记录以便于回滚，那么使用 <code>DELETE</code> 语句更合适。</p><p>delete删除的问题，重启数据库，现象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnoDB 自增列会重1开始 (存在内存当中的，断电即失)</span><br><span class="line">MyISAM继续从上一个自增量开始(存在文件中的，不会丢失)</span><br></pre></td></tr></table></figure><h2 id="4-4-查询"><a href="#4-4-查询" class="headerlink" title="4.4. 查询"></a>4.4. 查询</h2><p>SELECT：用于从数据库中查询数据。</p><p>DISTINCT：用于去重查询，作用于所有列。在 SELECT 语句中使用 DISTINCT，它会确保返回的结果集中没有重复的行。它作用于所有列，也就是说所有列的值都相同才算相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure><p>LIMIT：用于限制返回的行数，可以有一个或两个参数。</p><ul><li>一个参数：表示返回的行数。</li><li>两个参数：第一个参数表示起始行（从 0 开始），第二个参数表示返回的总行数</li></ul><p>ORDER BY：用于对结果集进行排序，默认升序，可以指定降序。</p><ul><li>ASC ：升序（默认）</li><li>DESC ：降序<h1 id="5-外键（不建议使用）"><a href="#5-外键（不建议使用）" class="headerlink" title="5. 外键（不建议使用）"></a>5. 外键（不建议使用）</h1></li></ul><p>外键是一种用于建立表之间关系的约束。它指定了一个表中的列，该列的值必须与另一个表中的列的值匹配。这种匹配通常是基于主键和外键之间的关系进行的</p><p>在SQL中，可以使用FOREIGN KEY关键字来定义外键约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders (</span><br><span class="line">    order_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    customer_id <span class="type">INT</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (customer_id) <span class="keyword">REFERENCES</span> customers(customer_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上示例中，创建了一个名为 orders 的表，其中包含一个名为 order_id 的列和一个名为 customer_id 的列。还定义了一个外键约束，该约束指定 customer_id 列必须与 customers 表中的 customer_id 列匹配</p><p>当向orders 表中插入数据时，如果customer_id 列的值不在customers 表中，则会出现外键约束错误。这可以确保数据的完整性和一致性</p><p>以上操作是物理外键，数据库级别的外键，不建议使用（数据库插入和删除都会麻烦、异常）</p><p>推荐方式：想使用外键通过程序去实现</p><h1 id="6-查询数据"><a href="#6-查询数据" class="headerlink" title="6. 查询数据"></a>6. 查询数据</h1><p><strong>通配符</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*  匹配任意一个或多个字符</span><br><span class="line">_  匹配任意一个字符</span><br><span class="line">%  匹配任意一个字符串</span><br></pre></td></tr></table></figure><p>注：若要匹配的字符串中有 <code>%</code>、<code>_</code>则需要转义</p><p>在下面的代码中，我们使用了LIKE关键字进行模糊匹配，并使用了<code>%</code>和<code>_</code>通配符。同时，我们使用了ESCAPE关键字指定了转义符为<code>\</code>。因此，在LIKE子句中，我们需要使用<code>\%</code>和<code>\_</code>对<code>%</code>和<code>_</code>进行转义，以避免它们被解释为通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">sql</span> <span class="operator">=</span> &quot;SELECT * FROM student WHERE name LIKE &#x27;%\\_%&#x27; ESCAPE &#x27;\\&#x27;&quot;;</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><div class="table-container"><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>and  、&amp;&amp;</td><td>a and b 、a&amp;&amp;b</td><td>逻辑与，两个都为真，结果为真</td></tr><tr><td>or 、 \</td><td>\</td><td></td><td>a or b 、a\</td><td>\</td><td>b</td><td>逻辑或，其中一个为真，则结果为真</td></tr><tr><td>not 、!</td><td>not a、 !a</td><td>逻辑非，真为假，假为真</td></tr></tbody></table></div><h2 id="6-1-单表查询"><a href="#6-1-单表查询" class="headerlink" title="6.1. 单表查询"></a>6.1. 单表查询</h2><p>查询所有字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>查询指定字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span> <span class="keyword">from</span> 表名</span><br></pre></td></tr></table></figure><p>where 等值查询，where过滤指定的行，后面不能加聚合函数（分组函数）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span>,字段名<span class="number">2</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>distinct 去重查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> 字段名 <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>起别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">AS</span> 给结果起一个名字、可以给字段起别名、也可以给表起别名</span><br><span class="line">例</span><br><span class="line"><span class="keyword">select</span> 字段名<span class="number">1</span> <span class="keyword">as</span> newname <span class="keyword">from</span> 表名;</span><br></pre></td></tr></table></figure><p>select <code>表达式</code> from 表;  其中表达式的内容可以是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">文本值，列，<span class="keyword">Null</span>,函数，计算表达式，系统变量...</span><br><span class="line">例</span><br><span class="line">查询当前数据库版本</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"></span><br><span class="line">查看数据库文件存放的目录</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@datadir</span>;</span><br><span class="line"></span><br><span class="line">查询MySQL服务的安装路径</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@basedir</span>;</span><br><span class="line"></span><br><span class="line">全部学生成绩<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> studentResult <span class="operator">+</span> <span class="number">1</span> <span class="keyword">AS</span> <span class="string">&#x27;成绩+1&#x27;</span> <span class="keyword">from</span> <span class="keyword">result</span>;</span><br></pre></td></tr></table></figure><h2 id="6-2-模糊查询"><a href="#6-2-模糊查询" class="headerlink" title="6.2. 模糊查询"></a>6.2. 模糊查询</h2><div class="table-container"><table><thead><tr><th>运算符</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td>is null</td><td>a is null</td><td>如果操作符为null，结果为真</td></tr><tr><td>is not null</td><td>a is not null</td><td>如果操作符不为null，结果为真</td></tr><tr><td>between</td><td>a between b and c</td><td>若a在b和c之间，则结果为真</td></tr><tr><td>like</td><td>a like b</td><td>SQL匹配，如果a匹配b，则结果为真</td></tr><tr><td>in</td><td>a in (b,c,d)</td><td>假设a在其中的某一个值中， 结果为真</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例 select studentResult from result where name in (a,b,c);</span><br></pre></td></tr></table></figure><h2 id="6-3-联表查询（常用）"><a href="#6-3-联表查询（常用）" class="headerlink" title="6.3. 联表查询（常用）"></a>6.3. 联表查询（常用）</h2><p>在SQL中使用多个表的数据来生成结果集的查询</p><p>两张表中的字段名冲突时，用<code>表名.字段名</code>的方法解决</p><p>join关键字左边的是左表，右边的是右表</p><p><strong>内联接（INNER JOIN）</strong></p><p>返回两个表中满足连接条件的记录</p><p><strong>左联接（LEFT JOIN）</strong> </p><p>返回左表中的所有记录，以及右表中满足连接条件的记录。如果右表中没有匹配的记录，则结果集中的此部分将为 NULL</p><p><strong>右联接（RIGHT JOIN）</strong></p><p>返回右表中的所有记录，以及左表中满足连接条件的记录。如果左表中没有匹配的记录，则结果集中的此部分将为 NULL</p><p><strong>自联接</strong></p><p>自己的表和自己连接，核心：通过别名来将一张表视为两张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> a.columns, b.columns</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">table</span> a</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> b</span><br><span class="line"><span class="keyword">ON</span> a.column <span class="operator">=</span> b.column;</span><br></pre></td></tr></table></figure><p><strong>注意：只写JOIN会由MySQL自动决定是左联接还是右联接</strong></p><p>例</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从学生表和成绩表中查询成绩大于60分的学生的姓名和成绩*/</span></span><br><span class="line"><span class="keyword">select</span> score.score,student.name </span><br><span class="line"><span class="keyword">from</span> score </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> student </span><br><span class="line"><span class="keyword">on</span> score.student_id<span class="operator">=</span>student.student_id </span><br><span class="line"><span class="keyword">where</span> score <span class="operator">&gt;</span><span class="number">60</span>;</span><br></pre></td></tr></table></figure><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131058798.jpg" alt="QQ图片20240825131420.jpg"></p><h2 id="6-4-分页查询"><a href="#6-4-分页查询" class="headerlink" title="6.4. 分页查询"></a>6.4. 分页查询</h2><p><strong>物理分页</strong></p><p>物理分页是指在数据库层面上进行分页，即只返回指定页的数据，而不是返回整个结果集。这种分页方式通常用于处理大型数据集，因为它可以避免在内存中加载整个结果集</p><p><strong>逻辑分页</strong></p><p>逻辑分页是指在应用程序层面上进行分页，即返回整个结果集，然后在应用程序中对结果集进行分页。这种分页方式通常用于处理较小的数据集，因为它可以提供更好的用户体验</p><p><strong>两种分页方式对比</strong></p><p>物理分页每次都访问数据库，逻辑分页只访问一次数据库，物理分页对数据库造成的负担大</p><p>逻辑分页一次性将数据读取到内存，占用了较大的内容空间，物理分页每次只读取一部分数据，占用内存空间较小</p><p>逻辑分页一次性将数据读取到内存，数据发生改变，数据库的最新状态不能实时反映到操作中，实时性差。物理分页每次需要数据时都访问数据库，能够获取数据库的最新状态，实时性强。</p><p>逻辑分页主要用于数据量不大、数据稳定的场合，物理分页主要用于数据量较大、更新频繁的场合</p><p><strong>LIMIT属于物理分页</strong></p><p>LIMIT子句有一个参数时，<code>limit 3</code>，表示查询前3条记录</p><p>LIMIT子句有两个参数时，<code>limit N,M</code> 相当于 <code>limit M offset N</code>，从第 N 条记录开始，返回 M 条记录</p><p>LIMIT子句指定要返回的行数，OFFSET子句指定要跳过的行数（默认为0），对于 LIMIT 子句中的值，必须是常量，不得使用变量</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从table_name表中返回10行，跳过前20行*/</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name LIMIT <span class="number">10</span> <span class="keyword">OFFSET</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>常用的分页模板</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*常用的分页模板*/</span></span><br><span class="line">limit(查询起始下标,pageSize)  </span><br><span class="line">即 limit((n<span class="number">-1</span>)<span class="operator">*</span>pageSize,pageSize)</span><br><span class="line"><span class="comment">/*n是当前页数，pageSize是页面大小*/</span></span><br></pre></td></tr></table></figure><h2 id="6-5-排序"><a href="#6-5-排序" class="headerlink" title="6.5. 排序"></a>6.5. 排序</h2><p><strong>order by</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">result</span> <span class="keyword">asc</span> 升序</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">result</span> <span class="keyword">desc</span> 降序</span><br></pre></td></tr></table></figure><h2 id="6-6-子查询（常用）"><a href="#6-6-子查询（常用）" class="headerlink" title="6.6. 子查询（常用）"></a>6.6. 子查询（常用）</h2><p>子查询就是指将一个 select查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> studentNo <span class="keyword">from</span> student </span><br><span class="line"><span class="keyword">where</span> Name <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> studentID <span class="keyword">from</span> <span class="keyword">result</span> <span class="keyword">where</span> grade<span class="operator">=</span><span class="number">80</span>) </span><br></pre></td></tr></table></figure><h2 id="6-7-分组查询"><a href="#6-7-分组查询" class="headerlink" title="6.7. 分组查询"></a>6.7. 分组查询</h2><p><strong>GROUP BY</strong>子句用于对具有相同值的行进行分组。它通常与聚合函数（如COUNT、SUM、AVG、MAX和MIN）一起使用，以对每个行组执行计算</p><p><strong>having</strong>：过滤分组，一般都是和 group by 连用，不能单独使用</p><p>以下是GROUP BY子句的一些常见用途：</p><p>聚合数据：使用GROUP BY子句计算行组的汇总统计信息。例如，使用GROUP BY在销售表中为每个产品类别计算总销售额</p><p>过滤数据：使用GROUP BY子句过滤掉不符合某些条件的行。例如，使用GROUP BY在销售表中查找下订单最多的客户</p><p>排序数据：使用GROUP BY子句按一个或多个列对查询结果进行排序。例如，使用GROUP BY按产品类别排序销售表，然后按每个类别内的总销售额排序</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*按班级分组，并且统计每个班级的学生数，最后过滤出学生数大于3的班级*/</span></span><br><span class="line"><span class="keyword">select</span> class_id,<span class="built_in">count</span>(name) <span class="keyword">from</span> student <span class="keyword">group</span> <span class="keyword">by</span> class_id <span class="keyword">having</span> <span class="built_in">count</span>(name) <span class="operator">&gt;</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h2 id="6-8-联合查询"><a href="#6-8-联合查询" class="headerlink" title="6.8. 联合查询"></a>6.8. 联合查询</h2><p>UNION 操作符用于合并两个或多个SELECT 语句的结果集</p><p>UNION操作的基本规则：</p><ul><li>所有查询的列数和列顺序必须相同</li><li>每个查询中涉及表的列的数据类型必须相同或兼容</li><li>通常返回的列名取自第一个查询</li></ul><p><strong>注意</strong>：UNION 内部的SELECT 语句必须拥有相同数量的列。UNION 结果集中的列名总是等于 UNION 中第一个 SELECT  语句中的列名。列也必须拥有相似的数据类型。同时，每条SELECT 语句中的列的顺序必须相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*version()的查询结果是int型，且只有一列，所以 union 之后的那个select查询结果也必须只有一列，而且数据类型也需要类似 int*/</span></span><br><span class="line"><span class="keyword">select</span> version() <span class="keyword">union</span> <span class="keyword">select</span> id <span class="keyword">from</span> users;</span><br></pre></td></tr></table></figure><h2 id="6-9-select完整语法（重点）"><a href="#6-9-select完整语法（重点）" class="headerlink" title="6.9. select完整语法（重点）"></a>6.9. select完整语法（重点）</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> [<span class="keyword">all</span> <span class="operator">|</span> <span class="keyword">distinct</span>]</span><br><span class="line"><span class="keyword">from</span> tablename1 [<span class="keyword">as</span> newname]</span><br><span class="line">[<span class="keyword">left</span> <span class="operator">|</span> <span class="keyword">right</span> <span class="operator">|</span> <span class="keyword">inner</span> <span class="keyword">join</span> tablename2] <span class="comment">-- 联表查询</span></span><br><span class="line">[<span class="keyword">where</span>] <span class="comment">-- 条件查询</span></span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span>] <span class="comment">-- 指定结果按照哪几个字段来分组</span></span><br><span class="line">[<span class="keyword">having</span>] <span class="comment">-- 过滤分组的记录必须满足的次要条件</span></span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span>] <span class="comment">-- 指定查询记录按一个或多个条件排序</span></span><br><span class="line">[limit] <span class="comment">-- 指定查询的记录从哪条至哪条</span></span><br><span class="line"></span><br><span class="line">以上先后顺序不能改变</span><br><span class="line">[]括号代表可选的, &#123; &#125;括号代表必选得</span><br></pre></td></tr></table></figure><h1 id="7-MySQL常见函数"><a href="#7-MySQL常见函数" class="headerlink" title="7. MySQL常见函数"></a>7. MySQL常见函数</h1><h2 id="7-1-数学运算"><a href="#7-1-数学运算" class="headerlink" title="7.1. 数学运算"></a>7.1. 数学运算</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span> (<span class="number">-8</span>) <span class="comment">--绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">9.4</span>) <span class="comment">--向上取整</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">9.4</span>) <span class="comment">-- 向下取整</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND() <span class="comment">-- 返回一个0~1之间的随机数</span></span><br><span class="line"><span class="keyword">SELECT</span> SIGN(<span class="number">10</span>) <span class="comment">--判断一个数的符号，0-0，负数返回-1，正数返回1</span></span><br></pre></td></tr></table></figure><h2 id="7-2-字符串函数"><a href="#7-2-字符串函数" class="headerlink" title="7.2. 字符串函数"></a>7.2. 字符串函数</h2><p><strong>字符串拼接函数</strong></p><p><code>concat(str1,str2 … … )</code> 没有分隔符的连接字符串</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(id,<span class="string">&#x27;-&#x27;</span>,name) <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">/*结果为 id-name 的拼接*/</span></span><br></pre></td></tr></table></figure><p>如果连接串中存在NULL，则返回结果为NULL</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat(id,<span class="keyword">NULL</span>,name) <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">/*结果为 NULL*/</span></span><br></pre></td></tr></table></figure><p><code>concat_ws(separator,str1,str2… … )</code>该函数的第一个参数是其他参数的分隔符，分隔符在连接字符串之间加入。分隔符可以是一个字符串，也可以是其它参数。分隔符为NULL，则返回结果为NULL。如果参数中存在NULL，则会被忽略</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;-&#x27;</span>,id,name,password) <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">/*结果为 id - name - password 的拼接*/</span></span><br></pre></td></tr></table></figure><p><code>group_concat(str1,str2… … )</code>将多行查询的结果以逗号为分隔符连接成一行结果</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> group_concat(id,name,password) <span class="keyword">from</span> users;</span><br><span class="line"><span class="comment">/*所有结果显示在一行*/</span></span><br></pre></td></tr></table></figure><p><strong>字符串截取函数</strong></p><p><code>left()</code></p><p>从左开始截取字符串 <code>left(str,length)</code> ，<code>str</code>要截取的字符串， <code>length</code>要截取的长度</p><p><code>right()</code></p><p>从右开始截取字符</p><p><code>substring(str,pos,length)</code></p><p><code>str</code>被截取字段， <code>pos</code>从第几位开始截取， <code>length</code>截取长度</p><p><code>substring_index(str,delim,count)</code></p><p>按关键字截取字符串 </p><p><code>str</code>被截取字段， <code>delim</code>关键字 ，<code>count</code>关键字出现的次数</p><h2 id="7-3-时间和日期"><a href="#7-3-时间和日期" class="headerlink" title="7.3. 时间和日期"></a>7.3. 时间和日期</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CURRENT</span> <span class="type">DATE</span>() <span class="comment">--获取当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> CURDATE() <span class="comment">--获取当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> NOW()<span class="comment">--获取当前的时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LOCALTIME</span>() <span class="comment">--本地时间</span></span><br><span class="line"><span class="keyword">SELECT</span> SYSDATE() <span class="comment">--系统时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW())</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW())</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(NOW())</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">HOUR</span>(NOW())</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MINUTE</span>(NOW())</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SECOND</span>(NOW())</span><br></pre></td></tr></table></figure><h2 id="7-4-系统"><a href="#7-4-系统" class="headerlink" title="7.4. 系统"></a>7.4. 系统</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SYSTEM_USER</span>()</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>()</span><br><span class="line"><span class="keyword">SELECT</span> VERSION()</span><br></pre></td></tr></table></figure><h2 id="7-5-聚合函数"><a href="#7-5-聚合函数" class="headerlink" title="7.5. 聚合函数"></a>7.5. 聚合函数</h2><div class="table-container"><table><thead><tr><th>函数名称</th><th>描述</th></tr></thead><tbody><tr><td>COUNT()</td><td>统计查询到的记录的条数</td></tr><tr><td>SUM()</td><td>求出表中某个字段所有值的总和</td></tr><tr><td>AVG()</td><td>求出表中某个字段所有值的平均值</td></tr><tr><td>MIN()</td><td>最小值</td></tr><tr><td>MAX()</td><td>最大值</td></tr></tbody></table></div><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(字段名) <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(字段名) <span class="keyword">FROM</span> 表名;</span><br></pre></td></tr></table></figure><h2 id="7-6-MD5"><a href="#7-6-MD5" class="headerlink" title="7.6. MD5"></a>7.6. MD5</h2><p>md5()</p><p>如何校验：将用户传递进来的密码，进行md5加密，然后比对加密后的值</p><h1 id="8-事务"><a href="#8-事务" class="headerlink" title="8. 事务"></a>8. 事务</h1><p>事务是一组SQL语句，它们被视为单个逻辑单元并且必须全部执行或全部回滚。事务可以确保数据库的一致性和完整性，即使在出现故障或其他问题的情况下也是如此</p><p>在SQL中，可以使用BEGIN TRANSACTION、COMMIT和ROLLBACK语句来管理事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> table_name <span class="keyword">SET</span> column1 <span class="operator">=</span> value1 <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...) <span class="keyword">VALUES</span> (value1, value2, ...);</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p>以上例子中，使用BEGIN TRANSACTION 语句开始一个新的事务。然后执行一些SQL语句，包括UPDATE、INSERT和DELETE语句。如果所有语句都成功执行，则我们使用COMMIT语句提交事务。如果出现错误或其他问题，则可以使用ROLLBACK语句回滚事务，以便撤消所有更改</p><h2 id="8-1-事务的四个特性（ACID）"><a href="#8-1-事务的四个特性（ACID）" class="headerlink" title="8.1. 事务的四个特性（ACID）"></a>8.1. 事务的四个特性（ACID）</h2><p><strong>原子性</strong>（Atomicity）</p><p>事务被视为单个逻辑单元，必须全部执行或全部回滚。如果事务中的任何一部分失败，则整个事务都将回滚到原始状态</p><p><strong>一致性</strong>（Consistency）</p><p>事务必须确保数据库的一致性和完整性。这意味着在事务开始和结束时，数据库必须处于一致的状态（数据总量不变）。如果事务失败，则必须回滚所有更改，以便数据库保持一致</p><p><strong>隔离性</strong>（Isolation）</p><p>针对多个用户同时操作。事务必须在隔离的环境中执行，以便它们不会相互干扰。这意味着在事务执行期间，其他事务不能访问正在使用的数据</p><p><strong>持久性</strong>（Durability）</p><p>一旦事务提交，其结果必须永久保存在数据库中。即使在出现故障或其他问题的情况下，也必须保持数据的完整性和一致性</p><p><strong>隔离所导致的一些问题</strong></p><p>脏读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">指一个事务读取了另外一个事务未提交的数据</span><br></pre></td></tr></table></figure><p>不可重复读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在一个事务内读取表中的某一行数据， 多次读取结果不同</span><br></pre></td></tr></table></figure><p>虚读</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是指在一个事务内读取到了别的事务插入的数据，导致前后读取不一致</span><br></pre></td></tr></table></figure><h2 id="8-2-事务处理"><a href="#8-2-事务处理" class="headerlink" title="8.2. 事务处理"></a>8.2. 事务处理</h2><p>MySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 <code>BEGIN TRANSACTION</code> 语句时，会关闭隐式提交；当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭，重新恢复隐式提交</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*autocommit 标记是针对每个连接而不是针对服务器的*/</span></span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span> 关闭自动提交</span><br><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">1</span> 开启</span><br></pre></td></tr></table></figure><p>手动处理事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 关闭自动提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">0</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开始事务</span></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 A</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;root1&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建保留点 updateA</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 插入操作 B</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>`</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;root2&#x27;</span>, <span class="string">&#x27;xxxx@163.com&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 回滚到保留点 updateA</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> updateA;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 提交事务，只有操作 A 生效</span></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 开启自动提交</span></span><br><span class="line"><span class="keyword">SET</span> autocommit <span class="operator">=</span> <span class="number">1</span> </span><br></pre></td></tr></table></figure><h1 id="9-索引"><a href="#9-索引" class="headerlink" title="9. 索引"></a>9. 索引</h1><p>索引是一种数据结构，用于加速数据库中的数据访问。索引可以将数据按照特定的顺序组织起来，以便更快地查找和检索数据</p><p>在SQL中，可以使用CREATE INDEX 语句来创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name <span class="keyword">ON</span> table_name (column1, column2, ...);</span><br></pre></td></tr></table></figure><p>以上示例中，使用CREATE INDEX 语句创建了一个名为 index_name 的索引，该索引基于名为 table_name 的表中的 column1、column2 等列。一旦创建了索引，就可以使用SELECT语句等来查询数据，而无需扫描整个表。这可以大大提高查询性能，特别是在大型表中</p><p>但是，索引也有一些缺点。首先，索引需要占用额外的存储空间。其次，索引需要维护，这可能会导致插入、更新和删除操作的性能下降。因此，应该仔细考虑何时使用索引，并确保只为最常用的查询创建索引</p><h2 id="9-1-索引的使用"><a href="#9-1-索引的使用" class="headerlink" title="9.1. 索引的使用"></a>9.1. 索引的使用</h2><p>在创建表的时候给字段增加索引或创建完毕后再增加索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DESC命令可以查看表中所有字段的信息，包括该字段是否为主键。在输出的结果中，主键字段会有一个“PRI”的标识</span></span><br><span class="line"><span class="keyword">DESC</span> `table_name`;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示所有的索引信息</span></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> `table_name`</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加一个索引 列名(索引名) </span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> `classes`(`classes`);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建索引 CREATE INDEX 索引名on表(字段)</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX id_ app_ user_ name <span class="keyword">ON</span> app_ <span class="keyword">user</span>(`name`) ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- EXPLAIN 分析sql执行的状况</span></span><br><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure><h1 id="10-视图"><a href="#10-视图" class="headerlink" title="10. 视图"></a>10. 视图</h1><p>视图是一种虚拟表，它是基于SQL查询的结果集构建的。视图不包含任何数据，而是根据查询定义的规则动态生成数据。视图可以像表一样使用，可以查询、插入、更新和删除数据。视图的主要优点是它们提供了一种简单的方法来组织和管理复杂的查询。视图还可以用于隐藏底层表的复杂性，从而简化应用程序的开发和维护</p><p>在SQL中，可以使用CREATE VIEW语句来创建视图。以下语句将创建一个名为view_name 的视图，该视图基于名为 table_name 的表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure><p>在以上语句中，使用SELECT语句定义了视图的查询规则。还使用WHERE子句来指定要包含在视图中的行。一旦创建了视图，就可以像使用表一样使用它例如，以下查询将从view_name 视图中检索数据：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> view_name;</span><br></pre></td></tr></table></figure><p>视图可以像表一样使用，但是它们不包含任何数据。每次查询视图时，都会根据定义的规则动态生成数据。如果底层表发生更改，则视图也会相应地更新</p><h1 id="11-数据库用户管理"><a href="#11-数据库用户管理" class="headerlink" title="11. 数据库用户管理"></a>11. 数据库用户管理</h1><h2 id="11-1-MySQL权限级别"><a href="#11-1-MySQL权限级别" class="headerlink" title="11.1. MySQL权限级别"></a>11.1. MySQL权限级别</h2><p>权限存储在 mysql库 的user、db、tables_priv、columns_priv、procs_priv这几个系统表中，待MySQL实例启动后就加载到内存中</p><h2 id="11-2-操作用户"><a href="#11-2-操作用户" class="headerlink" title="11.2. 操作用户"></a>11.2. 操作用户</h2><p>要授予用户帐户权限，可以用<code>GRANT</code>命令。有撤销用户的权限，可以用<code>REVOKE</code>命令</p><p><code>GRANT</code> 和 <code>REVOKE</code> 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 <code>GRANT ALL</code> 和 <code>REVOKE ALL</code></li><li>整个数据库，使用 <code>ON database.*</code></li><li>特定的表，使用 <code>ON database.table</code></li><li>特定的列</li><li>特定的存储过程</li></ul><p>用户表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql.user</span><br></pre></td></tr></table></figure><p>数据库用户名的含义</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root<span class="variable">@127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">用户root的访问权限为<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>，表示root用户只支持本地访问</span><br></pre></td></tr></table></figure><p>开启数据库外连：使某个数据库用户支持除本地IP外的外部IP连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> PRIVILEGES <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;root&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*password是root用户的密码；代码中的 % 表示任何IP地址，如果你的IP地址固定，可以把 % 换成你的IP地址，不换也行*/</span></span><br></pre></td></tr></table></figure><p>刷新权限：每次更新权限后记得刷新权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>查询当前数据库用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>();</span><br></pre></td></tr></table></figure><p>查看当前用户权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> grants <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看所有用户（用户名、给谁授权）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span>,host <span class="keyword">from</span> mysql.user; </span><br><span class="line">或 </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br></pre></td></tr></table></figure><p>添加用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> 用户名@<span class="string">&#x27;主机地址&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>创建用户同时授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> mq.<span class="operator">*</span> <span class="keyword">to</span> 用户名@主机名 identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>;</span><br></pre></td></tr></table></figure><p>设置与更改用户密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWORD <span class="keyword">FOR</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span> <span class="operator">=</span> PASSWORD(<span class="string">&#x27;新密码&#x27;</span>);</span><br></pre></td></tr></table></figure><p>删除用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> 用户名@<span class="string">&#x27;主机地址&#x27;</span>;</span><br></pre></td></tr></table></figure><p>给用户授权</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">to</span> 用户名@<span class="string">&#x27;主机名&#x27;</span> （在这里加上 <span class="keyword">WITH</span> <span class="keyword">GRANT</span> OPTION，可以使他有赋权能力即root用户的权限）</span><br></pre></td></tr></table></figure><p>撤销权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">revoke</span> 权限 <span class="keyword">on</span> 数据库名.表名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;主机名&#x27;</span>;</span><br></pre></td></tr></table></figure><p>切换用户</p><p>注意：不同用户的主机得是一样的，否则无法切换</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用命令 <span class="operator">-</span>u 用户名 <span class="operator">-</span>p </span><br></pre></td></tr></table></figure><h1 id="12-MySQL备份"><a href="#12-MySQL备份" class="headerlink" title="12. MySQL备份"></a>12. MySQL备份</h1><p>导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表1 表2 表3 &gt; 导出的文件.sql</span><br></pre></td></tr></table></figure><p>将<code>.sql</code>文件导入数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source  D:\ceshi.sql</span><br></pre></td></tr></table></figure><h1 id="13-预编译"><a href="#13-预编译" class="headerlink" title="13. 预编译"></a>13. 预编译</h1><h2 id="13-1-即时-SQL"><a href="#13-1-即时-SQL" class="headerlink" title="13.1. 即时 SQL"></a>13.1. 即时 SQL</h2><p>一条 SQL 在 DB 接收到最终执行完毕返回，大致的过程如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">词法和语义解析</span><br><span class="line"></span><br><span class="line">优化 SQL 语句，制定执行计划</span><br><span class="line"></span><br><span class="line">执行并返回结果</span><br></pre></td></tr></table></figure><p>如上，一条 SQL 直接是走流程处理，一次编译，单次运行，此类普通语句被称作 Immediate Statements （即时 SQL）</p><h2 id="13-2-预处理-SQL"><a href="#13-2-预处理-SQL" class="headerlink" title="13.2. 预处理 SQL"></a>13.2. 预处理 SQL</h2><p><strong>介绍</strong></p><p>所谓<strong>预编译语句就是将 SQL 语句中的值用占位符替代</strong>，可以视为将 SQL 语句模板化或者说参数化，一般称这类语句叫Prepared Statements。</p><p>预编译语句的优势在于归纳为：一次编译、多次运行，省去了解析优化等过程</p><p>此外<strong>预编译语句能防止 SQL 注入</strong></p><p><strong>语法</strong></p><p> prepare、execute、deallocate 统称为 PREPARE STATEMENT</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 定义预处理语句</span></span><br><span class="line"><span class="keyword">PREPARE</span> stmt_name <span class="keyword">FROM</span> preparable_stmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行预处理语句</span></span><br><span class="line"><span class="keyword">EXECUTE</span> stmt_name [<span class="keyword">USING</span> <span class="variable">@var_name</span> , <span class="variable">@var_name</span> ...];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除(释放)定义</span></span><br><span class="line">&#123;<span class="keyword">DEALLOCATE</span> <span class="operator">|</span> <span class="keyword">DROP</span>&#125; <span class="keyword">PREPARE</span> stmt_name;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#计算一个数加<span class="number">2</span>的值</span><br><span class="line"><span class="keyword">PREPARE</span> stmt1 <span class="keyword">FROM</span> <span class="string">&#x27;SELECT (?+2) AS name&#x27;</span>;</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">EXECUTE</span> stmt1 <span class="keyword">USING</span> <span class="variable">@a</span>;</span><br><span class="line"><span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt1;</span><br></pre></td></tr></table></figure><p><strong>解决limit无法传参问题</strong></p><p>对于 LIMIT 子句中的值，必须是常量，不得使用变量，也就是说不能使用：<code>SELECT * FROM TABLE LIMIT @skip, @numrows;</code> 可以用 PREPARE 语句解决此问题</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SET</span> <span class="variable">@skip</span> <span class="operator">=</span> <span class="number">100</span>; <span class="keyword">SET</span> <span class="variable">@numrows</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 LIMIT <span class="variable">@skip</span>, <span class="variable">@numrows</span>;</span><br><span class="line">ERROR <span class="number">1064</span> (<span class="number">42000</span>): You have an error <span class="keyword">in</span> your <span class="keyword">SQL</span> syntax; <span class="keyword">check</span> the manual that corresponds <span class="keyword">to</span> your MySQL server version <span class="keyword">for</span> the <span class="keyword">right</span> syntax <span class="keyword">to</span> use near <span class="string">&#x27;@skip, @numrows&#x27;</span> <span class="keyword">at</span> line <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">PREPARE</span> stmt3 <span class="keyword">FROM</span> &quot;SELECT * FROM t1 LIMIT ?, ?&quot;;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">Statement prepared</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">EXECUTE</span> stmt3 <span class="keyword">USING</span> <span class="variable">@skip</span>, <span class="variable">@numrows</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+</span></span><br><span class="line"><span class="operator">|</span> a   <span class="operator">|</span> filler <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> filler <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">101</span> <span class="operator">|</span> filler <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">102</span> <span class="operator">|</span> filler <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+--------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> stmt3;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p><strong>预处理 SQL 使用注意点</strong></p><ul><li><code>stmt_name</code> 作为<code>preparable_stmt</code>的接收者，唯一标识，不区分大小写</li><li><code>preparable_stmt</code> 语句中的 <code>?</code>是个占位符，所代表的是一个字符串，不需要将 <code>?</code> 用引号包含起来</li><li>定义一个已存在的 <code>stmt_name</code> ，原有的将被立即释放，类似于变量的重新赋值</li><li><code>PREPARE stmt_name</code> 的作用域是<code>session</code>级</li><li>预处理编译 SQL 是占用资源的，所以在使用后注意及时使用 DEALLOCATE PREPARE 释放资源，这是一个好习惯</li></ul><h1 id="14-存储过程（不建议使用）"><a href="#14-存储过程（不建议使用）" class="headerlink" title="14. 存储过程（不建议使用）"></a>14. 存储过程（不建议使用）</h1><p>存储过程是一组为了完成特定功能的SQL语句集合，它们被预编译并存储在数据库中，可以被多次调用。存储过程可以提高程序的运行效率，减少网络传输的数据量，同时也可以提高程序的安全性</p><p>在MySQL中，可以使用CREATE PROCEDURE 语句来创建存储过程，使用CALL语句来调用存储过程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> GetCustomerOrders(<span class="keyword">IN</span> CustomerID <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Orders <span class="keyword">WHERE</span> CustomerID <span class="operator">=</span> CustomerID;</span><br><span class="line"><span class="keyword">END</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 执行 </span></span><br><span class="line"><span class="keyword">CALL</span> GetCustomerOrders(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在上面的示例中，创建了一个名为GetCustomerOrders的存储过程，它接受一个名为CustomerID的输入参数，并返回与该客户相关的所有订单</p><h1 id="15-游标"><a href="#15-游标" class="headerlink" title="15. 游标"></a>15. 游标</h1><p>游标是一种用于遍历结果集的数据库对象。它可以让我们逐行处理结果集，而不是一次性将整个结果集加载到内存中</p><p>在MySQL中，可以使用DECLARE CURSOR 语句声明游标，使用FETCH 语句获取结果集中的行，使用CLOSE 语句关闭游标，使用DEALLOCATE 语句释放游标所占用的资源</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">DECLARE</span> total <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建接收游标数据的变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sid <span class="type">INT</span>;</span><br><span class="line">    <span class="keyword">DECLARE</span> sname <span class="type">VARCHAR</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">-- 创建总数变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> sage <span class="type">INT</span>;</span><br><span class="line">    <span class="comment">-- 创建结束标志变量</span></span><br><span class="line">    <span class="keyword">DECLARE</span> done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">-- 创建游标</span></span><br><span class="line">    <span class="keyword">DECLARE</span> cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> id,name,age <span class="keyword">from</span> cursor_table <span class="keyword">where</span> age<span class="operator">&gt;</span><span class="number">30</span>;</span><br><span class="line">    <span class="comment">-- 指定游标循环结束时的返回值</span></span><br><span class="line">    <span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> done <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">SET</span> total <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">OPEN</span> cur;</span><br><span class="line">    <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    WHILE(<span class="keyword">NOT</span> done)</span><br><span class="line">    DO</span><br><span class="line">        <span class="keyword">SET</span> total <span class="operator">=</span> total <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">FETCH</span> cur <span class="keyword">INTO</span> sid, sname, sage;</span><br><span class="line">    <span class="keyword">END</span> WHILE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CLOSE</span> cur;</span><br><span class="line">    <span class="keyword">SELECT</span> total;</span><br><span class="line"><span class="keyword">END</span> $</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1 id="16-触发器"><a href="#16-触发器" class="headerlink" title="16. 触发器"></a>16. 触发器</h1><p>触发器是一种特殊的存储过程，它与表操作有关，当触发器所在表上进行插入、更新或删除操作时将自动执行某些操作</p><p>在MySQL中使用 <code>CREATE TRIGGER</code> 语句创建触发器，使用 <code>SHOW TRIGGERS</code> 语句查看触发器，使用 <code>DROP TRIGGER trigger_name</code> 语句删除触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> tr_Customer_Insert</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">ON</span> Customers</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span>  <span class="comment">-- 表示任何一条记录上的操作满足触发事件都会触发该触发器</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> CustomerAudit (CustomerID, Action) <span class="keyword">VALUES</span> (NEW.CustomerID, <span class="string">&#x27;INSERT&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在上面的示例中，创建了一个名为tr_Customer_Insert的触发器，它在Customers表上定义。该触发器在每次插入新行时自动执行，并将新行的CustomerID插入到CustomerAudit表中</p><p>MySQL 不允许在触发器中使用 CALL 语句 ，也就是不能调用存储过程</p><p>在 MySQL 5.7.2 版之前，可以为每个表定义最多六个触发器</p><ul><li><code>BEFORE INSERT</code> - 在将数据插入表格之前激活</li><li><code>AFTER INSERT</code> - 将数据插入表格后激活</li><li><code>BEFORE UPDATE</code> - 在更新表中的数据之前激活</li><li><code>AFTER UPDATE</code> - 更新表中的数据后激活</li><li><code>BEFORE DELETE</code> - 在从表中删除数据之前激活</li><li><code>AFTER DELETE</code> - 从表中删除数据后激活</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-04-25-Python%E4%B9%8B%E6%97%85%E4%B8%8A/"/>
      <url>/2024/10/28/2022-04-25-Python%E4%B9%8B%E6%97%85%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="1-python3特性"><a href="#1-python3特性" class="headerlink" title="1. python3特性"></a>1. python3特性</h1><ul><li>python对大小写敏感</li><li>python通过缩进来控制结构层次（通常4个空格为一个标准缩进）</li><li>使用斜杠<code>\</code> 实现换行代码的衔接</li><li>id() 获取内存地址</li><li>type() 获取数据类型</li><li>help(方法名称) 查看某方法的使用</li><li>import + 库名 导入库</li><li>库名.方法名 调用库中某方法</li><li>python库安装和卸载</li></ul><p>安装：pip install 库名 -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>​<br>卸载： pip uninstall 库名</p><ul><li>更新pip</li></ul><p>cmd下运行python -m pip install —upgrade pip</p><ul><li>注释符<code>#</code></li></ul><p><strong>标识符命名</strong></p><ul><li><p>由字母、下划线和数字组成，且数字不能开头</p></li><li><p>严格区分大小写</p></li><li><p>不能使用关键字</p></li></ul><p>变量名，函数名和文件名全小写，使用下划线连接</p><h1 id="2-python编写规范"><a href="#2-python编写规范" class="headerlink" title="2. python编写规范"></a>2. python编写规范</h1><p><a href="https://legacy.python.org/dev/peps/pep-0008/">Python PEP8 编码规范</a></p><h1 id="3-交互式编程"><a href="#3-交互式编程" class="headerlink" title="3. 交互式编程"></a>3. 交互式编程</h1><p>即直接在终端（如 cmd ）中运行解释器，而不使用文件名的方式来执行文件。这种交互式的编程环境，我们也可以称之为REPL，即读取(Read)输入的内容，执行(Eval)用户输入的指令，打印(Print)执行结果，然后进行循环(Loop)，Python支持交互式编程</p><p><code>ipython</code>是一个<code>python</code>的交互式<code>shell</code>，比默认的<code>python shell</code>好用得多，支持变量自动补全，自动缩进，支持<code>bash shell</code>命令，内置了许多很有用的功能和函数</p><h1 id="4-基础"><a href="#4-基础" class="headerlink" title="4. 基础"></a>4. 基础</h1><h2 id="4-1-字符编码"><a href="#4-1-字符编码" class="headerlink" title="4.1. 字符编码"></a>4.1. 字符编码</h2><div class="table-container"><table><thead><tr><th style="text-align:left">概念</th><th style="text-align:left">概念描述</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">字符集</td><td style="text-align:left">字符的集合</td><td style="text-align:left">ASCII 字符集，GB2312 字符集，Unicode 字符集</td></tr><tr><td style="text-align:left">字符编码</td><td style="text-align:left">将字符集中的字符，编码为特定的二进制数</td><td style="text-align:left">ASCII 编码，GB2312 编码，Unicode 编码</td></tr></tbody></table></div><p>Python3 的默认编码是 utf-8</p><p>UTF-8 是一种针对 Unicode 的可变长度字符编码，它是 Unicode 的实现方式之一</p><h2 id="4-2-输入和输出"><a href="#4-2-输入和输出" class="headerlink" title="4.2. 输入和输出"></a>4.2. 输入和输出</h2><p><strong>输入（input）</strong></p><p>返回字符串类型 <code>input(&#39;提示信息&#39;)</code></p><p>同时输入多个值 <code>a,b,c=input().split(&#39; &#39;)</code>  输入a，b，c时，将a、b、c用空格隔开 </p><p>如有特殊要求，可以考虑加上 <code>eval(input())</code></p><p><strong>输出(print)</strong></p><p><code>print(value,sep,end)</code></p><p><strong>%格式化输出</strong></p><p><code>%</code>占位符，格式化一个字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">16</span>  </span><br><span class="line">b = <span class="string">&#x27;zhao&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my age is %d my name is %s&#x27;</span>%(a,b))  </span><br><span class="line"><span class="comment">#结果为 my age is 16 my name is zhao</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left">格式符号</th><th style="text-align:left">转换</th></tr></thead><tbody><tr><td style="text-align:left"><code>%%</code></td><td style="text-align:left">输出 <code>%</code> 号</td></tr><tr><td style="text-align:left"><code>%s</code></td><td style="text-align:left">字符串</td></tr><tr><td style="text-align:left"><code>%d</code></td><td style="text-align:left">有符号十进制整数</td></tr><tr><td style="text-align:left"><code>%f</code></td><td style="text-align:left">浮点数</td></tr><tr><td style="text-align:left"><code>%c</code></td><td style="text-align:left">字符</td></tr><tr><td style="text-align:left"><code>%u</code></td><td style="text-align:left">无符号十进制整数</td></tr><tr><td style="text-align:left"><code>%o</code></td><td style="text-align:left">八进制整数</td></tr><tr><td style="text-align:left"><code>%x</code></td><td style="text-align:left">十六进制整数(小写字母<code>0x</code>)</td></tr><tr><td style="text-align:left"><code>%X</code></td><td style="text-align:left">十六进制整数(大写字母<code>0X</code>)</td></tr><tr><td style="text-align:left"><code>%e</code></td><td style="text-align:left">科学计数法(小写<code>e</code>)</td></tr><tr><td style="text-align:left"><code>%E</code></td><td style="text-align:left">科学计数法(大写<code>E</code>)</td></tr><tr><td style="text-align:left"><code>%g</code></td><td style="text-align:left"><code>％f</code>和<code>％e</code> 的简写</td></tr><tr><td style="text-align:left"><code>%G</code></td><td style="text-align:left"><code>％f</code>和<code>％E</code>的简写</td></tr></tbody></table></div><p><strong>{}格式化输出</strong></p><p><code>&#123;&#125;</code>占位符，格式化一个字符串</p><p><code>&#123;&#125;</code>中什么都不写，python会按顺序填充<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>))  </span><br><span class="line"><span class="comment">#结果为 my name is 123 my age is 456</span></span><br></pre></td></tr></table></figure><br><code>&#123;数字&#125;</code>数字就是值的下标（从0开始）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;1&#125; my age is &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;123&#x27;</span>,<span class="string">&#x27;456&#x27;</span>))  </span><br><span class="line"><span class="comment">#结果为 my name is 456 my age is 123</span></span><br></pre></td></tr></table></figure><p><code>&#123;变量名&#125;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;name&#125; my age is &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(name = <span class="string">&#x27;123&#x27;</span>,age = <span class="string">&#x27;456&#x27;</span>)) </span><br><span class="line"><span class="comment">#结果为 my name is 123 my age is 456</span></span><br></pre></td></tr></table></figure><p>使用<code>*序列名</code>传参，<code>&#123;&#125;</code>中什么都不用填，python会自动拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="string">&#x27;bv&#x27;</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*a))  </span><br><span class="line"><span class="comment">#结果为 my name is 1 my age is 5</span></span><br></pre></td></tr></table></figure><p>使用<code>**字典名</code>传参，<code>&#123;&#125;</code>中需要填写字典中的键名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;zhao&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">16</span>,<span class="string">&#x27;high&#x27;</span>:<span class="number">180</span>&#125;  </span><br><span class="line"><span class="built_in">print</span>(*b)  </span><br><span class="line"><span class="comment">#结果为 name age high</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;name&#125; my age is &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(**b))  </span><br><span class="line"><span class="comment">#结果为 my name is zhao my age is 16</span></span><br></pre></td></tr></table></figure><p><strong>格式化操作符辅助指令</strong></p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>符号</strong></th><th style="text-align:left"><strong>功能</strong></th></tr></thead><tbody><tr><td style="text-align:left">*</td><td style="text-align:left">定义宽度或者小数点精度</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">用做左对齐</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">在正数前面显示加号( + )</td></tr><tr><td style="text-align:left"><code>&lt;sp&gt;</code></td><td style="text-align:left">在正数前面显示空格</td></tr><tr><td style="text-align:left"><code>#</code></td><td style="text-align:left">在八进制数前面显示零<code>0</code>，在十六进制前面显示<code>0x</code>或者<code>0X</code></td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">显示的数字前面填充0而不是默认的空格</td></tr><tr><td style="text-align:left">(var)</td><td style="text-align:left">映射变量(字典参数)</td></tr><tr><td style="text-align:left">m.n</td><td style="text-align:left">m 是显示的最小总宽度，n 是小数点后的位数</td></tr></tbody></table></div><h2 id="4-3-流程控制"><a href="#4-3-流程控制" class="headerlink" title="4.3. 流程控制"></a>4.3. 流程控制</h2><h3 id="4-3-1-条件判断"><a href="#4-3-1-条件判断" class="headerlink" title="4.3.1. 条件判断"></a>4.3.1. 条件判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">int</span>(<span class="built_in">input</span>())  </span><br><span class="line"><span class="keyword">if</span> a==<span class="number">1</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=1&#x27;</span>)  </span><br><span class="line"><span class="keyword">elif</span> a==<span class="number">2</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;a=2&#x27;</span>)  </span><br><span class="line"><span class="keyword">else</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="4-3-2-循环结构"><a href="#4-3-2-循环结构" class="headerlink" title="4.3.2. 循环结构"></a>4.3.2. 循环结构</h3><p>for，一般用于循环次数可知</p><p>while，一般用于循环次数未知</p><p><strong>相关函数</strong></p><ul><li>range()</li></ul><p>range函数可以有三个参数，第一个参数作为下界，第二个参数作为上界，第三个参数为步长，返回一个含有数值类型的列表</p><p>如</p><p>a=range(1,10)<br>b=list(a)<br>print(b)</p><h1 id="结果为-1-2-3-4-5-6-7-8-9"><a href="#结果为-1-2-3-4-5-6-7-8-9" class="headerlink" title="结果为[1, 2, 3, 4, 5, 6, 7, 8, 9]"></a>结果为[1, 2, 3, 4, 5, 6, 7, 8, 9]</h1><ul><li>len()</li></ul><p>返回变量的长度，无论这个变量是string类型，list类型亦或是dictionary类型</p><p><strong>结束循环</strong></p><ul><li><p>BREAK ，用于跳出最近的一级for或while循环</p></li><li><p>CONTINUE，表示结束本次循环，继续执行下一次迭代</p></li><li><p>PASS，用于那些语法上必须要有什么语句，但程序什么也不做的场合。通常我们使用pass语句来进行占位</p></li></ul><h2 id="4-4-变量"><a href="#4-4-变量" class="headerlink" title="4.4. 变量"></a>4.4. 变量</h2><p>只要定义了一个变量，而且它有数据，那么它的类型就已经确定了，不需要开发者主动的去说明它的类型，系统会自动辨别。<strong>变量没有类型，数据才有类型</strong></p><p>同时为多个变量赋值</p><p><code>x, y, z = &quot;Orange&quot;, &quot;Banana&quot;, &quot;Cherry&quot;</code></p><p>交换a b的值</p><p><code>a,b=b,a</code></p><p><code>+</code>号连接字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&quot;awesome&quot;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python is &quot;</span> + x)</span><br></pre></td></tr></table></figure><p><code>*</code>重复多次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x= <span class="string">&#x27;abc&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(x*<span class="number">2</span>)  </span><br><span class="line"><span class="comment">#结果为 abcabc</span></span><br></pre></td></tr></table></figure><h2 id="4-5-运算符"><a href="#4-5-运算符" class="headerlink" title="4.5. 运算符"></a>4.5. 运算符</h2><p><strong>赋值运算符</strong></p><p><code>=</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x,*y = <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment"># * 设置y的长度可变</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment">#结果是 [3,4,5,6]</span></span><br></pre></td></tr></table></figure></p><p><strong>算术运算符</strong></p><ul><li><p>除<code>/</code></p></li><li><p>乘<code>*</code></p></li><li><p>减<code>-</code></p></li><li><p>加<code>+</code></p></li><li><p>取余<code>%</code></p></li><li><p>幂次<code>**</code></p></li><li><p><code>//</code></p></li></ul><p>返回商的整数部分，向下取整，如，<code>5//2</code>，得2</p><ul><li><code>()</code>提高运算优先级</li></ul><p><strong>关系运算符</strong></p><ul><li><p><code>&gt;</code></p></li><li><p><code>&lt;</code></p></li><li><p><code>&gt;=</code></p></li><li><p><code>&lt;=</code></p></li><li><p><code>!=</code></p></li><li><p><code>==</code></p></li></ul><p>比较内存地址</p><p><strong>字符串使用关系运算符</strong></p><ul><li><p>数字和字符串做<code>==</code> 运算，结果是 false</p></li><li><p>数字和字符串做除了<code>==</code>以外的逻辑运算时，会直接报错</p></li><li><p>两个字符串进行比较，会将每个字符都转换成对应的ASCII编码，然后逐一进行对比</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">y = <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="keyword">if</span> y&gt;=x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;大&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><p><strong>and</strong></p><p>只要有一个运算数是False，结果就是False</p><p>只有所有的运算数都为True时，结果才是True</p><p>做取值运算时，取第一个为False的值，如果所 有的值都为True，取最后一个值</p><p><strong>or</strong></p><p>只要有一个运算数是True，结果就是True</p><p>只有所有的运算数都为False时，结果才是 False</p><p>做取值运算时，取第一个为True的值，如果所 有的值都为False，取最后一个值</p><p><strong>not</strong></p><p>取反</p><p><strong>成员运算符</strong></p><p>用来判断一个东西(比如变量)是不是在另一个范围(比如列表/字典/元组)里面，若是返回True 否则返回False</p><ul><li><p>in</p></li><li><p>not in</p></li></ul><p><strong>身份运算符</strong></p><ul><li>is</li></ul><p>判断两个对象是否是同一个对象</p><p><strong>位运算符</strong></p><p>按位运算符是把数字看作二进制来进行计算的</p><p><strong><code>&amp;</code> 按位与</strong></p><p>两个相应位都为1，则该位的结果为1，否则为0</p><p>a = 0b110<br>b = 0b111<br>print(a&amp;b)</p><h1 id="结果为-6"><a href="#结果为-6" class="headerlink" title="结果为 6"></a>结果为 6</h1><p><strong><code>|</code> 按位或</strong></p><p>两个相应位相同为0，不同为1</p><p>a = 0b110<br>b = 0b111<br>print(a|b)</p><h1 id="结果为-7"><a href="#结果为-7" class="headerlink" title="结果为 7"></a>结果为 7</h1><p><strong><code>^</code> 按位异或</strong></p><p>两个相应位相异时，结果为1，否则为 0</p><p>a = 0b110<br>b = 0b111<br>print(a^b)</p><h1 id="结果为-1"><a href="#结果为-1" class="headerlink" title="结果为 1"></a>结果为 1</h1><p><strong><code>~</code> 按位取反</strong></p><p>对数据的每个二进制位取反，把1变为0，把0变为1</p><p><code>~x</code> 类似于 <code>-x-1</code></p><p>b = 0b111<br>print(~b)</p><h1 id="结果为-8"><a href="#结果为-8" class="headerlink" title="结果为 -8"></a>结果为 -8</h1><p><strong><code>&lt;&lt;</code> 左移动运算</strong></p><p>运算数的各二进位全部左移若干位，由 <code>&lt;&lt;</code> 右边的数字指定移动的位数，高位丢弃，低位补0</p><p>b = 0b1<br>print(b&lt;&lt;3)</p><h1 id="结果为-8-1"><a href="#结果为-8-1" class="headerlink" title="结果为 8"></a>结果为 8</h1><p><strong><code>&gt;&gt;</code> 右移动运算</strong></p><p>运算数的各二进位全部右移若干位，由 <code>&gt;&gt;</code> 左边的数字指定移动的位数</p><p>b = 0b100<br>print(b&gt;&gt;2)</p><h1 id="结果为-1-1"><a href="#结果为-1-1" class="headerlink" title="结果为 1"></a>结果为 1</h1><h2 id="4-6-进制的表示"><a href="#4-6-进制的表示" class="headerlink" title="4.6. 进制的表示"></a>4.6. 进制的表示</h2><ul><li>二进制<code>0b</code>开头</li><li>八进制<code>0o</code>开头</li><li>十六进制<code>0x</code>开头</li></ul><h1 id="5-常用数据类型"><a href="#5-常用数据类型" class="headerlink" title="5. 常用数据类型"></a>5. 常用数据类型</h1><p><strong>不可变数据（3 个）</strong>：Number（数字）、String（字符串）、Tuple（元组）</p><p><strong>可变数据（3 个）</strong>：List（列表）、Dictionary（字典）、Set（集合）</p><h2 id="5-1-数字（Number）"><a href="#5-1-数字（Number）" class="headerlink" title="5.1. 数字（Number）"></a>5.1. 数字（Number）</h2><p>包括整型、浮点型、复数等</p><p><strong>科学计数</strong></p><p>科学计数法：<br>1.5 x 10^11表示为：</p><p>1.5e11<br>这里e和E不区分大小写</p><p><strong>复数</strong></p><p>复数由实数部分和虚数部分组成，实数部分和虚数部分都是浮点型，虚数部分必须有后缀j或J</p><p>print (64.375+1j)<br>结果为64.375+1j</p><h2 id="5-2-字符串（String）"><a href="#5-2-字符串（String）" class="headerlink" title="5.2. 字符串（String）"></a>5.2. 字符串（String）</h2><p>用于表示文本数据，可以使用单引号、双引号或三引号来定义字符串</p><p><strong>特点</strong></p><p>使用<code>&#39;</code>或<code>&quot;</code>来创建字符串</p><p> 三引号<code>&#39;&#39;&#39;</code>允许一个字符串跨多行，其中可以包含换行符、制表符以及其他特殊字符</p><p><strong>转义</strong></p><p>python用反斜杠<code>\</code>转义字符</p><div class="table-container"><table><thead><tr><th style="text-align:left"><code>\</code>(在行尾时)</th><th style="text-align:left">续行符</th></tr></thead><tbody><tr><td style="text-align:left"><code>\\</code></td><td style="text-align:left">反斜杠符号</td></tr><tr><td style="text-align:left"><code>\&#39;</code></td><td style="text-align:left">单引号</td></tr><tr><td style="text-align:left"><code>\&quot;</code></td><td style="text-align:left">双引号</td></tr><tr><td style="text-align:left"><code>\a</code></td><td style="text-align:left">响铃</td></tr><tr><td style="text-align:left"><code>\b</code></td><td style="text-align:left">退格(Backspace)</td></tr><tr><td style="text-align:left"><code>\e</code></td><td style="text-align:left">转义</td></tr><tr><td style="text-align:left"><code>\000</code></td><td style="text-align:left">空</td></tr><tr><td style="text-align:left"><code>\n</code></td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left"><code>\v</code></td><td style="text-align:left">纵向制表符</td></tr><tr><td style="text-align:left"><code>\t</code></td><td style="text-align:left">横向制表符</td></tr><tr><td style="text-align:left"><code>\r</code></td><td style="text-align:left">回车</td></tr><tr><td style="text-align:left"><code>\f</code></td><td style="text-align:left">换页</td></tr><tr><td style="text-align:left"><code>\oyy</code></td><td style="text-align:left">八进制数，yy代表的字符，例如：\o12代表换行</td></tr><tr><td style="text-align:left"><code>\xyy</code></td><td style="text-align:left">十六进制数，yy代表的字符，例如：\x0a代表换行</td></tr><tr><td style="text-align:left"><code>\other</code></td><td style="text-align:left">其它的字符以普通格式输出</td></tr></tbody></table></div><p><strong>索引</strong></p><p><code>s[i]</code> 正下标正向找，负下标逆向找</p><p><strong>切片</strong></p><p><code>s[start:end:step]</code></p><ul><li><p>返回序列s中第start到end-1 以step 为步长的元素子序列</p></li><li><p>step若为负数，表示倒数(倒数是从第0个开始的)</p></li><li><p>start和end若为负数，表示从右边数</p></li><li><p>倒序 <code>y = s[::-1]</code></p></li><li><p>倒数第4个 到 倒数第1个<code>y = s[-4:-1]</code></p></li><li><p>从下标为7的元素开始包含下标为7的元素，倒着取到下标为2的元素不包括下标为2的元素<code>s[7:2:-1]</code></p></li></ul><p>注：切片时必须在最后字符后再加1，因为python只会截取到最后字符的前一个字符</p><p><strong>获取长度</strong></p><p>len()</p><p><strong>查找</strong></p><ul><li><p>find()</p><p>查找指定内容在字符串中是否存在，如果存在就返回该内容在字符串中第一次出现的开始位置索引值，如果不存在，则返回-1</p><p>S.find(sub[, start[, end]])</p><ul><li><p>index 跟find()方法一样，只不过，未找到时，会报异常</p></li><li><p>rfind 是从右边开始查找的</p></li><li><p>rindex 是从右边开始查找的</p></li></ul></li></ul><p><strong>判断</strong></p><ul><li><p>startswith 判断字符串是否以指定内容开始</p></li><li><p>endswith 判断字符串是否以指定内容结束</p></li><li><p>isalpha 判断字符串是否是纯字母</p></li><li><p>isdigit 判断一个字符串是否是纯数字</p></li><li><p>isalnum 判断是否由数字和字母组成</p></li><li><p>isspace 只包含空格，则返回 True，否则返回 False</p></li></ul><p><strong>出现的次数</strong></p><p>count()</p><p><strong>替换</strong></p><p>replace()</p><p>s.replace(‘被替换的’,’替换的’)</p><p><strong>切割字符串</strong></p><p>如果 maxsplit 有指定值，则仅分隔 maxsplit + 1 个子字符串</p><p>  s.split(‘分割字符’,maxsplit)<br>  s.split(‘-‘,2)</p><ul><li><p>split 以指定字符串为分隔符切片，返回的结果是一个列表</p></li><li><p>rsplit 从右往左分隔</p></li><li><p>splitlines 按照行分隔，返回一个包含各行作为元素的列表</p></li><li><p>partition 把字符串分割成三部分，str前，str和str后，三部分组成一个元组</p></li><li><p>rpartition 从右边开始</p></li></ul><p><strong>大小写</strong></p><ul><li><p>capitalize 第一个单词的首字母大写</p></li><li><p>title 每个单词的首字母大写</p></li><li><p>lower 所有都变成小写</p></li><li><p>upper 所有都变成大写</p></li></ul><p><strong>空格处理</strong></p><ul><li><p>ljust</p><p>返回指定长度的字符串，并在右侧使用空白字符补全(左对齐)</p><p>str = ‘hello’<br>print(str.ljust(10))</p></li><li><p>rjust</p><p>返回指定长度的字符串，并在左侧使用空白字符补全(右对齐)</p></li><li><p>center</p><p>返回指定长度的字符串，并在两端使用空白字符补全(居中对齐)</p></li><li><p>lstrip</p><p>删除字符串左边的空白字符</p></li><li><p>rstrip</p><p>删除字符串右边的空白字符</p></li><li><p>strip</p><p>删除字符串两边的空白字符</p></li></ul><p><strong>字符串拼接</strong></p><p>把参数进行遍历，取出参数里的每一项，然后再在后面加上字符串</p><p>S.join(iterable)</p><p>作用：可以把列表或者元组快速的转变成为字符串，并且以指定的字符分隔</p><p>x = ‘-‘<br>print(x.join([‘abc’,’dcdf’]))</p><h1 id="结果是-abc-dcdf"><a href="#结果是-abc-dcdf" class="headerlink" title="结果是 abc-dcdf"></a>结果是 abc-dcdf</h1><p><strong>字符串运算符</strong></p><p>下表实例变量a值为字符串”Hello”，b变量值为”Python”</p><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>操作符</strong></th><th style="text-align:left"><strong>描述</strong></th><th style="text-align:left"><strong>实例</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>+</code></td><td style="text-align:left">字符串连接</td><td style="text-align:left"><code>a + b 输出结果： HelloPython</code></td></tr><tr><td style="text-align:left"><code>*</code></td><td style="text-align:left">重复输出字符串</td><td style="text-align:left"><code>a*2 输出结果：HelloHello</code></td></tr><tr><td style="text-align:left"><code>in</code></td><td style="text-align:left">如果字符串中包含给定的字符返回 True</td><td style="text-align:left"><code>H in a 输出结果 1</code></td></tr><tr><td style="text-align:left"><code>not in</code></td><td style="text-align:left">如果字符串中不包含给定的字符返回 True</td><td style="text-align:left"><code>M not in a 输出结果 1</code></td></tr><tr><td style="text-align:left"><code>r、R</code></td><td style="text-align:left">原生字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。原始字符串除在字符串的第一个引号前加上字母”r”（可以大小写）以外，与普通字符串有着几乎完全相同的语法</td><td style="text-align:left"><code>print r&#39;\n&#39; 输出 \n 和 print R&#39;\n&#39;输出 \n</code></td></tr></tbody></table></div><p><strong>字符和编码相互转换</strong></p><ul><li><p>chr(x) 将一个ASCII码转换为一个字符</p></li><li><p>ord(x) 将一个字符转换为它的ASCII值</p></li></ul><ul><li>encode方法</li></ul><p>可以将字符串按照指定的编码格式转换为二进制</p><ul><li>decode方法</li></ul><p>可以将一个二进制数据按照指定的编码格式转换成为字符串</p><p>x = b’\xe4\xbd\xa0’</p><p>print(x.decode(‘utf-8’))</p><ul><li>Unicode 字符串</li></ul><p>引号前小写的<code>u</code>表示这里创建的是一个 Unicode 字符串</p><p>s=u”hello word”</p><ul><li><p>字符串从Unicode到bytes，需要编码：<code>str.enconde(&quot;utf-8&quot;)</code></p></li><li><p>字符串从bytes到Unicode，需要解码：<code>str.decode(&quot;utf-8&quot;)</code></p></li></ul><h2 id="5-3-列表（List）"><a href="#5-3-列表（List）" class="headerlink" title="5.3. 列表（List）"></a>5.3. 列表（List）</h2><p><strong>特点</strong></p><p> <code>[]</code>用于存储一组有序的元素，可以包含不同类型的元素，通过索引访问元素</p><p>字符串和元组是不可变的，而列表是可变（mutable）的，可以对它进行随意修改。我们还可以将字符串和元组转换成一个列表，只需使用 <code>list</code> 函数</p><p><strong>切片</strong></p><p><code>[start:end:step]</code>，第一个参数，是开始切割的位置，第二个参数，是结束切割的位置，第三个参数，是步长</p><p>倒序：<code>[::-1]</code></p><p><strong>列表运算符</strong></p><p><code>+</code> 将两个列表合并</p><p><strong>列表推导式</strong></p><p>指的是轻量级循环创建列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">20</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>我们使用了一个临时声明的变量i，i后面跟了一个for循环，迭代返回的每一个值都被放进了列表里</p><p><strong>列表的复制</strong></p><p>直接使用<code>=</code>，得到的两个列表指向同一个地址</p><p>copy()，得到的两个列表指向不同的地址（分为深浅拷贝）</p><p><strong>列表的遍历</strong></p><p>enumerate()，带下标的遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">84</span>,<span class="number">55</span>,<span class="number">12</span>,<span class="number">2</span>]</span><br><span class="line">en = <span class="built_in">enumerate</span>(test)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> en:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="comment"># (0, 84)  </span></span><br><span class="line"><span class="comment"># (1, 55)  </span></span><br><span class="line"><span class="comment"># (2, 12)  </span></span><br><span class="line"><span class="comment"># (3, 2)</span></span><br></pre></td></tr></table></figure><p><strong>常用的列表方法</strong></p><ul><li>index</li><li>count</li><li>append</li><li>extend</li><li>insert</li><li>pop</li><li>remove</li><li>reverse</li><li>sort</li></ul><p><strong>添加元素</strong></p><ul><li>append()</li></ul><p>接收一个参数。把接收到的参数放在列表的末尾</p><p>  a=[‘a’,’d’,’w’]<br>  a.append(‘q’)<br>  a.append(1)</p><h1 id="结果为-‘a’-‘d’-‘w’-‘q’-1"><a href="#结果为-‘a’-‘d’-‘w’-‘q’-1" class="headerlink" title="结果为[‘a’, ‘d’, ‘w’, ‘q’, 1]"></a>结果为[‘a’, ‘d’, ‘w’, ‘q’, 1]</h1><ul><li>insert(index,object)</li></ul><p>接收两个参数，index参数表示在列表的哪个索引位置上进行插入，object表示要插入的值</p><p>  a=[‘a’,’d’,’w’]<br>  a.insert(2,’1’)</p><h1 id="结果为-‘a’-‘d’-‘1’-‘w’"><a href="#结果为-‘a’-‘d’-‘1’-‘w’" class="headerlink" title="结果为[‘a’, ‘d’, ‘1’, ‘w’]"></a>结果为[‘a’, ‘d’, ‘1’, ‘w’]</h1><ul><li>extend(seq)</li></ul><p>在列表末尾一次性追加另一个序列中的多个值(用新列表扩展原来的列表)</p><p>  a = [1,2,3]<br>  b = [4,5,6]</p><p>  a.extend(b)<br>  print(a)</p><h1 id="结果为-1-2-3-4-5-6"><a href="#结果为-1-2-3-4-5-6" class="headerlink" title="结果为 [1, 2, 3, 4, 5, 6]"></a>结果为 [1, 2, 3, 4, 5, 6]</h1><p><strong>删除元素</strong></p><ul><li>remove()</li></ul><p>删除特定的值(列表中第一次出现的)，并不能根据我们给定的索引进行删除</p><p>  a=[‘a’,’d’,’w’,’a’,’g’,’a’]<br>  a.remove(‘a’)</p><h1 id="结果为-‘d’-‘w’-‘a’-‘g’-‘a’"><a href="#结果为-‘d’-‘w’-‘a’-‘g’-‘a’" class="headerlink" title="结果为[‘d’, ‘w’, ‘a’, ‘g’, ‘a’]"></a>结果为[‘d’, ‘w’, ‘a’, ‘g’, ‘a’]</h1><ul><li>del()</li></ul><p>删除指定索引位的值</p><p>  a=[‘a’,’d’,’w’]<br>  del(a[2])</p><h1 id="结果为-‘a’-‘d’"><a href="#结果为-‘a’-‘d’" class="headerlink" title="结果为[‘a’, ‘d’]"></a>结果为[‘a’, ‘d’]</h1><ul><li>pop()</li></ul><p>移除列表中指定索引位的值，并且返回该元素的值，默认删除最后一个元素</p><ul><li>clear()</li></ul><p>清空一个列表</p><p><strong>查询元素</strong></p><p>运算符 in</p><p><strong>列表元素个数</strong></p><p>len()</p><p><strong>找最大最小值</strong></p><ul><li><p>max()</p></li><li><p>min()</p></li></ul><p><strong>统计某个元素在列表中出现的次数</strong></p><p>count()</p><p><strong>从列表中找出某个值第一个匹配项的索引位置</strong></p><p>index()</p><p><strong>元素反转</strong></p><p>reverse()</p><p><strong>排序</strong></p><ul><li>sorted()</li></ul><p>排序内置函数，不会改变原有数据，而是排序后返回一个有序的列表</p><ul><li>sort(cmp=None, key=None, reverse=False)</li></ul><p>对原列表进行排序，reverse=False正序排，reverse=True逆序排</p><p>key的参数类型是函数，需要传递参数key来确定排序规则</p><h1 id="对列表中的字典元素进行排序，因为字典有多个参数，那么根据哪一个参数进行排序呢？？"><a href="#对列表中的字典元素进行排序，因为字典有多个参数，那么根据哪一个参数进行排序呢？？" class="headerlink" title="对列表中的字典元素进行排序，因为字典有多个参数，那么根据哪一个参数进行排序呢？？"></a>对列表中的字典元素进行排序，因为字典有多个参数，那么根据哪一个参数进行排序呢？？</h1><p>student = [<br>    {‘name’:’zhangsan’,’age’:14,’score’:98},<br>    {‘name’:’lier’,’age’:17,’score’:68},<br>    {‘name’:’zhaoshi’,’age’:19,’score’:78}<br>     ]</p><p>def foo(a):        #可以打印，看一下a的值<br>    return a[‘age’]    #通过返回值告诉sort排序规则，这里是按照age排序</p><p>student.sort()    #直接进行排序会报错：TypeError: ‘&lt;’ not supported between instances of ‘dict’ and ‘dict’<br>print(student)                    #说明字典间无法直接比较，无法排序</p><p>student.sort(key=foo)    #给key传一个函数，在sort函数内部会调用foo函数<br>print(student)</p><h1 id="foo函数还可以直接写在sort的参数中，student-sort-key-lambda-x-x-‘age’"><a href="#foo函数还可以直接写在sort的参数中，student-sort-key-lambda-x-x-‘age’" class="headerlink" title="foo函数还可以直接写在sort的参数中，student.sort(key=lambda x:x[‘age’])"></a>foo函数还可以直接写在sort的参数中，student.sort(key=lambda x:x[‘age’])</h1><h2 id="5-4-元组（Tuple）"><a href="#5-4-元组（Tuple）" class="headerlink" title="5.4. 元组（Tuple）"></a>5.4. 元组（Tuple）</h2><p><code>()</code>类似于列表，但是元组中的元素不可修改，通常用于存储不可变的数据</p><p>创建一个空元组可以用没有包含内容的圆括号来表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ()</span><br></pre></td></tr></table></figure><p><strong>定义只有一个元素的元组时，要在一个元素后加逗号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=(<span class="string">&#x27;3&#x27;</span>,)  <span class="comment">#类型为元组</span></span><br><span class="line">a=(<span class="string">&#x27;3&#x27;</span>)   <span class="comment">#类型为字符</span></span><br></pre></td></tr></table></figure><p><strong>常用方法</strong></p><ul><li>tuple(seq)</li></ul><p>将列表转换为元组</p><ul><li><p>index()</p></li><li><p>count()</p></li></ul><p><strong>注意</strong></p><p>元组的增删查改是基于整个元组改变的，而若想改变里面的元素，应该用列表（list）</p><h2 id="5-5-集合（Set）"><a href="#5-5-集合（Set）" class="headerlink" title="5.5. 集合（Set）"></a>5.5. 集合（Set）</h2><p><strong>特点</strong></p><p><code>&#123;&#125;</code>用于存储一组不重复的元素，可以进行交、并、差等集合运算</p><p>只读不写</p><p>无序</p><p>空集合 <code>set()</code></p><p><strong>更新集合</strong></p><ul><li><code>.add(elem)</code></li></ul><p>将元素 elem添加到集合中</p><ul><li><code>.pop()</code></li></ul><p>随机删除一个元素</p><ul><li><code>.update()</code></li></ul><p>A.update(B)`B拼接到A里</p><ul><li><code>.remove(elem)</code></li></ul><p>删除elem元素</p><p>如果元素不存在，则会发生错误</p><ul><li><code>discard(elem)</code></li></ul><p>如果元素不存在，不会发生错误</p><ul><li><code>.clear()</code></li></ul><p>清空集合</p><p><strong>联合<code>|</code>**</strong><br>**<br>与集合的OR操作其实等价的，联合符号有个等价的方法，union()</p><p>s1=set(‘abcdde’)</p><p>s2=set([1,2,3,4,5])</p><p>s4=s1|s2</p><p>print s4<br>结果为{‘e’, 1, 2, 3, 4, 5, ‘a’, ‘d’, ‘b’, ‘c’}</p><p><strong>交集<code>&amp;</code></strong></p><p>与集合AND等价，交集符号的等价方法是intersection()</p><p><strong>差集<code>-</code></strong></p><p>等价方法是difference()</p><p><strong>异或<code>^</code></strong></p><p>求两集合差集的并集</p><h2 id="5-6-字典（Dictionary）"><a href="#5-6-字典（Dictionary）" class="headerlink" title="5.6. 字典（Dictionary）"></a>5.6. 字典（Dictionary）</h2><p><code>&#123; : &#125;</code> 用于存储键值对，可以通过键来访问对应的值，键必须是不可变的类型，字典的值可以是任意类型的数据</p><p><strong>字典的常用方法</strong></p><ul><li>创建字典</li><li>遍历字典</li><li><p>判断键是否在字典里面</p></li><li><p>提取出字典中的值</p></li></ul><pre><code>`字典名[&#39;键名&#39;]`a = &#123;&#39;name&#39;:&#39;zhaoshi&#39;,&#39;age&#39;:16&#125;print(a[&#39;name&#39;])#结果为 zhaoshi-   .get()提取出字典中的值a = &#123;&#39;name&#39;:&#39;value&#39;&#125;print(a.get(&#39;name&#39;))#结果为 value</code></pre><ul><li>添加元素</li></ul><p><code>字典名[&#39;键名&#39;] = 添加的值</code>，如果这个值在字典中，不存在，那么就会新增这个元素</p><p>a = {‘name’:’value’}<br>a[‘age’] = 12<br>print(a)</p><h1 id="结果为-‘name’-‘value’-‘age’-12"><a href="#结果为-‘name’-‘value’-‘age’-12" class="headerlink" title="结果为 {‘name’: ‘value’, ‘age’: 12}"></a>结果为 {‘name’: ‘value’, ‘age’: 12}</h1><ul><li><p>删除元素</p><ul><li>pop()</li></ul></li></ul><pre><code>删除键名对应的键值a = &#123;&#39;name&#39;:&#39;value&#39;,&#39;age&#39;:16&#125;b = a.pop(&#39;name&#39;)print(a)#结果为 &#123;&#39;age&#39;: 16&#125;-   popitem()-   del`del 字典名[&#39;键名&#39;]`a = &#123;&#39;name&#39;:&#39;value&#39;,&#39;age&#39;:16&#125;del(a[&#39;name&#39;])print(a)#结果为 &#123;&#39;age&#39;: 16&#125;`del 字典名`删除整个字典-   clear()清空整个字典a = &#123;&#39;name&#39;:&#39;value&#39;,&#39;age&#39;:16&#125;a.clear()print(a)#结果为 &#123;&#125;</code></pre><ul><li>str()</li></ul><p>将字典以字符串表示</p><ul><li>.keys()</li></ul><p>显示字典里的所有键名</p><p>a = {‘name’:’value’,’age’:16}<br>b = a.keys()<br>for i in b:<br>    print(i)</p><ul><li>.values()</li></ul><p>显示所有的值</p><p>a = {‘name’:’value’,’age’:16}<br>b = a.values()<br>for i in b:<br>    print(i)</p><ul><li>.items()</li></ul><p>显示所有的关键字和他们的值(同时显示)</p><p>a = {‘name’:’value’,’age’:16}<br>b = a.items()<br>for i,j in b:<br>    print(i,j)</p><ul><li>update()</li></ul><p>在字典末尾一次性追加另一个字典(用新字典扩展原来的字典)</p><p>a = {‘name’:’value’,’age’:16}<br>c = {‘test’:123}<br>a.update(c)<br>print(a)</p><h1 id="结果为-‘name’-‘value’-‘age’-16-‘test’-123"><a href="#结果为-‘name’-‘value’-‘age’-16-‘test’-123" class="headerlink" title="结果为 {‘name’: ‘value’, ‘age’: 16, ‘test’: 123}"></a>结果为 {‘name’: ‘value’, ‘age’: 16, ‘test’: 123}</h1><h2 id="5-7-布尔（Boolean）"><a href="#5-7-布尔（Boolean）" class="headerlink" title="5.7. 布尔（Boolean）"></a>5.7. 布尔（Boolean）</h2><p>用于表示真（True）和假（False）两种状态。</p><h2 id="5-8-类型转换"><a href="#5-8-类型转换" class="headerlink" title="5.8. 类型转换"></a>5.8. 类型转换</h2><ul><li><p>set(s) 转换为可变集合</p></li><li><p>int() 转换为整型</p></li><li><p>str() 转换为字符型</p></li><li><p>float() 转换为浮点型</p></li><li><p>bool(x) 布尔型转换</p></li></ul><p>在python3中，只有空字符串<code>&#39;&#39;</code>、<code>&quot;&quot;</code> 、数字0、空字典<code>&#123;&#125;</code>、空列表<code>[]</code>、空元组<code>()</code>、空数据None会被转换成为False，其他的都会被转换成为True</p><ul><li><p>unichr(x) ASCII码转为Unicode单字符串</p></li><li><p>abs() 取绝对值</p></li><li><p>round 四舍五入保留指定小数位</p></li><li><p>sum 求和</p></li><li><p>type() 查看数据的类型</p></li></ul><h1 id="6-拆包"><a href="#6-拆包" class="headerlink" title="6. 拆包"></a>6. 拆包</h1><p><code>*</code>加一个序列（列表、元组等）表示拆包，即将一个数据拆成多个数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(*a))  </span><br><span class="line"><span class="comment">#结果是 my name is 1 my age is 2</span></span><br><span class="line"><span class="built_in">print</span>(a)  </span><br><span class="line"><span class="comment">#结果是 (1, 2, 3, 5)</span></span><br><span class="line"><span class="built_in">print</span>(*a)  </span><br><span class="line"><span class="comment">#结果是 1 2 3 5</span></span><br><span class="line">x,*y = <span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span><span class="comment"># * 设置y的长度可变</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line"><span class="comment">#结果是 [3,4,5,6]</span></span><br></pre></td></tr></table></figure><h1 id="7-序列的转换"><a href="#7-序列的转换" class="headerlink" title="7. 序列的转换"></a>7. 序列的转换</h1><p><strong>set()</strong></p><p><strong>list()</strong></p><p><strong>tuple()</strong></p><p><strong>eval()</strong></p><p>称为评估函数，作用是去掉参数中最外层引号并执行剩余语句</p><p>可转换序列的类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;465&#x27;</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))  <span class="comment"># 字符串类型  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(<span class="built_in">eval</span>(a)))  <span class="comment"># int类型</span></span><br></pre></td></tr></table></figure><p>多被用来执行字符串里的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;input(&quot;请输入&quot;)&#x27;</span>  <span class="comment">#字符串  </span></span><br><span class="line"><span class="built_in">eval</span>(a)</span><br></pre></td></tr></table></figure><p><strong>转JSON</strong></p><ul><li>引入json模块</li></ul><p>import json</p><ul><li><code>.dumps()</code>方法</li></ul><p><code>.dumps()</code>将字典、列表、集合等转换为JSON字符串</p><p>import json<br>person = {‘name’:’zhangsan’,’age’:18}<br>m = json.dumps(person)<br>print(m)</p><ul><li><code>.loads()</code>方法</li></ul><p>将JSON字符串转换为python对应的类型，字典、列表等</p><h1 id="8-函数"><a href="#8-函数" class="headerlink" title="8. 函数"></a>8. 函数</h1><h2 id="8-1-定义函数"><a href="#8-1-定义函数" class="headerlink" title="8.1. 定义函数"></a>8.1. 定义函数</h2><p>在 Python 中，定义函数使用 <code>def</code> 语句。一个函数主要由三部分构成：</p><ul><li>函数名</li><li>函数参数</li><li>函数返回值</li></ul><p>如果函数没有 <code>return</code> 语句，则自动 <code>return None</code></p><p>可以将多个数据捆绑到一个列表、字典、元组中进行<code>return</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fun</span>():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;runing&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="8-2-函数参数"><a href="#8-2-函数参数" class="headerlink" title="8.2. 函数参数"></a>8.2. 函数参数</h2><p>Python 的函数参数主要分为以下几种：</p><ul><li>必选参数</li><li>默认参数</li><li>可变参数</li><li>关键字参数</li></ul><p><strong>必选参数</strong></p><p>必选参数就是在调用函数的时候要传入数量一致的参数</p><p><strong>默认参数</strong></p><p>形参中默认有值的参数</p><p>有默认值的参数，一定要位于参数列表的最后面</p><p>为了避免不必要的错误，我们应该使用不可变对象作为函数的默认参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b=<span class="number">5</span></span>)</span><br><span class="line"><span class="comment">#是有效的</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a=<span class="number">5</span>, b</span>)</span><br><span class="line"><span class="comment">#是无效的</span></span><br></pre></td></tr></table></figure><p><strong>可变参数</strong></p><p>在定义函数的时候，无法预估函数应该制定多少个参数，这时我们就可以使用可变参数</p><p>参数前面有一个 <code>*</code> 号，表示是可变的</p><p>下面例子中，在函数内部，参数 args 接收到的是一个 tuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;arg = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(args))</span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment">#结果是 arg = (4, 5, 6, 7)</span></span><br></pre></td></tr></table></figure><p><strong>关键字传参</strong></p><p>下面例子中的kwargs 就是一个关键字参数，它前面有两个 <code>*</code> 号。kwargs 可以接收不定长度的键值对，在函数内部，它会表示成一个 dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b,**kwargs</span>):</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;kwargs = &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(kwargs))</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>,<span class="number">2</span>,x = <span class="number">4</span>,y = <span class="number">5</span>)</span><br><span class="line"><span class="comment">#结果是  kwargs = &#123;&#x27;x&#x27;: 4, &#x27;y&#x27;: 5&#125;</span></span><br></pre></td></tr></table></figure><p><strong>参数的顺序</strong></p><p><code>def func(一般参数，*args，缺省参数，**kwargs)</code></p><h2 id="8-3-函数变量"><a href="#8-3-函数变量" class="headerlink" title="8.3. 函数变量"></a>8.3. 函数变量</h2><p>在函数外声明的变量，可以在脚本程序的任意位置调用这个变量</p><p><strong>全局变量</strong></p><p>用来在函数内部<strong>修改</strong>全局变量</p><p>x = 50<br>def func():<br>    x = 2<br>    print(x)</p><p>func()<br>print(x)</p><h1 id="改变的是局部变量x，外部x不受影响"><a href="#改变的是局部变量x，外部x不受影响" class="headerlink" title="改变的是局部变量x，外部x不受影响"></a>改变的是局部变量x，外部x不受影响</h1><p>def func():<br>    global x<br>    x = 2<br>    print(x)</p><p>func()<br>print(x)</p><h1 id="注意：当x被定义为全局变量时，x就不能被当作形参传入函数中"><a href="#注意：当x被定义为全局变量时，x就不能被当作形参传入函数中" class="headerlink" title="注意：当x被定义为全局变量时，x就不能被当作形参传入函数中"></a>注意：当x被定义为全局变量时，x就不能被当作形参传入函数中</h1><p><strong>内置函数</strong></p><ul><li><p>globals() 查看全局变量</p></li><li><p>locals() 查看局部变量</p></li></ul><p><strong>局部变量</strong></p><p>在函数里声明的变量，只能在函数内部被调用而不能在函数外部调用</p><p>注：如果在函数范围内定义了具有相同名称的变量，那么它将仅打印函数内给出的值而不是全局值</p><h1 id="9-函数式编程"><a href="#9-函数式编程" class="headerlink" title="9. 函数式编程"></a>9. 函数式编程</h1><p>函数式编程的一大特性就是：可以把函数当成变量来使用，比如将函数赋值给其他变量、把函数作为参数传递给其他函数、函数的返回值也可以是一个函数等等</p><p>Python 中的函数式编程，主要包括以下几个方面：</p><ul><li>高阶函数</li><li>匿名函数</li><li>map/reduce/filter</li><li>闭包</li><li>装饰器</li><li>partial 函数</li></ul><h2 id="9-1-函数名"><a href="#9-1-函数名" class="headerlink" title="9.1. 函数名"></a>9.1. 函数名</h2><p>函数名相当于变量，指向函数体中的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输出a&quot;</span>);</span><br><span class="line">b = a;<span class="comment">#相当于给函数起个别名</span></span><br><span class="line"></span><br><span class="line">b();<span class="comment">#结果是 输出a</span></span><br></pre></td></tr></table></figure><h2 id="9-2-函数的回调"><a href="#9-2-函数的回调" class="headerlink" title="9.2. 函数的回调"></a>9.2. 函数的回调</h2><p>把该函数当作参数传给另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运算 a b</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>(<span class="params">a,b,fun</span>):</span><br><span class="line">    c = fun(a,b)</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jian</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a - b</span><br><span class="line"></span><br><span class="line"><span class="comment">#把函数名当作参数传递给另一个函数，就可以在另一个函数中调用</span></span><br><span class="line">calc(<span class="number">5</span>,<span class="number">2</span>,add)<span class="comment">#调用加法函数</span></span><br><span class="line">calc(<span class="number">5</span>,<span class="number">2</span>,jian)<span class="comment">#调用减法函数</span></span><br></pre></td></tr></table></figure><h2 id="9-3-高阶函数"><a href="#9-3-高阶函数" class="headerlink" title="9.3. 高阶函数"></a>9.3. 高阶函数</h2><p>将函数当作变量一样使用。一个函数接收另一个函数作为参数，这种函数称之为<strong>高阶函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">g, arr</span>):  </span><br><span class="line">    <span class="keyword">return</span> [g(x) <span class="keyword">for</span> x <span class="keyword">in</span> arr]</span><br></pre></td></tr></table></figure><ul><li>将函数作为另一个函数的返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">old</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我被old调用了&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> old</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;我被new掉调用了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># return old()</span></span><br><span class="line">    <span class="keyword">return</span> old<span class="comment">#将函数名作为返回值</span></span><br><span class="line"></span><br><span class="line">a = new()</span><br><span class="line">a()<span class="comment">#调用返回的函数`</span></span><br></pre></td></tr></table></figure><ul><li>函数中定义函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    m = <span class="number">10</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        n = <span class="number">90</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;我是inner&#x27;</span>)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&#x27;我是outer&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> inner<span class="comment">#返回函数名</span></span><br><span class="line"></span><br><span class="line">outer()<span class="comment">#调用outer函数</span></span><br><span class="line">outer()()<span class="comment">#先调用outer后调用inner</span></span><br></pre></td></tr></table></figure><h2 id="9-4-内建高阶函数"><a href="#9-4-内建高阶函数" class="headerlink" title="9.4. 内建高阶函数"></a>9.4. 内建高阶函数</h2><p>map/reduce/filter 是 Python 中较为常用的内建高阶函数</p><ul><li>fliter()</li></ul><p>对可迭代对象进行过滤</p><p>可以被用来过滤原有的list，并把过滤结果放进新的list里。filter接受两个参数，第一个是lambda表达式提供的过滤条件，第二个是要进行过滤的现有列表。最后，filter返回一个符合条件的列表类型</p><p>如</p><p>from functools import fliter<br>a=[x for x in range(1,10)]<br>b=filter(lambda i:i%2==0,a)#将列表中符合条件的值，过滤出来<br>print(b)</p><h1 id="结果为-2-4-6-8"><a href="#结果为-2-4-6-8" class="headerlink" title="结果为[2, 4, 6, 8]"></a>结果为[2, 4, 6, 8]</h1><ul><li>map()</li></ul><p>可以同时对list里的所有元素进行操作，并以列表方式给出返回值</p><p>如</p><p>from functools import map<br>a=[x for x in range(1,10)]<br>b=map(lambda i:i**2,a)#将列表里的内容都平方<br>print(b)</p><h1 id="结果为-1-4-9-16-25-36-49-64-81"><a href="#结果为-1-4-9-16-25-36-49-64-81" class="headerlink" title="结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]"></a>结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]</h1><ul><li>reduce()</li></ul><p>可以对列表顺序执行算术运算</p><p>from functools import reduce<br>a = [1, 4, 9, 16, 25, 36, 49, 64, 81]<br>b = reduce(lambda x,y:x+y,a)#将列表里的内容相加，具体过程：x = 1,y = 4;x = 1 + 4,y = 9;x = 1+ 4 + 9..<br>print(b)</p><h1 id="结果为-1-4-9-16-25-36-49-64-81-1"><a href="#结果为-1-4-9-16-25-36-49-64-81-1" class="headerlink" title="结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]"></a>结果为[1, 4, 9, 16, 25, 36, 49, 64, 81]</h1><p>高级操作</p><h1 id="对列表中字典元素的年龄进行求和，因为字典有多个参数，那么如何让年龄求和呢？？"><a href="#对列表中字典元素的年龄进行求和，因为字典有多个参数，那么如何让年龄求和呢？？" class="headerlink" title="对列表中字典元素的年龄进行求和，因为字典有多个参数，那么如何让年龄求和呢？？"></a>对列表中字典元素的年龄进行求和，因为字典有多个参数，那么如何让年龄求和呢？？</h1><p>from functools import reduce</p><p>student = [<br>    {‘name’:’zhangsan’,’age’:14,’score’:98},<br>    {‘name’:’lier’,’age’:17,’score’:68},<br>    {‘name’:’zhaoshi’,’age’:19,’score’:78}<br>     ]<br>def bar(x,y):</p><p>b = reduce(bar,student,0)#定义一个bar函数实现，列表内字典元素的相加，并给x一个初始值 0<br>print(b)    #结果为 50</p><h2 id="9-5-匿名函数"><a href="#9-5-匿名函数" class="headerlink" title="9.5. 匿名函数"></a>9.5. 匿名函数</h2><p><code>lambda 参数: 表达式</code> ，冒号 <code>:</code> 前面的变量是该匿名函数的参数，冒号后面是函数的返回值，注意这里不需使用 return 关键字</p><p>匿名函数一般适用于创建一些临时性的，小巧的函数</p><p><strong>调用函数</strong></p><p>由于匿名函数本质上是一个函数对象，也可以将其赋值给另一个变量，再由该变量来调用函数</p><ul><li>给函数命名(使用较少)</li></ul><p>f=lambda x,y : x+y</p><p>print(f(1, 2))  #计算两数之和，输出：3</p><ul><li>函数回调</li></ul><p>def calc(a,b,fun):<br>    c = fun(a,b)<br>    return c</p><p>x1 = calc(5,2,lambda x,y:x+y)    #计算加法</p><p>x2 = calc(5,2,lambda x,y:x-y)    #计算减法</p><p>x3 = calc(5,2,lambda x,y:x/y)    #计算除法</p><p>print(x1)</p><h2 id="9-6-闭包"><a href="#9-6-闭包" class="headerlink" title="9.6. 闭包"></a>9.6. 闭包</h2><p>在 Python 中，函数也是一个对象。因此，我们在定义函数时，可以再嵌套定义一个函数，并将该嵌套函数返回</p><p>在内部函数里对外部函数的变量进行调用</p><p>在内部函数里对外部函数的变量进行修改，需要用<code>nonlocal</code>声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    m = <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(m)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> m<span class="comment">#nonlocal，进行声明</span></span><br><span class="line">        m = <span class="number">50</span><span class="comment">#修改外部函数变量的值</span></span><br><span class="line">        <span class="built_in">print</span>(m)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">        inner()</span><br><span class="line">    <span class="built_in">print</span>(m)<span class="comment">#前面如果不用nonlocal声明，这里将打印 10而不是50</span></span><br></pre></td></tr></table></figure><h2 id="9-7-装饰器"><a href="#9-7-装饰器" class="headerlink" title="9.7. 装饰器"></a>9.7. 装饰器</h2><p>用<code>@</code>声明一个装饰器</p><p>给某个函数加装饰器，在该函数的前一行，声明装饰器即可</p><p>import time</p><p>def cal_time(fun):<br>    print(‘外部函数被调用’)</p><pre><code>def inner():    start = time.time()    fun()    end = time.time()    print(&#39;本次程序耗时&#39;,end-start)return inner</code></pre><p>@cal_time   #相当于cal_time(demo)</p><pre><code>       #装饰器        #第一件事，调用cal_time        #第二件事，把装饰器的函数传递给fun        #第三件事，再次调用demo时，执行的已经不是以前的demo</code></pre><p>def demo():<br>    x = 0<br>    for i in range(1,100000):<br>        x+=i<br>    print(‘demo被执行’)</p><p>demo()    #执行的已经不是以前的demo，而是cal_time函数内的inner函数,通过inner函数来调用demo函数</p><p><strong>被修饰的函数无参数</strong></p><p>def check_time(action):<br>    print(‘check_time被调用’)<br>    def do_action():<br>        action()<br>        print(‘do_action被调用’)</p><pre><code>return do_action</code></pre><p>@check_time    #会调用check_time</p><p>def go_to_bad():<br>    print(‘上床睡觉’)</p><p>go_to_bad()    #实际上调用的是do_action</p><p><strong>被修饰的函数有参数</strong></p><p>def check_time(action):<br>    print(‘check_time被调用’)<br>    def do_action(name):<br>        action(name)<br>        print(‘do_action被调用’)</p><pre><code>return do_action</code></pre><p>@check_time</p><p>def go_to_bad(name):<br>    print(‘{}上床睡觉’.format(name))</p><p>go_to_bad(‘张三’)</p><p><strong>被修饰的函数有不定长参数</strong></p><p>def check_time(action):<br>    print(‘check_time被调用’)<br>    def do_action(<em>args):<br>        action(</em>args)<br>        print(‘do_action被调用’)</p><pre><code>return do_action</code></pre><p>@check_time</p><p>def go_to_bad(*args):<br>    sum = 0<br>    for x in args:<br>        sum +=x<br>    print(sum)</p><p>go_to_bad(1,2,3,4,5)</p><p><strong>装饰器中的return</strong></p><h2 id="9-8-partial-函数"><a href="#9-8-partial-函数" class="headerlink" title="9.8. partial 函数"></a>9.8. partial 函数</h2><h1 id="10-文件和目录"><a href="#10-文件和目录" class="headerlink" title="10. 文件和目录"></a>10. 文件和目录</h1><h2 id="10-1-读写文本文件"><a href="#10-1-读写文本文件" class="headerlink" title="10.1. 读写文本文件"></a>10.1. 读写文本文件</h2><ul><li>推荐使用 with 语句操作文件 IO。</li><li>如果文件较大，可以按字节读取或按行读取。</li><li>使用文件迭代器进行逐行迭代</li></ul><p>open(file,mode,encoding)</p><ul><li>file 文件路径(相对或者绝对路径)</li></ul><p>windows中使用<code>\</code>分隔路径，但python中<code>\</code>表示转义符</p><p>python中可以使用<code>\\</code>或<code>/</code>分割路径，也可以使用<code>r&#39;路径&#39;</code>表示(即在路径前加r)</p><ul><li>encoding 打开文件时的编码方式</li></ul><p><code>open</code> 函数的常用模式主要有：</p><div class="table-container"><table><thead><tr><th style="text-align:center">‘r’</th><th style="text-align:center">读模式</th></tr></thead><tbody><tr><td style="text-align:center">‘w’</td><td style="text-align:center">写模式</td></tr><tr><td style="text-align:center">‘a’</td><td style="text-align:center">追加模式</td></tr><tr><td style="text-align:center">‘b’</td><td style="text-align:center">二进制模式（可添加到其他模式中使用）</td></tr><tr><td style="text-align:center">‘+’</td><td style="text-align:center">读/写模式（可添加到其他模式中使用）</td></tr></tbody></table></div><p>通常而言，读取文件有以下几种方式：</p><ul><li>一次性读取所有内容，使用 <code>read()</code> 或 <code>readlines()</code>；</li><li>按字节读取，使用 <code>read(size)</code>；</li><li>按行读取，使用 <code>readline()</code>；</li></ul><p><strong>read()</strong></p><p>read(num)，num表示要从文件中读取的数据的长度(单位是字节)，如果没有传入num，那么就表示读取文件中所有的数据，返回的数据类型是一个字符串</p><p><strong>readline()</strong></p><p>每次读出一行内容，包括 <code>\n</code>字符</p><h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><p>file = open(“foo.txt”)</p><p>while True:<br>    content = file.readline()<br>    print(content)<br>    if content ==’’:<br>        break<br>file.close()</p><h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><p>for line in open(‘文件名’)<br>    print(line)</p><p><strong>readlines()</strong></p><p>读取整个文件所有行，保存在一个列表中，每行作为一个元素</p><p><strong>write()</strong></p><p>写数据，只能写入字符串和二进制</p><p><strong>writelines()</strong></p><p>写行数据，只能写入字符串和二进制</p><p>将多个值同时写入一行中</p><p><strong>文件迭代器</strong></p><p>在 Python 中，<strong>文件对象是可迭代的</strong>，这意味着我们可以直接在 for 循环中使用它们，而且是逐行迭代的，也就是说，效果和 <code>readline()</code> 是一样的，而且更简洁</p><p><strong>按字节读取</strong></p><p>如果文件较小，一次性读取所有内容确实比较方便。但是，如果文件很大，比如有 100G，那就不能一次性读取所有内容了。这时，我们构造一个固定长度的缓冲区，来不断读取文件内容。</p><h2 id="10-2-读写二进制文件"><a href="#10-2-读写二进制文件" class="headerlink" title="10.2. 读写二进制文件"></a>10.2. 读写二进制文件</h2><p>Python 支持二进制文件的读写，比如图片，声音文件等</p><ul><li>读取二进制文件使用 <code>rb</code> 模式。</li><li>写入二进制文件使用 <code>wb</code> 模式。<h2 id="10-3-OS模块"><a href="#10-3-OS模块" class="headerlink" title="10.3. OS模块"></a>10.3. OS模块</h2></li></ul><p>Python 的 os 模块封装了常见的文件和目录操作，下面只列出部分常用的方法</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">os.mkdir</td><td style="text-align:center">创建目录</td></tr><tr><td style="text-align:center">os.rmdir</td><td style="text-align:center">删除目录</td></tr><tr><td style="text-align:center">os.rename</td><td style="text-align:center">重命名</td></tr><tr><td style="text-align:center">os.remove</td><td style="text-align:center">删除文件</td></tr><tr><td style="text-align:center">os.getcwd</td><td style="text-align:center">获取当前工作路径</td></tr><tr><td style="text-align:center">os.walk</td><td style="text-align:center">遍历目录</td></tr><tr><td style="text-align:center">os.path.join</td><td style="text-align:center">连接目录与文件名</td></tr><tr><td style="text-align:center">os.path.split</td><td style="text-align:center">分割文件名与目录</td></tr><tr><td style="text-align:center">os.path.abspath</td><td style="text-align:center">获取绝对路径</td></tr><tr><td style="text-align:center">os.path.dirname</td><td style="text-align:center">获取路径</td></tr><tr><td style="text-align:center">os.path.basename</td><td style="text-align:center">获取文件名或文件夹名</td></tr><tr><td style="text-align:center">os.path.splitext</td><td style="text-align:center">分离文件名与扩展名</td></tr><tr><td style="text-align:center">os.path.isfile</td><td style="text-align:center">判断给出的路径是否是一个文件</td></tr><tr><td style="text-align:center">os.path.isdir</td><td style="text-align:center">判断给出的路径是否是一个目录</td></tr></tbody></table></div><h1 id="11-异常处理"><a href="#11-异常处理" class="headerlink" title="11. 异常处理"></a>11. 异常处理</h1><p>增加程序的稳定性（健壮性），我们应该尽可能的考虑可能发生错误的点以及用户的使用方式，以使得程序不会轻易的崩溃</p><ul><li>Python 中所有的异常类都是从 <code>BaseException</code> 类派生的。</li><li>通过 try/except 来捕捉异常，可以使用多个 except 子句来分别处理不同的异常。</li><li>else 子句在主 try 块没有引发异常的情况下被执行。</li><li>finally 子句不管是否发生异常都会被执行。</li><li>通过继承 Exception 类可以创建自己的异常类。</li></ul><h2 id="11-1-try-except"><a href="#11-1-try-except" class="headerlink" title="11.1. try+except"></a>11.1. try+except</h2><p>except可以专门处理单一的错误或异常，也可以处理一组在元组中的错误/异常。如果没有给出错误或异常的名称，它会处理所有的错误和异常</p><p>try:<br>可能会出现异常的代码块<br>except 异常的类型:<br>出现异常以后的处理理语句</p><h2 id="11-2-try-except-else"><a href="#11-2-try-except-else" class="headerlink" title="11.2. try+except+else"></a>11.2. try+except+else</h2><p>如果没有捕获到异常，那么就执行else中的代码</p><p>try:<br>    num = 100<br>    print(num)<br>except NameError as e:<br>    print(‘产⽣生错误了了:%s’%e)<br>else:<br>    print(‘没有捕获到异常，真⾼高兴’)</p><h2 id="11-3-try-finally"><a href="#11-3-try-finally" class="headerlink" title="11.3. try+finally"></a>11.3. try+finally</h2><p>在程序中，如果一段代码必须要执行，即无论异常是否产生都要执行，那么此时就需要使用finally，比如 文件关闭，释放锁，把数据库连接返还给连接池</p><p>如果函数里有finally，finally里的返回值会覆盖之前的返回值</p><p>def div(a,b):<br>    try:<br>        x = a/b<br>    except:<br>        return ‘error’<br>    else:<br>        return x<br>    finally:<br>        return ‘没有捕获到异常，真⾼兴’</p><p>print(div(1, 2))</p><h1 id="结果为-没有捕获到异常，真⾼兴"><a href="#结果为-没有捕获到异常，真⾼兴" class="headerlink" title="结果为 没有捕获到异常，真⾼兴"></a>结果为 没有捕获到异常，真⾼兴</h1><h2 id="11-4-自定义异常"><a href="#11-4-自定义异常" class="headerlink" title="11.4. 自定义异常"></a>11.4. 自定义异常</h2><p>用raise语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是Error或Exception类的子类</p><p>常用</p><p>except Exception as e:</p><p>高级</p><p>class ShortInputException(Exception):<br>    ‘’’⾃定义的异常类’’’<br>    def <strong>init</strong>(self, length, atleast):</p><pre><code>#super().__init__()    self.length = length    self.atleast = atleastdef __str__(self):    return &#39;输入的长度是 %d,长度至少应是 %d&#39;% (self.length, self.atleast)</code></pre><p>def main():<br>    try:<br>        s = input(‘请输入 —&gt; ‘)<br>        if len(s) &lt; 3:</p><pre><code># raise 引发一个自定义的异常        raise ShortInputException(len(s), 3)except ShortInputException as result: # x这个变量被绑定到了错误的实例    print(&#39;ShortInputException:&#39; % result)else:    print(&#39;没有异常发生.&#39;)</code></pre><p>main()</p><h2 id="11-5-异常获取"><a href="#11-5-异常获取" class="headerlink" title="11.5. 异常获取"></a>11.5. 异常获取</h2><ul><li>str(e)</li></ul><p>返回字符串类型，只给出异常信息，不包括异常信息的类型，如1/0的异常信息</p><p>‘integer division or modulo by zero’</p><ul><li>repr(e)</li></ul><p>给出较全的异常信息，包括异常信息的类型，如1/0的异常信息</p><p>“ZeroDivisionError(‘integer division or modulo by zero’,)”</p><ul><li>e.message</li></ul><p>获得的信息同str(e)</p><ul><li>采用traceback模块</li></ul><p>需要导入traceback模块，此时获取的信息最全，与python命令行运行程序出现错误信息一致。使用<code>traceback.print_exc()</code>打印异常信息到标准错误，就像没有获取一样，或者使用<code>traceback.format_exc()</code>将同样的输出获取为字符串。你可以向这些函数传递各种各样的参数来限制输出，或者重新打印到像文件类型的对象</p><p>注意：</p><p>在 Python 3 Exception 的 except 子句中，不支持使用逗号 <code>,</code>分隔 Exception 和 e，所以需要采用 as 关键词进行替换</p><h1 id="以-1-0-异常处理为例"><a href="#以-1-0-异常处理为例" class="headerlink" title="以 1/0 异常处理为例"></a>以 1/0 异常处理为例</h1><p>try:<br>    1/0<br>except Exception as e:<br>    print(‘str(Exception):\t’, e.message)<br>    print(‘str(e):\t\t’, str(e))<br>    print(‘repr(e):\t’, repr(e))</p><p>与 Python 2 Exception 类相比，Python 3 Exception 类没有 message 成员变量。针对这个问题，可以采用 <code>sys.exc_info()</code>方法获取得到相关的异常信息。 <code>sys.exc_info</code>方法可以获取 except 子句正在处理的异常，其返回值为一个tuple类型的三元组<code>(exc_type, exc_value, exc_traceback)</code>，其中，<code>exc_type</code>为获取到的异常类型；<code>exc_value</code>为该异常类型对象；<code>exc_traceback</code>为一个 traceback 对象，包含异常最初发生的调用栈信息。</p><p>程序中的变量 e 和 exc_value 是同一个异常类型实例对象</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2022-04-25-Python%E5%BC%82%E6%AD%A5/"/>
      <url>/2024/10/28/2022-04-25-Python%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><p>资源分配的基本单位</p><p>进程是正在运行的程序的实例</p><h2 id="1-1-fork"><a href="#1-1-fork" class="headerlink" title="1.1. fork()"></a>1.1. fork()</h2><p>在 Unix/Linux 系统中<code>fork</code> 函数被用于创建进程。这个函数很特殊，对于普通的函数，调用一次，返回一次，但是调用 <code>fork</code> 一次，它返回两次。事实上，<code>fork</code> 函数创建了新的进程，我们把它称为子进程，子进程几乎是当前进程（即父进程）的一个拷贝：它会复制父进程的代码段，堆栈段和数据段。</p><p>对于父进程，<code>fork</code> 函数返回了子进程的进程号 pid。对于子进程，<code>fork</code> 函数则返回 <code>0</code>，这也是 <code>fork</code> 函数返回两次的原因，根据返回值，我们可以判断进程是父进程还是子进程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pid = os.fork()</span><br><span class="line"><span class="keyword">if</span> pid &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Fail to create process&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> pid == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;I am child process (%s) and my parent is (%s).&#x27;</span> % (os.getpid(), os.getppid())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;I (%s) just created a child process (%s).&#x27;</span> % (os.getpid(), pid)</span><br></pre></td></tr></table></figure><p>虽然子进程复制了父进程的代码段和数据段等，但是一旦子进程开始运行，子进程和父进程就是相互独立的，它们之间不再共享任何数据</p><h2 id="1-2-多进程"><a href="#1-2-多进程" class="headerlink" title="1.2. 多进程"></a>1.2. 多进程</h2><p>python提供multiprocessing模块实现多进程，需要注意的是multiprocessing 在 Windows 和 Linux 平台的不一致性：一样的代码在 Windows 和 Linux 下运行的结果可能不同。因为 Windows 的进程模型和 Linux 不一样，Windows 下没有 fork</p><p><strong>创建进程对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line">p = Process(参数)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>执行的目标任务名，应该是一个函数名(函数名后不要加括号)</td></tr><tr><td>name</td><td>进程名，一般不用设置</td></tr><tr><td>group</td><td>进程组，目前只能使用None</td></tr></tbody></table></div><p>执行带参数的任务</p><div class="table-container"><table><thead><tr><th>参数名</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>以元组的方式给执行任务传参，参数是按顺序进行对应的</td></tr><tr><td>kwargs</td><td>以字典的方式给执行任务传参，参数是按键名进行对应的</td></tr></tbody></table></div><p><strong>启动进程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.start()</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;singing&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;drawing&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process1 = multiprocessing.Process(target=sing,args=(<span class="number">3</span>,))<span class="comment">#使用元组进行传参</span></span><br><span class="line">    </span><br><span class="line">    process2 = multiprocessing.Process(target=draw,kwargs=&#123;<span class="string">&quot;num&quot;</span>:<span class="number">3</span>&#125;)</span><br><span class="line">    <span class="comment">#使用字典进行传参</span></span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># sing(3)</span></span><br><span class="line">    <span class="comment"># draw(3)</span></span><br></pre></td></tr></table></figure><p><strong>获取当前进程id</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.getpid()</span><br></pre></td></tr></table></figure><p><strong>获取当前父进程id</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.getppid()</span><br></pre></td></tr></table></figure><h2 id="1-3-守护主进程"><a href="#1-3-守护主进程" class="headerlink" title="1.3. 守护主进程"></a>1.3. 守护主进程</h2><p>如果希望主进程结束的同时结束所有子进程，就需要设置守护主进程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子进程.daemon = <span class="literal">True</span>  <span class="comment">#在启动进程前设置</span></span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;singing&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    process1 = multiprocessing.Process(target=sing)</span><br><span class="line"></span><br><span class="line">    process1.daemon = <span class="literal">True</span>      <span class="comment">#设置主进程守护</span></span><br><span class="line"></span><br><span class="line">    process1.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程结束&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="1-4-进程阻塞"><a href="#1-4-进程阻塞" class="headerlink" title="1.4. 进程阻塞"></a>1.4. 进程阻塞</h2><p>join 方法，该方法用于阻塞子进程以外的所有进程（这里指父进程），当子进程执行完毕后，父进程才会继续执行，它通常用于进程间的同步</p><h2 id="1-5-结束进程"><a href="#1-5-结束进程" class="headerlink" title="1.5. 结束进程"></a>1.5. 结束进程</h2><p>不管任务是否完成，立即停止工作进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">进程对象.terminate()</span><br></pre></td></tr></table></figure><p>但是通过执行系统命令ps查看停止后的进程, 会发现, 直接调用terminate方法停止的进程变成了一个僵尸进程(defunct), 只能等待主程序退出, 这个僵尸进程才会消失.</p><p>通过在terminate后添加一次调用join方法等待进程真正结束, 就能避免出现僵尸进程:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程对象.terminate()</span><br><span class="line">进程对象.join()</span><br></pre></td></tr></table></figure><h2 id="1-6-进程池"><a href="#1-6-进程池" class="headerlink" title="1.6. 进程池"></a>1.6. 进程池</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">x</span>):  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Run task %s (pid:%s)...&#x27;</span> % (x, os.getpid()))  </span><br><span class="line">    time.sleep(<span class="number">2</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Task %s result is: %s&#x27;</span> % (x, x * x))  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Parent process %s.&#x27;</span> % os.getpid())  </span><br><span class="line">    p = Pool(<span class="number">4</span>)         <span class="comment"># 设置进程数  </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">        p.apply_async(foo, args=(i,))    <span class="comment"># 设置每个进程要执行的函数和参数  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Waiting for all subprocesses done...&#x27;</span>)  </span><br><span class="line">    p.close()  </span><br><span class="line">    p.join()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;All subprocesses done.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Pool 用于生成进程池，对 Pool 对象调用 apply_async 方法可以使每个进程异步执行任务，也就说不用等上一个任务执行完才执行下一个任务，close 方法用于关闭进程池，确保没有新的进程加入，join 方法会等待所有子进程执行完毕</p><h2 id="1-7-进程间通信"><a href="#1-7-进程间通信" class="headerlink" title="1.7. 进程间通信"></a>1.7. 进程间通信</h2><p>由于每个进程都有各自的内存空间，数据栈等，所以只能使用进程间通讯（Inter-Process Communication, IPC），而不能直接共享信息</p><p>Python 的 multiprocessing 模块封装了底层的实现机制，让我们可以通过Queue很容易地实现进程间的通信</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue  </span><br><span class="line"><span class="comment"># 向队列中写入数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_task</span>(<span class="params">q</span>):  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        n = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> n &lt; <span class="number">5</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;write, %d&quot;</span> % n)  </span><br><span class="line">            q.put(n)  </span><br><span class="line">            time.sleep(<span class="number">1</span>)  </span><br><span class="line">            n += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">except</span> BaseException:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;write_task error&quot;</span>)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;write_task end&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从队列读取数据  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_task</span>(<span class="params">q</span>):  </span><br><span class="line">    <span class="keyword">try</span>:  </span><br><span class="line">        n = <span class="number">1</span>  </span><br><span class="line">        <span class="keyword">while</span> n &lt; <span class="number">5</span>:  </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;read, %d&quot;</span> % q.get())  </span><br><span class="line">            time.sleep(<span class="number">1</span>)  </span><br><span class="line">            n += <span class="number">1</span>  </span><br><span class="line">    <span class="keyword">except</span> BaseException:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;read_task error&quot;</span>)  </span><br><span class="line">    <span class="keyword">finally</span>:  </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;read_task end&quot;</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  </span><br><span class="line">    q = Queue()  <span class="comment"># 父进程创建Queue，并传给各个子进程  </span></span><br><span class="line">    pw = Process(target=write_task, args=(q,))  </span><br><span class="line">    pr = Process(target=read_task, args=(q,))  </span><br><span class="line">    pw.start()   <span class="comment"># 启动子进程 pw，写入  </span></span><br><span class="line">    pr.start()   <span class="comment"># 启动子进程 pr，读取  </span></span><br><span class="line">    pw.join()    <span class="comment"># 等待 pw 结束  </span></span><br><span class="line">    pr.join()    <span class="comment"># 等待 pr 结束  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;DONE&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><p>执行程序的最小单元</p><p>进程是线程的容器</p><p>一个进程中最少有一个线程负责执行程序</p><p>它与同属一个进程的其他线程共享进程所拥有的全部资源</p><h2 id="2-1-多线程"><a href="#2-1-多线程" class="headerlink" title="2.1. 多线程"></a>2.1. 多线程</h2><p>在 Python 中，进行多线程编程的模块有两个：thread 和 threading。其中，thread 是低级模块，threading 是高级模块，对 thread 进行了封装，一般来说，我们只需使用 threading 这个模块</p><p><strong>创建线程对象</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">t = threading.Thread(target=任务名)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>target</td><td>执行的目标任务名，一般是函数名</td></tr><tr><td>name</td><td>线程名</td></tr><tr><td>group</td><td>线程组，目前只能使用None</td></tr></tbody></table></div><p><strong>线程执行带参数的任务</strong></p><div class="table-container"><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>args</td><td>以元组的方式给执行任务传参，参数是按顺序进行对应的</td></tr><tr><td>kwargs</td><td>以字典的方式给执行任务传参，参数是按键名进行对应的</td></tr></tbody></table></div><p><strong>启动线程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程对象.start()</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;dance&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># sing()</span></span><br><span class="line">    <span class="comment"># dance()</span></span><br><span class="line">    sing_thread = threading.Thread(target=sing)</span><br><span class="line">    dance_thread = threading.Thread(target=dance)</span><br><span class="line">    </span><br><span class="line">    sing_thread.start()</span><br><span class="line">    dance_thread.start()</span><br></pre></td></tr></table></figure><h2 id="2-2-守护线程"><a href="#2-2-守护线程" class="headerlink" title="2.2. 守护线程"></a>2.2. 守护线程</h2><p>如果希望主线程结束的同时结束所有子线程，就需要设置守护主线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程对象 = threading.Thread(target= ,daemon=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程对象.setDaemon(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;sing&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># sing()</span></span><br><span class="line">    <span class="comment"># dance()</span></span><br><span class="line">    sing_thread = threading.Thread(target=sing)</span><br><span class="line"></span><br><span class="line">    sing_thread.setDaemon(<span class="literal">True</span>)</span><br><span class="line">    sing_thread.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主线程结束&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2-3-线程阻塞"><a href="#2-3-线程阻塞" class="headerlink" title="2.3. 线程阻塞"></a>2.3. 线程阻塞</h2><p>使用join方法，让主线程等待子线程执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">print</span>(threading.current_thread())  </span><br><span class="line">    time.sleep(<span class="number">5</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    thread_list = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">        th = threading.Thread(target=test)  </span><br><span class="line">        th.start()  </span><br><span class="line">        thread_list.append(th)  </span><br><span class="line">    <span class="keyword">for</span> th <span class="keyword">in</span> thread_list:  </span><br><span class="line">        th.join()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果代码写为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    thread_list = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">        th = threading.Thread(target=test)  </span><br><span class="line">        th.start()  </span><br><span class="line">        th.join()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程结束&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当代码第一次运行到<code>join()</code>时，主线程就卡住了，后面的循环根本没有执行。此时当前只有 <code>thread_1</code>执行过<code>.start()</code>方法，所以此时只有 <code>thread_1</code>在运行。这个线程需要执行5秒钟。等5秒过后，<code>thread_1</code>结束，于是主线程才会运行for的第二次循环，第二个线程才会开始运行。所以这个例子里面，三个线程串行运行</p><p>为什么会有 join 这个功能呢？我们设想这样一个场景。你的爬虫使用10个线程爬取100个 URL，主线程需要等到所有URL 都已经爬取完成以后，再来分析数据。此时就可以通过 join 先把主线程卡住，等到10个子线程全部运行结束了，再用主线程进行后面的操作</p><h2 id="2-4-锁"><a href="#2-4-锁" class="headerlink" title="2.4. 锁"></a>2.4. 锁</h2><p>由于同一个进程之间的线程是内存共享的，所以当多个线程对同一个变量进行修改的时候，就会得到意想不到的结果</p><p>由于线程是交替运行的，线程在执行时可能中断，就会导致其他线程读到一个脏值</p><p>为了保证计算的准确性，我们就需要给操作加上<code>锁</code>。当某个线程开始执行这个操作时，由于该线程获得了锁，因此其他线程不能同时执行该操作，只能等待，直到锁被释放，这样就可以避免修改的冲突。创建一个锁可以通过 <code>threading.Lock()</code> 来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread, Lock  </span><br><span class="line">num = <span class="number">0</span>  </span><br><span class="line">lock = Lock()  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calc</span>():  </span><br><span class="line">    <span class="keyword">global</span> num  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % current_thread().name)  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):  </span><br><span class="line">        lock.acquire()    <span class="comment"># 获取锁  </span></span><br><span class="line">        num += <span class="number">1</span>  </span><br><span class="line">        lock.release()    <span class="comment"># 释放锁  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % current_thread().name)  </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s is running...&#x27;</span> % current_thread().name)  </span><br><span class="line">    threads = []  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">        threads.append(Thread(target=calc))  </span><br><span class="line">        threads[i].start()  </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):  </span><br><span class="line">        threads[i].join()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;global num: %d&#x27;</span> % num)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;thread %s ended.&#x27;</span> % current_thread().name)</span><br></pre></td></tr></table></figure><h2 id="2-5-GIL-锁"><a href="#2-5-GIL-锁" class="headerlink" title="2.5. GIL 锁"></a>2.5. GIL 锁</h2><p><code>GIL</code> 全称是 Global Interpreter Lock，译为<strong>全局解释锁</strong></p><p><code>GIL</code> 锁的存在导致 Python 不能有效地使用多线程实现多核任务，因为在同一时间，只能有一个线程在运行</p><h2 id="2-6-信号量"><a href="#2-6-信号量" class="headerlink" title="2.6. 信号量"></a>2.6. 信号量</h2><h2 id="2-7-事件"><a href="#2-7-事件" class="headerlink" title="2.7. 事件"></a>2.7. 事件</h2><h2 id="2-8-销毁子线程"><a href="#2-8-销毁子线程" class="headerlink" title="2.8. 销毁子线程"></a>2.8. 销毁子线程</h2><p>要做到主线程不结束，但是要强行结束子线程</p><p><strong>方法一：使用ctypes强行杀掉线程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_async_raise</span>(<span class="params">tid, exctype</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;raises the exception, performs cleanup if needed&quot;&quot;&quot;</span></span><br><span class="line">    tid = ctypes.c_long(tid)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> inspect.isclass(exctype):</span><br><span class="line">        exctype = <span class="built_in">type</span>(exctype)</span><br><span class="line">    res = ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, ctypes.py_object(exctype))</span><br><span class="line">    <span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;invalid thread id&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> res != <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># &quot;&quot;&quot;if it returns a number greater than one, you&#x27;re in trouble,</span></span><br><span class="line">        <span class="comment"># and you should call it again with exc=NULL to revert the effect&quot;&quot;&quot;</span></span><br><span class="line">        ctypes.pythonapi.PyThreadState_SetAsyncExc(tid, <span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">raise</span> SystemError(<span class="string">&quot;PyThreadState_SetAsyncExc failed&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stop_thread</span>(<span class="params">thread</span>):</span><br><span class="line">    _async_raise(thread.ident, SystemExit)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_thread</span>():</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(i+<span class="number">1</span>)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    t = threading.Thread(target=test_thread)</span><br><span class="line">    t.start()</span><br><span class="line">    stop_thread(t)</span><br></pre></td></tr></table></figure><p><strong>方法二：使用全局变量控制退出条件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量，用于控制子线程退出</span></span><br><span class="line">stop_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 子线程的执行函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">child_thread</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程开始执行&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> stop_flag:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子线程正在运行&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子线程退出&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子线程并启动</span></span><br><span class="line">thread = threading.Thread(target=child_thread)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主线程中等待一段时间</span></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改全局变量，通知子线程退出</span></span><br><span class="line">stop_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待子线程结束</span></span><br><span class="line">thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;主线程结束&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h1><p>为了避免多个线程同时修改全局变量，我们就需要对全局变量的修改加锁。</p><p>除了对全局变量的修改进行加锁，你可能也想到了可以使用线程自己的局部变量，因为局部变量只有线程自己能看见，对同一进程的其他线程是不可访问的</p><p><code>threading.local()</code>使用 ThreadLocal 对象来线程绑定自己独有的数据</p><h1 id="4-协程"><a href="#4-协程" class="headerlink" title="4. 协程"></a>4. 协程</h1><p><strong>协程允许有多个入口对程序进行中断、继续执行等操作</strong>。</p><p>协程的切换由用户自己管理和调度</p><p>通过创建协程将异步编程同步化</p><p>第三方库 gevent 对协程提供了强大的支持。另外，Python3.5 提供了 async/await 语法来实现对协程的支持。</p><p>相比多线程，协程的一大特点就是<strong>它在一个线程内执行</strong>，既避免了多线程之间切换带来的开销，也避免了对共享资源的访问冲突</p><h1 id="5-concurrent-futures模块"><a href="#5-concurrent-futures模块" class="headerlink" title="5. concurrent.futures模块"></a>5. concurrent.futures模块</h1><p>异步执行可以由 ThreadPoolExecutor 使用线程或由 ProcessPoolExecutor 使用单独的进程来实现。 两者都是实现抽像类 Executor 定义的接口</p><h2 id="5-1-Executor-对象"><a href="#5-1-Executor-对象" class="headerlink" title="5.1. Executor 对象"></a>5.1. Executor 对象</h2><p>抽象类Executor提供异步执行调用方法。要通过它的子类调用，而不是直接调用</p><p><strong>submit(fn, args, </strong>kwargs)**</p><p>调度可调用对象 <code>fn</code>，并返回一个代表该可调用对象的执行的 Future 对象</p><p>建议使用 with 语句来搭配执行，否则得手动实现资源的释放</p><p><strong>map(fn, *iterables, timeout=None, chunksize=1)</strong></p><p>返回一个 map()迭代器，这个迭代器中的回调执行返回的结果是有序的</p><h2 id="5-2-ThreadPoolExecutor"><a href="#5-2-ThreadPoolExecutor" class="headerlink" title="5.2. ThreadPoolExecutor"></a>5.2. ThreadPoolExecutor</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">concurrent</span>.futures.ThreadPoolExecutor(max_workers=<span class="literal">None</span>, thread_name_prefix=<span class="string">&#x27;&#x27;</span>, initializer=<span class="literal">None</span>, initargs=())</span><br></pre></td></tr></table></figure><p>使用最多 <code>max_workers</code> 个线程的线程池来异步执行调用</p><p><code>thread_name_prefix</code>参数允许用户控制由线程池创建的线程名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">url</span>):  </span><br><span class="line">    page.get(url)  </span><br><span class="line">    <span class="keyword">for</span> li <span class="keyword">in</span> page.eles(<span class="string">&#x27;tag:li&#x27;</span>):  </span><br><span class="line">        <span class="keyword">for</span> img <span class="keyword">in</span> li.eles(<span class="string">&#x27;tag:img&#x27;</span>):  </span><br><span class="line">            img_page = img.attr(<span class="string">&#x27;src&#x27;</span>)  </span><br><span class="line">            <span class="built_in">print</span>(img_page)  </span><br><span class="line">            page.download(img_page, <span class="string">&#x27;./img&#x27;</span>)  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getPic</span>():  </span><br><span class="line">    start_overall = time.time()  </span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">50</span>) <span class="keyword">as</span> executor:  </span><br><span class="line">        <span class="keyword">for</span> pageNum <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):  </span><br><span class="line">            <span class="keyword">if</span> pageNum == <span class="number">1</span>:  </span><br><span class="line">                url = <span class="string">&#x27;https://pic.netbian.com/4kdongman/index.html&#x27;</span>  </span><br><span class="line">            <span class="keyword">else</span>:  </span><br><span class="line">                url = <span class="string">&#x27;https://pic.netbian.com/4kdongman/index_&#x27;</span> + <span class="built_in">str</span>(pageNum) +<span class="string">&#x27;.html&#x27;</span>  </span><br><span class="line">            executor.submit(get_page, url)  </span><br><span class="line">    end_overall = time.time()  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总耗时 <span class="subst">&#123;end_overall - start_overall:<span class="number">.2</span>f&#125;</span> 秒&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="5-3-ProcessPoolExecutor"><a href="#5-3-ProcessPoolExecutor" class="headerlink" title="5.3. ProcessPoolExecutor"></a>5.3. ProcessPoolExecutor</h2><p>ProcessPoolExecutor 会使用 multiprocessing 模块，这允许它绕过全局解释器锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">concurrent</span>.futures.ProcessPoolExecutor(max_workers=<span class="literal">None</span>, mp_context=<span class="literal">None</span>, initializer=<span class="literal">None</span>, initargs=(), max_tasks_per_child=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>使用最多具有 <code>max_workers</code> 个进程的进程池，在 Windows 上，<code>max_workers</code> 必须小于等于 <code>61</code>，否则将引发ValueError</p><p><code>mp_context</code> 参数允许用户控制由进程池创建给工作者进程的开始方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">PRIMES = [</span><br><span class="line"></span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">112582705942171</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">112272535095293</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">115280095190773</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">115797848077099</span>,</span><br><span class="line"></span><br><span class="line">    <span class="number">1099726899285419</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_prime</span>(<span class="params">n</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    sqrt_n = <span class="built_in">int</span>(math.floor(math.sqrt(n)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, sqrt_n + <span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n % i == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> <span class="built_in">zip</span>(PRIMES, executor.<span class="built_in">map</span>(is_prime, PRIMES)):</span><br><span class="line"></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;%d is prime: %s&#x27;</span> % (number, prime))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-09-30-%E5%AE%89%E5%85%A8%E8%B5%84%E8%AE%AF/"/>
      <url>/2024/10/28/2021-09-30-%E5%AE%89%E5%85%A8%E8%B5%84%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="1-个人博客"><a href="#1-个人博客" class="headerlink" title="1. 个人博客"></a>1. 个人博客</h1><p><a href="https://www.webshell.cc">WebShell Blog</a><br><a href="https://wiki.y1ng.org/">安全运营之路</a><br><a href="https://x.hacking8.com/">小草窝</a><br><a href="https://www.ddosi.org/">雨苁</a><br><a href="https://www.sqlsec.com/">国光</a></p><hr><h1 id="2-官方安全资讯"><a href="#2-官方安全资讯" class="headerlink" title="2. 官方安全资讯"></a>2. 官方安全资讯</h1><p><a href="http://wiki.ioin.in/">Sec-News安全文摘</a><br><a href="https://xz.aliyun.com/">先知社区</a></p><hr><h2 id="2-1-国外"><a href="#2-1-国外" class="headerlink" title="2.1. 国外"></a>2.1. 国外</h2><p><a href="https://0x00sec.org/">0x00sec</a><br><a href="https://hackerone.com/">hackone</a><br><a href="https://www.offensivecommunity.net/">offensivecommunity</a></p><hr><h2 id="2-2-公开知识库"><a href="#2-2-公开知识库" class="headerlink" title="2.2. 公开知识库"></a>2.2. 公开知识库</h2><p><a href="https://baizesec.github.io/bylibrary/">白阁文库</a><br><a href="https://paper.seebug.org/">Seebug</a><br><a href="https://quickref.me/">quickref</a><br><a href="https://wiki.wgpsec.org/">狼组文库</a><br><a href="https://websec.readthedocs.io/zh/latest/index.html">Web安全学习笔记</a></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> 安全资讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-07-01-Python%E6%AD%A3%E5%88%99/"/>
      <url>/2024/10/28/2021-07-01-Python%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h1><p>正则表达式是一个特殊的字符序列，通常被用来检索或替换那些符合某个规则的字符串</p><h1 id="2-正则表达式模式"><a href="#2-正则表达式模式" class="headerlink" title="2. 正则表达式模式"></a>2. 正则表达式模式</h1><h2 id="2-1-规则"><a href="#2-1-规则" class="headerlink" title="2.1. 规则"></a>2.1. 规则</h2><ul><li>数字和字母都表示本身</li><li>有的字母前加<code>\</code>有特殊含义(重点)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = re.search(<span class="string">r&#x27;\d&#x27;</span>,<span class="string">&#x27;he12ms90&#x27;</span>) <span class="comment"># 这⾥的 \d 表示的是匹配数字</span></span><br></pre></td></tr></table></figure><ul><li>大多数标点符号都有特殊含义(重点)</li><li>要匹配标点符号需要在前面加<code>\</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = re.search(<span class="string">r&#x27;\.&#x27;</span>,<span class="string">&#x27;he.llo&#x27;</span>) <span class="comment"># 这⾥的 \. 进⾏了转义，才表示标点符号自身</span></span><br></pre></td></tr></table></figure><h2 id="2-2-分组"><a href="#2-2-分组" class="headerlink" title="2.2. 分组"></a>2.2. 分组</h2><p>正则表达式里使用<code>()</code>来表示一个分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = re.findall(<span class="string">r&#x27;\w+@(qq|126|163)\.com&#x27;</span>,<span class="string">&#x27;123@qq.com;aa@163.com;bb@126.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret) </span><br><span class="line"><span class="comment">#结果为 [&#x27;qq&#x27;, &#x27;163&#x27;, &#x27;126&#x27;] 只匹配到了了分组里的内容</span></span><br></pre></td></tr></table></figure><h2 id="2-3-模式（通用）"><a href="#2-3-模式（通用）" class="headerlink" title="2.3. 模式（通用）"></a>2.3. 模式（通用）</h2><h3 id="2-3-1-非打印字符"><a href="#2-3-1-非打印字符" class="headerlink" title="2.3.1. 非打印字符"></a>2.3.1. 非打印字符</h3><p>非打印字符，即在程序中不显示的字符，如换行符<code>\n</code>等</p><div class="table-container"><table><thead><tr><th>非打印字符</th><th>描述</th></tr></thead><tbody><tr><td><code>\cx</code></td><td>匹配由x指明的控制字符，例如， <code>\cM</code> 匹配一个 Control-M 或 回车符。x 的值必须为 A-Z 或 a-z之一。否则，将 c 视为一个原义的 <code>c</code>字符</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符。等价于 <code>\x0c</code> 和 <code>\cL</code></td></tr><tr><td><code>\n</code></td><td>匹配一个换行符。等价于 <code>\x0a</code> 和 <code>\cJ</code></td></tr><tr><td><code>\r</code></td><td>匹配一个回车符。等价于 <code>\x0d</code>和 <code>\cM</code></td></tr><tr><td><code>\s</code></td><td>匹配任何非打印字符(空白字符)，包括空格、制表符、换页符等。等价于 <code>[ \f\n\r\t\v]</code>。注意 Unicode 正则表达式会匹配全角空格符</td></tr><tr><td><code>\S</code></td><td>匹配任何非空白字符。等价于<code>[^ \f\n\r\t\v]</code></td></tr><tr><td><code>\t</code></td><td>匹配一个制表符。等价于 <code>\x09</code> 和 <code>\cI</code></td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符。等价于 <code>\x0b</code> 和 <code>\cK</code></td></tr></tbody></table></div><h3 id="2-3-2-特殊字符"><a href="#2-3-2-特殊字符" class="headerlink" title="2.3.2. 特殊字符"></a>2.3.2. 特殊字符</h3><p>有特殊含义的字符。若要匹配这些特殊字符，必须首先使字符转义，即将反斜杠字符<code>\</code>放在它们前面</p><div class="table-container"><table><thead><tr><th>特殊字符</th><th>描述</th></tr></thead><tbody><tr><td><code>()</code></td><td>使用 <code>\(</code> 和 <code>\)</code></td></tr><tr><td><code>.</code></td><td>匹配除换行符 <code>\n</code> 之外的任何单字符。要匹配 <code>.</code> 用 <code>\.</code></td></tr><tr><td><code>[</code></td><td>表示可选项的范围，<code>[x-y]</code>表示匹配x到y中的一个(包含x、y)。要匹配 <code>[</code>用 <code>\[</code></td></tr><tr><td><code>\</code></td><td>使用原生字符串使用两个<code>\</code>即可匹配一个<code>\</code></td></tr><tr><td><code>&#123;</code></td><td>限定前面元素出现的次数。要匹配 <code>&#123;</code>用 <code>\&#123;</code></td></tr><tr><td>`</td><td>`</td><td>表示或者。要匹配`</td><td><code>用</code>&#124;`</td></tr><tr><td><code>\d</code></td><td>匹配一个数字字符。等价于 <code>[0-9]</code></td></tr><tr><td><code>[0-9]</code></td><td>匹配任何数字。等价于 <code>\d</code></td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符。等价于 <code>[^0-9]</code></td></tr><tr><td><code>[a-z]</code></td><td>匹配任何小写字母</td></tr><tr><td><code>[A-Z]</code></td><td>匹配任何大写字母</td></tr><tr><td><code>[a-zA-Z0-9]</code></td><td>匹配任何字母及数字。等价于<code>\w</code></td></tr><tr><td><code>\w</code></td><td>匹配包括下划线的任何单词字符。等价于<code>[a-zA-Z0-9]</code></td></tr><tr><td><code>\W</code></td><td>匹配任何非单词字符。等价于 <code>[^a-zA-Z0-9]</code></td></tr><tr><td><code>[\u4e00-\u9fa5]</code></td><td>匹配纯中文</td></tr></tbody></table></div><h3 id="2-3-3-定位符"><a href="#2-3-3-定位符" class="headerlink" title="2.3.3. 定位符"></a>2.3.3. 定位符</h3><p>将正则表达式固定到行首或行尾。它能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾</p><div class="table-container"><table><thead><tr><th>定位符</th><th>描述</th></tr></thead><tbody><tr><td><code>^</code></td><td>以指定内容开头，如<code>^a</code>表示以a开头的内容，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 <code>^</code> 字符本身，请使用 <code>\^</code></td></tr><tr><td>$$`</td><td>指定内容结尾，如`a$$表示以a结尾的内容</td></tr><tr><td><code>\b</code></td><td>匹配一个单词边界，即字与空格间的位置</td></tr><tr><td><code>\B</code></td><td>非单词边界匹配</td></tr></tbody></table></div><p><strong>详解<code>\b</code></strong></p><ul><li>什么是位置</li></ul><p>It’s a nice day today.</p><p>‘I’占一个位置，’t’ 占一个位置，所有的单个字符（包括不可见的空白字符）都会占一个位置，这样的位置我给它取个名字叫“显式位置”。</p><p>注意：字符与字符之间还有一个位置，例如 ‘I’ 和 ‘t’ 之间就有一个位置（没有任何东西），这样的位置我给它取个名字叫“隐式位置”。</p><p><code>\b</code> 就是“隐式位置”</p><ul><li><code>\b</code></li></ul><p>就用 “It’s a nice day today.” 举例说明：</p><p>正确的正则：<code>\bnice\b</code></p><p>分析：第一个 <code>\b</code> 前面一个字符是空格，后面一个字符是 ‘n’，不全是 <code>\w</code>，所以可以匹配出 ‘n’ 是一个单词的开头。第二个 <code>\b</code> 前面一个字符是 ‘e’，后面一个字符是空格，不全是 <code>\w</code>，可以匹配出 ‘e’ 是一个单词的结尾。所以，合在一起，就能匹配出以 ‘n’ 开头以 ‘e’ 结尾的单词，这里就能匹配出 “nice” 这个单词。</p><h3 id="2-3-4-限定符"><a href="#2-3-4-限定符" class="headerlink" title="2.3.4. 限定符"></a>2.3.4. 限定符</h3><p>用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p><div class="table-container"><table><thead><tr><th>限定符</th><th>描述</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配前面的子表达式零次或多次。例如，<code>zo*</code> 能匹配 <code>z</code> 以及 <code>zoo</code>。<code>*</code> 等价于<code>&#123;0,&#125;</code></td></tr><tr><td><code>+</code></td><td>匹配前面的子表达式一次或多次。例如，<code>zo+</code> 能匹配 <code>zo</code> 以及<code>zoo</code>，但不能匹配 <code>z</code>。<code>+</code> 等价于 <code>&#123;1,&#125;</code></td></tr><tr><td><code>?</code></td><td>匹配前面的子表达式零次或一次。例如，<code>do(es)?</code> 可以匹配 <code>do</code> 、<code>does</code>中的 <code>does</code>、 <code>doxy</code> 中的<code>do</code>。<code>?</code>等价于 <code>&#123;0,1&#125;</code></td></tr><tr><td><code>&#123;n&#125;</code></td><td>n 是一个非负整数。匹配前面的子表达式确定的 n 次。例如，<code>o&#123;2&#125;</code> 不能匹配<code>Bob</code>中的 <code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code></td></tr><tr><td><code>&#123;n,&#125;</code></td><td>n 是一个非负整数。至少匹配前面的子表达式 n 次。例如，<code>o&#123;2,&#125;</code> 不能匹配 <code>Bob</code> 中的 <code>o</code>，但能匹配 <code>foooood</code>中的所有 <code>o</code>。<code>&#123;1,&#125;</code> 等价于 <code>o+</code>。<code>o&#123;0,&#125;</code> 则等价于 <code>o*</code></td></tr><tr><td><code>&#123;,n&#125;</code></td><td>表示前面的元素出现 n 次以下</td></tr><tr><td><code>&#123;n,m&#125;</code></td><td>m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。。例如，<code>o&#123;1,3&#125;</code> 将匹配<code>fooooood</code>中的前三个<code>o</code>。<code>o&#123;0,1&#125;</code> 等价于 <code>o?</code></td></tr></tbody></table></div><h1 id="3-匹配"><a href="#3-匹配" class="headerlink" title="3. 匹配\"></a>3. 匹配<code>\</code></h1><ul><li>需要使用四个<code>\</code>来匹配一个<code>\</code></li><li>在Python 字符串前面添加<code>r</code> 即可将字符串转换成为原生字符串，通过原生字符串使用两个<code>\</code>即可匹配一个<code>\</code></li></ul><h1 id="4-re之查找"><a href="#4-re之查找" class="headerlink" title="4. re之查找"></a>4. re之查找</h1><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>匹配的正则表达式</td></tr><tr><td>string</td><td>要匹配的字符串</td></tr><tr><td>flags</td><td>标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等</td></tr></tbody></table></div><h2 id="4-1-re-match"><a href="#4-1-re-match" class="headerlink" title="4.1. re.match"></a>4.1. re.match</h2><ul><li>只对字符串查询一次</li><li>只匹配字符串开头，如果不是起始位置匹配成功的话，match()就返回none</li><li>返回值的类型为re.Match类型的对象</li><li>使用group(num)函数来获取匹配的字符串结果</li></ul><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.<span class="keyword">match</span>(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;helloword&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.<span class="keyword">match</span>(<span class="string">r&#x27;H&#x27;</span>,x)</span><br><span class="line">b = re.<span class="keyword">match</span>(<span class="string">r&#x27;h&#x27;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#结果为 None</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 &lt;re.Match object; span=(0, 1), match=&#x27;h&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="4-2-re-search"><a href="#4-2-re-search" class="headerlink" title="4.2. re.search"></a>4.2. re.search</h2><ul><li>只对字符串查询一次</li><li>扫描整个字符串，并返回第一个成功的匹配</li><li>返回值的类型为re.Match类型的对象</li><li>使用group(num)函数来获取匹配的字符串结果</li></ul><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.search(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskldjklasjpdf&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.search(<span class="string">r&#x27;a&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#结果为 &lt;re.Match object; span=(1, 2), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="comment">#只返回第一个成功的匹配</span></span><br></pre></td></tr></table></figure></p><h2 id="4-3-re-finditer"><a href="#4-3-re-finditer" class="headerlink" title="4.3. re.finditer"></a>4.3. re.finditer</h2><p>和findall类似，但是re.finditer更适合当你需要匹配的详细信息或处理大文本时，<code>finditer</code>是按需生成匹配对象，不会一次性将所有匹配存入内存</p><ul><li>扫描整个字符串，找到所有的匹配</li><li>返回一个可迭代对象</li><li>返回值的类型为re.Match类型的对象</li><li>使用group(num)函数来获取匹配的字符串结果</li></ul><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.finditer(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>例子</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskldjklasjpdf&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.finditer(<span class="string">r&#x27;a&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#结果是 &lt;re.Match object; span=(1, 2), match=&#x27;a&#x27;&gt;</span></span><br><span class="line">  <span class="comment">#&lt;re.Match object; span=(9, 10), match=&#x27;a&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-4-re-findall"><a href="#4-4-re-findall" class="headerlink" title="4.4. re.findall"></a>4.4. re.findall</h2><ul><li>扫描整个字符串，找到所有的匹配</li><li>返回一个列表</li><li>如果没有找到匹配的，则返回空列表</li></ul><p><strong>注意</strong></p><p>如果匹配规则里有分组，则只匹配分组数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ret = re.findall(<span class="string">r&#x27;\w+@(qq|126|163)\.com&#x27;</span>,<span class="string">&#x27;123@qq.com;aa@163.com;bb@126.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(ret) </span><br><span class="line"><span class="comment">#结果为 [&#x27;qq&#x27;, &#x27;163&#x27;, &#x27;126&#x27;] 只匹配到了了分组里的内容</span></span><br></pre></td></tr></table></figure><p>如果匹配规则里存在多个分组，则会把多个分组匹配成元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = re.findall(<span class="string">r&#x27;\w+@(qq|126|163)(\.com)&#x27;</span>,<span class="string">&#x27;123@qq.com;aa@163.com;bb@126.com&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ret) </span><br><span class="line"><span class="comment">#结果为 [(&#x27;qq&#x27;, &#x27;.com&#x27;), (&#x27;163&#x27;, &#x27;.com&#x27;), (&#x27;126&#x27;, &#x27;.com&#x27;)]</span></span><br></pre></td></tr></table></figure><p>如果想要让findall匹配所有的内容，而不仅只是匹配正则表达式里的分组，可以使用 <code>?:</code>来将分组标记为非捕获分组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ret = re.findall(<span class="string">r&#x27;\w+@(?:qq|126|163)\.com&#x27;</span>,<span class="string">&#x27;123@qq.com;aa@163.com;bb@126.com&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(ret) </span><br><span class="line"><span class="comment">#结果为 [&#x27;123@qq.com&#x27;, &#x27;aa@163.com&#x27;, &#x27;bb@126.com&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>语法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.findall(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskl9lasj&#x27;</span></span><br><span class="line">a = re.findall(<span class="string">r&#x27;a&#x27;</span>,x)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="comment">#结果为 [&#x27;a&#x27;, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure></p><h2 id="4-5-re-fullmatch"><a href="#4-5-re-fullmatch" class="headerlink" title="4.5. re.fullmatch"></a>4.5. re.fullmatch</h2><ul><li>检查整个字符串是否完全匹配给定的正则表达式模式。如果字符串与模式完全一致，则返回一个 <code>Match</code> 对象，否则返回 <code>None</code>。这个方法适合用于需要验证整个输入格式的场景，比如输入校验或数据验证</li><li>使用group(num)函数来获取匹配的字符串结果</li></ul><p><strong>语法</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.fullmatch(pattern,string,flags=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><br><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskl9lasj&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.fullmatch(<span class="string">r&#x27;jask&#x27;</span>,x)</span><br><span class="line">b = re.fullmatch(<span class="string">r&#x27;j.*j&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)<span class="comment">#结果为 None</span></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 &lt;re.Match object; span=(0, 10), match=&#x27;jaskl9lasj&#x27;&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="4-6-re-Match类"><a href="#4-6-re-Match类" class="headerlink" title="4.6. re.Match类"></a>4.6. re.Match类</h2><p>调用re.match 方法、re.search 方法、re.fullmatch方法，或者对re.finditer 方法的结果进行迭代时，拿到的数据类型都是re.Match 对象，这个类里定义了相关的属性</p><div class="table-container"><table><thead><tr><th>属性和方法</th><th>说 明</th></tr></thead><tbody><tr><td>pos</td><td>搜 索 的 开 始 位 置</td></tr><tr><td>endpos</td><td>搜 索 的 结 束 位 置</td></tr><tr><td>string</td><td>搜 索 的 字 符 串</td></tr><tr><td>re</td><td>当 前 使  用 的 正 则 表 达 式 的 对 象</td></tr><tr><td>lastindex</td><td>最 后 匹 配 的 组 索 引</td></tr><tr><td>lastgroup</td><td>最 后 匹 配 的 组 名</td></tr><tr><td>group(index=0)</td><td>某个分组的匹配结果。如果index等于0，便是匹配整个正则表达式</td></tr><tr><td>groups()</td><td>所有分组的匹配结果，每个分组的结果组成一个元组返回</td></tr><tr><td>groupdict()</td><td>返回组名作为key，每个分组的匹配结果做为value的字典</td></tr><tr><td>start([group])</td><td>获 取 组 的 开 始 位 置</td></tr><tr><td>end([group])</td><td>获 取 组 的 结 束 位 置</td></tr><tr><td>span([group])</td><td>获 取 组 的 开 始 和 结 束 位 置</td></tr><tr><td>expand(template)</td><td>使用组的匹配结果来替换模板template中的内容，并把替换后的字符串返回</td></tr></tbody></table></div><p><strong>group()</strong></p><p>group()方法表示正则表达式的分组。group(n)来表示第 n 个分组，第 0 组就是把整个正则表达式当做整体。没有分组，则默认只有一组。分组的下标从 0 开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskl9laasd5sad4123as1231x2j&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.search(<span class="string">r&#x27;(j.*)(9.*)(4.*)&#x27;</span>,x) <span class="comment"># 分3组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(a.group(<span class="number">0</span>))<span class="comment"># 0 组默认是把整个正则表达式当做整体 </span></span><br><span class="line"><span class="built_in">print</span>(a.group(<span class="number">1</span>))<span class="comment"># 1 组 </span></span><br><span class="line"><span class="built_in">print</span>(a.group(<span class="number">2</span>))<span class="comment"># 2 组</span></span><br><span class="line"><span class="built_in">print</span>(a.group(<span class="number">3</span>))<span class="comment"># 3 组</span></span><br></pre></td></tr></table></figure><p><strong>groupdict()</strong></p><p>groupdict() 返回组名作为key，每个分组的匹配结果做为value的字典</p><p>为分组起名字 <code>?P&lt;name&gt;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;jaskl9laasd5sad4123as1231x2j&#x27;</span></span><br><span class="line"></span><br><span class="line">a = re.search(<span class="string">r&#x27;(?P&lt;name1&gt;j.*)(?P&lt;name2&gt;9.*)(?P&lt;name3&gt;4.*)&#x27;</span>,x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.groupdict())</span><br></pre></td></tr></table></figure><h1 id="5-re-compile方法"><a href="#5-re-compile方法" class="headerlink" title="5. re.compile方法"></a>5. re.compile方法</h1><ul><li>使用正则表达式时，可以直接调用re 模块的 match、search、findall 等方法，传入指定的正则表达式</li><li>也可以调用re.compile方法，生成一个正则表达式对象，再调用这个正则表达式对象的相关方法实现匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 1 </span></span><br><span class="line">y = <span class="string">&#x27;jaskl9laasd5sad4123as1231x2j&#x27;</span></span><br><span class="line">r = re.<span class="built_in">compile</span>(<span class="string">r&#x27;j.*&#x27;</span>)</span><br><span class="line">b = r.search(y)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 2 </span></span><br><span class="line">y = <span class="string">&#x27;jaskl9laasd5sad4123as1231x2j&#x27;</span></span><br><span class="line">b = re.search(<span class="string">r&#x27;j.*&#x27;</span>,y)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"><span class="comment"># 1 和 2 等价</span></span><br></pre></td></tr></table></figure><h1 id="6-正则表达式修饰符"><a href="#6-正则表达式修饰符" class="headerlink" title="6. 正则表达式修饰符"></a>6. 正则表达式修饰符</h1><div class="table-container"><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>re.I(大写i)</td><td>使匹配对大小写不敏感</td></tr><tr><td>re.M</td><td>多行匹配，影响 <code>^</code> 和 <code>$</code></td></tr><tr><td>re.S</td><td>使 <code>.</code> 匹配包括换行在内的所有字符</td></tr></tbody></table></div><p><strong>re.I</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">x = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line">b = re.search(<span class="string">r&#x27;a.*&#x27;</span>,x)</span><br><span class="line">c = re.search(<span class="string">r&#x27;a.*&#x27;</span>,x,re.I)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 None</span></span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#结果为 &lt;re.Match object; span=(0, 3), match=&#x27;ABC&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>re.M</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">y = <span class="string">&#x27;I like eat food\nShe do not like\nShe love me&#x27;</span></span><br><span class="line"></span><br><span class="line">b = re.findall(<span class="string">r&#x27;\w+$&#x27;</span>,y)</span><br><span class="line">c = re.findall(<span class="string">r&#x27;\w+$&#x27;</span>,y,re.M)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 [&#x27;me&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#结果为 [&#x27;food&#x27;, &#x27;like&#x27;, &#x27;me&#x27;]</span></span><br></pre></td></tr></table></figure><p><strong>re.S</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">y = <span class="string">&#x27;ajakl9l\nad5&#x27;</span></span><br><span class="line">b = re.search(<span class="string">r&#x27;9.*&#x27;</span>,y)</span><br><span class="line">c = re.search(<span class="string">r&#x27;9.*&#x27;</span>,y,re.S)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 &lt;re.Match object; span=(5, 7), match=&#x27;9l&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#结果为 &lt;re.Match object; span=(5, 11), match=&#x27;9l\nad5&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h1 id="7-正则替换"><a href="#7-正则替换" class="headerlink" title="7. 正则替换"></a>7. 正则替换</h1><p>使用 re.sub 替换字符串中的匹配项</p><h2 id="7-1-语法"><a href="#7-1-语法" class="headerlink" title="7.1. 语法"></a>7.1. 语法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">re.sub(pattern,repl,string,count=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="7-2-参数"><a href="#7-2-参数" class="headerlink" title="7.2. 参数"></a>7.2. 参数</h2><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>pattern</td><td>正则中的模式字符串</td></tr><tr><td>repl</td><td>替换的字符串，也可为一个函数</td></tr><tr><td>string</td><td>要被查找替换的原始字符串</td></tr><tr><td>count</td><td>模式匹配后替换的最大次数，默认 0 表示替换所有的匹配</td></tr></tbody></table></div><p><strong>repl</strong></p><p>当repl传入的是一个函数test()时，re.sub内部会调用该函数，并把每一个匹配到的数据以re.Match的格式传参，传给函数test()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">y = <span class="string">&#x27;I like eat123food,She do888not like,She love me&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">x</span>):</span><br><span class="line">    y = <span class="built_in">int</span>(x.group(<span class="number">0</span>))</span><br><span class="line">    y *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">str</span>(y)</span><br><span class="line">b = re.sub(<span class="string">r&#x27;\d&#x27;</span>,test,y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="7-3-例子"><a href="#7-3-例子" class="headerlink" title="7.3. 例子"></a>7.3. 例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">y = <span class="string">&#x27;I like eat123food,She do888not like,She love me&#x27;</span></span><br><span class="line"></span><br><span class="line">b = re.sub(<span class="string">r&#x27;\d&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,y)</span><br><span class="line">c = re.sub(<span class="string">r&#x27;\d+&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,y)</span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 I like eatxxxfood,She doxxxnot like,She love me</span></span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#结果为 I like eatxfood,She doxnot like,She love me</span></span><br></pre></td></tr></table></figure><h1 id="8-贪婪和非贪婪"><a href="#8-贪婪和非贪婪" class="headerlink" title="8. 贪婪和非贪婪"></a>8. 贪婪和非贪婪</h1><ul><li>Python里数量词默认是贪婪的(在少数语言里也可能是默认非贪婪)，总是尝试匹配尽可能多的字符</li><li>非贪婪则相反，总是尝试匹配尽可能少的字符</li><li>在<code>*</code>、<code>?</code>、<code>+</code>、<code>&#123;m,n&#125;</code> 后面加上 <code>?</code> 使贪婪变成非贪婪</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">y = <span class="string">&#x27;m1234&#x27;</span></span><br><span class="line">b = re.search(<span class="string">r&#x27;m\d+?&#x27;</span>,y)</span><br><span class="line">c = re.search(<span class="string">r&#x27;m\d+&#x27;</span>,y)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)<span class="comment">#结果为 &lt;re.Match object; span=(0, 2), match=&#x27;m1&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(c)<span class="comment">#结果为 &lt;re.Match object; span=(0, 5), match=&#x27;m1234&#x27;&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-07-05-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/10/28/2021-07-05-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-网络通信的要素"><a href="#1-网络通信的要素" class="headerlink" title="1. 网络通信的要素"></a>1. 网络通信的要素</h1><ul><li><code>ip:端口</code></li><li>网络通信协议<h1 id="2-网络通信的两种模型"><a href="#2-网络通信的两种模型" class="headerlink" title="2. 网络通信的两种模型"></a>2. 网络通信的两种模型</h1></li></ul><h2 id="2-1-C-S"><a href="#2-1-C-S" class="headerlink" title="2.1. C/S"></a>2.1. C/S</h2><p>一套程序为客户端，另外一套程序为服务器端</p><p>这种开发可以由开发者自定义传输协议，并且使用一些比较私密的端口</p><p>所以安全性是比较高的，但是开发与维护成本比较高</p><p>其分为两种开发：TCP(可靠的数据连接)、UDP(不可靠的数据连接）</p><h2 id="2-2-B-S"><a href="#2-2-B-S" class="headerlink" title="2.2. B/S"></a>2.2. B/S</h2><p>只开发一套服务器端的程序，使用的是公共的HTTP协议并且使用的公共的 80 端口，所以其安全性相对较差</p><h1 id="3-TCP通信"><a href="#3-TCP通信" class="headerlink" title="3. TCP通信"></a>3. TCP通信</h1><p>使用两个类实现数据的交互处理：ServerSocket  (服务器端)、Socket（客户端）</p><h2 id="3-1-ServerSocket"><a href="#3-1-ServerSocket" class="headerlink" title="3.1. ServerSocket"></a>3.1. ServerSocket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 实例化一个 ServerSocket 对象</span></span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">888</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;listening......&quot;</span>);</span><br><span class="line">        <span class="comment">// 监听端口，等待客户端连接</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> server.accept();</span><br><span class="line">        <span class="comment">// 接收客户端的输入流</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(client.getInputStream());</span><br><span class="line">        <span class="comment">// 向客户端发送数据</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(client.getOutputStream());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="comment">// 如果接收到客户端的信息</span></span><br><span class="line">            <span class="keyword">if</span> (scan.hasNext())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">val</span> <span class="operator">=</span> scan.next();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;stop&quot;</span>.equals(val))&#123;</span><br><span class="line">                    out.println(<span class="string">&quot;stop server!!!&quot;</span>);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 向客户端返回数据</span></span><br><span class="line">                    out.println(<span class="string">&quot;【echo】&quot;</span> + val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        server.close();</span><br><span class="line">        scan.close();</span><br><span class="line">        out.close();</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-Socket"><a href="#3-2-Socket" class="headerlink" title="3.2. Socket"></a>3.2. Socket</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Socket</span> &#123;</span><br><span class="line">    <span class="comment">// 接收键盘的输入内容</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Scanner</span> <span class="variable">keyboard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 连接服务器</span></span><br><span class="line">        <span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">888</span>);</span><br><span class="line">        <span class="comment">// 接收服务器端的输入流</span></span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(client.getInputStream());</span><br><span class="line">        <span class="comment">// 向服务器端发送内容</span></span><br><span class="line">        <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintStream</span>(client.getOutputStream());</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (flag)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">input</span> <span class="operator">=</span> getString(<span class="string">&quot;【input content】&quot;</span>);</span><br><span class="line">            out.println(input);</span><br><span class="line">            <span class="comment">// 如果服务器端有响应</span></span><br><span class="line">            <span class="keyword">if</span> (scan.hasNext())&#123;</span><br><span class="line">                System.out.println(scan.next());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果输入 stop 就停止</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;stop&quot;</span>.equals(input))&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">        out.close();</span><br><span class="line">        scan.close();</span><br><span class="line">        keyboard.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收键盘的输入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getString</span><span class="params">(String prompt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        System.out.println(prompt);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> keyboard.next();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接建立后，通过 I/O 流进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。</p><p>TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送。</p><h1 id="4-UDP通信"><a href="#4-UDP通信" class="headerlink" title="4. UDP通信"></a>4. UDP通信</h1><p>实现UDP程序需要两个类：DatagramPacket(数据内容)、DatagramSocket (网络发送与接收) 数据报的发送：客户端是否接收到与发送者无关</p><h2 id="4-1-客户端"><a href="#4-1-客户端" class="headerlink" title="4.1. 客户端"></a>4.1. 客户端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 客户端接收信息的端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">888</span>);</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,data.length);</span><br><span class="line">        System.out.println(<span class="string">&quot;waiting accept content...&quot;</span>);</span><br><span class="line">        <span class="comment">// 接收消息</span></span><br><span class="line">        client.receive(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;【accepted content】&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data,<span class="number">0</span>,packet.getLength()));</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-服务端"><a href="#4-2-服务端" class="headerlink" title="4.2. 服务端"></a>4.2. 服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 服务端发送信息的端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">88</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;www.baidu.com&quot;</span>;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(str.getBytes(),<span class="number">0</span>,str.length(), InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>),<span class="number">888</span>);</span><br><span class="line">        server.send(packet);</span><br><span class="line">        System.out.println(<span class="string">&quot;message sended&quot;</span>);</span><br><span class="line">        server.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-URL下载网络资源"><a href="#5-URL下载网络资源" class="headerlink" title="5. URL下载网络资源"></a>5. URL下载网络资源</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 资源地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://img1.wallspic.com/previews/8/8/9/1/7/171988/171988-genshin_impact_ling_xiang_nu_pu-hoyolab-ka_tong-bai_se-zi_se_de-x750.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 连接资源</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="comment">// 请求资源</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">        <span class="comment">// 设置文件</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 临时缓存</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len=inputStream.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 将请求得到的数据写入文件</span></span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭IO</span></span><br><span class="line">        fos.close();</span><br><span class="line">        inputStream.close();</span><br><span class="line">        urlConnection.disconnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>笔记根据王爽写，文末总结有指令查询手册</p><h1 id="1-什么是汇编"><a href="#1-什么是汇编" class="headerlink" title="1. 什么是汇编"></a>1. 什么是汇编</h1><p>汇编语言提供了一种直接操控CPU、寄存器和内存的工具</p><h1 id="2-第一章"><a href="#2-第一章" class="headerlink" title="2. 第一章"></a>2. 第一章</h1><h2 id="2-1-数的表示"><a href="#2-1-数的表示" class="headerlink" title="2.1. 数的表示"></a>2.1. 数的表示</h2><p>在汇编语言中， 数值后面分别用字母B代表二进制（Binary）、 H代表十六进制（Hexadecimal）、 D 代表十进制（Decimal）（十进制数可以省略D）</p><h3 id="2-1-1-进制数三要素"><a href="#2-1-1-进制数三要素" class="headerlink" title="2.1.1. 进制数三要素"></a>2.1.1. 进制数三要素</h3><ul><li>基数</li><li>位权</li><li>进位</li></ul><h3 id="2-1-2-有符号数"><a href="#2-1-2-有符号数" class="headerlink" title="2.1.2. 有符号数"></a>2.1.2. 有符号数</h3><p>0代表非负数，1代表负数</p><p>根据不同表示方式，分为原码、反码、补码</p><h3 id="2-1-3-无符号数"><a href="#2-1-3-无符号数" class="headerlink" title="2.1.3. 无符号数"></a>2.1.3. 无符号数</h3><p>直接使用十六进制表示</p><h3 id="2-1-4-机器数"><a href="#2-1-4-机器数" class="headerlink" title="2.1.4. 机器数"></a>2.1.4. 机器数</h3><p>把正负号数值化后，得到的计算机能实际表示的数</p><p>包括：原码、反码、补码</p><h3 id="2-1-5-真值"><a href="#2-1-5-真值" class="headerlink" title="2.1.5. 真值"></a>2.1.5. 真值</h3><p>带有正负号的实际数值</p><h3 id="2-1-6-内存中的数据（重点）"><a href="#2-1-6-内存中的数据（重点）" class="headerlink" title="2.1.6. 内存中的数据（重点）"></a>2.1.6. 内存中的数据（重点）</h3><ul><li>数字</li></ul><p>有符号数存放的是数字的补码的二进制，无符号数直接存放十六进制的二进制</p><ul><li>字符</li></ul><p>存放的是字符对应的某种编码的二进制</p><h3 id="2-1-7-二进制数"><a href="#2-1-7-二进制数" class="headerlink" title="2.1.7. 二进制数"></a>2.1.7. 二进制数</h3><p>从右向左分别为1位、2位、4位、8位、16位</p><div class="table-container"><table><thead><tr><th>2的n次方</th><th>大小</th></tr></thead><tbody><tr><td>2^10</td><td>1024 = 1K</td></tr><tr><td>2^20</td><td>1024K = 1M</td></tr><tr><td>2^30</td><td>1024M = 1G</td></tr><tr><td>2^40</td><td>1024G = 1T</td></tr></tbody></table></div><h3 id="2-1-8-十进制数"><a href="#2-1-8-十进制数" class="headerlink" title="2.1.8. 十进制数"></a>2.1.8. 十进制数</h3><p>从右向左依次为个位、十位、百位、千位、万位</p><h3 id="2-1-9-十进制数和二进制数的关系"><a href="#2-1-9-十进制数和二进制数的关系" class="headerlink" title="2.1.9. 十进制数和二进制数的关系"></a>2.1.9. 十进制数和二进制数的关系</h3><p>当二进制产生进位时，代表的十进制数为2、4、8、16、32、64、128</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045676.jpg" alt=""></p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045080.jpg" alt=""></p><h2 id="2-2-进制转换"><a href="#2-2-进制转换" class="headerlink" title="2.2. 进制转换"></a>2.2. 进制转换</h2><p>在计算机中， 数据都是以二进制表示的， 因此采用2的n次方形式描述数的权值大小。 </p><h3 id="2-2-1-十进制与其他进制转换（重点）"><a href="#2-2-1-十进制与其他进制转换（重点）" class="headerlink" title="2.2.1. 十进制与其他进制转换（重点）"></a>2.2.1. 十进制与其他进制转换（重点）</h3><p>十进制整数部分转换为其他进制数采用 “除基取余”法，直到商为0， 小数部分转换采用 “乘基取整”法</p><p>例</p><p>将十进制数58.125转换为二进制数</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045593.jpg" alt=""></p><p><img src="F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5C%E5%8D%81%E8%BD%AC%E4%BA%8C%E5%B0%8F%E6%95%B0.jpg" alt=""></p><h3 id="2-2-2-二进制与其他进制转换（重点）"><a href="#2-2-2-二进制与其他进制转换（重点）" class="headerlink" title="2.2.2. 二进制与其他进制转换（重点）"></a>2.2.2. 二进制与其他进制转换（重点）</h3><p><strong>二进制转十进制</strong></p><p>按权展开法，小数点前一位，权值为0，小数点后一位权值为-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制数101101.18 转换为十进制数</span><br><span class="line">101101.1 B = 1 x 2^5 + 0 x 2^4 + 1 x 2^3 + 1 x 2^2 + 0 x 2^1 + 1 x2^0 + 1 x 1^-1 =45.5 D</span><br></pre></td></tr></table></figure><p><strong>二进制转十六进制</strong></p><p>每四位二进制数转为一位十六进制数。二进制数整数从小数点左边开始每4位一组， 小数则从小数点右边开始每4位一组， 不够位数以0补齐。</p><p>注意：整数位补0，对值没有影响，小数位补0对值有影响</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101101 B = 0010 1101.1000 = 2D.8 H</span><br></pre></td></tr></table></figure><h3 id="2-2-3-十六进制与其他进制转换"><a href="#2-2-3-十六进制与其他进制转换" class="headerlink" title="2.2.3. 十六进制与其他进制转换"></a>2.2.3. 十六进制与其他进制转换</h3><p><strong>十六进制转换为十进制</strong></p><p>按位权展开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十六进制数39C H转换为十进制数</span><br><span class="line">按权展开：</span><br><span class="line">39C H= 3 X 16^2 + 9 X 16^1 + 12 X 16^0 = 924 D</span><br></pre></td></tr></table></figure><p><strong>十六进制转换为二进制</strong></p><p>每一位十六进制数转位四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧</p><h2 id="2-3-进制运算"><a href="#2-3-进制运算" class="headerlink" title="2.3. 进制运算"></a>2.3. 进制运算</h2><h3 id="2-3-1-二进制运算（重点）"><a href="#2-3-1-二进制运算（重点）" class="headerlink" title="2.3.1. 二进制运算（重点）"></a>2.3.1. 二进制运算（重点）</h3><p><strong>加法</strong></p><p>对于多位数二进制相加，考虑进位采用“逢2进1”的方式</p><p>有4种可能 0+0=0、0+1=1、1+0=1、1+1=10</p><p><strong>减法</strong></p><p>有4种可能 0-0=0、1-0=1、1-1=0、0-1=1（同时向高位借1，即看作是10 - 1，因为10 = 1+1，所以 10 -1 = 0-1 = 1）</p><p><strong>乘法</strong></p><p>如果是乘以2，那么只需要左移一位就可以，后面无论是正数还是负数，全部补0</p><p><strong>除法</strong></p><p>除以2时，向右移一位，如果这个数是正数，那么右移的时候左边补0。<br>如果这个数时负数，那么右移的时候左边补1</p><h3 id="2-3-2-十六进制运算"><a href="#2-3-2-十六进制运算" class="headerlink" title="2.3.2. 十六进制运算"></a>2.3.2. 十六进制运算</h3><p><strong>加法</strong></p><p><strong>减法</strong></p><h2 id="2-4-补码（重点）"><a href="#2-4-补码（重点）" class="headerlink" title="2.4. 补码（重点）"></a>2.4. 补码（重点）</h2><ul><li>汇编中数都是以补码的形式表示的</li><li>有关补码的运算，要转为二进制再做计算</li></ul><h3 id="2-4-1-原码"><a href="#2-4-1-原码" class="headerlink" title="2.4.1. 原码"></a>2.4.1. 原码</h3><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line"></span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure><h3 id="2-4-2-反码"><a href="#2-4-2-反码" class="headerlink" title="2.4.2. 反码"></a>2.4.2. 反码</h3><p>正数的反码是其本身</p><p>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line"></span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure><h3 id="2-4-3-补码"><a href="#2-4-3-补码" class="headerlink" title="2.4.3. 补码"></a>2.4.3. 补码</h3><p>正数的补码就是其本身</p><p>负数的补码是在其原码的基础上，符号位不变， 其余各位取反，最后+1（即在反码的基础上+1），或 用<code>2^n - |X|</code>表示负数X的补码，n二进制位数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line"></span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>8位二进制补码的范围</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正数 </span><br><span class="line">00000000 B - 01111111 B</span><br><span class="line">00H - 7FH</span><br><span class="line">0 - 127D</span><br><span class="line"></span><br><span class="line">负数</span><br><span class="line">10000000 B - 11111111 B</span><br><span class="line">80H - FFH</span><br><span class="line">-128D - -1D</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-4-4-求补运算"><a href="#2-4-4-求补运算" class="headerlink" title="2.4.4. 求补运算"></a>2.4.4. 求补运算</h3><p>对补码连同符号位一起求反，在末位加1，得到这个数相反数的补码。</p><p>即正数的补码求补得到其负数的补码，负数的补码求补得到其正数的补码</p><p>求补运算是一种数值运算方法，它与补码表示有所不同。在求补运算中，不考虑数的符号位，对所有位进行按位取反操作，并最后加一。它求得的结果不是求这个数的补码，而是这个数相反数的补码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">机器字长为8位，则－50D 的补码为：</span><br><span class="line">   ＋50的补码为   0011 0010B</span><br><span class="line">   按位求反后为： 1100 1101B</span><br><span class="line">   末位加1 ：     1100 1110B</span><br><span class="line">   则[-50]补＝ 1100 1110 B=0CE H</span><br></pre></td></tr></table></figure><h3 id="2-4-5-从补码求真值"><a href="#2-4-5-从补码求真值" class="headerlink" title="2.4.5. 从补码求真值"></a>2.4.5. 从补码求真值</h3><p>正数直接从补码得到真值。负数补码的数值位求反，符号位变为负号，末位加1，就得到其真值</p><h3 id="2-4-6-补码的运算规则"><a href="#2-4-6-补码的运算规则" class="headerlink" title="2.4.6. 补码的运算规则"></a>2.4.6. 补码的运算规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[A+B]补= [A]补+ [B]补</span><br><span class="line"></span><br><span class="line">[A- B]补= [A]补+ [-B]补</span><br></pre></td></tr></table></figure><h3 id="2-4-7-引入补码的意义（重点）"><a href="#2-4-7-引入补码的意义（重点）" class="headerlink" title="2.4.7. 引入补码的意义（重点）"></a>2.4.7. 引入补码的意义（重点）</h3><p>统一了加法和减法运算：在计算机中，加法是一种基本的运算操作，而减法可以通过加法来实现。使用补码可以使加法和减法运算的处理方式保持一致。在补码表示中，减法运算可以转换为加法运算，简化了运算器的设计和实现。</p><p>消除了正负数的不对称性：在使用原码表示法时，正数和负数的表示形式不对称，这会给运算和比较操作带来复杂性。而使用补码表示法后，正数和负数的表示形式统一了，使得计算机可以使用相同的硬件逻辑来处理正数和负数的运算，简化了计算机的设计。</p><p>增加了数的表示范围：在使用补码表示法中，有限位数的二进制数可以表示更大的数值范围。例如，对于一个8位的二进制数，使用原码表示法可以表示-127到127的范围，而使用补码表示法可以表示-128到127的范围。补码表示法允许使用相同的数值位数表示更广泛的数值范围。</p><p>消除了零的重复表示：在使用原码和反码表示法时，零有两个不同的表示形式，即+0和-0，这会引起计算和比较操作的混乱。而在补码表示法中，零只有一种表示形式，消除了零的重复表示问题。</p><p>下面看计算十进制的表达式 1-1 = 1 + (-1) = 0的例子</p><ul><li>使用原码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</span><br></pre></td></tr></table></figure><ul><li>使用反码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</span><br></pre></td></tr></table></figure><ul><li>补码</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</span><br></pre></td></tr></table></figure><p>这样0用<code>[0000 0000]</code>表示，而以前出现问题的-0则不存在了。而且可以用<code>[1000 0000]</code>表示 -128</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</span><br></pre></td></tr></table></figure><p>注意：-128并没有原码和反码表示。对-128的补码表示<code>[1000 0000]</code>补算出来的原码是<code>[0000 0000]</code>原，这是不正确的</p><h2 id="2-5-数的范围"><a href="#2-5-数的范围" class="headerlink" title="2.5. 数的范围"></a>2.5. 数的范围</h2><h3 id="2-5-1-8位二进制所能表示的有符号数范围"><a href="#2-5-1-8位二进制所能表示的有符号数范围" class="headerlink" title="2.5.1. 8位二进制所能表示的有符号数范围"></a>2.5.1. 8位二进制所能表示的有符号数范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1111 1111 ，0111 1111]</span><br><span class="line">即</span><br><span class="line">[-127 ，127]</span><br></pre></td></tr></table></figure><p>原码或反码表示的范围为[-127，+127]，而使用补码表示的范围为[-128，127]</p><h3 id="2-5-2-8位二进制所能表示的无符号数范围"><a href="#2-5-2-8位二进制所能表示的无符号数范围" class="headerlink" title="2.5.2. 8位二进制所能表示的无符号数范围"></a>2.5.2. 8位二进制所能表示的无符号数范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0000 0000 , 1111 1111]</span><br><span class="line">即</span><br><span class="line">[0 , 255]</span><br></pre></td></tr></table></figure><h2 id="2-6-双精度数"><a href="#2-6-双精度数" class="headerlink" title="2.6. 双精度数"></a>2.6. 双精度数</h2><p>16位计算机表示32位数的时候，用两个字长，则称两个十六位数位双精度数</p><h3 id="2-6-1-字节-byte"><a href="#2-6-1-字节-byte" class="headerlink" title="2.6.1. 字节(byte)"></a>2.6.1. 字节(byte)</h3><p>一个字节占8个二进制位（bit位）</p><h3 id="2-6-2-字"><a href="#2-6-2-字" class="headerlink" title="2.6.2. 字"></a>2.6.2. 字</h3><p>一个字等于两个字节</p><h3 id="2-6-3-字长"><a href="#2-6-3-字长" class="headerlink" title="2.6.3. 字长"></a>2.6.3. 字长</h3><p>计算机一次可处理的二进制位数</p><h2 id="2-7-存储容量"><a href="#2-7-存储容量" class="headerlink" title="2.7. 存储容量"></a>2.7. 存储容量</h2><h3 id="2-7-1-表示"><a href="#2-7-1-表示" class="headerlink" title="2.7.1. 表示"></a>2.7.1. 表示</h3><p>存储容量可用<code>存储字数(存储单元数)x存储字长</code>表示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1MB = 1024KB = 1M x 8bit </span><br></pre></td></tr></table></figure><h3 id="2-7-2-换算"><a href="#2-7-2-换算" class="headerlink" title="2.7.2. 换算"></a>2.7.2. 换算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1k = 2^10 = 1024</span><br><span class="line">1M = 2^20</span><br><span class="line">1byte = 8bit</span><br><span class="line">1kB = 1024byte</span><br></pre></td></tr></table></figure><h2 id="2-8-符号位扩展"><a href="#2-8-符号位扩展" class="headerlink" title="2.8. 符号位扩展"></a>2.8. 符号位扩展</h2><ul><li>首先要明确，是有符号数还是无符号数</li><li>无符号数扩展，前面补充若干个0</li><li>有符号数扩展，最高位是1，前面补充1，最高位是0，前面补充0</li></ul><h2 id="2-9-进位"><a href="#2-9-进位" class="headerlink" title="2.9. 进位"></a>2.9. 进位</h2><p>由于运算结果超出了位数最高有效位向前的进位，这一位自然丢失，但结果是正确的</p><h2 id="2-10-溢出"><a href="#2-10-溢出" class="headerlink" title="2.10. 溢出"></a>2.10. 溢出</h2><p>表示结果超出了字长允许表示的范围，一般会造成结果出错</p><ul><li><p>两个正数相加得到负数</p></li><li><p>两个负数相加得到正数</p></li></ul><h2 id="2-11-编码"><a href="#2-11-编码" class="headerlink" title="2.11. 编码"></a>2.11. 编码</h2><p>所谓编码，就是采用按一定规则组合而成的若干位二进制码来表示数或字符</p><h3 id="2-11-1-BCD码"><a href="#2-11-1-BCD码" class="headerlink" title="2.11.1. BCD码"></a>2.11.1. BCD码</h3><ul><li>对十进制的10个数码用二进制编码表示</li><li>只是看起来是用二进制编码表示0~9，在计算时，仍为二进制的计算，所以计算结果需要修正</li></ul><p><strong>分类</strong></p><ul><li>BCD码可以是8421码、2421码、余3码等</li></ul><p>BCD码采用四位二进制数表示一位十进制数， 如果这四位二进制数的各位之权自左至右分别为8、4、2、I，则称为8421码</p><ul><li>压缩的：4位二进制数表示一位十进制数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">85D = 10000101 = 85H</span><br></pre></td></tr></table></figure><p>用4位二进制数表示一位十进制数，恰好可以用一位16进制数显示一位十进制数</p><ul><li>非压缩的：8位二进制数表示一位十进制数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">85D = 000010000 00000101 = 0805H</span><br></pre></td></tr></table></figure><p>非压缩的BCD码加上30H, 就转换成了该数字的ASCII码</p><h2 id="2-12-ASCII码"><a href="#2-12-ASCII码" class="headerlink" title="2.12. ASCII码"></a>2.12. ASCII码</h2><ul><li>标准ASCII码采用7位编码，即一个字节的最高位0，共128种代码</li><li>位数从0开始算起</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">大写字母A-Z: 41H-5AH </span><br><span class="line">小写字母a-z: 61H-7AH </span><br><span class="line">数字0-9: 30H -39H</span><br><span class="line"></span><br><span class="line">空格： 20H </span><br><span class="line">回车： ODH </span><br><span class="line">换行： OAH </span><br><span class="line">响铃： 07H</span><br></pre></td></tr></table></figure><h1 id="3-第二章"><a href="#3-第二章" class="headerlink" title="3. 第二章"></a>3. 第二章</h1><h2 id="3-1-计算机基本结构"><a href="#3-1-计算机基本结构" class="headerlink" title="3.1. 计算机基本结构"></a>3.1. 计算机基本结构</h2><h3 id="3-1-1-组成（五大件）"><a href="#3-1-1-组成（五大件）" class="headerlink" title="3.1.1. 组成（五大件）"></a>3.1.1. 组成（五大件）</h3><p>运算器、控制器、存储器、输入设备、输出设备</p><h3 id="3-1-2-总线"><a href="#3-1-2-总线" class="headerlink" title="3.1.2. 总线"></a>3.1.2. 总线</h3><p><strong>内部总线</strong></p><p>CPU内部各个部件间的连线</p><p><strong>外部总线（系统总线）</strong></p><p>连接主板上各个部件的总线</p><p>总线的位数由CPU决定，如8086的地址总线为20位，数据总线为16位</p><ul><li>地址总线</li></ul><p>它的宽度（也称为位数）决定了CPU的寻址能力，即CPU可以直接访问的内存或设备的地址范围。例如，如果计算机的地址总线宽度为32位，那么CPU可以寻址的内存或设备地址范围可以达到2^32个（约为4GB）</p><ul><li>数据总线</li></ul><p>它的宽度决定了CPU一次可以传输的数据量。例如，如果计算机的数据总线宽度为16位，那么每次数据传输的量为16位（2个字节）。数据总线的宽度直接影响数据传输的速度和效率。</p><ul><li>控制总线</li></ul><p>它的宽度决定了CPU对系统中其他设备的控制能力。控制总线传输的信号包括读写控制、中断请求、时钟同步、设备选择等。控制总线的宽度决定了CPU与其他设备之间的控制通路数量和功能。</p><h3 id="3-1-3-接口"><a href="#3-1-3-接口" class="headerlink" title="3.1.3. 接口"></a>3.1.3. 接口</h3><p>外部设备和计算机主机间的中间缓存介质</p><p><strong>并行接口</strong></p><p>多个数据位同时通过多根数据线进行传输。每个数据位占用一根数据线，数据在并行接口中同时进行传输，从而实现高速数据传输。</p><p>如 8位数据用8根数据线传输</p><p><strong>串行接口</strong></p><p>串行接口使用较少的信号线来传输数据，通常只有一根数据线。每个数据位按照顺序依次传输，其中每个数据位之间可能会包含起始位、停止位和校验位等控制信号</p><h2 id="3-2-8086CPU"><a href="#3-2-8086CPU" class="headerlink" title="3.2. 8086CPU"></a>3.2. 8086CPU</h2><h3 id="3-2-1-组成"><a href="#3-2-1-组成" class="headerlink" title="3.2.1. 组成"></a>3.2.1. 组成</h3><p><strong>执行单元（EU）</strong></p><p>算术逻辑运算单元（ALU）</p><p>标志寄存器</p><p>暂存器</p><p>寄存器组</p><p>控制单元</p><p><strong>总线接口单元（BIU）</strong></p><p>段寄存器组</p><p>指令指针寄存器IP</p><p>地址加法器</p><p>指令队列单元</p><p>总线控制系统</p><h3 id="3-2-2-内部"><a href="#3-2-2-内部" class="headerlink" title="3.2.2. 内部"></a>3.2.2. 内部</h3><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045988.jpg" alt=""></p><h2 id="3-3-8086寄存器"><a href="#3-3-8086寄存器" class="headerlink" title="3.3. 8086寄存器"></a>3.3. 8086寄存器</h2><ul><li><p>计算机的字长和处理器的寄存器位数有关</p></li><li><p>8086寄存器都是16位的</p></li></ul><h3 id="3-3-1-数据寄存器"><a href="#3-3-1-数据寄存器" class="headerlink" title="3.3.1. 数据寄存器"></a>3.3.1. 数据寄存器</h3><p>用来保存操作数或运算结果等信息</p><ul><li>AX</li><li>BX</li><li>CX</li><li><p>DX</p><h3 id="3-3-2-指针寄存器"><a href="#3-3-2-指针寄存器" class="headerlink" title="3.3.2. 指针寄存器"></a>3.3.2. 指针寄存器</h3></li><li><p>SP 堆栈指针</p></li></ul><p>指示栈顶的偏移地址，不能再用于其他目的</p><ul><li>BP 基址指针</li></ul><p>表示数据在堆栈段中某个单元的偏移地址</p><h3 id="3-3-3-变址寄存器"><a href="#3-3-3-变址寄存器" class="headerlink" title="3.3.3. 变址寄存器"></a>3.3.3. 变址寄存器</h3><p>常用于存储器寻址时提供地址</p><ul><li>SI 源地址</li><li>DI 目的地址</li></ul><p>串操作类指令中，SI 和 DI具有特别的功能</p><h3 id="3-3-4-段寄存器"><a href="#3-3-4-段寄存器" class="headerlink" title="3.3.4. 段寄存器"></a>3.3.4. 段寄存器</h3><p>每个段寄存器用来确定一个逻辑段的起始地址，CPU访问内存时由段寄存器提供内存单元的段地址</p><ul><li>CS 代码段</li></ul><p>CS寄存器不允许用MOV指令赋值</p><p>任意时刻CPU将CS:IP指向的内容作为指令执行，CPU复位后执行的第一条指令位于CS=FFFFH，IP=0000H</p><p>从CS:IP指向的内存单元读取指令，存入指令缓冲器</p><p>IP = IP + 所读取指令的长度，从而指向下条指令</p><p>CPU执行指令缓冲器中的指令</p><ul><li>DS 数据段</li></ul><p>通常存放要访问的数据的段地址</p><ul><li>SS 堆栈段</li></ul><p>任意时刻SS:SP指向栈顶元素，SS存放栈顶的段地址，SP存放栈顶的偏移地址</p><p>栈为空时，SS:SP指向栈最底部单元下面的字单元</p><p>SP是16位寄存器，栈的深度是64KB，最多可放32K个字的数据</p><ul><li>ES 附加段</li></ul><p>处理器利用ES:EA(有效地址)存取附加段中的数据 v串操作指令将附加段作为其目的操作数的存放区域</p><h3 id="3-3-5-控制寄存器"><a href="#3-3-5-控制寄存器" class="headerlink" title="3.3.5. 控制寄存器"></a>3.3.5. 控制寄存器</h3><ul><li>IP 指令指针</li></ul><p>指示代码段中下一条指令的偏移地址</p><p>与代码段寄存器 CS 联用（CS:IP），确定下一条指令的物理地址</p><ul><li>FLAGS 标志寄存器</li></ul><p>用于反映指令执行结果或控制指令执行形式</p><p>共9 个标志，分为6个条件标志码标志和3个控制标志</p><ul><li>条件码标志</li></ul><p>CF 进位标志，结果最高位向前进位时(无符号数才考虑进位)</p><p>SF 符号标志，结果最高位(符号位)为负时</p><p>ZF 零标志，结果为0</p><p>OF 溢出标志</p><p>AF 辅助进位标志，结果中第3位(半字节)向前进位时</p><p>PF 奇偶标志，结果中1的个数为偶数个时</p><ul><li>控制标志</li></ul><p>DF 方向标志</p><p>IF 中断标志</p><p>TF 陷阱标志</p><p>  <img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045109.jpg" alt=""></p><h3 id="3-3-6-注意"><a href="#3-3-6-注意" class="headerlink" title="3.3.6. 注意"></a>3.3.6. 注意</h3><ul><li>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确</li><li>溢出标志表示有符号数运算结果是否超出范围，运算结果不正确</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1：3AH + 7CH＝B6H  </span><br><span class="line">即00111010 + 01111100 = 10110110</span><br><span class="line">无符号数运算：58＋124＝182</span><br><span class="line">范围内，无进位</span><br><span class="line">有符号数运算： 58＋124＝182</span><br><span class="line">范围外，有溢出</span><br></pre></td></tr></table></figure><h2 id="3-4-内存储器"><a href="#3-4-内存储器" class="headerlink" title="3.4. 内存储器"></a>3.4. 内存储器</h2><h3 id="3-4-1-内存地址"><a href="#3-4-1-内存地址" class="headerlink" title="3.4.1. 内存地址"></a>3.4.1. 内存地址</h3><p>cpu对内存的访问，通过地址总线，地址总线的每一组二进制数对应一个存储单元。</p><p>当地址总线只有1根时，只有0、1两个状态，所以对应2个存储单元。当地址总线有2根时，只有00、01、10、11四个状态，所以对应4个存储单元。</p><p><strong>地址位数与存储空间关系</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若地址位数为 n，则CPU可以直接寻址 2^n个存储单元</span><br></pre></td></tr></table></figure><h3 id="3-4-2-存储单元"><a href="#3-4-2-存储单元" class="headerlink" title="3.4.2. 存储单元"></a>3.4.2. 存储单元</h3><p>在8086中一个实际的存储单元只存放8位二进制数，称为字节单元，存储单元从0开始顺序编号</p><p>注意：为方便人阅读，内存和寄存器中数据用十六进制表示</p><h3 id="3-4-3-物理地址"><a href="#3-4-3-物理地址" class="headerlink" title="3.4.3. 物理地址"></a>3.4.3. 物理地址</h3><ul><li>内存单元的真实地址</li><li>存储单元的物理地址是唯一的</li><li>CPU直接读取的地址</li><li>8086CPU有20根地址线，cpu可直接寻址的存储单元可达 2^20 个，每个存储单元的地址应该用20位二进制数表示，用十六进制表示的范围是 <code>[00000H,FFFFFH]</code></li></ul><h3 id="3-4-4-逻辑地址"><a href="#3-4-4-逻辑地址" class="headerlink" title="3.4.4. 逻辑地址"></a>3.4.4. 逻辑地址</h3><ul><li>不唯一</li><li>形式：<code>段地址 : 偏移地址</code></li></ul><p><strong>段地址（SA）</strong></p><p>段地址指逻辑段在主存中的起始位置，必须是分段后的小段的首地址</p><p><strong>偏移地址（EA、有效地址）</strong></p><p>偏移地址用来定位段中的内存单元</p><h3 id="3-4-5-逻辑地址和物理地址的转换"><a href="#3-4-5-逻辑地址和物理地址的转换" class="headerlink" title="3.4.5. 逻辑地址和物理地址的转换"></a>3.4.5. 逻辑地址和物理地址的转换</h3><ul><li>由CPU的地址加法器实现</li><li><code>段地址 x 16</code> 定位段的起始地址（基础地址）</li></ul><p>所以段的起始地址一定是16的倍数</p><ul><li><code>物理地址 = 基础地址 + 偏移地址</code></li></ul><p>也就是将十六进制的段地址左移1位，再加十六进制的偏移地址</p><h3 id="3-4-6-字的传送"><a href="#3-4-6-字的传送" class="headerlink" title="3.4.6. 字的传送"></a>3.4.6. 字的传送</h3><p>因为一个存储单元只存放8位二进制数，即一个字节。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,1000H</span><br><span class="line">MOV DS,BX</span><br><span class="line"></span><br><span class="line">MOV AX,[0]  表示将起始内存为1000:0000的字数据存放到AX中</span><br><span class="line">MOV AL,[0]  表示将起始内存为1000:0000的字节数据存放到AL中</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当要存放较大的数据时，使用<code>高高低低</code>的方式存放。即低字节存入低地址，高字节存入高地址。表达时，用它的低地址表示多字节数据占据的地址空间。</p><p>如</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045365.jpg" alt=""></p><p>图中</p><p><code>字单元</code>的内容为</p><p><code>[00002H]</code> = 1256H</p><p><code>双字单元</code>的内容为</p><p><code>[00002H]</code> = 67341256H</p><h3 id="3-4-7-数据的地址对齐"><a href="#3-4-7-数据的地址对齐" class="headerlink" title="3.4.7. 数据的地址对齐"></a>3.4.7. 数据的地址对齐</h3><ul><li>同一个存储器地址可以是字节单元地址、字单元地址、双字单元地址等等。</li><li>字单元安排在偶地址（xxx0B）、双字单元安排在模4地址（xx00B）等，被称为”地址对齐“<h3 id="3-4-8-计算某数据区最末单元的物理地址"><a href="#3-4-8-计算某数据区最末单元的物理地址" class="headerlink" title="3.4.8. 计算某数据区最末单元的物理地址"></a>3.4.8. 计算某数据区最末单元的物理地址</h3></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">末单元物理地址=首地址+(N-1)*TYPE</span><br><span class="line"></span><br><span class="line">N为存储区空间大小，单位是字节，因为地址是从0开始，所以要减一</span><br><span class="line"></span><br><span class="line">TYPE 是存储区的数据类型所占存储单元个数，如字节型，值为1，字型为2</span><br></pre></td></tr></table></figure><h3 id="3-4-9-存储单元中地址与内容"><a href="#3-4-9-存储单元中地址与内容" class="headerlink" title="3.4.9. 存储单元中地址与内容"></a>3.4.9. 存储单元中地址与内容</h3><p>地址与内容的区分方法是：用括号将地址括起来以代表单元的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(3075A H) = 12 H 代表3075A H单元中的内容是 12H</span><br><span class="line"></span><br><span class="line">(37692 H) = 5678 H 代表37692 H单元和 37693 H单元一起存放 5678H，该单元是字单元</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-10-存储器分段"><a href="#3-4-10-存储器分段" class="headerlink" title="3.4.10. 存储器分段"></a>3.4.10. 存储器分段</h3><p>解决16位字长的机器提供20位地址的问题，段的划分来源于CPU，内存并没有分段</p><p><strong>概念</strong></p><p>8086CPU将1MB空间分成许多逻辑段</p><p>大段：每个段最大限制为64KB（偏移地址是16位的2进制数，所以2^16=64KB），最大可有16个段</p><p>小段：每16个字节为一小段，共有64K个（65536）小段</p><p>段内单元的地址用16位二进制数表示，称为偏移地址</p><p>每小段第一个单元的物理地址称小段首地址</p><p>小段首地址的特点是低位为 0H</p><p>省略最低位 0H，就可用16位段寄存器保存小段首地址</p><p>各个段之间可以重叠</p><p><strong>类型</strong></p><ul><li>代码段</li><li>数据段</li><li>附加段</li><li>堆栈段</li></ul><p>注意：在汇编程序中，必须有代码段</p><h1 id="4-第三章"><a href="#4-第三章" class="headerlink" title="4. 第三章"></a>4. 第三章</h1><p>汇编语言有3种指令</p><ul><li>汇编指令</li></ul><p>机器码的助记符，有对应的机器码</p><ul><li>伪指令</li></ul><p>没有对应的机器码，由编译器执行，计算机不执行</p><ul><li>宏指令</li></ul><p>不同机器对应不同的指令系统</p><h2 id="4-1-汇编指令"><a href="#4-1-汇编指令" class="headerlink" title="4.1. 汇编指令"></a>4.1. 汇编指令</h2><h3 id="4-1-1-格式"><a href="#4-1-1-格式" class="headerlink" title="4.1.1. 格式"></a>4.1.1. 格式</h3><p><code>操作码字段 操作数字段</code></p><p>操作数用来指明被操作的数的值或数据的存放位置</p><p>只有操作码，没有操作数，称为零地址指令</p><h3 id="4-1-2-属性"><a href="#4-1-2-属性" class="headerlink" title="4.1.2. 属性"></a>4.1.2. 属性</h3><p><strong>指令长度</strong></p><p>以字节为单位</p><p><strong>执行时间</strong></p><p>以CPU时钟周期为单位</p><h3 id="4-1-3-注意"><a href="#4-1-3-注意" class="headerlink" title="4.1.3. 注意"></a>4.1.3. 注意</h3><ul><li>符号地址代表位移量</li><li><code>[...]</code>代表一个内存单元，<code>[32H]</code>表示偏移地址是32H，<code>[]</code>表示的单元长度可由具体指令中的其他操作对象指出</li></ul><h2 id="4-2-内存单元的描述"><a href="#4-2-内存单元的描述" class="headerlink" title="4.2. 内存单元的描述"></a>4.2. 内存单元的描述</h2><ul><li>内存单元的地址</li></ul><p><code>[0]</code>表示单元的偏移地址为0</p><ul><li>内存单元的长度(类型)</li></ul><p><code>MOV AX,0002H</code></p><p><code>MOV AL,02H</code></p><h2 id="4-3-指令的寻址"><a href="#4-3-指令的寻址" class="headerlink" title="4.3. 指令的寻址"></a>4.3. 指令的寻址</h2><p>指令的寻址方式有两大类：与数据有关的寻址和与转移地址有关的寻址</p><p>寻址方式：指的是指令按什么方式给出操作数或与其有关的地址信息</p><h3 id="4-3-1-段前缀（段超越）"><a href="#4-3-1-段前缀（段超越）" class="headerlink" title="4.3.1. 段前缀（段超越）"></a>4.3.1. 段前缀（段超越）</h3><p>与内存有关的寻址中，操作数的段地址默认为数据段，段地址除了在数据段中，还可以在其他三种段中，若放在其他三段中，则称为段超越。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,DS:[2000H]</span><br></pre></td></tr></table></figure><h2 id="4-4-数据相关寻址"><a href="#4-4-数据相关寻址" class="headerlink" title="4.4. 数据相关寻址"></a>4.4. 数据相关寻址</h2><p>对数据操作数而言，数据可能在内存中、CPU的寄存器中、或直接写在指令中。若数据不在内存中存放，操作数就没有逻辑地址的概念</p><h3 id="4-4-1-立即寻址"><a href="#4-4-1-立即寻址" class="headerlink" title="4.4.1. 立即寻址"></a>4.4.1. 立即寻址</h3><p>操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式，把该操作数称为立即数</p><p>注意：立即寻址方式只能出现在源操作数的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,[32H]</span><br><span class="line">MOV AX,1234H</span><br><span class="line">MOV BX,16</span><br><span class="line">MOV EAX,56H</span><br></pre></td></tr></table></figure><h3 id="4-4-2-寄存器寻址"><a href="#4-4-2-寄存器寻址" class="headerlink" title="4.4.2. 寄存器寻址"></a>4.4.2. 寄存器寻址</h3><p>操作数直接包含在寄存器中，由指令指定寄存器</p><p>注意：寄存器可以是8位、16位、32位通用寄存器或16位段寄存器，但CS不能用于目标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure><h3 id="4-4-3-存储器寻址"><a href="#4-4-3-存储器寻址" class="headerlink" title="4.4.3. 存储器寻址"></a>4.4.3. 存储器寻址</h3><p><strong>直接寻址</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,DS:[2000H]</span><br><span class="line">操作数的有效地址EA直接写在指令中，用括号里的数值作为操作数的偏移地址(有效地址)，操作数的段地址为数据段，由DS指出</span><br><span class="line">注意：不加DS:前缀，汇编时会认为，[2000H]是立即数而不是偏移地址</span><br></pre></td></tr></table></figure><p>直接寻址还可以有符号地址(代表位移量)，即为存储单元定义一个变量名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x dw 5678H</span><br><span class="line">MOV AX,X</span><br><span class="line">或</span><br><span class="line">MOV AX,[X]</span><br></pre></td></tr></table></figure><p><strong>寄存器间接寻址</strong></p><p>有效地址存放在BX，BP或SI、DI中</p><p>默认段地址在DS，可使用段超越前缀改变</p><p>若使用的是BP，则段地址是SS</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX]</span><br><span class="line">MOV AX,SS:[BP]  这里使用了段超越前缀</span><br></pre></td></tr></table></figure><p><strong>寄存器相对寻址</strong></p><p>操作数的有效地址是一个基址或变址寄存器的内容再加上8位或16位位移量之和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX+1234H]</span><br><span class="line">MOV AX,VALUE[BX] #符号地址</span><br></pre></td></tr></table></figure><p><strong>基址变址寻址</strong></p><p>操作数的有效地址是一个基存储器和一个变址寄存器的内容之和。该方法可用于二维表的处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX+DI]</span><br><span class="line">MOV AX,[BX][DI]</span><br></pre></td></tr></table></figure><p><strong>相对基址变址寻址</strong></p><p>操作数的有效地址是一个基存储器加一个变址寄存器再加一个位移量。该方法可用于二维查表和栈处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[MASK+BX+SI]</span><br></pre></td></tr></table></figure><p>注意：以上寻址方式得到的地址只是有效地址（偏移地址）简写为EA，段基址与段寄存器有关</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045451.jpg" alt=""></p><ul><li>对双操作数指令而言，两个操作数不允许同时用存储器寻址方式</li></ul><h2 id="4-5-栈"><a href="#4-5-栈" class="headerlink" title="4.5. 栈"></a>4.5. 栈</h2><h3 id="4-5-1-指令"><a href="#4-5-1-指令" class="headerlink" title="4.5.1. 指令"></a>4.5.1. 指令</h3><p>入栈和出栈操作以字单位进行操作</p><ul><li>pop(出栈)</li></ul><p>先读取SS:SP处的数据，再改变SP</p><p>SP = SP + 2</p><ul><li>push(入栈)</li></ul><p>先改变SP，再向SS:SP传送地址</p><p>SP = SP + 2</p><h3 id="4-5-2-操作"><a href="#4-5-2-操作" class="headerlink" title="4.5.2. 操作"></a>4.5.2. 操作</h3><ul><li>任意时刻SS:SP指向栈顶元素，SS存放栈顶的段地址，SP存放栈顶的偏移地址</li><li>栈为空时，SS:SP指向栈最底部单元下面的字单元（字单元的低字节的地址）</li><li>SP是16位寄存器，栈的深度是64KB，最多可放32K个字的数据</li></ul><h3 id="4-5-3-计算sp"><a href="#4-5-3-计算sp" class="headerlink" title="4.5.3. 计算sp"></a>4.5.3. 计算sp</h3><p>因为栈的操作单位是字，若定义一个段的范围是<code>10000H~1000FH</code></p><ul><li>栈中只有一个元素时，SP应该指向<code>1000EH</code>，即为栈的最后一个字单元的低地址</li><li>栈空时，SP应该指向100010H，即为栈的最后一个字单元后面的一个字单元的低地址</li></ul><h3 id="4-5-4-用途"><a href="#4-5-4-用途" class="headerlink" title="4.5.4. 用途"></a>4.5.4. 用途</h3><p>源程序需要暂存数据的时候，一般存在栈中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;以1000CH-1000FH段内存为栈</span><br><span class="line">MOV AX,1000H</span><br><span class="line">MOV SS,AX</span><br><span class="line">MOV SP,0010H</span><br><span class="line"></span><br><span class="line">MOV AX,001AH;以字为单位进行操作</span><br><span class="line">MVO BX,001BH</span><br><span class="line"></span><br><span class="line">PUSH AX</span><br><span class="line">PUSH BX</span><br></pre></td></tr></table></figure><h1 id="5-Debug使用"><a href="#5-Debug使用" class="headerlink" title="5. Debug使用"></a>5. Debug使用</h1><h2 id="5-1-debug特性"><a href="#5-1-debug特性" class="headerlink" title="5.1. debug特性"></a>5.1. debug特性</h2><ul><li>debug 默认是十六进制</li><li>不区分大小写</li></ul><h2 id="5-2-常用指令"><a href="#5-2-常用指令" class="headerlink" title="5.2. 常用指令"></a>5.2. 常用指令</h2><h3 id="5-2-1-R-查改寄存器内容"><a href="#5-2-1-R-查改寄存器内容" class="headerlink" title="5.2.1. R - 查改寄存器内容"></a>5.2.1. R - 查改寄存器内容</h3><p>查看、改变CPU寄存器的内容</p><ul><li><code>R 寄存器名</code></li></ul><p>修改寄存器的内容</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046471.jpg" alt=""></p><h3 id="5-2-2-D-显示内存单元"><a href="#5-2-2-D-显示内存单元" class="headerlink" title="5.2.2. D - 显示内存单元"></a>5.2.2. D - 显示内存单元</h3><p>查看内存中的内容</p><ul><li><code>D 段地址:偏移地址</code></li></ul><p>查看指定内存处的内容</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046468.jpg" alt=""></p><p>左边是每行的起始地址</p><p>中间是从指定地址开始的128个内存单元的内容，以16进制的形式显示，每行的起始地址都是16的整数倍，每行最多输出16个单元的内容</p><p>右边是每个内存单元中的数据对应的可显示的ASCII码</p><ul><li><code>D 段地址:起始偏移地址 结尾偏移地址</code></li></ul><p>查看一段内存中的内容</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046462.jpg" alt=""></p><h3 id="5-2-3-E-修改内存单元"><a href="#5-2-3-E-修改内存单元" class="headerlink" title="5.2.3. E - 修改内存单元"></a>5.2.3. E - 修改内存单元</h3><p>改写内存中的内容</p><ul><li><code>E 段地址:起始偏移地址 数据 数据 数据 数据...</code></li></ul><p>一起修改内存单元的数据</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046770.jpg" alt=""></p><ul><li><code>E 段地址:起始偏移地址</code></li></ul><p>一个一个的修改内存单元的数据</p><p>输入<code>E 段地址:起始偏移地址</code>后，按Enter键，显示起始地址和第一单元的原始内容，光标停在<code>.</code>后，在<code>.</code>后输入要修改的数据，然后按空格键</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046969.jpg" alt=""></p><ul><li>内存中写入字符</li></ul><p>写入字符时，要加单引号</p><h3 id="5-2-4-U-反汇编"><a href="#5-2-4-U-反汇编" class="headerlink" title="5.2.4. U - 反汇编"></a>5.2.4. U - 反汇编</h3><p>将内存中的机器指令翻译为汇编指令</p><ul><li><code>U 段地址:偏移地址</code></li><li><code>U 段地址:起始偏移地址 结尾偏移地址</code></li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046511.jpg" alt=""></p><p>如</p><p>从内存<code>1000：0000</code>处开始写入一段机器码</p><p>B80100 对应 MOV AX,0001</p><p>B90200 对应 MOV CX,0002</p><p>01C8 对应 ADD AX,CX</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046271.jpg" alt=""></p><h3 id="5-2-5-T-跟踪"><a href="#5-2-5-T-跟踪" class="headerlink" title="5.2.5. T - 跟踪"></a>5.2.5. T - 跟踪</h3><p>执行一条或多条机器指令，默认执行<code>CS:IP</code>指向的命令</p><ul><li><code>T =段地址:偏移地址</code></li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046171.jpg" alt=""></p><ul><li><code>T =段地址:偏移地址 指令条数</code></li></ul><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046787.jpg" alt=""></p><h3 id="5-2-6-A-汇编"><a href="#5-2-6-A-汇编" class="headerlink" title="5.2.6. A - 汇编"></a>5.2.6. A - 汇编</h3><p>以汇编指令的格式在内存中写入一条机器指令</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046784.jpg" alt=""></p><h3 id="5-2-7-P-执行过程"><a href="#5-2-7-P-执行过程" class="headerlink" title="5.2.7. P - 执行过程"></a>5.2.7. P - 执行过程</h3><p>执行一条指令或一个完整的子程序</p><p>与T指令类似，当遇到下一条指令是INT 21的时候，要使用P指令来执行命令</p><h3 id="5-2-8-Q-退出"><a href="#5-2-8-Q-退出" class="headerlink" title="5.2.8. Q - 退出"></a>5.2.8. Q - 退出</h3><h2 id="5-3-熟悉界面"><a href="#5-3-熟悉界面" class="headerlink" title="5.3. 熟悉界面"></a>5.3. 熟悉界面</h2><ul><li>右边显示数据的ASCII码对应的字符</li><li>中间显示存储的数据</li><li>左边显示</li></ul><h1 id="6-第四章"><a href="#6-第四章" class="headerlink" title="6. 第四章"></a>6. 第四章</h1><h2 id="6-1-汇编程序"><a href="#6-1-汇编程序" class="headerlink" title="6.1. 汇编程序"></a>6.1. 汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">    MOV AX,3</span><br><span class="line">    MOV BX,5</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h3 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1. 概念"></a>6.1.1. 概念</h3><ul><li>源程序</li></ul><p>汇编文件中的所有内容</p><ul><li>程序</li></ul><p>最终由计算机执行的程序</p><h3 id="6-1-2-形成"><a href="#6-1-2-形成" class="headerlink" title="6.1.2. 形成"></a>6.1.2. 形成</h3><p>编辑<code>.asm</code>文件    编译生成<code>.obj</code>    连接生成<code>.exe</code>文件</p><h3 id="6-1-3-伪指令"><a href="#6-1-3-伪指令" class="headerlink" title="6.1.3. 伪指令"></a>6.1.3. 伪指令</h3><ul><li><code>segment</code>和<code>ends</code></li></ul><p>定义一个段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><ul><li><code>end</code></li></ul><p>一个汇编程序的结束标记</p><p><code>end 标号</code>通知编译器程序的入口，<code>end 标号</code>会被转化为一个入口地址</p><p>如</p><p>下面源程序中end指明了程序的入口在标号start处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">    MOV AX,3</span><br><span class="line">    MOV BX,5</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><ul><li><code>assume</code></li></ul><p>将有特定用途的段和相关的段寄存器关联起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将用作代码段的段codesg和寄存器cs关联起来</span><br><span class="line">assume  cs:codesg</span><br></pre></td></tr></table></figure><h3 id="6-1-4-标号"><a href="#6-1-4-标号" class="headerlink" title="6.1.4. 标号"></a>6.1.4. 标号</h3><p>一个标号代表一个地址</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">codesg最终将被处理为一个段的段地址</span><br></pre></td></tr></table></figure><h3 id="6-1-5-程序返回"><a href="#6-1-5-程序返回" class="headerlink" title="6.1.5. 程序返回"></a>6.1.5. 程序返回</h3><p>程序P2若要运行，则需要有一个正在运行的P1程序将P2程序加载，然后将CPU的控制权交给P2，P2执行结束后将权限再交给P1，这个过程叫程序返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,4c00H</span><br><span class="line">int 21H</span><br><span class="line">这两段代码的功能就是程序返回</span><br></pre></td></tr></table></figure><h3 id="6-1-6-EXE的加载"><a href="#6-1-6-EXE的加载" class="headerlink" title="6.1.6. EXE的加载"></a>6.1.6. EXE的加载</h3><ul><li>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0</li><li>这个内存区的前256个字节(100H)中存放的是PSP，DOS用来和程序进行通信，256个字节后的空间是存放程序的</li><li>PSP的段地址SA</li><li>程序存放的物理地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SA x 16 + 0 + 256 = SA x 16 + 16 x 16 </span><br><span class="line">或</span><br><span class="line">SA + 10H : 0</span><br></pre></td></tr></table></figure><h2 id="6-2-注意"><a href="#6-2-注意" class="headerlink" title="6.2. 注意"></a>6.2. 注意</h2><p>汇编源程序中，数据不能以字母开头</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffff H 需要写为 0ffff H</span><br></pre></td></tr></table></figure><h1 id="7-第五章"><a href="#7-第五章" class="headerlink" title="7. 第五章"></a>7. 第五章</h1><h2 id="7-1-LOOP"><a href="#7-1-LOOP" class="headerlink" title="7.1. LOOP"></a>7.1. LOOP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">MOV AX,2</span><br><span class="line">MOV CX,3</span><br><span class="line">S:ADD AX,AX;标号S标记了一个地址，这个地址有一条指令ADD AX,AX</span><br><span class="line">LOOP S</span><br><span class="line"></span><br><span class="line">MOV AX,4c00H</span><br><span class="line">INT 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="7-1-1-格式"><a href="#7-1-1-格式" class="headerlink" title="7.1.1. 格式"></a>7.1.1. 格式</h3><p><code>loop 标号</code></p><h3 id="7-1-2-操作"><a href="#7-1-2-操作" class="headerlink" title="7.1.2. 操作"></a>7.1.2. 操作</h3><ul><li>CX中的内容减1</li><li>判断CX中的值，不为0则转至标号处继续执行，若为0则向下执行</li></ul><h3 id="7-1-3-使用"><a href="#7-1-3-使用" class="headerlink" title="7.1.3. 使用"></a>7.1.3. 使用</h3><ul><li>通常用CX存放循环次数</li><li>要使用一个标号，指示循环体的起始地址</li><li>循环体应位于标号和loop指令间</li><li>当遇到loop时，可使用P指令执行，会自动执行完循环</li></ul><h3 id="7-1-4-寻址范围"><a href="#7-1-4-寻址范围" class="headerlink" title="7.1.4. 寻址范围"></a>7.1.4. 寻址范围</h3><p>通常段内寻址的范围是<code>[-128,127]</code></p><p>loop指令是不允许往后面跳的，所以后127的范围是不生效的，它构成的循环范围是在-128字节之内</p><h2 id="7-2-安全空间"><a href="#7-2-安全空间" class="headerlink" title="7.2. 安全空间"></a>7.2. 安全空间</h2><ul><li>DOS下，<code>0:200~0:2ff</code>空间是安全空间</li><li><p>向内存中写内容时，可以写在安全空间中</p><h2 id="7-3-其他"><a href="#7-3-其他" class="headerlink" title="7.3. 其他"></a>7.3. 其他</h2></li><li><p>idata</p></li></ul><p>约定符号idata表示常量</p><ul><li>inc bx</li></ul><p>将BX中的内容加1</p><ul><li>dec bx</li></ul><p>将BX中的内容减1</p><h1 id="8-第六章"><a href="#8-第六章" class="headerlink" title="8. 第六章"></a>8. 第六章</h1><p>程序取得所需空间的方法</p><ul><li>在加载程序的过程中为程序分配</li><li>程序在执行的过程中向系统申请</li></ul><h2 id="8-1-代码段中使用数据"><a href="#8-1-代码段中使用数据" class="headerlink" title="8.1. 代码段中使用数据"></a>8.1. 代码段中使用数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">CODE SEGMENT</span><br><span class="line">DW 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</span><br><span class="line"></span><br><span class="line">MOV AX,0</span><br><span class="line">MOV BX,0</span><br><span class="line"></span><br><span class="line">MOV CX,8</span><br><span class="line"></span><br><span class="line">S:ADD AX,CS:[BX]</span><br><span class="line">ADD BX,2</span><br><span class="line">LOOP S</span><br><span class="line"></span><br><span class="line">MOV AX,4C00H</span><br><span class="line">INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="8-1-1-db"><a href="#8-1-1-db" class="headerlink" title="8.1.1. db"></a>8.1.1. db</h3><ul><li><p>define byte，定义字节型数据</p><h3 id="8-1-2-dw"><a href="#8-1-2-dw" class="headerlink" title="8.1.2. dw"></a>8.1.2. dw</h3></li><li><p>define word，定义字型数据</p></li><li><p>可以通过定义一些值为0的字数据来开辟一段内存空间</p></li><li><p>在代码段中的最开始部分定义数据，所以第一个数据的偏移地址是0，而段地址就是存放在寄存器CS中的代码段的地址</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT </span><br><span class="line">;定义数据</span><br><span class="line">START:</span><br><span class="line">;代码</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h2 id="8-2-多个段的程序"><a href="#8-2-多个段的程序" class="headerlink" title="8.2. 多个段的程序"></a>8.2. 多个段的程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATA,SS:STACK</span><br><span class="line">DATA SEGMENT</span><br><span class="line">DW 0123H</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">DW 0,0,0,0,0</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">MOV AX,STACK</span><br><span class="line">MOV SS,AX</span><br><span class="line"></span><br><span class="line">MOV AX,DATA</span><br><span class="line">MOV DS,AX</span><br><span class="line"></span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h3 id="8-2-1-对段地址的引用"><a href="#8-2-1-对段地址的引用" class="headerlink" title="8.2.1. 对段地址的引用"></a>8.2.1. 对段地址的引用</h3><p>段名就相当于一个标号，它代表了段地址，如<code>MOV AX,STACK</code>表示将名称为<code>STACK</code>的段的段地址送入<code>AX</code>中</p><h3 id="8-2-2-多个段的关系"><a href="#8-2-2-多个段的关系" class="headerlink" title="8.2.2. 多个段的关系"></a>8.2.2. 多个段的关系</h3><p>在源程序中定义的多个段，在内存中是连续的，按源程序中的顺序在内存中排列，知道其中一个段的段地址就可以知道其他段的段地址</p><h1 id="9-第七章"><a href="#9-第七章" class="headerlink" title="9. 第七章"></a>9. 第七章</h1><h2 id="9-1-and"><a href="#9-1-and" class="headerlink" title="9.1. and"></a>9.1. and</h2><p>将操作对象的指定位设置为0，其他位不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR AL,00100000B</span><br></pre></td></tr></table></figure><h2 id="9-2-or"><a href="#9-2-or" class="headerlink" title="9.2. or"></a>9.2. or</h2><p>将操作对象的指定位设置为1，其他位不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR AL,00100000B</span><br></pre></td></tr></table></figure><h2 id="9-3-字符型数据"><a href="#9-3-字符型数据" class="headerlink" title="9.3. 字符型数据"></a>9.3. 字符型数据</h2><p>字符型数据以<code>&#39;&#39;</code>的形式给出，编译器将它们转为ASCII码，用DB定义</p><h2 id="9-4-大小写转换"><a href="#9-4-大小写转换" class="headerlink" title="9.4. 大小写转换"></a>9.4. 大小写转换</h2><p>以ASCII码的二进制来看，大小写字母只有第5位不一样，大写字母第5位为0，小写字母第5位为1</p><p>使用or、and可转换大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">全部转为小写字母</span><br><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line">DATAS SEGMENT</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">    </span><br><span class="line">START:</span><br><span class="line">    MOV AX,DATAS</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    </span><br><span class="line">    MOV BX,0</span><br><span class="line">    MOV CX,5</span><br><span class="line">S:MOV AL,[BX]</span><br><span class="line">OR AL,00100000B</span><br><span class="line">MOV [BX],AL</span><br><span class="line">INC BX</span><br><span class="line">LOOP S</span><br><span class="line"> </span><br><span class="line">    </span><br><span class="line">    MOV AH,4C00H</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h2 id="9-5-定位内存地址"><a href="#9-5-定位内存地址" class="headerlink" title="9.5. 定位内存地址"></a>9.5. 定位内存地址</h2><h3 id="9-5-1-bx-idata"><a href="#9-5-1-bx-idata" class="headerlink" title="9.5.1. [bx + idata]"></a>9.5.1. <code>[bx + idata]</code></h3><p><strong>常见格式</strong></p><ul><li><code>mov ax,[200 + bx]</code></li><li><code>mov ax,200[bx]</code></li><li><code>mov ax,[bx].200</code></li></ul><p><strong>处理数组</strong></p><p>当要操作的数据，起始偏移地址不同，但是从起始偏移地址开始的相对地址变化相同时，可以看做是两个长度一样的数组</p><p>C语言 <code>a[i]、b[i]</code></p><p>汇编 <code>idata1[bx]、idata2[bx]</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">将数据段中定义的第一个字符串转为大写，第二个字符串转为小写</span><br><span class="line">ASSUME CS:CODES,DS:DATA</span><br><span class="line">DATA SEGMENT</span><br><span class="line">DB &#x27;BaSiC&#x27;</span><br><span class="line">DB &#x27;MinIX&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">START:</span><br><span class="line">MOV AX,DATA</span><br><span class="line">MOV DS,AX</span><br><span class="line"></span><br><span class="line">MOV BX,0</span><br><span class="line">MOV CX,5</span><br><span class="line">S:MOV AL,0[BX]</span><br><span class="line">AND AL,11011111B</span><br><span class="line">MOV 0[BX],AL</span><br><span class="line"></span><br><span class="line">MOV AL,5[BX]</span><br><span class="line">OR AL,00100000B</span><br><span class="line">MOV 5[BX],AL</span><br><span class="line">INC BX</span><br><span class="line">LOOP S</span><br><span class="line"></span><br><span class="line">MOV AX,4C00H</span><br><span class="line">INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h3 id="9-5-2-bx-si-和-bx-di"><a href="#9-5-2-bx-si-和-bx-di" class="headerlink" title="9.5.2. [bx + si]和[bx + di]"></a>9.5.2. <code>[bx + si]</code>和<code>[bx + di]</code></h3><p><strong>常用格式</strong></p><ul><li><code>mov ax,[bx][si]</code></li></ul><h3 id="9-5-3-bx-si-idata-和-bx-di-idata"><a href="#9-5-3-bx-si-idata-和-bx-di-idata" class="headerlink" title="9.5.3. [bx + si + idata]和[bx + di + idata]"></a>9.5.3. <code>[bx + si + idata]</code>和<code>[bx + di + idata]</code></h3><p><strong>常用格式</strong></p><ul><li><code>mov ax,[bx + 200 + si]</code></li><li><code>mov ax,[200 + bx + si]</code></li><li><code>mov ax,200[bx][si]</code></li><li><code>mov ax,[bx].200[si]</code></li><li><code>mov ax,[bx][si].200</code></li></ul><h3 id="9-5-4-二重循环"><a href="#9-5-4-二重循环" class="headerlink" title="9.5.4. 二重循环"></a>9.5.4. 二重循环</h3><h1 id="10-第八章"><a href="#10-第八章" class="headerlink" title="10. 第八章"></a>10. 第八章</h1><p>reg表示一个寄存器</p><p>sreg表示一个段寄存器</p><h2 id="10-1-表示的内存地址"><a href="#10-1-表示的内存地址" class="headerlink" title="10.1. [...]表示的内存地址"></a>10.1. <code>[...]</code>表示的内存地址</h2><p><code>[]</code>表示的单元长度可由具体指令中的其他操作对象指出</p><h3 id="10-1-1-bx、si、di、bp"><a href="#10-1-1-bx、si、di、bp" class="headerlink" title="10.1.1. bx、si、di、bp"></a>10.1.1. bx、si、di、bp</h3><p>只有bx、si、di、bp可以用在<code>[]</code>中来进行内存单元的寻址</p><h3 id="10-1-2-组合"><a href="#10-1-2-组合" class="headerlink" title="10.1.2. 组合"></a>10.1.2. 组合</h3><ul><li>bx、si、di、bp 寄存器单个出现</li><li>bx和si/di</li><li>bp和si/di</li></ul><h3 id="10-1-3-bp"><a href="#10-1-3-bp" class="headerlink" title="10.1.3. bp"></a>10.1.3. bp</h3><p>只要在<code>[]</code>中使用寄存器bp，且没有显性的给出段地址，段地址就默认在SS中</p><h2 id="10-2-指令中数据的长度"><a href="#10-2-指令中数据的长度" class="headerlink" title="10.2. 指令中数据的长度"></a>10.2. 指令中数据的长度</h2><p>在指令中要指明，指令操作的是字型数据还是字节型数据</p><h3 id="10-2-1-ptr"><a href="#10-2-1-ptr" class="headerlink" title="10.2.1. ptr"></a>10.2.1. ptr</h3><p>在没有寄存器名的情况下使用<code>操作符 X ptr</code>指明内存单元的长度，<code>X</code>的值为word或byte</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word ptr指明访问的内存单元是字型</span><br><span class="line">inc word ptr [bx]</span><br><span class="line"></span><br><span class="line">byte ptr指明访问的内存单元是字节型</span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure><h2 id="10-3-div"><a href="#10-3-div" class="headerlink" title="10.3. div"></a>10.3. div</h2><p>除法指令</p><ul><li>格式</li></ul><p><code>div 寄存器</code>或<code>div 内存单元</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[21]</span><br></pre></td></tr></table></figure><ul><li>除数</li></ul><p>有8位和16位两种，在一个寄存器中或内存单元中</p><ul><li>被除数</li></ul><p>默认放在AX或AX和DX中</p><p>如果除数为8位，被除数为16位，则默认放在AX中</p><p>如果除数为16位，被除数为32位，则放在DX和AX中，DX存放高16位，AX存放低16位</p><ul><li>结果</li></ul><p>如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数</p><p>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</p><h2 id="10-4-dd"><a href="#10-4-dd" class="headerlink" title="10.4. dd"></a>10.4. dd</h2><p>double word，定义双字型的数据</p><h2 id="10-5-dup"><a href="#10-5-dup" class="headerlink" title="10.5. dup"></a>10.5. dup</h2><p>用来定义重复数据，和db、dw、dd配合使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0) 相当于 db 0,0,0</span><br><span class="line">db 3 dup (0,1,2) 相当于 db 0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></table></figure><h1 id="11-第九章"><a href="#11-第九章" class="headerlink" title="11. 第九章"></a>11. 第九章</h1><h2 id="11-1-转移行为"><a href="#11-1-转移行为" class="headerlink" title="11.1. 转移行为"></a>11.1. 转移行为</h2><h3 id="11-1-1-段内转移"><a href="#11-1-1-段内转移" class="headerlink" title="11.1.1. 段内转移"></a>11.1.1. 段内转移</h3><p>只修改IP</p><p><strong>短转移</strong></p><p>IP修改范围 <code>-128~127</code>(补码表示)</p><p><strong>近转移</strong></p><p>IP修改范围 <code>-32768~32767</code>(补码表示)</p><h3 id="11-1-2-段间转移"><a href="#11-1-2-段间转移" class="headerlink" title="11.1.2. 段间转移"></a>11.1.2. 段间转移</h3><p>同时修改CS和IP</p><h2 id="11-2-操作符offset"><a href="#11-2-操作符offset" class="headerlink" title="11.2. 操作符offset"></a>11.2. 操作符offset</h2><p>由编译器处理，获取标号的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,offset start;相当于 mov ax,0</span><br><span class="line">s:</span><br><span class="line">mov ax,offset s;相当于 mov ax,3</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="11-3-转移指令"><a href="#11-3-转移指令" class="headerlink" title="11.3. 转移指令"></a>11.3. 转移指令</h2><h3 id="11-3-1-注"><a href="#11-3-1-注" class="headerlink" title="11.3.1. 注"></a>11.3.1. 注</h3><p>一般的汇编指令中，指令中的idata(立即数)，都会在机器指令中出现</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131047119.jpg" alt=""></p><h3 id="11-3-2-转移原理"><a href="#11-3-2-转移原理" class="headerlink" title="11.3.2. 转移原理"></a>11.3.2. 转移原理</h3><p><strong>位移转移</strong></p><ul><li>jmp short 标号</li></ul><p>段内短转移，转到标号处执行指令</p><p>(IP) = (IP) + 8位位移</p><p>8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</p><ul><li>jmp near ptr 标号</li></ul><p>段内近转移，转到标号处执行指令</p><p>(IP) = (IP) +16位位移</p><p>16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</p><p><strong>目的地址转移</strong></p><ul><li>jmp far ptr 标号</li></ul><p>段间转移</p><p>(CS) = 标号所在段的段地址</p><p>(IP) = 标号在段中的偏移地址</p><p><strong>地址在寄存器中</strong></p><ul><li>jmp 16位reg</li></ul><p>(IP) = (16位reg)</p><p><strong>地址在内存中</strong></p><ul><li>jmp word ptr 内存单元地址</li></ul><p>段内转移</p><p>从内存单元地址处开始存放一个字，是转移的目的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0];(IP) = 0123H</span><br></pre></td></tr></table></figure><ul><li>jmp dword ptr 内存单元地址</li></ul><p>段间转移</p><p>从内存单元地址处开始存放两个字</p><p>(CS) = (内存单元地址 + 2)</p><p>(IP) = (内存单元地址)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">(CS) = 0</span><br><span class="line">(IP) = 0123H</span><br></pre></td></tr></table></figure><h3 id="11-3-3-条件转移"><a href="#11-3-3-条件转移" class="headerlink" title="11.3.3. 条件转移"></a>11.3.3. 条件转移</h3><p>所有条件转移都是短转移，转移位移的范围<code>[-128,127]</code></p><ul><li>jcxz 标号(OPR)</li></ul><p>如果(cx) = 0，转移到标号处</p><p>(IP) = (IP) + 8位位移</p><p>8位位移 = 标号处的地址 - jcxz指令后的第一个字节的地址</p><h3 id="11-3-4-loop指令"><a href="#11-3-4-loop指令" class="headerlink" title="11.3.4. loop指令"></a>11.3.4. loop指令</h3><p>所有循环指令都是短转移</p><p>如果(cx) != 0，就转移到标号处</p><p>(IP) = (IP) + 8位位移</p><p>8位位移 = 标号处的地址 - loop指令后的第一个字节的地址</p><h3 id="11-3-5-总结"><a href="#11-3-5-总结" class="headerlink" title="11.3.5. 总结"></a>11.3.5. 总结</h3><p>根据位移转移，因为是靠位移来实现在段内进行转移，所以能保证程序在内存的不同位置都能正常执行</p><h1 id="12-第十章"><a href="#12-第十章" class="headerlink" title="12. 第十章"></a>12. 第十章</h1><h2 id="12-1-ret"><a href="#12-1-ret" class="headerlink" title="12.1. ret"></a>12.1. ret</h2><p>利用栈中数据修改IP的内容，实现近转移</p><p>执行ret指令，相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure><h2 id="12-2-retf"><a href="#12-2-retf" class="headerlink" title="12.2. retf"></a>12.2. retf</h2><p>利用栈中数据修改CS、IP内容，实现远转移</p><p>执行retf指令，相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP </span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure><h2 id="12-3-call"><a href="#12-3-call" class="headerlink" title="12.3. call"></a>12.3. call</h2><p>将当前的IP或CS和IP压入栈中</p><p>转移</p><h3 id="12-3-1-位移转移"><a href="#12-3-1-位移转移" class="headerlink" title="12.3.1. 位移转移"></a>12.3.1. 位移转移</h3><p>将当前的IP压栈后，转到标号处执行指令</p><p>段内直接调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL 标号</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><h3 id="12-3-2-目的地址转移"><a href="#12-3-2-目的地址转移" class="headerlink" title="12.3.2. 目的地址转移"></a>12.3.2. 目的地址转移</h3><p>段间直接远调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALL far ptr 标号</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h3 id="12-3-3-转移地址在寄存器中"><a href="#12-3-3-转移地址在寄存器中" class="headerlink" title="12.3.3. 转移地址在寄存器中"></a>12.3.3. 转移地址在寄存器中</h3><p>段内间接调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL 16位reg</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure><h3 id="12-3-4-转移地址在内存中"><a href="#12-3-4-转移地址在内存中" class="headerlink" title="12.3.4. 转移地址在内存中"></a>12.3.4. 转移地址在内存中</h3><p>段内间接调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL WORD PTR 内存单元地址</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>段间间接调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALL DWORD PTR 内存单元地址</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><h1 id="13-第十一章"><a href="#13-第十一章" class="headerlink" title="13. 第十一章"></a>13. 第十一章</h1><h2 id="13-1-标志寄存器"><a href="#13-1-标志寄存器" class="headerlink" title="13.1. 标志寄存器"></a>13.1. 标志寄存器</h2><h3 id="13-1-1-规律"><a href="#13-1-1-规律" class="headerlink" title="13.1.1. 规律"></a>13.1.1. 规律</h3><ul><li>大多数运算指令都影响标志位</li></ul><p>add、sub、mul、div、inc、or、and等</p><ul><li>大多数传送指令都不影响标志位</li></ul><p>mov、push、pop</p><h3 id="13-1-2-flag寄存器"><a href="#13-1-2-flag寄存器" class="headerlink" title="13.1.2. flag寄存器"></a>13.1.2. flag寄存器</h3><p>按位起作用(共16位)</p><p>0、2、4、6、7、8、9、10、11位都有特殊含义</p><h3 id="13-1-3-标志"><a href="#13-1-3-标志" class="headerlink" title="13.1.3. 标志"></a>13.1.3. 标志</h3><p>标志寄存器中的某个标志，值为1表示有某种状态，为0表示无某种状态</p><div class="table-container"><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>ZF</td><td>记录指令执行后，其结果是否为0</td></tr><tr><td>PF</td><td>记录指令执行后，其结果所有bit位中1的个数是否为偶数</td></tr><tr><td>SF</td><td>记录指令执行后，其结果是否为负</td></tr><tr><td>CF</td><td>进行无符号数计算时，记录其结果的最高有效位向更高位的进位值或从更高位的借位值</td></tr><tr><td>OF</td><td>有符号数运算后，其结果是否产生溢出</td></tr><tr><td>DF</td><td>串操作指令中，控制每次操作后SI、DI的增减</td></tr></tbody></table></div><hr><h1 id="14-分支程序"><a href="#14-分支程序" class="headerlink" title="14. 分支程序"></a>14. 分支程序</h1><p>分支程序要统一入口，出口</p><h2 id="14-1-位操作的分支程序"><a href="#14-1-位操作的分支程序" class="headerlink" title="14.1. 位操作的分支程序"></a>14.1. 位操作的分支程序</h2><p>如 test指令</p><h2 id="14-2-菜单法"><a href="#14-2-菜单法" class="headerlink" title="14.2. 菜单法"></a>14.2. 菜单法</h2><h3 id="14-2-1-原理"><a href="#14-2-1-原理" class="headerlink" title="14.2.1. 原理"></a>14.2.1. 原理</h3><p>主要利用比较指令判断输入的菜单号，然后利用条件转移指令跳转到指定程序执行</p><h3 id="14-2-2-缺点"><a href="#14-2-2-缺点" class="headerlink" title="14.2.2. 缺点"></a>14.2.2. 缺点</h3><p>菜单项较多时，需要使用较多的比较指令和条件转移指令，程序冗长</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         mov al,x</span><br><span class="line">       CMPAl，0  ;与0进行比较</span><br><span class="line">       JGEA1       ;X≥0转A1</span><br><span class="line">       MOVY，-1  ;X ＜0时，-1→Y</span><br><span class="line">       JMPEXIT</span><br><span class="line">A1：     JGA2           ;X＞0转</span><br><span class="line">       MOVY，0       ;X=0时，0→Y</span><br><span class="line">       JMPEXIT</span><br><span class="line">A2：     MOVY，1         ;X＞0，1→Y </span><br><span class="line"></span><br><span class="line">EXIT：   MOVAH，4CH</span><br><span class="line">       INT21H </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="14-3-跳转表法"><a href="#14-3-跳转表法" class="headerlink" title="14.3. 跳转表法"></a>14.3. 跳转表法</h2><p>跳转表法，表中顺序存放着进入各分支处理程序的程序段名(标号)或转移指令，称它们为跳转表的元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1．跳转表中存放多分支程序的偏移地址(标号)</span><br><span class="line">2．跳转表中存放多分支程序的转移指令</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DATAS SEGMENT</span><br><span class="line">    BASE   DW SUB1,SUB2,SUB3,SUB4,SUB5,……</span><br><span class="line">    BN     DB 3   </span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">      MOV AL, BN      </span><br><span class="line">      MOV AH, 0</span><br><span class="line">      DEC AL          ;建索引号</span><br><span class="line">      SHL AL, 1       ; (3-1)*2</span><br><span class="line">      MOV BX, OFFSET  BASE  ;?不用XLAT?</span><br><span class="line">      ADD BX, AX      ;求功能3的有效地址 </span><br><span class="line">      MOV BX, [BX];      jmp near ptr  [bx]</span><br><span class="line">      JMP BX       ;BX中存放具体标号(SUB3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SUB1: ....</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">SUB2: ....</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">SUB3: .......</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">      .....</span><br><span class="line">SUB8: .....</span><br><span class="line">      JMP EXIT</span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="15-循环程序"><a href="#15-循环程序" class="headerlink" title="15. 循环程序"></a>15. 循环程序</h1><p>找出循环体最后结果的输出点</p><h2 id="15-1-先判断，后执行"><a href="#15-1-先判断，后执行" class="headerlink" title="15.1. 先判断，后执行"></a>15.1. 先判断，后执行</h2><p>CMP</p><h2 id="15-2-先执行，后判断"><a href="#15-2-先执行，后判断" class="headerlink" title="15.2. 先执行，后判断"></a>15.2. 先执行，后判断</h2><p>LOOP</p><h1 id="16-串操作"><a href="#16-串操作" class="headerlink" title="16. 串操作"></a>16. 串操作</h1><h2 id="16-1-概念"><a href="#16-1-概念" class="headerlink" title="16.1. 概念"></a>16.1. 概念</h2><p>连续n 个存储单元称为串、表、数组等</p><h2 id="16-2-处理"><a href="#16-2-处理" class="headerlink" title="16.2. 处理"></a>16.2. 处理</h2><ul><li>串操作指令把附加段作为目的操作数的存放区域</li></ul><p>可以定义一个附加段，也可以把数据段、附加段定义为同一个段</p><h1 id="17-多重循环"><a href="#17-多重循环" class="headerlink" title="17. 多重循环"></a>17. 多重循环</h1><p>用两条loop指令实现双重循环时，对CX有冲突，可以用push CX，将外循环的CX进栈保存，内循环的LOOP结束后，再将外循环的CX恢复</p><h2 id="17-1-常用循环控制方法"><a href="#17-1-常用循环控制方法" class="headerlink" title="17.1. 常用循环控制方法"></a>17.1. 常用循环控制方法</h2><ul><li>计数器控制法：循环次数已知</li><li>条件控制法：循环次数未知</li><li>逻辑尺控制法：将标志位放入存储单元，存储单元就称为逻辑尺</li></ul><h2 id="17-2-内外循环的控制"><a href="#17-2-内外循环的控制" class="headerlink" title="17.2. 内外循环的控制"></a>17.2. 内外循环的控制</h2><p>不允许内外循环交叉</p><h2 id="17-3-内外循环的跳转"><a href="#17-3-内外循环的跳转" class="headerlink" title="17.3. 内外循环的跳转"></a>17.3. 内外循环的跳转</h2><p>只允许从内向外跳，不允许从外向内跳</p><p>例</p><p>用冒泡排序，实现升序排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS,SS:STACKS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">   buf DW 12,32,45,1,33       ;要排序的数</span><br><span class="line">   COUNT DW ?      ;数组元素个数</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">STACKS SEGMENT</span><br><span class="line">    ;此处输入堆栈段代码</span><br><span class="line">STACKS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">MOV AX,DATAS</span><br><span class="line">MOV DS,AX</span><br><span class="line">    </span><br><span class="line">;此段代码，按冒泡排序，小到大</span><br><span class="line">MOV CX,COUNT#count 记录数组长度</span><br><span class="line">DEC CX;记录循环次数</span><br><span class="line"></span><br><span class="line">lp1:;外循环</span><br><span class="line">PUSH CX;记录外循环次数</span><br><span class="line">MOV BX,0</span><br><span class="line"></span><br><span class="line">lp2:    ;内循环</span><br><span class="line">MOV AX,buf[BX]</span><br><span class="line">CMP AX,buf[BX+2];比较大小</span><br><span class="line">JLE next</span><br><span class="line">XCHG AX,buf[BX+2]</span><br><span class="line">MOV buf[BX],AX</span><br><span class="line"></span><br><span class="line">next:</span><br><span class="line">ADD BX,2</span><br><span class="line">LOOP lp2</span><br><span class="line">POP CX;恢复外循环次数</span><br><span class="line">LOOP lp1</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">MOV AH,4CH</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h1 id="18-子程序"><a href="#18-子程序" class="headerlink" title="18. 子程序"></a>18. 子程序</h1><h2 id="18-1-概念"><a href="#18-1-概念" class="headerlink" title="18.1. 概念"></a>18.1. 概念</h2><p>一个具有一定功能的程序段，子程序又叫过程</p><h2 id="18-2-定义子程序"><a href="#18-2-定义子程序" class="headerlink" title="18.2. 定义子程序"></a>18.2. 定义子程序</h2><h3 id="18-2-1-方法一"><a href="#18-2-1-方法一" class="headerlink" title="18.2.1. 方法一"></a>18.2.1. 方法一</h3><p>将子程序第一条指令的标号作为子程序名调用(使用call调用)</p><h3 id="18-2-2-方法二"><a href="#18-2-2-方法二" class="headerlink" title="18.2.2. 方法二"></a>18.2.2. 方法二</h3><p>伪指令proc</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc 属性       </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">子程序名 endp</span><br><span class="line"></span><br><span class="line">注：属性为 near或far</span><br><span class="line"></span><br><span class="line">属性的确定原则：</span><br><span class="line">1.主程序和子程序在同一个代码段内，用near</span><br><span class="line">2.主程序和子程序不在同一个代码段内，用far</span><br><span class="line">3.主程序是第一个被执行的程序，则主程序应定义为far(相对DOS系统来讲)</span><br></pre></td></tr></table></figure><h2 id="18-3-call执行子程序"><a href="#18-3-call执行子程序" class="headerlink" title="18.3. call执行子程序"></a>18.3. call执行子程序</h2><p>用call指令转去执行子程序，跳转之前call指令后面的指令的地址将存储在栈中</p><h2 id="18-4-现场保护"><a href="#18-4-现场保护" class="headerlink" title="18.4. 现场保护"></a>18.4. 现场保护</h2><p>为防止主程序中用寄存器存的数据被子程序覆盖，将主程序中用到的所有寄存器中的内容存入栈中，在子程序返回前再恢复</p><h2 id="18-5-参数和结果的传递"><a href="#18-5-参数和结果的传递" class="headerlink" title="18.5. 参数和结果的传递"></a>18.5. 参数和结果的传递</h2><p>如何将值传递给子程序去执行，然后将结果返回到主程序</p><h3 id="18-5-1-方法一"><a href="#18-5-1-方法一" class="headerlink" title="18.5.1. 方法一"></a>18.5.1. 方法一</h3><p>将数据存入内存中，然后传递其所在内存空间的首地址</p><h3 id="18-5-2-方法二"><a href="#18-5-2-方法二" class="headerlink" title="18.5.2. 方法二"></a>18.5.2. 方法二</h3><p>使用栈</p><h1 id="19-嵌套与递归"><a href="#19-嵌套与递归" class="headerlink" title="19. 嵌套与递归"></a>19. 嵌套与递归</h1><h2 id="19-1-子程序嵌套"><a href="#19-1-子程序嵌套" class="headerlink" title="19.1. 子程序嵌套"></a>19.1. 子程序嵌套</h2><h2 id="19-2-子程序递归"><a href="#19-2-子程序递归" class="headerlink" title="19.2. 子程序递归"></a>19.2. 子程序递归</h2><h1 id="20-宏汇编"><a href="#20-宏汇编" class="headerlink" title="20. 宏汇编"></a>20. 宏汇编</h1><h2 id="20-1-概念"><a href="#20-1-概念" class="headerlink" title="20.1. 概念"></a>20.1. 概念</h2><p>宏是源程序中具有一段独立功能的程序代码</p><h2 id="20-2-宏使用"><a href="#20-2-宏使用" class="headerlink" title="20.2. 宏使用"></a>20.2. 宏使用</h2><h3 id="20-2-1-宏定义"><a href="#20-2-1-宏定义" class="headerlink" title="20.2.1. 宏定义"></a>20.2.1. 宏定义</h3><p>一对伪指令MACRO、ENDM</p><p>格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">宏名字 MACRO 哑元1,哑元2,哑元3...</span><br><span class="line">语句串</span><br><span class="line">ENDM</span><br><span class="line">说明：</span><br><span class="line">语句串代表宏定义体，即具体的程序代码</span><br><span class="line">哑元代表形参，用逗号分割，可以没有形参，和哑元对应的是实元，相当于实参(实元和哑元统称为变元)</span><br><span class="line"></span><br><span class="line">例</span><br><span class="line">两数相加宏指令</span><br><span class="line">SUMM MACRO x1,x2,x3</span><br><span class="line">MOV AX,x1</span><br><span class="line">ADD AX,x2</span><br><span class="line">MOV X3,AX</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><h3 id="20-2-2-宏调用"><a href="#20-2-2-宏调用" class="headerlink" title="20.2.2. 宏调用"></a>20.2.2. 宏调用</h3><p>使用宏时，直接写出宏的名称即可，若有参数，后面跟上参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例</span><br><span class="line">调用宏SUMM实现(BX) = 34 + 25</span><br><span class="line">SUMM 34,25,BX</span><br></pre></td></tr></table></figure><h3 id="20-2-3-宏展开"><a href="#20-2-3-宏展开" class="headerlink" title="20.2.3. 宏展开"></a>20.2.3. 宏展开</h3><p>源程序在汇编时，宏指令会被汇编程序用相应的代码替换(用宏定义体替换)</p><h2 id="20-3-宏参数"><a href="#20-3-宏参数" class="headerlink" title="20.3. 宏参数"></a>20.3. 宏参数</h2><h3 id="20-3-1-变元是操作数"><a href="#20-3-1-变元是操作数" class="headerlink" title="20.3.1. 变元是操作数"></a>20.3.1. 变元是操作数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">MOV AX,x1</span><br><span class="line">ADD AX,x2</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><h3 id="20-3-2-变元是操作码"><a href="#20-3-2-变元是操作码" class="headerlink" title="20.3.2. 变元是操作码"></a>20.3.2. 变元是操作码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">x1 AX,2</span><br><span class="line">x2 AX,3</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure><h3 id="20-3-3-变元是操作码的一部分"><a href="#20-3-3-变元是操作码的一部分" class="headerlink" title="20.3.3. 变元是操作码的一部分"></a>20.3.3. 变元是操作码的一部分</h3><p>用<code>&amp;</code>作为分隔符，变元替换掉<code>&amp;</code>后面的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">MO&amp;x1 AX,2</span><br><span class="line">AD&amp;x2 AX,3</span><br><span class="line">ENDM</span><br><span class="line">宏调用</span><br><span class="line">TEST V,D </span><br><span class="line">等价于</span><br><span class="line">MOV AX,2</span><br><span class="line">ADD AX,3</span><br></pre></td></tr></table></figure><h3 id="20-3-4-变元是存储单元"><a href="#20-3-4-变元是存储单元" class="headerlink" title="20.3.4. 变元是存储单元"></a>20.3.4. 变元是存储单元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2,x3</span><br><span class="line">x1 DB x2 DUP(x3)</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">宏调用</span><br><span class="line">TEST SS,6,5</span><br><span class="line">等价于</span><br><span class="line">SS DB 6 DUP(5)</span><br></pre></td></tr></table></figure><h3 id="20-3-5-变元是字符串"><a href="#20-3-5-变元是字符串" class="headerlink" title="20.3.5. 变元是字符串"></a>20.3.5. 变元是字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1</span><br><span class="line">SS DB &#x27;Number &amp;x1&#x27;,&#x27;$&#x27;</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">宏调用</span><br><span class="line">TEST abc</span><br><span class="line">等价于</span><br><span class="line">SS DB &#x27;Number abc&#x27;,&#x27;$&#x27;</span><br></pre></td></tr></table></figure><h2 id="20-4-宏运算"><a href="#20-4-宏运算" class="headerlink" title="20.4. 宏运算"></a>20.4. 宏运算</h2><p>5种</p><ul><li><code>&amp;</code></li></ul><p>替换运算</p><ul><li><code>&lt;&gt;</code></li></ul><p>传递运算</p><p>如果实元是含有空格的字符串，则实元要用<code>&lt;&gt;</code>括起来</p><ul><li><code>!</code></li></ul><p>转义运算</p><p>当字符串中含有<code>&lt;</code>或<code>&gt;</code>时，为防止与传递运算符冲突，用<code>!&gt;</code>或<code>!&lt;</code>来转义</p><ul><li><code>%</code></li></ul><p>表达式运算</p><p>如果实元中有表达式，<code>%</code>将表达式的值作为实元</p><p>如<code>TEST % 35+12</code></p><ul><li><code>;;</code></li></ul><p>宏注释</p><h2 id="20-5-宏和子程序"><a href="#20-5-宏和子程序" class="headerlink" title="20.5. 宏和子程序"></a>20.5. 宏和子程序</h2><h3 id="20-5-1-区别"><a href="#20-5-1-区别" class="headerlink" title="20.5.1. 区别"></a>20.5.1. 区别</h3><ul><li>子程序是能够实现一定功能的代码，使用方法只能是跳转到子程序所在位置去执行，不能传参数</li><li>宏类似高级语言的自定义函数，可以传参数</li></ul><h3 id="20-5-2-优缺点"><a href="#20-5-2-优缺点" class="headerlink" title="20.5.2. 优缺点"></a>20.5.2. 优缺点</h3><ul><li>当传递参数较多时，可优先考虑宏</li><li>宏使用过多，会导致主程序代码太长，占用内存空间过大</li><li>当程序较长或对内存空间有要求时，可优先考虑子程序</li></ul><h1 id="21-中断"><a href="#21-中断" class="headerlink" title="21. 中断"></a>21. 中断</h1><h2 id="21-1-外中断"><a href="#21-1-外中断" class="headerlink" title="21.1. 外中断"></a>21.1. 外中断</h2><p>硬中断</p><h2 id="21-2-内中断"><a href="#21-2-内中断" class="headerlink" title="21.2. 内中断"></a>21.2. 内中断</h2><p>软中断</p><h1 id="22-查询手册"><a href="#22-查询手册" class="headerlink" title="22. 查询手册"></a>22. 查询手册</h1><h2 id="22-1-如何学习指令"><a href="#22-1-如何学习指令" class="headerlink" title="22.1. 如何学习指令"></a>22.1. 如何学习指令</h2><ul><li>操作数是单还是双</li><li>操作数的类型要求(有符号、无符号、一个地址、立即数…)</li><li>指令执行了哪些操作</li><li>是否影响标志位</li><li>结果是否回送</li></ul><h2 id="22-2-指令分类"><a href="#22-2-指令分类" class="headerlink" title="22.2. 指令分类"></a>22.2. 指令分类</h2><ul><li>汇编指令(计算机执行)</li><li>伪指令(编译器执行)</li><li>宏指令</li></ul><h2 id="22-3-伪指令"><a href="#22-3-伪指令" class="headerlink" title="22.3. 伪指令"></a>22.3. 伪指令</h2><h3 id="22-3-1-定义段"><a href="#22-3-1-定义段" class="headerlink" title="22.3.1. 定义段"></a>22.3.1. 定义段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">段名 segment </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure><h3 id="22-3-2-ASSUME"><a href="#22-3-2-ASSUME" class="headerlink" title="22.3.2. ASSUME"></a>22.3.2. ASSUME</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume 段寄存器:段名</span><br></pre></td></tr></table></figure><h3 id="22-3-3-数据定义"><a href="#22-3-3-数据定义" class="headerlink" title="22.3.3. 数据定义"></a>22.3.3. 数据定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(变量名)存储单元名 DB 操作数</span><br><span class="line"></span><br><span class="line">DB 个数 dup(?)  ;重复定义相同操作数</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">一条数据定义指令，可为多个存储单元赋值</span><br><span class="line">操作数默认是10进制的，定义16进制后面加H</span><br><span class="line">数字不能以字母开头，前面要加0</span><br><span class="line">操作数可为 ? 表示为变量预留空间而不赋初值</span><br><span class="line">操作数可为表达式，表达式会先计算，再将结果存到存储单元</span><br><span class="line">操作数若为字符串，要用单引号包围</span><br><span class="line">字符串应使用DB定义，存入的是字符串的ASCII码</span><br></pre></td></tr></table></figure><h3 id="22-3-4-赋值伪指令"><a href="#22-3-4-赋值伪指令" class="headerlink" title="22.3.4. 赋值伪指令"></a>22.3.4. 赋值伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">变量名 EQU 表达式或数据 </span><br><span class="line"></span><br><span class="line">变量名 = 表达书或数据</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">EQU不允许重复定义，即一个变量名只能使用一次</span><br><span class="line">= 允许重复定义</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">CR EQU 0DH  </span><br><span class="line">MOVAL,CR  ;等价于 MOV  AL, 0DH</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-3-5-模块定义伪指令"><a href="#22-3-5-模块定义伪指令" class="headerlink" title="22.3.5. 模块定义伪指令"></a>22.3.5. 模块定义伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name 模块名</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">end 起始标号</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">name伪指令可缺省</span><br></pre></td></tr></table></figure><h3 id="22-3-6-地址计数器"><a href="#22-3-6-地址计数器" class="headerlink" title="22.3.6. $地址计数器"></a>22.3.6. <code>$</code>地址计数器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ 表示当前的偏移地址</span><br><span class="line"></span><br><span class="line">如：jmp $+5 则跳转到当前指令的偏移地址加5的单元</span><br></pre></td></tr></table></figure><h3 id="22-3-7-ORG设置当前偏移地址"><a href="#22-3-7-ORG设置当前偏移地址" class="headerlink" title="22.3.7. ORG设置当前偏移地址"></a>22.3.7. ORG设置当前偏移地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在数据段中，可以在指定偏移地址的存储单元存放数据</span><br><span class="line">在代码段中，可以从指定单元开始存放并执行指令</span><br><span class="line"></span><br><span class="line">如 org 0020H 表示设置当前偏移地址为 0020H</span><br></pre></td></tr></table></figure><h3 id="22-3-8-操作符"><a href="#22-3-8-操作符" class="headerlink" title="22.3.8. 操作符"></a>22.3.8. 操作符</h3><p>程序在汇编时，将这些操作符变为相应的数值回送或者定义属性</p><p><strong>offset（回送偏移地址）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,offset x;将x单元的偏移地址送给bx</span><br><span class="line">mov ax,offset start;将标号start的偏移地址送给 ax</span><br></pre></td></tr></table></figure><p><strong>seg（回送段地址）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov bx,seg x;将x单元的段地址送给bx</span><br></pre></td></tr></table></figure><p><strong>type（类型回送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx,type x ;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果 x 是字节单元，回送值为 1 </span><br><span class="line">如果 x 是字单元，回送值为 2 </span><br></pre></td></tr></table></figure><p><strong>length（变量数回送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,length y</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">y如果是dup()定义的，cx = 变量的个数</span><br></pre></td></tr></table></figure><p><strong>size（字节数回送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,size y</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果y是用dup()定义的，ax = 所有变量所占的总字节数</span><br></pre></td></tr></table></figure><p><strong>ptr（属性定义）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr [bx],10;定义目的操作数为字节单元</span><br><span class="line">mov word ptr [ax],20;定义目的操作数为字单元</span><br></pre></td></tr></table></figure><p><strong>this（多重属性操作）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要与EQU配合</span><br></pre></td></tr></table></figure><p><strong>label（类型操作符）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x label byte ;将x单元的类型定义为byte字节型</span><br></pre></td></tr></table></figure><h3 id="22-3-9-注释伪指令"><a href="#22-3-9-注释伪指令" class="headerlink" title="22.3.9. 注释伪指令"></a>22.3.9. 注释伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><h2 id="22-4-基本汇编指令"><a href="#22-4-基本汇编指令" class="headerlink" title="22.4. 基本汇编指令"></a>22.4. 基本汇编指令</h2><p>操作数的属性必须一致</p><h3 id="22-4-1-数据、栈及查表"><a href="#22-4-1-数据、栈及查表" class="headerlink" title="22.4.1. 数据、栈及查表"></a>22.4.1. 数据、栈及查表</h3><p>数据操作指令不影响标志位</p><p><strong>mov（传送指令）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">立即数是字节型还是字型</span><br><span class="line">明确指令是字节操作还是字操作</span><br><span class="line">目标寄存器不能是CS</span><br><span class="line">立即数和存储器数不能直接送段寄存器</span><br><span class="line">两个段寄存器间不能直接传送</span><br><span class="line">两个存储单元之间不能直接传送</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>xchg（数据交换）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xchg ax,bx ;交换bx和ax的内容</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">必须有一个操作数是寄存器</span><br><span class="line">操作数不能是立即数</span><br></pre></td></tr></table></figure><p><strong>push（进栈）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">操作单位是 字</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>pop（出栈）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">操作单位是 字</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH  SP指令入栈的是该指令已修改的SP新值，</span><br><span class="line">PUSH  ESP指令入栈的是执行该指令之前的ESP旧值，</span><br><span class="line">POP ESP使用指令执行后的ESP内容.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>xlat（查表转换指令）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过AL寄存器中的索引值在表中查得表项内容并返回到AL中</span><br><span class="line"></span><br><span class="line">使用这条指令之前，数据段中应有一个字节型表，该表起始地址的偏移量应放入BX，表索引值(要查找单元的位移量)放入AL</span><br><span class="line"></span><br><span class="line">(AL) = ((BX)+(AL))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-4-2-逻辑地址的获取"><a href="#22-4-2-逻辑地址的获取" class="headerlink" title="22.4.2. 逻辑地址的获取"></a>22.4.2. 逻辑地址的获取</h3><p>这类指令传送的是操作数的地址，而不是操作数本身</p><p>不能使用段寄存器</p><p>源操作数不能使用立即数和寄存器寻址方式</p><p><strong>lea（有效地址传送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea 寄存器,存储单元</span><br><span class="line">把源操作数的有效地址送给指定的寄存器(除段寄存器)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">源操作数必须是存储单元</span><br><span class="line">等价的OFFSET后面只能跟变量，不能是变址(DI、SI)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>lds（数据段地址传送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lds 寄存器,双字存储单元</span><br><span class="line">将双字存储单元的低字节送入寄存器，高字节送入DS段寄存器</span><br></pre></td></tr></table></figure><p><strong>les（附加段地址传送）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">les 寄存器,双字存储单元</span><br><span class="line">将双字存储单元的低字节送入寄存器，高字节送入ES附加段寄存器</span><br></pre></td></tr></table></figure><h3 id="22-4-3-符号位扩展"><a href="#22-4-3-符号位扩展" class="headerlink" title="22.4.3. 符号位扩展"></a>22.4.3. 符号位扩展</h3><p>不影响条件标志位</p><p><strong>cbw（字节拓到字）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将al扩展到ax</span><br><span class="line">逻辑意义就是AL的符号扩展到AH</span><br></pre></td></tr></table></figure><p><strong>cwd（字拓到双字）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将ax扩展到dx</span><br></pre></td></tr></table></figure><h2 id="22-5-算术运算指令"><a href="#22-5-算术运算指令" class="headerlink" title="22.5. 算术运算指令"></a>22.5. 算术运算指令</h2><p>任何一条二进制加、减法指令均适用于带符号数和无符号数运算</p><h3 id="22-5-1-add-加法"><a href="#22-5-1-add-加法" class="headerlink" title="22.5.1. add(加法)"></a>22.5.1. add(加法)</h3><p>影响OF、SF、ZF、AF、PF、CF标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目的操作数是一个存储单元中的数据</span><br><span class="line">对操作数的限定同MOV指令</span><br></pre></td></tr></table></figure><h3 id="22-5-2-ADC-进位加法"><a href="#22-5-2-ADC-进位加法" class="headerlink" title="22.5.2. ADC(进位加法)"></a>22.5.2. ADC(进位加法)</h3><p>影响OF、SF、ZF、AF、PF、CF标志</p><p>适用于多字节或多字的加法运算</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADC执行加法运算时，会将CF位的值一起加到目标操作数中</span><br><span class="line">如果必须处理非常大的、不能存放到双字数据长度（ADD可以使用的最大长度）中的整数，可以把值分割为多个双字数据元素，并且对每个元素执行独立的加法操作。</span><br><span class="line">为了正确完成这个操作，必须检测每个加法操作的进位标志，如果进位标志被设置为1，就必须进位到下一对相加的数据元素</span><br></pre></td></tr></table></figure><h3 id="22-5-3-inc-加1指令"><a href="#22-5-3-inc-加1指令" class="headerlink" title="22.5.3. inc(加1指令)"></a>22.5.3. inc(加1指令)</h3><p>除不影响CF标志外，影响其它五个算术运算特征标志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现地址指针或循环次数的加1修改</span><br></pre></td></tr></table></figure><h3 id="22-5-4-加法指令对条件标志位的影响"><a href="#22-5-4-加法指令对条件标志位的影响" class="headerlink" title="22.5.4. 加法指令对条件标志位的影响"></a>22.5.4. 加法指令对条件标志位的影响</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sf = 1 结果为负</span><br><span class="line">zf = 1 结果为 0</span><br><span class="line">cf = 1 和的最高有效位，向前进位</span><br><span class="line">cf = 0 </span><br><span class="line">of = 1 两个操作数符号相同，结果符号与之相反</span><br><span class="line">of = 0 </span><br></pre></td></tr></table></figure><h3 id="22-5-5-sub-减法"><a href="#22-5-5-sub-减法" class="headerlink" title="22.5.5. sub(减法)"></a>22.5.5. sub(减法)</h3><p>要求同ADD</p><h3 id="22-5-6-sbb-带错位的"><a href="#22-5-6-sbb-带错位的" class="headerlink" title="22.5.6. sbb(带错位的)"></a>22.5.6. sbb(带错位的)</h3><p>同ADC</p><h3 id="22-5-7-dec-减1指令"><a href="#22-5-7-dec-减1指令" class="headerlink" title="22.5.7. dec(减1指令)"></a>22.5.7. dec(减1指令)</h3><p>和INC功能类似</p><h3 id="22-5-8-cmp-比较指令"><a href="#22-5-8-cmp-比较指令" class="headerlink" title="22.5.8. cmp(比较指令)"></a>22.5.8. cmp(比较指令)</h3><p>可进行两种比较，有符号数比较和无符号数比较</p><p>执行相减操作后，根据结果设置标志位，并不改变两个操作数的原值，其它要求同SUB</p><p>执行比较指令之后，可以根据标志判断两个数是否相等、大小关系等</p><h3 id="22-5-9-neg-求补指令"><a href="#22-5-9-neg-求补指令" class="headerlink" title="22.5.9. neg(求补指令)"></a>22.5.9. neg(求补指令)</h3><p>对目标操作数(含符号位)求反加1，并且把结果送回目标</p><p>利用NEG指令可实现求一个数的相反数</p><p>影响OF、SF、ZF、AF、PF、CF标志</p><h3 id="22-5-10-减法指令对条件标志位的影响"><a href="#22-5-10-减法指令对条件标志位的影响" class="headerlink" title="22.5.10. 减法指令对条件标志位的影响"></a>22.5.10. 减法指令对条件标志位的影响</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cf = 1 的最高有效位，向前进位</span><br><span class="line">cf = 0 </span><br><span class="line">of = 1 </span><br><span class="line">of = 0 </span><br></pre></td></tr></table></figure><h2 id="22-6-混合算术指令"><a href="#22-6-混合算术指令" class="headerlink" title="22.6. 混合算术指令"></a>22.6. 混合算术指令</h2><h3 id="22-6-1-mul-无符号乘法"><a href="#22-6-1-mul-无符号乘法" class="headerlink" title="22.6.1. mul(无符号乘法)"></a>22.6.1. mul(无符号乘法)</h3><p>实现两个无符号二进制数乘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字节乘法：被乘数放在al中，结果放在ax中</span><br><span class="line">字乘法：被乘数放在ax中，结果放在dx、ax中</span><br><span class="line">乘数写在指令中</span><br><span class="line">注意：</span><br><span class="line">源操作数只能是寄存器(reg)或存储器操作数(m)，不能是立即数</span><br><span class="line"></span><br><span class="line">对CF和OF的影响是:</span><br><span class="line">若乘积的高半部分(例字节型乘法结果的AH)为0则对CF和OF清0，否则置CF和OF为1</span><br></pre></td></tr></table></figure><h3 id="22-6-2-imul-带符号数相乘"><a href="#22-6-2-imul-带符号数相乘" class="headerlink" title="22.6.2. imul(带符号数相乘)"></a>22.6.2. imul(带符号数相乘)</h3><p>实现两个带符号二进制数乘</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">规则和mul一样</span><br><span class="line"></span><br><span class="line">对CF和OF的影响是:若乘积的高半部分为低半部分的符号扩展，则对CF和OF清0,否则置CF和OF为1</span><br></pre></td></tr></table></figure><h3 id="22-6-3-div-无符号除法"><a href="#22-6-3-div-无符号除法" class="headerlink" title="22.6.3. div(无符号除法)"></a>22.6.3. div(无符号除法)</h3><p>实现两个无符号数除法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">div registre</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">除数</span><br><span class="line"></span><br><span class="line">有8位和16位两种，在一个寄存器中或内存单元中</span><br><span class="line"></span><br><span class="line">被除数</span><br><span class="line"></span><br><span class="line">默认放在AX或AX和DX中</span><br><span class="line"></span><br><span class="line">如果除数为8位，被除数为16位，则默认放在AX中</span><br><span class="line"></span><br><span class="line">如果除数为16位，被除数为32位，则放在DX和AX中，DX存放高16位，AX存放低16位</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line"></span><br><span class="line">如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数</span><br><span class="line"></span><br><span class="line">如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</span><br><span class="line"></span><br><span class="line">为了保证被除数位数，需进行位扩展，使用CBW和CWD</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-6-4-idiv-带符号除法"><a href="#22-6-4-idiv-带符号除法" class="headerlink" title="22.6.4. idiv(带符号除法)"></a>22.6.4. idiv(带符号除法)</h3><p>同div</p><h2 id="22-7-十进制数运算"><a href="#22-7-十进制数运算" class="headerlink" title="22.7. 十进制数运算"></a>22.7. 十进制数运算</h2><h3 id="22-7-1-压缩的BCD码"><a href="#22-7-1-压缩的BCD码" class="headerlink" title="22.7.1. 压缩的BCD码"></a>22.7.1. 压缩的BCD码</h3><p>只是看起来是用二进制编码表示0~9，在计算时，仍为二进制的计算，所以计算结果需要修正</p><h4 id="22-7-1-1-daa-加法调整"><a href="#22-7-1-1-daa-加法调整" class="headerlink" title="22.7.1.1. daa(加法调整)"></a>22.7.1.1. daa(加法调整)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制加法指令之后,把AL中的结果调整成压缩BCD码并送回AL</span><br><span class="line"></span><br><span class="line">标志:</span><br><span class="line">AF、CF按以上情况设置,SF、ZF、PF按结果设置，OF位不确定</span><br><span class="line"></span><br><span class="line">若是多字节加法，可以通过ADC指令把CF的进位加到高位中</span><br></pre></td></tr></table></figure><h4 id="22-7-1-2-das-减法调整"><a href="#22-7-1-2-das-减法调整" class="headerlink" title="22.7.1.2. das(减法调整)"></a>22.7.1.2. das(减法调整)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制减法指令之后,把AL中的结果调整成两位压缩BCD码并送回AL</span><br></pre></td></tr></table></figure><h3 id="22-7-2-非压缩的BCD码"><a href="#22-7-2-非压缩的BCD码" class="headerlink" title="22.7.2. 非压缩的BCD码"></a>22.7.2. 非压缩的BCD码</h3><p><strong>aaa（加法调整）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制减法指令之后</span><br><span class="line">调整AL中的结果成为非压缩BCD码并送回AL</span><br><span class="line">如果AL的低4位大于9，则AL+6，AH+1，AL的高4位清0，CF=1，AF=1</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">参与运算的操作数必须是ASCII码或非压缩BCD码</span><br></pre></td></tr></table></figure><p><strong>aas（减法调整）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同加法</span><br></pre></td></tr></table></figure><p><strong>aam（乘法调整）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跟在乘法指令MUL之后,对AL中的结果进行调整，调整后的非压缩BCD码在AX中。（调整的过程相当于AL除10,商送AH，余数送AL）</span><br></pre></td></tr></table></figure><p><strong>aad（除法调整）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除法指令之前，对AX中的非压缩BCD码进行调整,以便执行DIV指令之后，得到非压缩BCD码形式的商在AL中，余数在AH中</span><br></pre></td></tr></table></figure><h2 id="22-8-屏幕显示"><a href="#22-8-屏幕显示" class="headerlink" title="22.8. 屏幕显示"></a>22.8. 屏幕显示</h2><p>直接写显存显示字符</p><p>规定偶地址单元放字符的ASCII码，奇地址单元放字符的属性</p><p>字符的位置=行号x160D + 列号x2D</p><h2 id="22-9-输入输出"><a href="#22-9-输入输出" class="headerlink" title="22.9. 输入输出"></a>22.9. 输入输出</h2><h3 id="22-9-1-调用-中断INT-21H"><a href="#22-9-1-调用-中断INT-21H" class="headerlink" title="22.9.1. 调用 中断INT 21H"></a>22.9.1. 调用 中断INT 21H</h3><p>可以通过DOS系统功能调用中断INT 21H，来使用输入、输出</p><p>INT 21H 系统功能调用方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能号送AH寄存器，</span><br><span class="line">调用参数送所要求的位置，</span><br><span class="line">再执行 INT  21H 系统功能调用中断</span><br></pre></td></tr></table></figure><h3 id="22-9-2-单字符输入"><a href="#22-9-2-单字符输入" class="headerlink" title="22.9.2. 单字符输入"></a>22.9.2. 单字符输入</h3><p>输入的是字符串，但存的是字符串对应的ASCII码</p><p>如果输入的是数，运算前，记得减30H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能号：1</span><br><span class="line">返回参数：AL＝输入字符的ASCII值</span><br><span class="line">说明：等待从标准输入设备(通常为键盘)输入一个字符，把接收到的字符的ASCII值送给AL，并显示到显示器的当前光标位置。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-9-3-单字符输出"><a href="#22-9-3-单字符输出" class="headerlink" title="22.9.3. 单字符输出"></a>22.9.3. 单字符输出</h3><p>存的是ASCII，输出的是字符串</p><p>因为存的是字符串对应的ASCII码，所以输出的是数时，记得加30H(之前若减过30H)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能号：2</span><br><span class="line">调用参数：DL＝字符的ASCII值</span><br><span class="line">说明：该输出功能使光标跟随移动，同时输出字符的ASCII值送给AL</span><br><span class="line">例：输出一个字符Y。</span><br><span class="line">MOV    AH , 2</span><br><span class="line">MOV    DL , &quot;Y&quot;</span><br><span class="line">INT      21H</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-9-4-输出字符串"><a href="#22-9-4-输出字符串" class="headerlink" title="22.9.4. 输出字符串"></a>22.9.4. 输出字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示字符串</span><br><span class="line">功能号：9</span><br><span class="line">调用参数：DS:DX指向要输出的以＄结尾的字符串首地址</span><br><span class="line">功能：输出字符串到标准输出设备</span><br><span class="line">说明：要输出的字符串必须以＄结束</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRINTDB &#x27;What is your name$&#x27;</span><br><span class="line">MOVAH,9</span><br><span class="line">MOV DX,OFFSET PRINT</span><br><span class="line">INT21H</span><br></pre></td></tr></table></figure><h3 id="22-9-5-输入字符串"><a href="#22-9-5-输入字符串" class="headerlink" title="22.9.5. 输入字符串"></a>22.9.5. 输入字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能号：0AH</span><br><span class="line">调用参数：DS:DX指向自定义的输入缓冲区首地址</span><br><span class="line">功能：从标准输入设备(例如键盘)输入一串字符到用户定义的缓冲区，直到按下Enter键为止，回车符0DH占用一个字节单元，在接收的同时显示到屏幕上，如果超过缓冲区的最大容纳量，则忽略此字符并响铃警告</span><br><span class="line">说明：定义缓冲区的第一个字节单元为允许输入的最大字符数，第二个字节单元为实际键入的字符个数(系统自动填入)，第三个字节单元开始存放键入的字符</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BUFFER DB 60;定义缓冲区长度</span><br><span class="line">DB ?;存放实际键入的字符数</span><br><span class="line">DB 61 DUP(?);存放实际输入的字符</span><br><span class="line">;设DS已是BUFFER的段基址</span><br><span class="line">MOV  AH,0AH;接收一串字符</span><br><span class="line">LEA  DX,BUFFER</span><br><span class="line">INT  21H</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-9-6-常用输出合集"><a href="#22-9-6-常用输出合集" class="headerlink" title="22.9.6. 常用输出合集"></a>22.9.6. 常用输出合集</h3><p><strong>输出换行</strong></p><p>先输出回车符，再输出换行符</p><p>方法一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;实现换行</span><br><span class="line">MOV AH,2;先输出 回车符</span><br><span class="line">MOV DL,0DH</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2;再输出 换行符</span><br><span class="line">MOV DL,0AH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><p>方法二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">CRLF DB 0AH,0DH,&#x27;$&#x27;;存放换行的存储单元</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    MOV AX,DATAS</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    LEA DX, CRLF     ;换行                   </span><br><span class="line">    MOV AH, 09H </span><br><span class="line">    INT 21H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出输入的字符</strong></p><p>输出输入的字符时，记得在输入的字符后面加<code>$</code>再输出</p><p>因为输入的字符串最后一个字符是回车符，所以要找到回车符的位置，并将其替换为<code>$</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">n DB 60,?,61 DUP(?);存放输入字符串的缓冲区</span><br><span class="line"></span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:    </span><br><span class="line">   </span><br><span class="line">    MOV DX,OFFSET n ;接收字符串，放入缓冲区</span><br><span class="line">    MOV AH,10</span><br><span class="line">    INT 21H</span><br><span class="line">    </span><br><span class="line">    ;对输入的字符串进行处理，准备输出</span><br><span class="line">    MOV AL,n+1       ;此时AL中存的是实际输入的字符的个数</span><br><span class="line">    ADD AL, 2;此时AL存的是整个输入缓存区的使用长度，也是回车符所在存储单元的偏移量</span><br><span class="line">    MOV AH, 0</span><br><span class="line">    MOV SI, AX;此时 SI 中存的是回车符所在存储单元的偏移量</span><br><span class="line">    MOV n[SI], &#x27;$&#x27;;用 $ 替换回车符</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line">MOV DX,OFFSET n;已经在输入字符串后面加了 $ ，所以直接 输出输入的字符</span><br><span class="line">    ADD DX,2</span><br><span class="line">    MOV AH,9 </span><br><span class="line">    INT 21H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出数字</strong></p><p>在汇编语言中，只能直接输入输出字符串，数字是不能直接输出的，要想把数字输出，就要将其转换成字符串(即字符)的形式，然后再输出数字的字符形式</p><p>当数字大于9时，便无法用数字加30H的方式来表示数字的字符形式了。</p><p>解决方法：将数字除以10，分别取商和余数组成数的字符形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">12除以10，商为1，余数为2，使用 1、2的字符形式组成12的字符形式</span><br></pre></td></tr></table></figure><p>具体实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">;输出数字36</span><br><span class="line"></span><br><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line"></span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line">      MOV AX,DATAS</span><br><span class="line">      MOV DS,AX</span><br><span class="line">      </span><br><span class="line">      MOV AX,36</span><br><span class="line">     MOV BL,10</span><br><span class="line">      DIV BL</span><br><span class="line">      </span><br><span class="line">      MOV BL,AH;BL存放余数</span><br><span class="line">      ADD BL,30H;余数的ASCII码</span><br><span class="line">  ADD AL,30H;商的ASCII码</span><br><span class="line">  </span><br><span class="line">  MOV AH,2;先输出商</span><br><span class="line">  MOV DL,AL</span><br><span class="line">  INT 21H</span><br><span class="line">  </span><br><span class="line">  MOV AH,2;再输出余数</span><br><span class="line">  MOV DL,BL</span><br><span class="line">  INT 21H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      MOV AX,4C00H</span><br><span class="line">      INT 21H </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出多位数</strong></p><p>因为2号功能只能输出单个字符，因此如果要输出多位数，需要一位一位的输出，利用将多位数除以10，再用得到的商除10，每次得到的余数，依次为多位数的个位、十位、百位…</p><p>在输出未知位数的数字时，需要判断商是否为0，除到商为0，就退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">;输出3位数，每次除10，取余</span><br><span class="line">MOV AX,res ; res中存的是3位数</span><br><span class="line">MOV Y,10</span><br><span class="line"></span><br><span class="line">DIV Y;共3位数，求个位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV g,AH</span><br><span class="line"></span><br><span class="line">CBW;拓展AL</span><br><span class="line">DIV Y;共2位数，求十位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV shi,AH</span><br><span class="line"></span><br><span class="line">CBW</span><br><span class="line">DIV Y;共1位数，求百位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV bai,AH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,bai</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,shi</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,g</span><br><span class="line">INT 21H</span><br><span class="line"> </span><br><span class="line">   MOV AH,4CH</span><br><span class="line">   INT 21H</span><br></pre></td></tr></table></figure><p><strong>输入多位数</strong></p><p>利用1号功能的循环输入多位数，用空格分割数字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">   buf DW 100 dup(?)       ;预留100个数组元素</span><br><span class="line">   COUNT DW ?      ;数组元素个数</span><br><span class="line">   error DB 13,10,&#x27;input error&#x27;,13,10,&#x27;$&#x27;</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">MOV AX,DATAS</span><br><span class="line">MOV DS,AX</span><br><span class="line"></span><br><span class="line">MOV SI,0</span><br><span class="line">MOV DI,0</span><br><span class="line"></span><br><span class="line">MOV BX,0</span><br><span class="line"></span><br><span class="line">input:</span><br><span class="line"></span><br><span class="line">MOV AH,1</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">.IF AL == 13;回车退出</span><br><span class="line">JMP exit1</span><br><span class="line">.ELSEIF AL== 32;空格输入下一组数据</span><br><span class="line">JMP lp1</span><br><span class="line">.ENDIF</span><br><span class="line"></span><br><span class="line">.IF AL &lt; &#x27;0&#x27;</span><br><span class="line">JMP e</span><br><span class="line">.ELSEIF AL &gt; &#x27;9&#x27;</span><br><span class="line">JMP e</span><br><span class="line">.ELSE; 40 - 49 得到输入的真实数值，并把两位数存入BX中</span><br><span class="line">SUB AL,30H;从ASCII码得到真实数字</span><br><span class="line"></span><br><span class="line">      CBW;将AL拓展为AX</span><br><span class="line">      XCHG  AX, BX   </span><br><span class="line"></span><br><span class="line">     MOV   CX, 10</span><br><span class="line">      MUL   CX</span><br><span class="line">      XCHG  AX, BX</span><br><span class="line">      ADD   BX, AX</span><br><span class="line">      JMP input      </span><br><span class="line"></span><br><span class="line">.ENDIF</span><br><span class="line"></span><br><span class="line">lp1:</span><br><span class="line">;存数据</span><br><span class="line">MOV buf[SI],BX</span><br><span class="line">MOV BX,0</span><br><span class="line">INC SI</span><br><span class="line">INC SI</span><br><span class="line">INC DI</span><br><span class="line"></span><br><span class="line">MOV COUNT,DI;记录输入的个数</span><br><span class="line"></span><br><span class="line">JMP input</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e:;错误提示</span><br><span class="line">MOV AH,9</span><br><span class="line">LEA DX,error</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">JMP finish</span><br><span class="line"></span><br><span class="line">exit1:</span><br><span class="line">MOV buf[SI],BX  ;存入最后一个数</span><br><span class="line">finish:</span><br><span class="line">MOV AH,ACH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure><h3 id="22-9-7-汇编中数的存储"><a href="#22-9-7-汇编中数的存储" class="headerlink" title="22.9.7. 汇编中数的存储"></a>22.9.7. 汇编中数的存储</h3><ul><li>调用输入功能，输入的数字，是以ASCII码的形式存的，在运算时要先减30H</li><li>直接在程序中定义的数字，是已数字的形式存的，输出时要输出它的字符串形式，要加30H</li></ul><h2 id="22-10-位操作指令"><a href="#22-10-位操作指令" class="headerlink" title="22.10. 位操作指令"></a>22.10. 位操作指令</h2><p><strong>逻辑运算和移位运算都用二进制来进行</strong></p><h3 id="22-10-1-逻辑运算"><a href="#22-10-1-逻辑运算" class="headerlink" title="22.10.1. 逻辑运算"></a>22.10.1. 逻辑运算</h3><p>适用于有符号数和无符号数</p><p><strong>AND</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">AND mem,imm/reg ;</span><br><span class="line">AND reg,imm/reg/mem ;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">均为1才为1，否则为0</span><br><span class="line">AND 指令可用于屏蔽某些位(用0相与)</span><br><span class="line">AND指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</span><br></pre></td></tr></table></figure><p><strong>OR</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">同上</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">有1为1，否则为0</span><br><span class="line">OR 指令可用于置位某些位(用1相或)</span><br><span class="line">标志的影响同AND指令</span><br></pre></td></tr></table></figure><p><strong>XOR</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">同上</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">相同为0，不同为1</span><br><span class="line">XOR 指令可用于求反某些位(用1相异或)</span><br><span class="line">标志的影响同AND指令</span><br></pre></td></tr></table></figure><p><strong>NOT</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">NOT reg/mem</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">取反</span><br><span class="line">NOT指令是一个单操作数指令</span><br><span class="line">NOT指令不影响标志位</span><br></pre></td></tr></table></figure><p><strong>TEST</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对两个操作数执行逻辑与运算，结果不回送到目的操作数</span><br><span class="line">标志的影响同 AND 指令</span><br></pre></td></tr></table></figure><p><strong>常用操作</strong></p><ul><li>使用TEST 数字和大小写字母的判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">大写字母A-Z: 01000001B - 01011010B</span><br><span class="line">小写字母a-z: 01100001B - 01111010B</span><br><span class="line">数字0-9:     00110000B - 00111001B</span><br><span class="line"></span><br><span class="line">数字和字母的第6位不同，TEST AL，40H，第6位为0是数字，第6位为1是字母</span><br><span class="line"></span><br><span class="line">大小写字母的第5位不同，TEST AL,20H，第5位为0是大写字母，第5位为1是小写字母</span><br></pre></td></tr></table></figure><ul><li>使用TEST 正数、负数、奇数、偶数的判断</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">偶数的特点是换算成二进制的话最后一位必定是0(2的倍数),所以检测最后一位是否是0就能判断出是否是偶</span><br><span class="line"></span><br><span class="line">有符号数的第一位用0代表正，1代表负</span><br></pre></td></tr></table></figure><ul><li>使用AND将键盘输入的小写字母转为大写</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND AL,0DFH</span><br></pre></td></tr></table></figure><h3 id="22-10-2-算术移位指令"><a href="#22-10-2-算术移位指令" class="headerlink" title="22.10.2. 算术移位指令"></a>22.10.2. 算术移位指令</h3><p>如果移位超过1，必须使用CL寄存器存放移位的位数</p><p>适用于有符号数</p><p><strong>SAL左移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术左移，最高位进入CF，最低位补0</span><br></pre></td></tr></table></figure><p><strong>SAR右移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术右移，最低位进入CF，最高位不变</span><br></pre></td></tr></table></figure><h3 id="22-10-3-逻辑移位指令"><a href="#22-10-3-逻辑移位指令" class="headerlink" title="22.10.3. 逻辑移位指令"></a>22.10.3. 逻辑移位指令</h3><p>使用于无符号数</p><p><strong>SHL左移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑左移，最高位进入CF，最低位补0</span><br></pre></td></tr></table></figure><p><strong>SHR右移</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑右移，最低位进入CF，最高位补0</span><br></pre></td></tr></table></figure><p><strong>移位指令对标志的影响</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按照移入的位设置进位标志CF</span><br><span class="line"></span><br><span class="line">对AF没有定义</span><br><span class="line"></span><br><span class="line">如果移位次数为1，则按照操作数的最高符号位是否改变，相应设置溢出标志OF：如果移位前操作数最高位与移位后不同则OF = 1；否则OF = 0。</span><br><span class="line"></span><br><span class="line">当移位次数大于1时，OF不确定</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-10-4-循环移位指令"><a href="#22-10-4-循环移位指令" class="headerlink" title="22.10.4. 循环移位指令"></a>22.10.4. 循环移位指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能：</span><br><span class="line">将操作数从一端移出的位返回到另一端形成循环，分成不带进位和带进位，分别具有左移或右移操作。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">ROL reg/mem,1/CL不带进位循环左移</span><br><span class="line">ROR reg/mem,1/CL不带进位循环右移</span><br><span class="line">RCL reg/mem,1/CL带进位循环左移</span><br><span class="line">RCR reg/mem,1/CL带进位循环右移</span><br></pre></td></tr></table></figure><p><strong>ROL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最高位移入CF，同时将操作数从首端移出的位返回到末端形成循环</span><br><span class="line">如：</span><br><span class="line">MOV AL,8AH;10001010</span><br><span class="line">ROL AL,1;00010101</span><br></pre></td></tr></table></figure><p><strong>ROR</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最低位移入CF，同时将操作数从末端移出的位返回到首端形成循环</span><br><span class="line">如：</span><br><span class="line">MOV AL,8AH;10001010</span><br><span class="line">ROR AL,1;01000101</span><br></pre></td></tr></table></figure><p><strong>RCL</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数和进位一起循环左移，CF移入最低位，同时最高位移入CF</span><br></pre></td></tr></table></figure><p><strong>RCR</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数和进位一起循环右移，CF移入最高位，同时最低位移入CF</span><br></pre></td></tr></table></figure><h3 id="22-10-5-总结"><a href="#22-10-5-总结" class="headerlink" title="22.10.5. 总结"></a>22.10.5. 总结</h3><p>用右移实现除法时，会出现余数丢失</p><h2 id="22-11-转移指令"><a href="#22-11-转移指令" class="headerlink" title="22.11. 转移指令"></a>22.11. 转移指令</h2><h3 id="22-11-1-CMP相关"><a href="#22-11-1-CMP相关" class="headerlink" title="22.11.1. CMP相关"></a>22.11.1. CMP相关</h3><p>可进行两种比较，有符号数比较和无符号数比较，所以转移也分两种，无符号比较结果根据(zf、cf的值)，有符号数比较根据(sf、of、zf的值)</p><p>无符号数比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CMP i,j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JE 标号;i == j 则跳转   检测 zf=1</span><br><span class="line">JNE 标号;i != j 则转移  检测 zf=0</span><br><span class="line"></span><br><span class="line">JB 标号;i &lt; j 跳转检测 cf=1</span><br><span class="line">JNB 标号;i &gt;= j 跳转检测 cf=0</span><br><span class="line"></span><br><span class="line">JA 标号;i &gt; j 跳转   检测 cf=0且zf=0</span><br><span class="line">JNA 标号 ;i &lt;=j 跳转检测 cf=1或zf=1</span><br><span class="line"></span><br><span class="line">JZ 标号; i == j 跳转</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">e 表示 equal 等于</span><br><span class="line">b 表示 below 小于</span><br><span class="line">a 表示 above 大于</span><br><span class="line">n 表示 no 否</span><br></pre></td></tr></table></figure><p>有符号数比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JL小于SF!=OF且ZF=0</span><br><span class="line">JLE 小于等于   SF!=OF或ZF=1</span><br><span class="line"></span><br><span class="line">JGSF=OF且ZF=0</span><br><span class="line">JGESF=OF或ZF=1</span><br><span class="line"></span><br><span class="line">G greater 大</span><br><span class="line">L less    小</span><br></pre></td></tr></table></figure><h3 id="22-11-2-条件标志转移"><a href="#22-11-2-条件标志转移" class="headerlink" title="22.11.2. 条件标志转移"></a>22.11.2. 条件标志转移</h3><p>指令结果影响标志位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JZ (JE) 结果为0或相等   ZF=1</span><br><span class="line">JNZ (JNE) 结果不为0或不相等  ZF=0</span><br><span class="line"></span><br><span class="line">JC     结果有进位 CF=1</span><br><span class="line">JNC结果无进位CF=0</span><br><span class="line"></span><br><span class="line">JS结果为负 SF=1</span><br><span class="line">JNS结果为正 SF=0</span><br><span class="line"></span><br><span class="line">JO结果溢出 OF=1</span><br><span class="line">JNO结果无溢出OF=0</span><br><span class="line"></span><br><span class="line">JP结果为偶数个1    PF=1</span><br><span class="line">JNP结果为奇数个1PF=0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-11-3-CX相关"><a href="#22-11-3-CX相关" class="headerlink" title="22.11.3. CX相关"></a>22.11.3. CX相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：JCXZ OPR</span><br><span class="line">若CX=0则转移</span><br></pre></td></tr></table></figure><h2 id="22-12-循环指令"><a href="#22-12-循环指令" class="headerlink" title="22.12. 循环指令"></a>22.12. 循环指令</h2><p>对状态标志位都没影响</p><h3 id="22-12-1-LOOP"><a href="#22-12-1-LOOP" class="headerlink" title="22.12.1. LOOP"></a>22.12.1. LOOP</h3><ul><li>CX = CX - 1</li><li>CX != 0 时循环</li></ul><h3 id="22-12-2-LOOPZ-LOOPE"><a href="#22-12-2-LOOPZ-LOOPE" class="headerlink" title="22.12.2. LOOPZ/LOOPE"></a>22.12.2. LOOPZ/LOOPE</h3><ul><li>CX = CX - 1</li><li>CX != 0 且 ZF = 1 时循环，ZF = 0 提前退出循环</li></ul><h3 id="22-12-3-LOOPNZ-LOOPNE"><a href="#22-12-3-LOOPNZ-LOOPNE" class="headerlink" title="22.12.3. LOOPNZ/LOOPNE"></a>22.12.3. LOOPNZ/LOOPNE</h3><ul><li>CX = CX - 1</li><li>CX != 0 且 ZF = 0 时循环，ZF = 1 提前退出循环</li></ul><h2 id="22-13-串操作指令"><a href="#22-13-串操作指令" class="headerlink" title="22.13. 串操作指令"></a>22.13. 串操作指令</h2><h3 id="22-13-1-指令格式"><a href="#22-13-1-指令格式" class="headerlink" title="22.13.1. 指令格式"></a>22.13.1. 指令格式</h3><p>唯一源和目标可同时为寄存器的操作指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显式：MOVS  DST, SRC</span><br><span class="line">隐式：MOVSB  ;字节传送</span><br><span class="line">     MOVSW;字传送</span><br><span class="line">     MOVSD;双字传送</span><br></pre></td></tr></table></figure><h3 id="22-13-2-操作数"><a href="#22-13-2-操作数" class="headerlink" title="22.13.2. 操作数"></a>22.13.2. 操作数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">串指令可以处理累加寄存器和存储器操作数。对于存储器操作数应先建立地址指针:</span><br><span class="line"></span><br><span class="line">若为源操作数，则必须把DS：源串首地址放入SI寄存器，缺省情况寻址DS段</span><br><span class="line"></span><br><span class="line">    若为目标操作数，则必须把ES：目标串首地址放入DI寄存器，不允许使用段超越前缀</span><br></pre></td></tr></table></figure><h3 id="22-13-3-地址指针"><a href="#22-13-3-地址指针" class="headerlink" title="22.13.3. 地址指针"></a>22.13.3. 地址指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串指令执行后自动修改地址指针SI、DI</span><br></pre></td></tr></table></figure><h3 id="22-13-4-方向标志"><a href="#22-13-4-方向标志" class="headerlink" title="22.13.4. 方向标志"></a>22.13.4. 方向标志</h3><p>方向标志DF决定地址指针的增减</p><p>CLD 指令 使 DF  = 0</p><p>STD 指令 使 DF = 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">若DF＝0，则地址指针增量</span><br><span class="line">若DF＝1，则地址指针减量</span><br></pre></td></tr></table></figure><h3 id="22-13-5-重复前缀"><a href="#22-13-5-重复前缀" class="headerlink" title="22.13.5. 重复前缀"></a>22.13.5. 重复前缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">串指令前可以加重复前缀REPE／REPZ、 REP或REPNE／REPNZ,使后跟的串指令重复执行</span><br><span class="line"></span><br><span class="line">重复次数应事先初始化在计数器CX中</span><br><span class="line"></span><br><span class="line">串操作指令的重复前缀和LOOP对应</span><br><span class="line"></span><br><span class="line">REP :重复串操作，直到（CX） = 0</span><br><span class="line"></span><br><span class="line">REPZ/REPE :结果为0或相等则重复。若CX != 0 且 ZF = 1，则重复，（CX） = （CX） - 1，直到（CX） = 0。如果结果不为0或不相等则提前退出，此时CX还没减为 0，SI和DI已经增量</span><br><span class="line"></span><br><span class="line">REPNZ/REPNE :结果不为0或不相等则重复。若CX != 0 且 ZF = 0，则重复，（CX） = （CX） - 1，直到（CX） = 0。如果结果为0或相等则提前退出，此时CX还没减为 0，SI和DI已经增量</span><br></pre></td></tr></table></figure><h3 id="22-13-6-操作指令"><a href="#22-13-6-操作指令" class="headerlink" title="22.13.6. 操作指令"></a>22.13.6. 操作指令</h3><p>串操作指令应该和重复前缀一起使用，但不是所有串操作指令前都可以加重复前缀</p><p>串操作指令和重复前缀，其中先执行串操作指令，后执行重复前缀</p><p><strong>串传送</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不影响标志位</span><br><span class="line">MOVS  DST, SRC</span><br><span class="line">REP MOVSB 以字节形式重复传送</span><br></pre></td></tr></table></figure><p><strong>串比较</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果不回送，改变标志位</span><br><span class="line">CMPS</span><br><span class="line">REPE CMPSB 以字节形式重复比较</span><br></pre></td></tr></table></figure><p><strong>串扫描</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果不保存，影响标志位</span><br><span class="line">在目的串中查找与AL、AX中相同或不同的字节或字</span><br><span class="line">SCAS DST</span><br><span class="line">SCASB</span><br></pre></td></tr></table></figure><p><strong>串获取</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前面不加重复指令</span><br><span class="line">不影响标志位</span><br><span class="line">从源串中取出字或字节放入AL、AX中</span><br><span class="line">LODS SRC</span><br><span class="line">LODSB</span><br></pre></td></tr></table></figure><p><strong>串存入</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将AL、AX内容存入目的串中</span><br><span class="line">STOS DST</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-14-高级汇编指令"><a href="#22-14-高级汇编指令" class="headerlink" title="22.14. 高级汇编指令"></a>22.14. 高级汇编指令</h2><h3 id="22-14-1-IF语句"><a href="#22-14-1-IF语句" class="headerlink" title="22.14.1. IF语句"></a>22.14.1. IF语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.IF 条件表达式 </span><br><span class="line">               分支体</span><br><span class="line"> [.ELSEIF 条件表达式 </span><br><span class="line">               分支体 ]</span><br><span class="line"> [.ELSE</span><br><span class="line">            分支体 ]</span><br><span class="line"> .ENDIF ;分支结束</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 例</span><br><span class="line">    .IF ax==5</span><br><span class="line">             mov bx, ax</span><br><span class="line">             mov ax, 0</span><br><span class="line">    .ELSE</span><br><span class="line">             dec  ax</span><br><span class="line">    .ENDIF</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="22-14-2-WHILE语句"><a href="#22-14-2-WHILE语句" class="headerlink" title="22.14.2. WHILE语句"></a>22.14.2. WHILE语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           .WHILE 条件表达式 </span><br><span class="line">                  循环体</span><br><span class="line">           .ENDW</span><br><span class="line"> UNTIL结构格式为：     &gt;=类是按无符号数</span><br><span class="line">           .REPEAT</span><br><span class="line">                  循环体</span><br><span class="line">           .UNTIL 条件表达式 </span><br><span class="line"> UNTIL结构还有一种格式：</span><br><span class="line">           .REPEAT </span><br><span class="line">                  循环体</span><br><span class="line">           .UNTILCXZ [条件表达式] </span><br><span class="line">;cx←cx-1，直到cx=0或条件为真</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="22-15-汇编错误汇总"><a href="#22-15-汇编错误汇总" class="headerlink" title="22.15. 汇编错误汇总"></a>22.15. 汇编错误汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">.MODEL must precede this directive                           .MODEL必须在指令之前</span><br><span class="line">[ELSE]IF2/.ERR2 not allowed : single-pass assembler          [ELSE]IF2/.ERR2不允许单独汇编</span><br><span class="line">assembler limit : macro parameter name table full      汇编限制：宏参数名表已满</span><br><span class="line">can ALIGN only to power of 2                    仅能对齐到2的幂</span><br><span class="line">cannot access label through segment registers        在段寄存器中不能存取标记</span><br><span class="line">cannot access symbol in given segment or group        在特定的段或类不能存取符号</span><br><span class="line">cannot add memory expression and code label                  不能增加内存表达式和代码标记</span><br><span class="line">cannot add two relocatable labels                         不能增加双重转移表标记</span><br><span class="line">cannot define as public or external                     不能定义为公有或外部的</span><br><span class="line">cannot find cvpack.exe                          找不到cvpack.exe</span><br><span class="line">cannot find link.exe                              找不到连接程序</span><br><span class="line">cannot have more than one ELSE clause per IF block            IF段只能有一个ELSE从句</span><br><span class="line">cannot mix 16- and 32-bit registers                 不能结合16位和32位寄存器</span><br><span class="line">cannot open file 不能打开文件</span><br><span class="line">COFF error writing file                      COFF错误，正在写文件</span><br><span class="line">constant expected                         连续预期</span><br><span class="line">constant or relocatable label expected                       预期的转移表或连续的</span><br><span class="line">constant value too large             连续标准太多</span><br><span class="line">count must be positive or zero                              计数必须是零或明确的</span><br><span class="line">count value too large                                        计数标准太多</span><br><span class="line">directive must be in control block                指令必须在控制段</span><br><span class="line">distance invalid for word size of current segment           当前区、段的大小命令无效</span><br><span class="line">DUP too complex                          DUP太复杂</span><br><span class="line">empty (null) string                没有字符串</span><br><span class="line">END directive required at end of file                        END指令必须在文件结尾</span><br><span class="line">error count exceeds 100; stopping assembly             错误数超过100，停止汇编</span><br><span class="line">expected               预定义  </span><br><span class="line">expression expected                   预期表达式</span><br><span class="line">expression must be a code address             表达式必须是一个代码地址</span><br><span class="line">expression too complex for .UNTILCXZ             .UNTILCXZ表达式太复杂</span><br><span class="line">extra characters after statement                           附加的字符在声明之后</span><br><span class="line">FATAL   严重错误</span><br><span class="line">forced error                           强制错误</span><br><span class="line">forced error : string blank                   字符串是空的</span><br><span class="line">forced error : string not blank             字符串不是空的</span><br><span class="line">forced error : strings equal              字符串是相同的</span><br><span class="line">forced error : strings not equal              字符串不是相同的</span><br><span class="line">forced error : symbol defined               符号已定义</span><br><span class="line">forced error : symbol not defined            符号没有定义</span><br><span class="line">forced error : value equal to 0                 标准等于零</span><br><span class="line">forced error : value not equal to 0             标准不等于零</span><br><span class="line">I/O error closing file I/O错误 正在关闭文件</span><br><span class="line">I/O error reading file            I/O错误 正在读取文件</span><br><span class="line">I/O error writing file I/O错误 正在写文件</span><br><span class="line">identifier not a record                      没有记录标示符</span><br><span class="line">identifier too long                       标识符太长</span><br><span class="line">immediate operand not allowed                      当前操作数无法载入</span><br><span class="line">incompatible CPU mode and segment size              不匹配的CPU模式和段尺寸</span><br><span class="line">index value past end of string                              索引标准在字符串结尾之后</span><br><span class="line">initializer magnitude too large for specified size        初始指定尺寸太大</span><br><span class="line">instruction does not allow FAR direct addressing       指令不允许远直接寻址</span><br><span class="line">instruction does not allow FAR indirect addressing      指令不允许远间接寻址</span><br><span class="line">instruction does not allow NEAR indirect addressing      指令不允许近间接寻址</span><br><span class="line">instruction form requires 80386/486                 指令需要80386/486指示   </span><br><span class="line">instruction operand must have size             命令操作数必须有长度</span><br><span class="line">instruction operands must be the same size        命令操作数必须是一样的长度</span><br><span class="line">instruction or register not accepted in current CPU mode   当前CPU模式不认可的指令或寄存器</span><br><span class="line">instruction prefix not allowed                    不允许的命令前缀</span><br><span class="line">Internal Assembler Error                         内部汇编错误</span><br><span class="line">invalid character in file                 文件里有无效字符</span><br><span class="line">invalid command-line option           无效命令行参数</span><br><span class="line">invalid debug and browser data; file exceeds line limit        不能排除故障和浏览数据；文件超过行限制</span><br><span class="line">invalid instruction operands                   无效的指令操作数</span><br><span class="line">invalid INVOKE argument                   无效的INVOKE符号</span><br><span class="line">invalid numerical command-line argument                无效命令行参数</span><br><span class="line">invalid operand for OFFSET                                    OFFSET操作数无效</span><br><span class="line">invalid operand size for instruction            操作数长度对于指令无效</span><br><span class="line">invalid scale value                                无效范围标准</span><br><span class="line">invalid type expression                      无效的类型表达式</span><br><span class="line">invalid use of external absolute                             由于完全外部的使用无效</span><br><span class="line">invalid use of external symbol               使用了无效的外部符号</span><br><span class="line">invalid use of register                     使用的寄存器无效</span><br><span class="line">jump destination must specify a label           跳转目标必须指定一个标记</span><br><span class="line">jump destination too far                            跳转目标太远</span><br><span class="line">jump distance not possible in current CPU mode       跳转距离不适合当前CPU模式</span><br><span class="line">line too long</span><br><span class="line">line too long                  行太长</span><br><span class="line">LOCK must be followed by a memory operation          LOCK指令必须跟在内存操作之后</span><br><span class="line">memory operand not allowed in context                  内存操作数无法载入上下文环境</span><br><span class="line">missing angle bracket or brace in literal         语句里找不到同样的括弧或框架</span><br><span class="line">missing operand after unary operator                 一元运算符之后找不到操作数</span><br><span class="line">missing operand for macro operator             找不到宏的操作数</span><br><span class="line">missing single or double quotation mark in string          找不到单引号或双引号</span><br><span class="line">missing source filename                                找不到源文件名</span><br><span class="line">multiple base registers not allowed             不允许多重基础寄存器</span><br><span class="line">multiple index registers not allowed           不允许多重标志寄存器</span><br><span class="line">must be in segment block                  必须在区、段、块中</span><br><span class="line">must be index or base register                  必须是基础或标志寄存器</span><br><span class="line">nesting level too deep             嵌套过深</span><br><span class="line">no operands allowed for this instruction          指令没有操作数</span><br><span class="line">non-benign record redefinition                      没有利于记录的定义</span><br><span class="line">nondigit in number                   没有总数</span><br><span class="line">operand must be a memory expression             操作数必须是一个内存表达式</span><br><span class="line">operand must be RECORD type or field            操作数必须是RECORD类型或域</span><br><span class="line">operand must be relocatable                                  操作数必须是转移表</span><br><span class="line">operands have different frames                  操作数存在不同的结构</span><br><span class="line">operands must be in same segment              操作数必须在相同的段</span><br><span class="line">operator expected                      预期操作数</span><br><span class="line">out of memory              缺少内存</span><br><span class="line">positive value expected                                      预期的明确的标准</span><br><span class="line">PROC, MACRO, or macro repeat directive must precede LOCAL    PROC, MACRO, 或 macro repeat指令必须在LOCAL之前</span><br><span class="line">real or BCD number not allowed                不允许real或BCD编码</span><br><span class="line">record constants may not span line breaks                 连续记录不能超过行间隔</span><br><span class="line">reserved word expected                      预期的保留字</span><br><span class="line">segment attributes cannot change                        区、段属性不能更换</span><br><span class="line">segment expected                                                预期的区段</span><br><span class="line">segment or group not allowed                               区段或类型不允许</span><br><span class="line">segment register not allowed in context            上下文不允许有寄存器</span><br><span class="line">segment, group, or segment register expected                   预期的段，类型或段寄存器</span><br><span class="line">SEVERE                              严重的错误</span><br><span class="line">statement not allowed inside structure definition         声明不允许在结构里面</span><br><span class="line">statement too complex                                   声明太复杂</span><br><span class="line">statement too complex                    声明太复杂</span><br><span class="line">string or text literal too long                 文本或字符串太长</span><br><span class="line">structure alignment must be 1, 2, 4, 8, or 16             结构对齐必须是1，2，4，8或16</span><br><span class="line">symbol redefinition                         符号已经定义</span><br><span class="line">symbol type conflict                             符号类型冲突</span><br><span class="line">syntax error                                语法错误</span><br><span class="line">syntax error in expression                   表达式存在语法错误</span><br><span class="line">syntax error in floating-point constant           不确定的指向中有语法错误</span><br><span class="line">text item required                       必须的文本项</span><br><span class="line">too many arguments                                     太多参数、定义、冲突</span><br><span class="line">too many bits in RECORD                                      太多位在记录里</span><br><span class="line">too many initial values for structure                太多结构的基础资料</span><br><span class="line">undefined symbol                        符号没有定义</span><br><span class="line">unmatched block nesting                   不正确的区、段嵌套</span><br><span class="line">unmatched macro nesting            不正确的宏嵌套</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC</title>
      <link href="/2024/10/28/2021-06-26-JDBC/"/>
      <url>/2024/10/28/2021-06-26-JDBC/</url>
      
        <content type="html"><![CDATA[<h1 id="1-JDBC简介"><a href="#1-JDBC简介" class="headerlink" title="1. JDBC简介"></a>1. JDBC简介</h1><p>Java Database Connectivity 提供了访问数据库的API，它由一些Java类和接口组成。使用JDBC的应用程序一旦和数据库建立连接，就可以使用JDBC提供的API操作数据库</p><p>JDBC兼容的数据库，包括Oracle、MySQL、Derby、PostgreSQL、SQL Server、H2等</p><p><img src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131044707.jpg" alt="jdbc"></p><h1 id="2-JDBC功能"><a href="#2-JDBC功能" class="headerlink" title="2. JDBC功能"></a>2. JDBC功能</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">与一个数据库建立连接</span><br><span class="line">向已连接的数据库发送SQL语句</span><br><span class="line">处理SQL语句返回的结果</span><br><span class="line">连接数据库方式：使用纯Java数据库驱动程序</span><br></pre></td></tr></table></figure><h1 id="3-JDBC使用（以MySQL为例）"><a href="#3-JDBC使用（以MySQL为例）" class="headerlink" title="3. JDBC使用（以MySQL为例）"></a>3. JDBC使用（以MySQL为例）</h1><p><strong>步骤</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加载驱动</span><br><span class="line">连接数据库DriverManager</span><br><span class="line">获得执行sq|的对象Statement</span><br><span class="line">获得返回的结果集</span><br><span class="line">释放连接</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span> &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">// 注册驱动：不同数据库使用不同驱动串</span></span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;<span class="comment">// 与数据库建立连接</span></span><br><span class="line">            <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/cj?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">sql</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">            <span class="comment">// 向已连接的数据库发送SQL语句</span></span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> sql.executeQuery(<span class="string">&quot;SELECT * FROM cjb&quot;</span>);<span class="comment">// cjb为数据表名</span></span><br><span class="line"><span class="comment">// 处理SQL语句返回的结果</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">xm</span> <span class="operator">=</span> rs.getString(<span class="number">1</span>);</span><br><span class="line">                String pjf=rs.getString(<span class="number">4</span>);</span><br><span class="line">                String yx=rs.getString(<span class="number">6</span>);  </span><br><span class="line">                System.out.println(<span class="string">&quot;姓名:&quot;</span> + xm + <span class="string">&quot;平均分&quot;</span> + pjf + <span class="string">&quot;院系:&quot;</span> + yx);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放连接</span></span><br><span class="line">            rs.close();</span><br><span class="line">            sql.close();</span><br><span class="line">            con.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><p><code>com.mysql.jdbc.Driver</code> 是 mysql-connector-java 5中的</p><p><code>com.mysql.cj.jdbc.Driver</code> 是 mysql-connector-java 6中的</p><p><code>com.mysql.cj.jdbc.Driver</code>， 需要指定时区serverTimezone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serverTimezone=UTC</span><br><span class="line"></span><br><span class="line">在设定时区的时候，如果设定serverTimezone=UTC，会比中国时间早8个小时，如果在中国，可以选择Asia/Shanghai或者Asia/Hongkong</span><br></pre></td></tr></table></figure><p>如果不需要使用SSL连接，需要通过设置 <code>useSSL=false</code>来显式禁用SSL连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useSSL=false</span><br></pre></td></tr></table></figure><h2 id="3-1-DriverManager"><a href="#3-1-DriverManager" class="headerlink" title="3.1. DriverManager"></a>3.1. DriverManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/cj?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br></pre></td></tr></table></figure><p>connection 代表数据库，可实现：数据库设置自动提交、事务提交、事务滚回</p><h2 id="3-2-Statement对象"><a href="#3-2-Statement对象" class="headerlink" title="3.2. Statement对象"></a>3.2. Statement对象</h2><p>用于向数据库发送SQL语句，完成对数据库的增删改查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">    Statement statement=con.createStatement();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(SQLException e)&#123; </span><br><span class="line">    System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现 CRUD</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">statement.executeQuery(<span class="string">&#x27;sql&#x27;</span>); <span class="comment">// 查询操作，返回ResultSet</span></span><br><span class="line">statement.execute(<span class="string">&#x27;sql&#x27;</span>); <span class="comment">// 可执行任何SQL</span></span><br><span class="line">statement.executeupdate(<span class="string">&#x27;sql&#x27;</span>); <span class="comment">// 更新、插入、删除。都是用这个，返回一个受影响的行数</span></span><br></pre></td></tr></table></figure><h2 id="3-3-ResultSet结果集"><a href="#3-3-ResultSet结果集" class="headerlink" title="3.3. ResultSet结果集"></a>3.3. ResultSet结果集</h2><p>封装了所有的查询结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> sql.executeQuery(<span class="string">&quot;select * from 表名&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="3-4-游标"><a href="#3-4-游标" class="headerlink" title="3.4. 游标"></a>3.4. 游标</h2><p>游标是一段内存区域，用于暂时存放受某条SQL语句影响后的数据（如查询后的结果集、DML影响后的记录）。通俗理解就是将这些数据暂时放到了一个内存区域的虚表中，而这个虚表就是游标。</p><p>ResultSet对象使用 <code>next()</code> 方法移动游标，定位某条记录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">xm</span> <span class="operator">=</span> rs.getString(<span class="number">1</span>); </span><br><span class="line">    String pjf=rs.getString(<span class="number">4</span>);  </span><br><span class="line">    String yx=rs.getString(<span class="number">6</span>); </span><br><span class="line">    System.out.println(<span class="string">&quot;姓名:&quot;</span> + xm + <span class="string">&quot;平均分&quot;</span> + pjf + <span class="string">&quot;院系:&quot;</span> + yx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-5-释放资源"><a href="#3-5-释放资源" class="headerlink" title="3.5. 释放资源"></a>3.5. 释放资源</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">sql.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure><h1 id="4-CachedRowSetImpl-类"><a href="#4-CachedRowSetImpl-类" class="headerlink" title="4. CachedRowSetImpl 类"></a>4. CachedRowSetImpl 类</h1><p>程序在使用ResultSet对象中的数据时，必须连接数据库，而CachedRowSetImpl对象不依赖Connnection对象，即把ResultSet对象中的数据保存到CachedRowSetImpl对象中后，就可以关闭和数据库的连接</p><p>CachedRowSetImpl对象可以保存ResultSet对象中的数据</p><p>CachedRowSetImpl对象继承了ResultSet对象的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.*; </span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.rowset.*; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example12_5</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">         Connection con;</span><br><span class="line">         Statement sql; </span><br><span class="line">         ResultSet rs;</span><br><span class="line">         CachedRowSetImpl rowSet;</span><br><span class="line">         <span class="keyword">try</span> &#123; Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);  </span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;&quot;</span>+e);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">try</span>&#123;   </span><br><span class="line">con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/cj?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">sql = con.createStatement();</span><br><span class="line">      rs = sql.executeQuery(<span class="string">&quot;SELECT * FROM cjb&quot;</span>);</span><br><span class="line">            rowSet = <span class="keyword">new</span> <span class="title class_">CachedRowSetImpl</span>();<span class="comment">//创建一个CachedRowSetImpl对象</span></span><br><span class="line">            rowSet.populate(rs);<span class="comment">//</span></span><br><span class="line">            con.close(); <span class="comment">//现在就可以关闭连接了</span></span><br><span class="line">            <span class="keyword">while</span>(rowSet.next())&#123;</span><br><span class="line">                  String number=rowSet.getString(<span class="number">1</span>);</span><br><span class="line">                  String name=rowSet.getString(<span class="number">2</span>);</span><br><span class="line">                  Date birth=rowSet.getDate(<span class="number">3</span>);</span><br><span class="line">                  <span class="type">double</span> height=rowSet.getDouble(<span class="number">4</span>);</span><br><span class="line"> System.out.println(number+<span class="string">&quot;,&quot;</span>+name+<span class="string">&quot;,&quot;</span>+birth+<span class="string">&quot;,&quot;</span>+height);</span><br><span class="line">               &#125;</span><br><span class="line">&#125;</span><br><span class="line">         <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">               System.out.println(e);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-PreparedStatement-类"><a href="#5-PreparedStatement-类" class="headerlink" title="5. PreparedStatement 类"></a>5. PreparedStatement 类</h1><p>执行sql语句时，数据库中的sql解释器把sql语句生成底层的内部命令，然后执行该命令。当执行的sql语句较多时，会增加sql解释器的负担，影响速度。同时Statement对象执行sql存在SQL注入问题</p><p>使用Connection连接对象con调用方法，返回一个生成数据库底层内部命令的预处理对象pre，通过对sql语句进行预编译处理，提前生成数据库底层的内部命令，加快速度，防止SQL注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PreparedStatement pre=con.prepareStatement(<span class="string">&quot;sql语句&quot;</span>)</span><br></pre></td></tr></table></figure><p>手动给参数赋值</p><p>预处理对象调用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ResultSet <span class="title function_">executeQuery</span><span class="params">()</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">executeUpdate</span><span class="params">()</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">execute</span><span class="params">()</span></span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        Connection con;</span><br><span class="line">        PreparedStatement pre;</span><br><span class="line">        ResultSet rs;</span><br><span class="line">        <span class="keyword">try</span> &#123; Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/cj?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            <span class="comment">// 使用 ？ 占位符代替参数</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into users(id,`name`) values(?,?)&quot;</span>;</span><br><span class="line">            <span class="comment">// 预编译sql</span></span><br><span class="line">            pre = con.prepareStatement(sql);</span><br><span class="line">            <span class="comment">// 手动给参数赋值</span></span><br><span class="line">            pre.setInt(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">            pre.setString(<span class="number">2</span>,<span class="string">&quot;laowang&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行</span></span><br><span class="line">            rs = pre.executeUpdate();</span><br><span class="line">          </span><br><span class="line">            rs.close();</span><br><span class="line">            sql.close();</span><br><span class="line">            con.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用预处理语句时可在语句中使用通配符 <code>?</code>代替字段的值，但需要在预处理语句执行之前再设置通配符所表示的具体值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prepareStatement pre=con.prepareStatement</span><br><span class="line">               (<span class="string">&quot;SELECT * FROM message where height&lt;?&quot;</span>)</span><br><span class="line">pre.setDouble(<span class="number">1</span>,<span class="number">1.72</span>);</span><br><span class="line">rs=pre.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似方法：setInt 、setLong 、setFloat 、setString 、setDate </span></span><br></pre></td></tr></table></figure><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6. 事务"></a>6. 事务</h1><p>事务由一组SQL语句组成，指应用程序保证事务中的SQL语句要么全部都执行，要么一个都不执行。</p><p>将connection对象设置非自动提交。con产生的Statement对数据库提交的任何sql语句都是立即生效的，实际应用时，需要多条sql语句同时执行生效或同时不执行。这时用到如下方法，设置connection对象为非自动提交</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>在SQL语句组后使用commit()方法</p><p>提交的多个sql语句不会被执行，这些sql语句构成了一个事务。直到调用commit()方法，让事务中的sql语句全部生效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con.commit()</span><br></pre></td></tr></table></figure><p>提交失败（异常）使用rollback()方法回滚</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123; con.rollback();           </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span>(SQLException exp)&#123;&#125;</span><br><span class="line">      System.out.println(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">work</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        Connection con=<span class="literal">null</span>;</span><br><span class="line">        Statement sql;</span><br><span class="line">        ResultSet rs;</span><br><span class="line">        <span class="keyword">try</span> &#123; Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(ClassNotFoundException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>+e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span>&#123;   <span class="type">double</span> n=<span class="number">50</span>;</span><br><span class="line">            con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://127.0.0.1:3306/cj?serverTimezone=UTC&amp;useSSL=false&amp;useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">            con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            sql=con.createStatement();</span><br><span class="line">            rs=sql.executeQuery(<span class="string">&quot;SELECT * FROM user WHERE number=&#x27;0001&#x27;&quot;</span>);</span><br><span class="line">            rs.next();</span><br><span class="line">            <span class="type">double</span> moneyOne=rs.getDouble(<span class="string">&quot;userMoney&quot;</span>);</span><br><span class="line">            moneyOne=moneyOne-n;</span><br><span class="line">            rs=sql.executeQuery(<span class="string">&quot;SELECT * FROM user WHERE number=&#x27;0002&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">            rs.next();</span><br><span class="line">            <span class="type">double</span> moneyTwo=rs.getDouble(<span class="string">&quot;userMoney&quot;</span>);</span><br><span class="line">            moneyTwo=moneyTwo+n;</span><br><span class="line">            sql.executeUpdate(<span class="string">&quot;UPDATE user SET userMoney =&quot;</span>+moneyOne+<span class="string">&quot; WHERE number=&#x27;0001&#x27;&quot;</span>);</span><br><span class="line">            sql.executeUpdate(<span class="string">&quot;UPDATE user SET userMoney=&quot;</span>+moneyTwo+<span class="string">&quot;WHERE number=&#x27;0002&#x27;&quot;</span>);</span><br><span class="line">            con.commit();</span><br><span class="line">            con.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123; con.rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(SQLException exp)&#123;&#125;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-数据库连接池"><a href="#7-数据库连接池" class="headerlink" title="7. 数据库连接池"></a>7. 数据库连接池</h1><p>池化技术：准备一些预先的资源，过来就使用预先准备好的，用完再放回池中</p><p>编写连接池，实现一个接口 <code>DataSource</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBCP</span><br><span class="line">C3P0</span><br><span class="line">Druid 阿里巴巴</span><br><span class="line">HikariCP springboot2.x默认</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/06/30/2023.06.30/"/>
      <url>/2023/06/30/2023.06.30/</url>
      
        <content type="html"><![CDATA[<h2 id="0-1-我tm来了"><a href="#0-1-我tm来了" class="headerlink" title="0.1 我tm来了"></a>0.1 我tm来了</h2>]]></content>
      
      
      <categories>
          
          <category> new </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
