<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>机器人之家 | 机器人之家</title><meta name="author" content="robotszx"><meta name="copyright" content="robotszx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="笔记根据王爽写，文末总结有指令查询手册 1. 什么是汇编汇编语言提供了一种直接操控CPU、寄存器和内存的工具 2. 第一章2.1. 数的表示在汇编语言中， 数值后面分别用字母B代表二进制（Binary）、 H代表十六进制（Hexadecimal）、 D 代表十进制（Decimal）（十进制数可以省略D） 2.1.1. 进制数三要素 基数 位权 进位  2.1.2. 有符号数0代表非负数，1代表负数">
<meta property="og:type" content="article">
<meta property="og:title" content="机器人之家">
<meta property="og:url" content="https://szx-zhao.github.io/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="机器人之家">
<meta property="og:description" content="笔记根据王爽写，文末总结有指令查询手册 1. 什么是汇编汇编语言提供了一种直接操控CPU、寄存器和内存的工具 2. 第一章2.1. 数的表示在汇编语言中， 数值后面分别用字母B代表二进制（Binary）、 H代表十六进制（Hexadecimal）、 D 代表十进制（Decimal）（十进制数可以省略D） 2.1.1. 进制数三要素 基数 位权 进位  2.1.2. 有符号数0代表非负数，1代表负数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png">
<meta property="article:published_time" content="2024-10-28T12:46:25.006Z">
<meta property="article:modified_time" content="2024-10-17T07:56:20.000Z">
<meta property="article:author" content="robotszx">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png"><link rel="shortcut icon" href="/img/favicon/%E6%9C%BA%E5%99%A8%E4%BA%BA.png"><link rel="canonical" href="https://szx-zhao.github.io/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '机器人之家',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-10-17 15:56:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Avatar/60910068.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png')"><nav id="nav"><span id="blog-info"><a href="/" title="机器人之家"><span class="site-name">机器人之家</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">无题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-28T12:46:25.006Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-17T07:56:20.000Z" title="更新于 2024-10-17 15:56:20">2024-10-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>笔记根据王爽写，文末总结有指令查询手册</p>
<h1 id="1-什么是汇编"><a href="#1-什么是汇编" class="headerlink" title="1. 什么是汇编"></a>1. 什么是汇编</h1><p>汇编语言提供了一种直接操控CPU、寄存器和内存的工具</p>
<h1 id="2-第一章"><a href="#2-第一章" class="headerlink" title="2. 第一章"></a>2. 第一章</h1><h2 id="2-1-数的表示"><a href="#2-1-数的表示" class="headerlink" title="2.1. 数的表示"></a>2.1. 数的表示</h2><p>在汇编语言中， 数值后面分别用字母B代表二进制（Binary）、 H代表十六进制（Hexadecimal）、 D 代表十进制（Decimal）（十进制数可以省略D）</p>
<h3 id="2-1-1-进制数三要素"><a href="#2-1-1-进制数三要素" class="headerlink" title="2.1.1. 进制数三要素"></a>2.1.1. 进制数三要素</h3><ul>
<li>基数</li>
<li>位权</li>
<li>进位</li>
</ul>
<h3 id="2-1-2-有符号数"><a href="#2-1-2-有符号数" class="headerlink" title="2.1.2. 有符号数"></a>2.1.2. 有符号数</h3><p>0代表非负数，1代表负数</p>
<p>根据不同表示方式，分为原码、反码、补码</p>
<h3 id="2-1-3-无符号数"><a href="#2-1-3-无符号数" class="headerlink" title="2.1.3. 无符号数"></a>2.1.3. 无符号数</h3><p>直接使用十六进制表示</p>
<h3 id="2-1-4-机器数"><a href="#2-1-4-机器数" class="headerlink" title="2.1.4. 机器数"></a>2.1.4. 机器数</h3><p>把正负号数值化后，得到的计算机能实际表示的数</p>
<p>包括：原码、反码、补码</p>
<h3 id="2-1-5-真值"><a href="#2-1-5-真值" class="headerlink" title="2.1.5. 真值"></a>2.1.5. 真值</h3><p>带有正负号的实际数值</p>
<h3 id="2-1-6-内存中的数据（重点）"><a href="#2-1-6-内存中的数据（重点）" class="headerlink" title="2.1.6. 内存中的数据（重点）"></a>2.1.6. 内存中的数据（重点）</h3><ul>
<li>数字</li>
</ul>
<p>有符号数存放的是数字的补码的二进制，无符号数直接存放十六进制的二进制</p>
<ul>
<li>字符</li>
</ul>
<p>存放的是字符对应的某种编码的二进制</p>
<h3 id="2-1-7-二进制数"><a href="#2-1-7-二进制数" class="headerlink" title="2.1.7. 二进制数"></a>2.1.7. 二进制数</h3><p>从右向左分别为1位、2位、4位、8位、16位</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>2的n次方</th>
<th>大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>2^10</td>
<td>1024 = 1K</td>
</tr>
<tr>
<td>2^20</td>
<td>1024K = 1M</td>
</tr>
<tr>
<td>2^30</td>
<td>1024M = 1G</td>
</tr>
<tr>
<td>2^40</td>
<td>1024G = 1T</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-1-8-十进制数"><a href="#2-1-8-十进制数" class="headerlink" title="2.1.8. 十进制数"></a>2.1.8. 十进制数</h3><p>从右向左依次为个位、十位、百位、千位、万位</p>
<h3 id="2-1-9-十进制数和二进制数的关系"><a href="#2-1-9-十进制数和二进制数的关系" class="headerlink" title="2.1.9. 十进制数和二进制数的关系"></a>2.1.9. 十进制数和二进制数的关系</h3><p>当二进制产生进位时，代表的十进制数为2、4、8、16、32、64、128</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045676.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045080.jpg" alt=""></p>
<h2 id="2-2-进制转换"><a href="#2-2-进制转换" class="headerlink" title="2.2. 进制转换"></a>2.2. 进制转换</h2><p>在计算机中， 数据都是以二进制表示的， 因此采用2的n次方形式描述数的权值大小。 </p>
<h3 id="2-2-1-十进制与其他进制转换（重点）"><a href="#2-2-1-十进制与其他进制转换（重点）" class="headerlink" title="2.2.1. 十进制与其他进制转换（重点）"></a>2.2.1. 十进制与其他进制转换（重点）</h3><p>十进制整数部分转换为其他进制数采用 “除基取余”法，直到商为0， 小数部分转换采用 “乘基取整”法</p>
<p>例</p>
<p>将十进制数58.125转换为二进制数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045593.jpg" alt=""></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="F:%5C%E7%AC%94%E8%AE%B0%5C%E5%8D%9A%E5%AE%A2%5C%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%5C%E5%8D%81%E8%BD%AC%E4%BA%8C%E5%B0%8F%E6%95%B0.jpg" alt=""></p>
<h3 id="2-2-2-二进制与其他进制转换（重点）"><a href="#2-2-2-二进制与其他进制转换（重点）" class="headerlink" title="2.2.2. 二进制与其他进制转换（重点）"></a>2.2.2. 二进制与其他进制转换（重点）</h3><p><strong>二进制转十进制</strong></p>
<p>按权展开法，小数点前一位，权值为0，小数点后一位权值为-1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">二进制数101101.18 转换为十进制数</span><br><span class="line">101101.1 B = 1 x 2^5 + 0 x 2^4 + 1 x 2^3 + 1 x 2^2 + 0 x 2^1 + 1 x2^0 + 1 x 1^-1 =45.5 D</span><br></pre></td></tr></table></figure>
<p><strong>二进制转十六进制</strong></p>
<p>每四位二进制数转为一位十六进制数。二进制数整数从小数点左边开始每4位一组， 小数则从小数点右边开始每4位一组， 不够位数以0补齐。</p>
<p>注意：整数位补0，对值没有影响，小数位补0对值有影响</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101101 B = 0010 1101.1000 = 2D.8 H</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-十六进制与其他进制转换"><a href="#2-2-3-十六进制与其他进制转换" class="headerlink" title="2.2.3. 十六进制与其他进制转换"></a>2.2.3. 十六进制与其他进制转换</h3><p><strong>十六进制转换为十进制</strong></p>
<p>按位权展开</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十六进制数39C H转换为十进制数</span><br><span class="line">按权展开：</span><br><span class="line">39C H= 3 X 16^2 + 9 X 16^1 + 12 X 16^0 = 924 D</span><br></pre></td></tr></table></figure>
<p><strong>十六进制转换为二进制</strong></p>
<p>每一位十六进制数转位四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧</p>
<h2 id="2-3-进制运算"><a href="#2-3-进制运算" class="headerlink" title="2.3. 进制运算"></a>2.3. 进制运算</h2><h3 id="2-3-1-二进制运算（重点）"><a href="#2-3-1-二进制运算（重点）" class="headerlink" title="2.3.1. 二进制运算（重点）"></a>2.3.1. 二进制运算（重点）</h3><p><strong>加法</strong></p>
<p>对于多位数二进制相加，考虑进位采用“逢2进1”的方式</p>
<p>有4种可能 0+0=0、0+1=1、1+0=1、1+1=10</p>
<p><strong>减法</strong></p>
<p>有4种可能 0-0=0、1-0=1、1-1=0、0-1=1（同时向高位借1，即看作是10 - 1，因为10 = 1+1，所以 10 -1 = 0-1 = 1）</p>
<p><strong>乘法</strong></p>
<p>如果是乘以2，那么只需要左移一位就可以，后面无论是正数还是负数，全部补0</p>
<p><strong>除法</strong></p>
<p>除以2时，向右移一位，如果这个数是正数，那么右移的时候左边补0。<br>如果这个数时负数，那么右移的时候左边补1</p>
<h3 id="2-3-2-十六进制运算"><a href="#2-3-2-十六进制运算" class="headerlink" title="2.3.2. 十六进制运算"></a>2.3.2. 十六进制运算</h3><p><strong>加法</strong></p>
<p><strong>减法</strong></p>
<h2 id="2-4-补码（重点）"><a href="#2-4-补码（重点）" class="headerlink" title="2.4. 补码（重点）"></a>2.4. 补码（重点）</h2><ul>
<li>汇编中数都是以补码的形式表示的</li>
<li>有关补码的运算，要转为二进制再做计算</li>
</ul>
<h3 id="2-4-1-原码"><a href="#2-4-1-原码" class="headerlink" title="2.4.1. 原码"></a>2.4.1. 原码</h3><p>原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1]原 = 0000 0001</span><br><span class="line"></span><br><span class="line">[-1]原 = 1000 0001</span><br></pre></td></tr></table></figure>
<h3 id="2-4-2-反码"><a href="#2-4-2-反码" class="headerlink" title="2.4.2. 反码"></a>2.4.2. 反码</h3><p>正数的反码是其本身</p>
<p>负数的反码是在其原码的基础上，符号位不变，其余各个位取反</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line"></span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure>
<h3 id="2-4-3-补码"><a href="#2-4-3-补码" class="headerlink" title="2.4.3. 补码"></a>2.4.3. 补码</h3><p>正数的补码就是其本身</p>
<p>负数的补码是在其原码的基础上，符号位不变， 其余各位取反，最后+1（即在反码的基础上+1），或 用<code>2^n - |X|</code>表示负数X的补码，n二进制位数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line"></span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure>
<p>8位二进制补码的范围</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">正数 </span><br><span class="line">00000000 B - 01111111 B</span><br><span class="line">00H - 7FH</span><br><span class="line">0 - 127D</span><br><span class="line"></span><br><span class="line">负数</span><br><span class="line">10000000 B - 11111111 B</span><br><span class="line">80H - FFH</span><br><span class="line">-128D - -1D</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-4-4-求补运算"><a href="#2-4-4-求补运算" class="headerlink" title="2.4.4. 求补运算"></a>2.4.4. 求补运算</h3><p>对补码连同符号位一起求反，在末位加1，得到这个数相反数的补码。</p>
<p>即正数的补码求补得到其负数的补码，负数的补码求补得到其正数的补码</p>
<p>求补运算是一种数值运算方法，它与补码表示有所不同。在求补运算中，不考虑数的符号位，对所有位进行按位取反操作，并最后加一。它求得的结果不是求这个数的补码，而是这个数相反数的补码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">机器字长为8位，则－50D 的补码为：</span><br><span class="line">   ＋50的补码为   0011 0010B</span><br><span class="line">   按位求反后为： 1100 1101B</span><br><span class="line">   末位加1 ：     1100 1110B</span><br><span class="line">   则[-50]补＝ 1100 1110 B=0CE H</span><br></pre></td></tr></table></figure>
<h3 id="2-4-5-从补码求真值"><a href="#2-4-5-从补码求真值" class="headerlink" title="2.4.5. 从补码求真值"></a>2.4.5. 从补码求真值</h3><p>正数直接从补码得到真值。负数补码的数值位求反，符号位变为负号，末位加1，就得到其真值</p>
<h3 id="2-4-6-补码的运算规则"><a href="#2-4-6-补码的运算规则" class="headerlink" title="2.4.6. 补码的运算规则"></a>2.4.6. 补码的运算规则</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[A+B]补= [A]补+ [B]补</span><br><span class="line"></span><br><span class="line">[A- B]补= [A]补+ [-B]补</span><br></pre></td></tr></table></figure>
<h3 id="2-4-7-引入补码的意义（重点）"><a href="#2-4-7-引入补码的意义（重点）" class="headerlink" title="2.4.7. 引入补码的意义（重点）"></a>2.4.7. 引入补码的意义（重点）</h3><p>统一了加法和减法运算：在计算机中，加法是一种基本的运算操作，而减法可以通过加法来实现。使用补码可以使加法和减法运算的处理方式保持一致。在补码表示中，减法运算可以转换为加法运算，简化了运算器的设计和实现。</p>
<p>消除了正负数的不对称性：在使用原码表示法时，正数和负数的表示形式不对称，这会给运算和比较操作带来复杂性。而使用补码表示法后，正数和负数的表示形式统一了，使得计算机可以使用相同的硬件逻辑来处理正数和负数的运算，简化了计算机的设计。</p>
<p>增加了数的表示范围：在使用补码表示法中，有限位数的二进制数可以表示更大的数值范围。例如，对于一个8位的二进制数，使用原码表示法可以表示-127到127的范围，而使用补码表示法可以表示-128到127的范围。补码表示法允许使用相同的数值位数表示更广泛的数值范围。</p>
<p>消除了零的重复表示：在使用原码和反码表示法时，零有两个不同的表示形式，即+0和-0，这会引起计算和比较操作的混乱。而在补码表示法中，零只有一种表示形式，消除了零的重复表示问题。</p>
<p>下面看计算十进制的表达式 1-1 = 1 + (-1) = 0的例子</p>
<ul>
<li>使用原码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2</span><br></pre></td></tr></table></figure>
<ul>
<li>使用反码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0</span><br></pre></td></tr></table></figure>
<ul>
<li>补码</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原</span><br></pre></td></tr></table></figure>
<p>这样0用<code>[0000 0000]</code>表示，而以前出现问题的-0则不存在了。而且可以用<code>[1000 0000]</code>表示 -128</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补</span><br></pre></td></tr></table></figure>
<p>注意：-128并没有原码和反码表示。对-128的补码表示<code>[1000 0000]</code>补算出来的原码是<code>[0000 0000]</code>原，这是不正确的</p>
<h2 id="2-5-数的范围"><a href="#2-5-数的范围" class="headerlink" title="2.5. 数的范围"></a>2.5. 数的范围</h2><h3 id="2-5-1-8位二进制所能表示的有符号数范围"><a href="#2-5-1-8位二进制所能表示的有符号数范围" class="headerlink" title="2.5.1. 8位二进制所能表示的有符号数范围"></a>2.5.1. 8位二进制所能表示的有符号数范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1111 1111 ，0111 1111]</span><br><span class="line">即</span><br><span class="line">[-127 ，127]</span><br></pre></td></tr></table></figure>
<p>原码或反码表示的范围为[-127，+127]，而使用补码表示的范围为[-128，127]</p>
<h3 id="2-5-2-8位二进制所能表示的无符号数范围"><a href="#2-5-2-8位二进制所能表示的无符号数范围" class="headerlink" title="2.5.2. 8位二进制所能表示的无符号数范围"></a>2.5.2. 8位二进制所能表示的无符号数范围</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[0000 0000 , 1111 1111]</span><br><span class="line">即</span><br><span class="line">[0 , 255]</span><br></pre></td></tr></table></figure>
<h2 id="2-6-双精度数"><a href="#2-6-双精度数" class="headerlink" title="2.6. 双精度数"></a>2.6. 双精度数</h2><p>16位计算机表示32位数的时候，用两个字长，则称两个十六位数位双精度数</p>
<h3 id="2-6-1-字节-byte"><a href="#2-6-1-字节-byte" class="headerlink" title="2.6.1. 字节(byte)"></a>2.6.1. 字节(byte)</h3><p>一个字节占8个二进制位（bit位）</p>
<h3 id="2-6-2-字"><a href="#2-6-2-字" class="headerlink" title="2.6.2. 字"></a>2.6.2. 字</h3><p>一个字等于两个字节</p>
<h3 id="2-6-3-字长"><a href="#2-6-3-字长" class="headerlink" title="2.6.3. 字长"></a>2.6.3. 字长</h3><p>计算机一次可处理的二进制位数</p>
<h2 id="2-7-存储容量"><a href="#2-7-存储容量" class="headerlink" title="2.7. 存储容量"></a>2.7. 存储容量</h2><h3 id="2-7-1-表示"><a href="#2-7-1-表示" class="headerlink" title="2.7.1. 表示"></a>2.7.1. 表示</h3><p>存储容量可用<code>存储字数(存储单元数)x存储字长</code>表示</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1MB = 1024KB = 1M x 8bit </span><br></pre></td></tr></table></figure>
<h3 id="2-7-2-换算"><a href="#2-7-2-换算" class="headerlink" title="2.7.2. 换算"></a>2.7.2. 换算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1k = 2^10 = 1024</span><br><span class="line">1M = 2^20</span><br><span class="line">1byte = 8bit</span><br><span class="line">1kB = 1024byte</span><br></pre></td></tr></table></figure>
<h2 id="2-8-符号位扩展"><a href="#2-8-符号位扩展" class="headerlink" title="2.8. 符号位扩展"></a>2.8. 符号位扩展</h2><ul>
<li>首先要明确，是有符号数还是无符号数</li>
<li>无符号数扩展，前面补充若干个0</li>
<li>有符号数扩展，最高位是1，前面补充1，最高位是0，前面补充0</li>
</ul>
<h2 id="2-9-进位"><a href="#2-9-进位" class="headerlink" title="2.9. 进位"></a>2.9. 进位</h2><p>由于运算结果超出了位数最高有效位向前的进位，这一位自然丢失，但结果是正确的</p>
<h2 id="2-10-溢出"><a href="#2-10-溢出" class="headerlink" title="2.10. 溢出"></a>2.10. 溢出</h2><p>表示结果超出了字长允许表示的范围，一般会造成结果出错</p>
<ul>
<li><p>两个正数相加得到负数</p>
</li>
<li><p>两个负数相加得到正数</p>
</li>
</ul>
<h2 id="2-11-编码"><a href="#2-11-编码" class="headerlink" title="2.11. 编码"></a>2.11. 编码</h2><p>所谓编码，就是采用按一定规则组合而成的若干位二进制码来表示数或字符</p>
<h3 id="2-11-1-BCD码"><a href="#2-11-1-BCD码" class="headerlink" title="2.11.1. BCD码"></a>2.11.1. BCD码</h3><ul>
<li>对十进制的10个数码用二进制编码表示</li>
<li>只是看起来是用二进制编码表示0~9，在计算时，仍为二进制的计算，所以计算结果需要修正</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li>BCD码可以是8421码、2421码、余3码等</li>
</ul>
<p>BCD码采用四位二进制数表示一位十进制数， 如果这四位二进制数的各位之权自左至右分别为8、4、2、I，则称为8421码</p>
<ul>
<li>压缩的：4位二进制数表示一位十进制数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">85D = 10000101 = 85H</span><br></pre></td></tr></table></figure>
<p>用4位二进制数表示一位十进制数，恰好可以用一位16进制数显示一位十进制数</p>
<ul>
<li>非压缩的：8位二进制数表示一位十进制数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">85D = 000010000 00000101 = 0805H</span><br></pre></td></tr></table></figure>
<p>非压缩的BCD码加上30H, 就转换成了该数字的ASCII码</p>
<h2 id="2-12-ASCII码"><a href="#2-12-ASCII码" class="headerlink" title="2.12. ASCII码"></a>2.12. ASCII码</h2><ul>
<li>标准ASCII码采用7位编码，即一个字节的最高位0，共128种代码</li>
<li>位数从0开始算起</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">大写字母A-Z: 41H-5AH 		</span><br><span class="line">小写字母a-z: 61H-7AH </span><br><span class="line">数字0-9: 30H -39H	</span><br><span class="line"></span><br><span class="line">空格： 20H </span><br><span class="line">回车： ODH </span><br><span class="line">换行： OAH </span><br><span class="line">响铃： 07H</span><br></pre></td></tr></table></figure>
<h1 id="3-第二章"><a href="#3-第二章" class="headerlink" title="3. 第二章"></a>3. 第二章</h1><h2 id="3-1-计算机基本结构"><a href="#3-1-计算机基本结构" class="headerlink" title="3.1. 计算机基本结构"></a>3.1. 计算机基本结构</h2><h3 id="3-1-1-组成（五大件）"><a href="#3-1-1-组成（五大件）" class="headerlink" title="3.1.1. 组成（五大件）"></a>3.1.1. 组成（五大件）</h3><p>运算器、控制器、存储器、输入设备、输出设备</p>
<h3 id="3-1-2-总线"><a href="#3-1-2-总线" class="headerlink" title="3.1.2. 总线"></a>3.1.2. 总线</h3><p><strong>内部总线</strong></p>
<p>CPU内部各个部件间的连线</p>
<p><strong>外部总线（系统总线）</strong></p>
<p>连接主板上各个部件的总线</p>
<p>总线的位数由CPU决定，如8086的地址总线为20位，数据总线为16位</p>
<ul>
<li>地址总线</li>
</ul>
<p>它的宽度（也称为位数）决定了CPU的寻址能力，即CPU可以直接访问的内存或设备的地址范围。例如，如果计算机的地址总线宽度为32位，那么CPU可以寻址的内存或设备地址范围可以达到2^32个（约为4GB）</p>
<ul>
<li>数据总线</li>
</ul>
<p>它的宽度决定了CPU一次可以传输的数据量。例如，如果计算机的数据总线宽度为16位，那么每次数据传输的量为16位（2个字节）。数据总线的宽度直接影响数据传输的速度和效率。</p>
<ul>
<li>控制总线</li>
</ul>
<p>它的宽度决定了CPU对系统中其他设备的控制能力。控制总线传输的信号包括读写控制、中断请求、时钟同步、设备选择等。控制总线的宽度决定了CPU与其他设备之间的控制通路数量和功能。</p>
<h3 id="3-1-3-接口"><a href="#3-1-3-接口" class="headerlink" title="3.1.3. 接口"></a>3.1.3. 接口</h3><p>外部设备和计算机主机间的中间缓存介质</p>
<p><strong>并行接口</strong></p>
<p>多个数据位同时通过多根数据线进行传输。每个数据位占用一根数据线，数据在并行接口中同时进行传输，从而实现高速数据传输。</p>
<p>如 8位数据用8根数据线传输</p>
<p><strong>串行接口</strong></p>
<p>串行接口使用较少的信号线来传输数据，通常只有一根数据线。每个数据位按照顺序依次传输，其中每个数据位之间可能会包含起始位、停止位和校验位等控制信号</p>
<h2 id="3-2-8086CPU"><a href="#3-2-8086CPU" class="headerlink" title="3.2. 8086CPU"></a>3.2. 8086CPU</h2><h3 id="3-2-1-组成"><a href="#3-2-1-组成" class="headerlink" title="3.2.1. 组成"></a>3.2.1. 组成</h3><p><strong>执行单元（EU）</strong></p>
<p>算术逻辑运算单元（ALU）</p>
<p>标志寄存器</p>
<p>暂存器</p>
<p>寄存器组</p>
<p>控制单元</p>
<p><strong>总线接口单元（BIU）</strong></p>
<p>段寄存器组</p>
<p>指令指针寄存器IP</p>
<p>地址加法器</p>
<p>指令队列单元</p>
<p>总线控制系统</p>
<h3 id="3-2-2-内部"><a href="#3-2-2-内部" class="headerlink" title="3.2.2. 内部"></a>3.2.2. 内部</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045988.jpg" alt=""></p>
<h2 id="3-3-8086寄存器"><a href="#3-3-8086寄存器" class="headerlink" title="3.3. 8086寄存器"></a>3.3. 8086寄存器</h2><ul>
<li><p>计算机的字长和处理器的寄存器位数有关</p>
</li>
<li><p>8086寄存器都是16位的</p>
</li>
</ul>
<h3 id="3-3-1-数据寄存器"><a href="#3-3-1-数据寄存器" class="headerlink" title="3.3.1. 数据寄存器"></a>3.3.1. 数据寄存器</h3><p>用来保存操作数或运算结果等信息</p>
<ul>
<li>AX</li>
<li>BX</li>
<li>CX</li>
<li><p>DX</p>
<h3 id="3-3-2-指针寄存器"><a href="#3-3-2-指针寄存器" class="headerlink" title="3.3.2. 指针寄存器"></a>3.3.2. 指针寄存器</h3></li>
<li><p>SP 堆栈指针</p>
</li>
</ul>
<p>指示栈顶的偏移地址，不能再用于其他目的</p>
<ul>
<li>BP 基址指针</li>
</ul>
<p>表示数据在堆栈段中某个单元的偏移地址</p>
<h3 id="3-3-3-变址寄存器"><a href="#3-3-3-变址寄存器" class="headerlink" title="3.3.3. 变址寄存器"></a>3.3.3. 变址寄存器</h3><p>常用于存储器寻址时提供地址</p>
<ul>
<li>SI 源地址</li>
<li>DI 目的地址</li>
</ul>
<p>串操作类指令中，SI 和 DI具有特别的功能</p>
<h3 id="3-3-4-段寄存器"><a href="#3-3-4-段寄存器" class="headerlink" title="3.3.4. 段寄存器"></a>3.3.4. 段寄存器</h3><p>每个段寄存器用来确定一个逻辑段的起始地址，CPU访问内存时由段寄存器提供内存单元的段地址</p>
<ul>
<li>CS 代码段</li>
</ul>
<p>CS寄存器不允许用MOV指令赋值</p>
<p>任意时刻CPU将CS:IP指向的内容作为指令执行，CPU复位后执行的第一条指令位于CS=FFFFH，IP=0000H</p>
<p>从CS:IP指向的内存单元读取指令，存入指令缓冲器</p>
<p>IP = IP + 所读取指令的长度，从而指向下条指令</p>
<p>CPU执行指令缓冲器中的指令</p>
<ul>
<li>DS 数据段</li>
</ul>
<p>通常存放要访问的数据的段地址</p>
<ul>
<li>SS 堆栈段</li>
</ul>
<p>任意时刻SS:SP指向栈顶元素，SS存放栈顶的段地址，SP存放栈顶的偏移地址</p>
<p>栈为空时，SS:SP指向栈最底部单元下面的字单元</p>
<p>SP是16位寄存器，栈的深度是64KB，最多可放32K个字的数据</p>
<ul>
<li>ES 附加段</li>
</ul>
<p>处理器利用ES:EA(有效地址)存取附加段中的数据 v串操作指令将附加段作为其目的操作数的存放区域</p>
<h3 id="3-3-5-控制寄存器"><a href="#3-3-5-控制寄存器" class="headerlink" title="3.3.5. 控制寄存器"></a>3.3.5. 控制寄存器</h3><ul>
<li>IP 指令指针</li>
</ul>
<p>指示代码段中下一条指令的偏移地址</p>
<p>与代码段寄存器 CS 联用（CS:IP），确定下一条指令的物理地址</p>
<ul>
<li>FLAGS 标志寄存器</li>
</ul>
<p>用于反映指令执行结果或控制指令执行形式</p>
<p>共9 个标志，分为6个条件标志码标志和3个控制标志</p>
<ul>
<li>条件码标志</li>
</ul>
<p>CF 进位标志，结果最高位向前进位时(无符号数才考虑进位)</p>
<p>SF 符号标志，结果最高位(符号位)为负时</p>
<p>ZF 零标志，结果为0</p>
<p>OF 溢出标志</p>
<p>AF 辅助进位标志，结果中第3位(半字节)向前进位时</p>
<p>PF 奇偶标志，结果中1的个数为偶数个时</p>
<ul>
<li>控制标志</li>
</ul>
<p>DF 方向标志</p>
<p>IF 中断标志</p>
<p>TF 陷阱标志</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045109.jpg" alt=""></p>
<h3 id="3-3-6-注意"><a href="#3-3-6-注意" class="headerlink" title="3.3.6. 注意"></a>3.3.6. 注意</h3><ul>
<li>进位标志表示无符号数运算结果是否超出范围，运算结果仍然正确</li>
<li>溢出标志表示有符号数运算结果是否超出范围，运算结果不正确</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例1：3AH + 7CH＝B6H  </span><br><span class="line">即00111010 + 01111100 = 10110110</span><br><span class="line">无符号数运算：	58＋124＝182</span><br><span class="line">	范围内，无进位</span><br><span class="line">有符号数运算： 	58＋124＝182</span><br><span class="line">	范围外，有溢出</span><br></pre></td></tr></table></figure>
<h2 id="3-4-内存储器"><a href="#3-4-内存储器" class="headerlink" title="3.4. 内存储器"></a>3.4. 内存储器</h2><h3 id="3-4-1-内存地址"><a href="#3-4-1-内存地址" class="headerlink" title="3.4.1. 内存地址"></a>3.4.1. 内存地址</h3><p>cpu对内存的访问，通过地址总线，地址总线的每一组二进制数对应一个存储单元。</p>
<p>当地址总线只有1根时，只有0、1两个状态，所以对应2个存储单元。当地址总线有2根时，只有00、01、10、11四个状态，所以对应4个存储单元。</p>
<p><strong>地址位数与存储空间关系</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">若地址位数为 n，则CPU可以直接寻址 2^n个存储单元</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-存储单元"><a href="#3-4-2-存储单元" class="headerlink" title="3.4.2. 存储单元"></a>3.4.2. 存储单元</h3><p>在8086中一个实际的存储单元只存放8位二进制数，称为字节单元，存储单元从0开始顺序编号</p>
<p>注意：为方便人阅读，内存和寄存器中数据用十六进制表示</p>
<h3 id="3-4-3-物理地址"><a href="#3-4-3-物理地址" class="headerlink" title="3.4.3. 物理地址"></a>3.4.3. 物理地址</h3><ul>
<li>内存单元的真实地址</li>
<li>存储单元的物理地址是唯一的</li>
<li>CPU直接读取的地址</li>
<li>8086CPU有20根地址线，cpu可直接寻址的存储单元可达 2^20 个，每个存储单元的地址应该用20位二进制数表示，用十六进制表示的范围是 <code>[00000H,FFFFFH]</code></li>
</ul>
<h3 id="3-4-4-逻辑地址"><a href="#3-4-4-逻辑地址" class="headerlink" title="3.4.4. 逻辑地址"></a>3.4.4. 逻辑地址</h3><ul>
<li>不唯一</li>
<li>形式：<code>段地址 : 偏移地址</code></li>
</ul>
<p><strong>段地址（SA）</strong></p>
<p>段地址指逻辑段在主存中的起始位置，必须是分段后的小段的首地址</p>
<p><strong>偏移地址（EA、有效地址）</strong></p>
<p>偏移地址用来定位段中的内存单元</p>
<h3 id="3-4-5-逻辑地址和物理地址的转换"><a href="#3-4-5-逻辑地址和物理地址的转换" class="headerlink" title="3.4.5. 逻辑地址和物理地址的转换"></a>3.4.5. 逻辑地址和物理地址的转换</h3><ul>
<li>由CPU的地址加法器实现</li>
<li><code>段地址 x 16</code> 定位段的起始地址（基础地址）</li>
</ul>
<p>所以段的起始地址一定是16的倍数</p>
<ul>
<li><code>物理地址 = 基础地址 + 偏移地址</code></li>
</ul>
<p>也就是将十六进制的段地址左移1位，再加十六进制的偏移地址</p>
<h3 id="3-4-6-字的传送"><a href="#3-4-6-字的传送" class="headerlink" title="3.4.6. 字的传送"></a>3.4.6. 字的传送</h3><p>因为一个存储单元只存放8位二进制数，即一个字节。只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV BX,1000H</span><br><span class="line">MOV DS,BX</span><br><span class="line"></span><br><span class="line">MOV AX,[0]  表示将起始内存为1000:0000的字数据存放到AX中</span><br><span class="line">MOV AL,[0]  表示将起始内存为1000:0000的字节数据存放到AL中</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当要存放较大的数据时，使用<code>高高低低</code>的方式存放。即低字节存入低地址，高字节存入高地址。表达时，用它的低地址表示多字节数据占据的地址空间。</p>
<p>如</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045365.jpg" alt=""></p>
<p>图中</p>
<p><code>字单元</code>的内容为</p>
<p><code>[00002H]</code> = 1256H</p>
<p><code>双字单元</code>的内容为</p>
<p><code>[00002H]</code> = 67341256H</p>
<h3 id="3-4-7-数据的地址对齐"><a href="#3-4-7-数据的地址对齐" class="headerlink" title="3.4.7. 数据的地址对齐"></a>3.4.7. 数据的地址对齐</h3><ul>
<li>同一个存储器地址可以是字节单元地址、字单元地址、双字单元地址等等。</li>
<li>字单元安排在偶地址（xxx0B）、双字单元安排在模4地址（xx00B）等，被称为”地址对齐“<h3 id="3-4-8-计算某数据区最末单元的物理地址"><a href="#3-4-8-计算某数据区最末单元的物理地址" class="headerlink" title="3.4.8. 计算某数据区最末单元的物理地址"></a>3.4.8. 计算某数据区最末单元的物理地址</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">末单元物理地址=首地址+(N-1)*TYPE</span><br><span class="line"></span><br><span class="line">N为存储区空间大小，单位是字节，因为地址是从0开始，所以要减一</span><br><span class="line"></span><br><span class="line">TYPE 是存储区的数据类型所占存储单元个数，如字节型，值为1，字型为2</span><br></pre></td></tr></table></figure>
<h3 id="3-4-9-存储单元中地址与内容"><a href="#3-4-9-存储单元中地址与内容" class="headerlink" title="3.4.9. 存储单元中地址与内容"></a>3.4.9. 存储单元中地址与内容</h3><p>地址与内容的区分方法是：用括号将地址括起来以代表单元的内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(3075A H) = 12 H 代表3075A H单元中的内容是 12H</span><br><span class="line"></span><br><span class="line">(37692 H) = 5678 H 代表37692 H单元和 37693 H单元一起存放 5678H，该单元是字单元</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-4-10-存储器分段"><a href="#3-4-10-存储器分段" class="headerlink" title="3.4.10. 存储器分段"></a>3.4.10. 存储器分段</h3><p>解决16位字长的机器提供20位地址的问题，段的划分来源于CPU，内存并没有分段</p>
<p><strong>概念</strong></p>
<p>8086CPU将1MB空间分成许多逻辑段</p>
<p>大段：每个段最大限制为64KB（偏移地址是16位的2进制数，所以2^16=64KB），最大可有16个段</p>
<p>小段：每16个字节为一小段，共有64K个（65536）小段</p>
<p>段内单元的地址用16位二进制数表示，称为偏移地址</p>
<p>每小段第一个单元的物理地址称小段首地址</p>
<p>小段首地址的特点是低位为 0H</p>
<p>省略最低位 0H，就可用16位段寄存器保存小段首地址</p>
<p>各个段之间可以重叠</p>
<p><strong>类型</strong></p>
<ul>
<li>代码段</li>
<li>数据段</li>
<li>附加段</li>
<li>堆栈段</li>
</ul>
<p>注意：在汇编程序中，必须有代码段</p>
<h1 id="4-第三章"><a href="#4-第三章" class="headerlink" title="4. 第三章"></a>4. 第三章</h1><p>汇编语言有3种指令</p>
<ul>
<li>汇编指令</li>
</ul>
<p>机器码的助记符，有对应的机器码</p>
<ul>
<li>伪指令</li>
</ul>
<p>没有对应的机器码，由编译器执行，计算机不执行</p>
<ul>
<li>宏指令</li>
</ul>
<p>不同机器对应不同的指令系统</p>
<h2 id="4-1-汇编指令"><a href="#4-1-汇编指令" class="headerlink" title="4.1. 汇编指令"></a>4.1. 汇编指令</h2><h3 id="4-1-1-格式"><a href="#4-1-1-格式" class="headerlink" title="4.1.1. 格式"></a>4.1.1. 格式</h3><p><code>操作码字段 操作数字段</code></p>
<p>操作数用来指明被操作的数的值或数据的存放位置</p>
<p>只有操作码，没有操作数，称为零地址指令</p>
<h3 id="4-1-2-属性"><a href="#4-1-2-属性" class="headerlink" title="4.1.2. 属性"></a>4.1.2. 属性</h3><p><strong>指令长度</strong></p>
<p>以字节为单位</p>
<p><strong>执行时间</strong></p>
<p>以CPU时钟周期为单位</p>
<h3 id="4-1-3-注意"><a href="#4-1-3-注意" class="headerlink" title="4.1.3. 注意"></a>4.1.3. 注意</h3><ul>
<li>符号地址代表位移量</li>
<li><code>[...]</code>代表一个内存单元，<code>[32H]</code>表示偏移地址是32H，<code>[]</code>表示的单元长度可由具体指令中的其他操作对象指出</li>
</ul>
<h2 id="4-2-内存单元的描述"><a href="#4-2-内存单元的描述" class="headerlink" title="4.2. 内存单元的描述"></a>4.2. 内存单元的描述</h2><ul>
<li>内存单元的地址</li>
</ul>
<p><code>[0]</code>表示单元的偏移地址为0</p>
<ul>
<li>内存单元的长度(类型)</li>
</ul>
<p><code>MOV AX,0002H</code></p>
<p><code>MOV AL,02H</code></p>
<h2 id="4-3-指令的寻址"><a href="#4-3-指令的寻址" class="headerlink" title="4.3. 指令的寻址"></a>4.3. 指令的寻址</h2><p>指令的寻址方式有两大类：与数据有关的寻址和与转移地址有关的寻址</p>
<p>寻址方式：指的是指令按什么方式给出操作数或与其有关的地址信息</p>
<h3 id="4-3-1-段前缀（段超越）"><a href="#4-3-1-段前缀（段超越）" class="headerlink" title="4.3.1. 段前缀（段超越）"></a>4.3.1. 段前缀（段超越）</h3><p>与内存有关的寻址中，操作数的段地址默认为数据段，段地址除了在数据段中，还可以在其他三种段中，若放在其他三段中，则称为段超越。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,DS:[2000H]</span><br></pre></td></tr></table></figure>
<h2 id="4-4-数据相关寻址"><a href="#4-4-数据相关寻址" class="headerlink" title="4.4. 数据相关寻址"></a>4.4. 数据相关寻址</h2><p>对数据操作数而言，数据可能在内存中、CPU的寄存器中、或直接写在指令中。若数据不在内存中存放，操作数就没有逻辑地址的概念</p>
<h3 id="4-4-1-立即寻址"><a href="#4-4-1-立即寻址" class="headerlink" title="4.4.1. 立即寻址"></a>4.4.1. 立即寻址</h3><p>操作数直接包含在指令中，紧跟在操作码之后的寻址方式称为立即寻址方式，把该操作数称为立即数</p>
<p>注意：立即寻址方式只能出现在源操作数的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,[32H]</span><br><span class="line">MOV AX,1234H</span><br><span class="line">MOV BX,16</span><br><span class="line">MOV EAX,56H</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-寄存器寻址"><a href="#4-4-2-寄存器寻址" class="headerlink" title="4.4.2. 寄存器寻址"></a>4.4.2. 寄存器寻址</h3><p>操作数直接包含在寄存器中，由指令指定寄存器</p>
<p>注意：寄存器可以是8位、16位、32位通用寄存器或16位段寄存器，但CS不能用于目标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,BX</span><br></pre></td></tr></table></figure>
<h3 id="4-4-3-存储器寻址"><a href="#4-4-3-存储器寻址" class="headerlink" title="4.4.3. 存储器寻址"></a>4.4.3. 存储器寻址</h3><p><strong>直接寻址</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,DS:[2000H]</span><br><span class="line">操作数的有效地址EA直接写在指令中，用括号里的数值作为操作数的偏移地址(有效地址)，操作数的段地址为数据段，由DS指出</span><br><span class="line">注意：不加DS:前缀，汇编时会认为，[2000H]是立即数而不是偏移地址</span><br></pre></td></tr></table></figure>
<p>直接寻址还可以有符号地址(代表位移量)，即为存储单元定义一个变量名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x dw 5678H</span><br><span class="line">MOV AX,X</span><br><span class="line">或</span><br><span class="line">MOV AX,[X]</span><br></pre></td></tr></table></figure>
<p><strong>寄存器间接寻址</strong></p>
<p>有效地址存放在BX，BP或SI、DI中</p>
<p>默认段地址在DS，可使用段超越前缀改变</p>
<p>若使用的是BP，则段地址是SS</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX]</span><br><span class="line">MOV AX,SS:[BP]  这里使用了段超越前缀</span><br></pre></td></tr></table></figure>
<p><strong>寄存器相对寻址</strong></p>
<p>操作数的有效地址是一个基址或变址寄存器的内容再加上8位或16位位移量之和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX+1234H]</span><br><span class="line">MOV AX,VALUE[BX] #符号地址</span><br></pre></td></tr></table></figure>
<p><strong>基址变址寻址</strong></p>
<p>操作数的有效地址是一个基存储器和一个变址寄存器的内容之和。该方法可用于二维表的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[BX+DI]</span><br><span class="line">MOV AX,[BX][DI]</span><br></pre></td></tr></table></figure>
<p><strong>相对基址变址寻址</strong></p>
<p>操作数的有效地址是一个基存储器加一个变址寄存器再加一个位移量。该方法可用于二维查表和栈处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,[MASK+BX+SI]</span><br></pre></td></tr></table></figure>
<p>注意：以上寻址方式得到的地址只是有效地址（偏移地址）简写为EA，段基址与段寄存器有关</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131045451.jpg" alt=""></p>
<ul>
<li>对双操作数指令而言，两个操作数不允许同时用存储器寻址方式</li>
</ul>
<h2 id="4-5-栈"><a href="#4-5-栈" class="headerlink" title="4.5. 栈"></a>4.5. 栈</h2><h3 id="4-5-1-指令"><a href="#4-5-1-指令" class="headerlink" title="4.5.1. 指令"></a>4.5.1. 指令</h3><p>入栈和出栈操作以字单位进行操作</p>
<ul>
<li>pop(出栈)</li>
</ul>
<p>先读取SS:SP处的数据，再改变SP</p>
<p>SP = SP + 2</p>
<ul>
<li>push(入栈)</li>
</ul>
<p>先改变SP，再向SS:SP传送地址</p>
<p>SP = SP + 2</p>
<h3 id="4-5-2-操作"><a href="#4-5-2-操作" class="headerlink" title="4.5.2. 操作"></a>4.5.2. 操作</h3><ul>
<li>任意时刻SS:SP指向栈顶元素，SS存放栈顶的段地址，SP存放栈顶的偏移地址</li>
<li>栈为空时，SS:SP指向栈最底部单元下面的字单元（字单元的低字节的地址）</li>
<li>SP是16位寄存器，栈的深度是64KB，最多可放32K个字的数据</li>
</ul>
<h3 id="4-5-3-计算sp"><a href="#4-5-3-计算sp" class="headerlink" title="4.5.3. 计算sp"></a>4.5.3. 计算sp</h3><p>因为栈的操作单位是字，若定义一个段的范围是<code>10000H~1000FH</code></p>
<ul>
<li>栈中只有一个元素时，SP应该指向<code>1000EH</code>，即为栈的最后一个字单元的低地址</li>
<li>栈空时，SP应该指向100010H，即为栈的最后一个字单元后面的一个字单元的低地址</li>
</ul>
<h3 id="4-5-4-用途"><a href="#4-5-4-用途" class="headerlink" title="4.5.4. 用途"></a>4.5.4. 用途</h3><p>源程序需要暂存数据的时候，一般存在栈中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">;以1000CH-1000FH段内存为栈</span><br><span class="line">MOV AX,1000H</span><br><span class="line">MOV SS,AX</span><br><span class="line">MOV SP,0010H</span><br><span class="line"></span><br><span class="line">MOV AX,001AH	;以字为单位进行操作</span><br><span class="line">MVO BX,001BH</span><br><span class="line"></span><br><span class="line">PUSH AX</span><br><span class="line">PUSH BX</span><br></pre></td></tr></table></figure>
<h1 id="5-Debug使用"><a href="#5-Debug使用" class="headerlink" title="5. Debug使用"></a>5. Debug使用</h1><h2 id="5-1-debug特性"><a href="#5-1-debug特性" class="headerlink" title="5.1. debug特性"></a>5.1. debug特性</h2><ul>
<li>debug 默认是十六进制</li>
<li>不区分大小写</li>
</ul>
<h2 id="5-2-常用指令"><a href="#5-2-常用指令" class="headerlink" title="5.2. 常用指令"></a>5.2. 常用指令</h2><h3 id="5-2-1-R-查改寄存器内容"><a href="#5-2-1-R-查改寄存器内容" class="headerlink" title="5.2.1. R - 查改寄存器内容"></a>5.2.1. R - 查改寄存器内容</h3><p>查看、改变CPU寄存器的内容</p>
<ul>
<li><code>R 寄存器名</code></li>
</ul>
<p>修改寄存器的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046471.jpg" alt=""></p>
<h3 id="5-2-2-D-显示内存单元"><a href="#5-2-2-D-显示内存单元" class="headerlink" title="5.2.2. D - 显示内存单元"></a>5.2.2. D - 显示内存单元</h3><p>查看内存中的内容</p>
<ul>
<li><code>D 段地址:偏移地址</code></li>
</ul>
<p>查看指定内存处的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046468.jpg" alt=""></p>
<p>左边是每行的起始地址</p>
<p>中间是从指定地址开始的128个内存单元的内容，以16进制的形式显示，每行的起始地址都是16的整数倍，每行最多输出16个单元的内容</p>
<p>右边是每个内存单元中的数据对应的可显示的ASCII码</p>
<ul>
<li><code>D 段地址:起始偏移地址 结尾偏移地址</code></li>
</ul>
<p>查看一段内存中的内容</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046462.jpg" alt=""></p>
<h3 id="5-2-3-E-修改内存单元"><a href="#5-2-3-E-修改内存单元" class="headerlink" title="5.2.3. E - 修改内存单元"></a>5.2.3. E - 修改内存单元</h3><p>改写内存中的内容</p>
<ul>
<li><code>E 段地址:起始偏移地址 数据 数据 数据 数据...</code></li>
</ul>
<p>一起修改内存单元的数据</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046770.jpg" alt=""></p>
<ul>
<li><code>E 段地址:起始偏移地址</code></li>
</ul>
<p>一个一个的修改内存单元的数据</p>
<p>输入<code>E 段地址:起始偏移地址</code>后，按Enter键，显示起始地址和第一单元的原始内容，光标停在<code>.</code>后，在<code>.</code>后输入要修改的数据，然后按空格键</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046969.jpg" alt=""></p>
<ul>
<li>内存中写入字符</li>
</ul>
<p>写入字符时，要加单引号</p>
<h3 id="5-2-4-U-反汇编"><a href="#5-2-4-U-反汇编" class="headerlink" title="5.2.4. U - 反汇编"></a>5.2.4. U - 反汇编</h3><p>将内存中的机器指令翻译为汇编指令</p>
<ul>
<li><code>U 段地址:偏移地址</code></li>
<li><code>U 段地址:起始偏移地址 结尾偏移地址</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046511.jpg" alt=""></p>
<p>如</p>
<p>从内存<code>1000：0000</code>处开始写入一段机器码</p>
<p>B80100 对应 MOV AX,0001</p>
<p>B90200 对应 MOV CX,0002</p>
<p>01C8 对应 ADD AX,CX</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046271.jpg" alt=""></p>
<h3 id="5-2-5-T-跟踪"><a href="#5-2-5-T-跟踪" class="headerlink" title="5.2.5. T - 跟踪"></a>5.2.5. T - 跟踪</h3><p>执行一条或多条机器指令，默认执行<code>CS:IP</code>指向的命令</p>
<ul>
<li><code>T =段地址:偏移地址</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046171.jpg" alt=""></p>
<ul>
<li><code>T =段地址:偏移地址 指令条数</code></li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046787.jpg" alt=""></p>
<h3 id="5-2-6-A-汇编"><a href="#5-2-6-A-汇编" class="headerlink" title="5.2.6. A - 汇编"></a>5.2.6. A - 汇编</h3><p>以汇编指令的格式在内存中写入一条机器指令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131046784.jpg" alt=""></p>
<h3 id="5-2-7-P-执行过程"><a href="#5-2-7-P-执行过程" class="headerlink" title="5.2.7. P - 执行过程"></a>5.2.7. P - 执行过程</h3><p>执行一条指令或一个完整的子程序</p>
<p>与T指令类似，当遇到下一条指令是INT 21的时候，要使用P指令来执行命令</p>
<h3 id="5-2-8-Q-退出"><a href="#5-2-8-Q-退出" class="headerlink" title="5.2.8. Q - 退出"></a>5.2.8. Q - 退出</h3><h2 id="5-3-熟悉界面"><a href="#5-3-熟悉界面" class="headerlink" title="5.3. 熟悉界面"></a>5.3. 熟悉界面</h2><ul>
<li>右边显示数据的ASCII码对应的字符</li>
<li>中间显示存储的数据</li>
<li>左边显示</li>
</ul>
<h1 id="6-第四章"><a href="#6-第四章" class="headerlink" title="6. 第四章"></a>6. 第四章</h1><h2 id="6-1-汇编程序"><a href="#6-1-汇编程序" class="headerlink" title="6.1. 汇编程序"></a>6.1. 汇编程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">    MOV AX,3</span><br><span class="line">    MOV BX,5</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-概念"><a href="#6-1-1-概念" class="headerlink" title="6.1.1. 概念"></a>6.1.1. 概念</h3><ul>
<li>源程序</li>
</ul>
<p>汇编文件中的所有内容</p>
<ul>
<li>程序</li>
</ul>
<p>最终由计算机执行的程序</p>
<h3 id="6-1-2-形成"><a href="#6-1-2-形成" class="headerlink" title="6.1.2. 形成"></a>6.1.2. 形成</h3><p>编辑<code>.asm</code>文件    编译生成<code>.obj</code>    连接生成<code>.exe</code>文件</p>
<h3 id="6-1-3-伪指令"><a href="#6-1-3-伪指令" class="headerlink" title="6.1.3. 伪指令"></a>6.1.3. 伪指令</h3><ul>
<li><code>segment</code>和<code>ends</code></li>
</ul>
<p>定义一个段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">段名 segment</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>
<ul>
<li><code>end</code></li>
</ul>
<p>一个汇编程序的结束标记</p>
<p><code>end 标号</code>通知编译器程序的入口，<code>end 标号</code>会被转化为一个入口地址</p>
<p>如</p>
<p>下面源程序中end指明了程序的入口在标号start处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">	CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">    MOV AX,3</span><br><span class="line">    MOV BX,5</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure>
<ul>
<li><code>assume</code></li>
</ul>
<p>将有特定用途的段和相关的段寄存器关联起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将用作代码段的段codesg和寄存器cs关联起来</span><br><span class="line">assume  cs:codesg</span><br></pre></td></tr></table></figure>
<h3 id="6-1-4-标号"><a href="#6-1-4-标号" class="headerlink" title="6.1.4. 标号"></a>6.1.4. 标号</h3><p>一个标号代表一个地址</p>
<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">codesg最终将被处理为一个段的段地址</span><br></pre></td></tr></table></figure>
<h3 id="6-1-5-程序返回"><a href="#6-1-5-程序返回" class="headerlink" title="6.1.5. 程序返回"></a>6.1.5. 程序返回</h3><p>程序P2若要运行，则需要有一个正在运行的P1程序将P2程序加载，然后将CPU的控制权交给P2，P2执行结束后将权限再交给P1，这个过程叫程序返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOV AX,4c00H</span><br><span class="line">int 21H</span><br><span class="line">这两段代码的功能就是程序返回</span><br></pre></td></tr></table></figure>
<h3 id="6-1-6-EXE的加载"><a href="#6-1-6-EXE的加载" class="headerlink" title="6.1.6. EXE的加载"></a>6.1.6. EXE的加载</h3><ul>
<li>程序加载后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0</li>
<li>这个内存区的前256个字节(100H)中存放的是PSP，DOS用来和程序进行通信，256个字节后的空间是存放程序的</li>
<li>PSP的段地址SA</li>
<li>程序存放的物理地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SA x 16 + 0 + 256 = SA x 16 + 16 x 16 </span><br><span class="line">或</span><br><span class="line">SA + 10H : 0</span><br></pre></td></tr></table></figure>
<h2 id="6-2-注意"><a href="#6-2-注意" class="headerlink" title="6.2. 注意"></a>6.2. 注意</h2><p>汇编源程序中，数据不能以字母开头</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffff H 需要写为 0ffff H</span><br></pre></td></tr></table></figure>
<h1 id="7-第五章"><a href="#7-第五章" class="headerlink" title="7. 第五章"></a>7. 第五章</h1><h2 id="7-1-LOOP"><a href="#7-1-LOOP" class="headerlink" title="7.1. LOOP"></a>7.1. LOOP</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	MOV AX,2</span><br><span class="line">	MOV CX,3</span><br><span class="line">S:	ADD AX,AX	;标号S标记了一个地址，这个地址有一条指令	ADD AX,AX</span><br><span class="line">	LOOP S	</span><br><span class="line">	</span><br><span class="line">	MOV AX,4c00H</span><br><span class="line">	INT 21H</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h3 id="7-1-1-格式"><a href="#7-1-1-格式" class="headerlink" title="7.1.1. 格式"></a>7.1.1. 格式</h3><p><code>loop 标号</code></p>
<h3 id="7-1-2-操作"><a href="#7-1-2-操作" class="headerlink" title="7.1.2. 操作"></a>7.1.2. 操作</h3><ul>
<li>CX中的内容减1</li>
<li>判断CX中的值，不为0则转至标号处继续执行，若为0则向下执行</li>
</ul>
<h3 id="7-1-3-使用"><a href="#7-1-3-使用" class="headerlink" title="7.1.3. 使用"></a>7.1.3. 使用</h3><ul>
<li>通常用CX存放循环次数</li>
<li>要使用一个标号，指示循环体的起始地址</li>
<li>循环体应位于标号和loop指令间</li>
<li>当遇到loop时，可使用P指令执行，会自动执行完循环</li>
</ul>
<h3 id="7-1-4-寻址范围"><a href="#7-1-4-寻址范围" class="headerlink" title="7.1.4. 寻址范围"></a>7.1.4. 寻址范围</h3><p>通常段内寻址的范围是<code>[-128,127]</code></p>
<p>loop指令是不允许往后面跳的，所以后127的范围是不生效的，它构成的循环范围是在-128字节之内</p>
<h2 id="7-2-安全空间"><a href="#7-2-安全空间" class="headerlink" title="7.2. 安全空间"></a>7.2. 安全空间</h2><ul>
<li>DOS下，<code>0:200~0:2ff</code>空间是安全空间</li>
<li><p>向内存中写内容时，可以写在安全空间中</p>
<h2 id="7-3-其他"><a href="#7-3-其他" class="headerlink" title="7.3. 其他"></a>7.3. 其他</h2></li>
<li><p>idata</p>
</li>
</ul>
<p>约定符号idata表示常量</p>
<ul>
<li>inc bx</li>
</ul>
<p>将BX中的内容加1</p>
<ul>
<li>dec bx</li>
</ul>
<p>将BX中的内容减1</p>
<h1 id="8-第六章"><a href="#8-第六章" class="headerlink" title="8. 第六章"></a>8. 第六章</h1><p>程序取得所需空间的方法</p>
<ul>
<li>在加载程序的过程中为程序分配</li>
<li>程序在执行的过程中向系统申请</li>
</ul>
<h2 id="8-1-代码段中使用数据"><a href="#8-1-代码段中使用数据" class="headerlink" title="8.1. 代码段中使用数据"></a>8.1. 代码段中使用数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODE</span><br><span class="line">CODE SEGMENT</span><br><span class="line">	DW 0123H,0456H,0789H,0ABCH,0DEFH,0FEDH,0CBAH,0987H</span><br><span class="line">	</span><br><span class="line">	MOV AX,0</span><br><span class="line">	MOV BX,0</span><br><span class="line">	</span><br><span class="line">	MOV CX,8</span><br><span class="line">	</span><br><span class="line">S:	ADD AX,CS:[BX]</span><br><span class="line">	ADD BX,2</span><br><span class="line">	LOOP S</span><br><span class="line">	</span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>
<h3 id="8-1-1-db"><a href="#8-1-1-db" class="headerlink" title="8.1.1. db"></a>8.1.1. db</h3><ul>
<li><p>define byte，定义字节型数据</p>
<h3 id="8-1-2-dw"><a href="#8-1-2-dw" class="headerlink" title="8.1.2. dw"></a>8.1.2. dw</h3></li>
<li><p>define word，定义字型数据</p>
</li>
<li><p>可以通过定义一些值为0的字数据来开辟一段内存空间</p>
</li>
<li><p>在代码段中的最开始部分定义数据，所以第一个数据的偏移地址是0，而段地址就是存放在寄存器CS中的代码段的地址</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES</span><br><span class="line">CODES SEGMENT </span><br><span class="line">;定义数据</span><br><span class="line">START:</span><br><span class="line">;代码</span><br><span class="line">    ADD BX,AX</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h2 id="8-2-多个段的程序"><a href="#8-2-多个段的程序" class="headerlink" title="8.2. 多个段的程序"></a>8.2. 多个段的程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATA,SS:STACK</span><br><span class="line">DATA SEGMENT</span><br><span class="line">	DW 0123H</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK SEGMENT</span><br><span class="line">	DW 0,0,0,0,0</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT </span><br><span class="line">START:</span><br><span class="line">	MOV AX,STACK</span><br><span class="line">	MOV SS,AX</span><br><span class="line">	</span><br><span class="line">	MOV AX,DATA</span><br><span class="line">	MOV DS,AX</span><br><span class="line">	</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h3 id="8-2-1-对段地址的引用"><a href="#8-2-1-对段地址的引用" class="headerlink" title="8.2.1. 对段地址的引用"></a>8.2.1. 对段地址的引用</h3><p>段名就相当于一个标号，它代表了段地址，如<code>MOV AX,STACK</code>表示将名称为<code>STACK</code>的段的段地址送入<code>AX</code>中</p>
<h3 id="8-2-2-多个段的关系"><a href="#8-2-2-多个段的关系" class="headerlink" title="8.2.2. 多个段的关系"></a>8.2.2. 多个段的关系</h3><p>在源程序中定义的多个段，在内存中是连续的，按源程序中的顺序在内存中排列，知道其中一个段的段地址就可以知道其他段的段地址</p>
<h1 id="9-第七章"><a href="#9-第七章" class="headerlink" title="9. 第七章"></a>9. 第七章</h1><h2 id="9-1-and"><a href="#9-1-and" class="headerlink" title="9.1. and"></a>9.1. and</h2><p>将操作对象的指定位设置为0，其他位不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR AL,00100000B</span><br></pre></td></tr></table></figure>
<h2 id="9-2-or"><a href="#9-2-or" class="headerlink" title="9.2. or"></a>9.2. or</h2><p>将操作对象的指定位设置为1，其他位不变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OR AL,00100000B</span><br></pre></td></tr></table></figure>
<h2 id="9-3-字符型数据"><a href="#9-3-字符型数据" class="headerlink" title="9.3. 字符型数据"></a>9.3. 字符型数据</h2><p>字符型数据以<code>&#39;&#39;</code>的形式给出，编译器将它们转为ASCII码，用DB定义</p>
<h2 id="9-4-大小写转换"><a href="#9-4-大小写转换" class="headerlink" title="9.4. 大小写转换"></a>9.4. 大小写转换</h2><p>以ASCII码的二进制来看，大小写字母只有第5位不一样，大写字母第5位为0，小写字母第5位为1</p>
<p>使用or、and可转换大小写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">全部转为小写字母</span><br><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line">DATAS SEGMENT</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">    </span><br><span class="line">START:</span><br><span class="line">    MOV AX,DATAS</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    </span><br><span class="line">    MOV BX,0</span><br><span class="line">    MOV CX,5</span><br><span class="line">S:	MOV AL,[BX]</span><br><span class="line">	OR AL,00100000B</span><br><span class="line">	MOV [BX],AL</span><br><span class="line">	INC BX</span><br><span class="line">	LOOP S</span><br><span class="line">	 </span><br><span class="line">    </span><br><span class="line">    MOV AH,4C00H</span><br><span class="line">    INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h2 id="9-5-定位内存地址"><a href="#9-5-定位内存地址" class="headerlink" title="9.5. 定位内存地址"></a>9.5. 定位内存地址</h2><h3 id="9-5-1-bx-idata"><a href="#9-5-1-bx-idata" class="headerlink" title="9.5.1. [bx + idata]"></a>9.5.1. <code>[bx + idata]</code></h3><p><strong>常见格式</strong></p>
<ul>
<li><code>mov ax,[200 + bx]</code></li>
<li><code>mov ax,200[bx]</code></li>
<li><code>mov ax,[bx].200</code></li>
</ul>
<p><strong>处理数组</strong></p>
<p>当要操作的数据，起始偏移地址不同，但是从起始偏移地址开始的相对地址变化相同时，可以看做是两个长度一样的数组</p>
<p>C语言 <code>a[i]、b[i]</code></p>
<p>汇编 <code>idata1[bx]、idata2[bx]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">将数据段中定义的第一个字符串转为大写，第二个字符串转为小写</span><br><span class="line">ASSUME CS:CODES,DS:DATA</span><br><span class="line">DATA SEGMENT</span><br><span class="line">	DB &#x27;BaSiC&#x27;</span><br><span class="line">	DB &#x27;MinIX&#x27;</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">START:</span><br><span class="line">	MOV AX,DATA</span><br><span class="line">	MOV DS,AX</span><br><span class="line">	</span><br><span class="line">	MOV BX,0</span><br><span class="line">	MOV CX,5</span><br><span class="line">S:	MOV AL,0[BX]</span><br><span class="line">	AND AL,11011111B</span><br><span class="line">	MOV 0[BX],AL</span><br><span class="line">	</span><br><span class="line">	MOV AL,5[BX]</span><br><span class="line">	OR AL,00100000B</span><br><span class="line">	MOV 5[BX],AL</span><br><span class="line">	INC BX</span><br><span class="line">	LOOP S</span><br><span class="line">	</span><br><span class="line">	MOV AX,4C00H</span><br><span class="line">	INT 21H</span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h3 id="9-5-2-bx-si-和-bx-di"><a href="#9-5-2-bx-si-和-bx-di" class="headerlink" title="9.5.2. [bx + si]和[bx + di]"></a>9.5.2. <code>[bx + si]</code>和<code>[bx + di]</code></h3><p><strong>常用格式</strong></p>
<ul>
<li><code>mov ax,[bx][si]</code></li>
</ul>
<h3 id="9-5-3-bx-si-idata-和-bx-di-idata"><a href="#9-5-3-bx-si-idata-和-bx-di-idata" class="headerlink" title="9.5.3. [bx + si + idata]和[bx + di + idata]"></a>9.5.3. <code>[bx + si + idata]</code>和<code>[bx + di + idata]</code></h3><p><strong>常用格式</strong></p>
<ul>
<li><code>mov ax,[bx + 200 + si]</code></li>
<li><code>mov ax,[200 + bx + si]</code></li>
<li><code>mov ax,200[bx][si]</code></li>
<li><code>mov ax,[bx].200[si]</code></li>
<li><code>mov ax,[bx][si].200</code></li>
</ul>
<h3 id="9-5-4-二重循环"><a href="#9-5-4-二重循环" class="headerlink" title="9.5.4. 二重循环"></a>9.5.4. 二重循环</h3><h1 id="10-第八章"><a href="#10-第八章" class="headerlink" title="10. 第八章"></a>10. 第八章</h1><p>reg表示一个寄存器</p>
<p>sreg表示一个段寄存器</p>
<h2 id="10-1-表示的内存地址"><a href="#10-1-表示的内存地址" class="headerlink" title="10.1. [...]表示的内存地址"></a>10.1. <code>[...]</code>表示的内存地址</h2><p><code>[]</code>表示的单元长度可由具体指令中的其他操作对象指出</p>
<h3 id="10-1-1-bx、si、di、bp"><a href="#10-1-1-bx、si、di、bp" class="headerlink" title="10.1.1. bx、si、di、bp"></a>10.1.1. bx、si、di、bp</h3><p>只有bx、si、di、bp可以用在<code>[]</code>中来进行内存单元的寻址</p>
<h3 id="10-1-2-组合"><a href="#10-1-2-组合" class="headerlink" title="10.1.2. 组合"></a>10.1.2. 组合</h3><ul>
<li>bx、si、di、bp 寄存器单个出现</li>
<li>bx和si/di</li>
<li>bp和si/di</li>
</ul>
<h3 id="10-1-3-bp"><a href="#10-1-3-bp" class="headerlink" title="10.1.3. bp"></a>10.1.3. bp</h3><p>只要在<code>[]</code>中使用寄存器bp，且没有显性的给出段地址，段地址就默认在SS中</p>
<h2 id="10-2-指令中数据的长度"><a href="#10-2-指令中数据的长度" class="headerlink" title="10.2. 指令中数据的长度"></a>10.2. 指令中数据的长度</h2><p>在指令中要指明，指令操作的是字型数据还是字节型数据</p>
<h3 id="10-2-1-ptr"><a href="#10-2-1-ptr" class="headerlink" title="10.2.1. ptr"></a>10.2.1. ptr</h3><p>在没有寄存器名的情况下使用<code>操作符 X ptr</code>指明内存单元的长度，<code>X</code>的值为word或byte</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">word ptr指明访问的内存单元是字型</span><br><span class="line">inc word ptr [bx]</span><br><span class="line"></span><br><span class="line">byte ptr指明访问的内存单元是字节型</span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure>
<h2 id="10-3-div"><a href="#10-3-div" class="headerlink" title="10.3. div"></a>10.3. div</h2><p>除法指令</p>
<ul>
<li>格式</li>
</ul>
<p><code>div 寄存器</code>或<code>div 内存单元</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[21]</span><br></pre></td></tr></table></figure>
<ul>
<li>除数</li>
</ul>
<p>有8位和16位两种，在一个寄存器中或内存单元中</p>
<ul>
<li>被除数</li>
</ul>
<p>默认放在AX或AX和DX中</p>
<p>如果除数为8位，被除数为16位，则默认放在AX中</p>
<p>如果除数为16位，被除数为32位，则放在DX和AX中，DX存放高16位，AX存放低16位</p>
<ul>
<li>结果</li>
</ul>
<p>如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数</p>
<p>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</p>
<h2 id="10-4-dd"><a href="#10-4-dd" class="headerlink" title="10.4. dd"></a>10.4. dd</h2><p>double word，定义双字型的数据</p>
<h2 id="10-5-dup"><a href="#10-5-dup" class="headerlink" title="10.5. dup"></a>10.5. dup</h2><p>用来定义重复数据，和db、dw、dd配合使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db 3 dup (0) 相当于 db 0,0,0</span><br><span class="line">db 3 dup (0,1,2) 相当于 db 0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></table></figure>
<h1 id="11-第九章"><a href="#11-第九章" class="headerlink" title="11. 第九章"></a>11. 第九章</h1><h2 id="11-1-转移行为"><a href="#11-1-转移行为" class="headerlink" title="11.1. 转移行为"></a>11.1. 转移行为</h2><h3 id="11-1-1-段内转移"><a href="#11-1-1-段内转移" class="headerlink" title="11.1.1. 段内转移"></a>11.1.1. 段内转移</h3><p>只修改IP</p>
<p><strong>短转移</strong></p>
<p>IP修改范围 <code>-128~127</code>(补码表示)</p>
<p><strong>近转移</strong></p>
<p>IP修改范围 <code>-32768~32767</code>(补码表示)</p>
<h3 id="11-1-2-段间转移"><a href="#11-1-2-段间转移" class="headerlink" title="11.1.2. 段间转移"></a>11.1.2. 段间转移</h3><p>同时修改CS和IP</p>
<h2 id="11-2-操作符offset"><a href="#11-2-操作符offset" class="headerlink" title="11.2. 操作符offset"></a>11.2. 操作符offset</h2><p>由编译器处理，获取标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	start:</span><br><span class="line">	mov ax,offset start		;相当于 mov ax,0</span><br><span class="line">	s:</span><br><span class="line">	mov ax,offset s			;相当于 mov ax,3</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="11-3-转移指令"><a href="#11-3-转移指令" class="headerlink" title="11.3. 转移指令"></a>11.3. 转移指令</h2><h3 id="11-3-1-注"><a href="#11-3-1-注" class="headerlink" title="11.3.1. 注"></a>11.3.1. 注</h3><p>一般的汇编指令中，指令中的idata(立即数)，都会在机器指令中出现</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://blog0912pic.oss-cn-beijing.aliyuncs.com/blog/202409131047119.jpg" alt=""></p>
<h3 id="11-3-2-转移原理"><a href="#11-3-2-转移原理" class="headerlink" title="11.3.2. 转移原理"></a>11.3.2. 转移原理</h3><p><strong>位移转移</strong></p>
<ul>
<li>jmp short 标号</li>
</ul>
<p>段内短转移，转到标号处执行指令</p>
<p>(IP) = (IP) + 8位位移</p>
<p>8位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</p>
<ul>
<li>jmp near ptr 标号</li>
</ul>
<p>段内近转移，转到标号处执行指令</p>
<p>(IP) = (IP) +16位位移</p>
<p>16位位移 = 标号处的地址 - jmp指令后的第一个字节的地址</p>
<p><strong>目的地址转移</strong></p>
<ul>
<li>jmp far ptr 标号</li>
</ul>
<p>段间转移</p>
<p>(CS) = 标号所在段的段地址</p>
<p>(IP) = 标号在段中的偏移地址</p>
<p><strong>地址在寄存器中</strong></p>
<ul>
<li>jmp 16位reg</li>
</ul>
<p>(IP) = (16位reg)</p>
<p><strong>地址在内存中</strong></p>
<ul>
<li>jmp word ptr 内存单元地址</li>
</ul>
<p>段内转移</p>
<p>从内存单元地址处开始存放一个字，是转移的目的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">jmp word ptr ds:[0]		;(IP) = 0123H</span><br></pre></td></tr></table></figure>
<ul>
<li>jmp dword ptr 内存单元地址</li>
</ul>
<p>段间转移</p>
<p>从内存单元地址处开始存放两个字</p>
<p>(CS) = (内存单元地址 + 2)</p>
<p>(IP) = (内存单元地址)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">(CS) = 0</span><br><span class="line">(IP) = 0123H</span><br></pre></td></tr></table></figure>
<h3 id="11-3-3-条件转移"><a href="#11-3-3-条件转移" class="headerlink" title="11.3.3. 条件转移"></a>11.3.3. 条件转移</h3><p>所有条件转移都是短转移，转移位移的范围<code>[-128,127]</code></p>
<ul>
<li>jcxz 标号(OPR)</li>
</ul>
<p>如果(cx) = 0，转移到标号处</p>
<p>(IP) = (IP) + 8位位移</p>
<p>8位位移 = 标号处的地址 - jcxz指令后的第一个字节的地址</p>
<h3 id="11-3-4-loop指令"><a href="#11-3-4-loop指令" class="headerlink" title="11.3.4. loop指令"></a>11.3.4. loop指令</h3><p>所有循环指令都是短转移</p>
<p>如果(cx) != 0，就转移到标号处</p>
<p>(IP) = (IP) + 8位位移</p>
<p>8位位移 = 标号处的地址 - loop指令后的第一个字节的地址</p>
<h3 id="11-3-5-总结"><a href="#11-3-5-总结" class="headerlink" title="11.3.5. 总结"></a>11.3.5. 总结</h3><p>根据位移转移，因为是靠位移来实现在段内进行转移，所以能保证程序在内存的不同位置都能正常执行</p>
<h1 id="12-第十章"><a href="#12-第十章" class="headerlink" title="12. 第十章"></a>12. 第十章</h1><h2 id="12-1-ret"><a href="#12-1-ret" class="headerlink" title="12.1. ret"></a>12.1. ret</h2><p>利用栈中数据修改IP的内容，实现近转移</p>
<p>执行ret指令，相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop IP</span><br></pre></td></tr></table></figure>
<h2 id="12-2-retf"><a href="#12-2-retf" class="headerlink" title="12.2. retf"></a>12.2. retf</h2><p>利用栈中数据修改CS、IP内容，实现远转移</p>
<p>执行retf指令，相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop IP </span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure>
<h2 id="12-3-call"><a href="#12-3-call" class="headerlink" title="12.3. call"></a>12.3. call</h2><p>将当前的IP或CS和IP压入栈中</p>
<p>转移</p>
<h3 id="12-3-1-位移转移"><a href="#12-3-1-位移转移" class="headerlink" title="12.3.1. 位移转移"></a>12.3.1. 位移转移</h3><p>将当前的IP压栈后，转到标号处执行指令</p>
<p>段内直接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL 标号</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="12-3-2-目的地址转移"><a href="#12-3-2-目的地址转移" class="headerlink" title="12.3.2. 目的地址转移"></a>12.3.2. 目的地址转移</h3><p>段间直接远调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALL far ptr 标号</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<h3 id="12-3-3-转移地址在寄存器中"><a href="#12-3-3-转移地址在寄存器中" class="headerlink" title="12.3.3. 转移地址在寄存器中"></a>12.3.3. 转移地址在寄存器中</h3><p>段内间接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL 16位reg</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure>
<h3 id="12-3-4-转移地址在内存中"><a href="#12-3-4-转移地址在内存中" class="headerlink" title="12.3.4. 转移地址在内存中"></a>12.3.4. 转移地址在内存中</h3><p>段内间接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CALL WORD PTR 内存单元地址</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<p>段间间接调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CALL DWORD PTR 内存单元地址</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h1 id="13-第十一章"><a href="#13-第十一章" class="headerlink" title="13. 第十一章"></a>13. 第十一章</h1><h2 id="13-1-标志寄存器"><a href="#13-1-标志寄存器" class="headerlink" title="13.1. 标志寄存器"></a>13.1. 标志寄存器</h2><h3 id="13-1-1-规律"><a href="#13-1-1-规律" class="headerlink" title="13.1.1. 规律"></a>13.1.1. 规律</h3><ul>
<li>大多数运算指令都影响标志位</li>
</ul>
<p>add、sub、mul、div、inc、or、and等</p>
<ul>
<li>大多数传送指令都不影响标志位</li>
</ul>
<p>mov、push、pop</p>
<h3 id="13-1-2-flag寄存器"><a href="#13-1-2-flag寄存器" class="headerlink" title="13.1.2. flag寄存器"></a>13.1.2. flag寄存器</h3><p>按位起作用(共16位)</p>
<p>0、2、4、6、7、8、9、10、11位都有特殊含义</p>
<h3 id="13-1-3-标志"><a href="#13-1-3-标志" class="headerlink" title="13.1.3. 标志"></a>13.1.3. 标志</h3><p>标志寄存器中的某个标志，值为1表示有某种状态，为0表示无某种状态</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZF</td>
<td>记录指令执行后，其结果是否为0</td>
</tr>
<tr>
<td>PF</td>
<td>记录指令执行后，其结果所有bit位中1的个数是否为偶数</td>
</tr>
<tr>
<td>SF</td>
<td>记录指令执行后，其结果是否为负</td>
</tr>
<tr>
<td>CF</td>
<td>进行无符号数计算时，记录其结果的最高有效位向更高位的进位值或从更高位的借位值</td>
</tr>
<tr>
<td>OF</td>
<td>有符号数运算后，其结果是否产生溢出</td>
</tr>
<tr>
<td>DF</td>
<td>串操作指令中，控制每次操作后SI、DI的增减</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h1 id="14-分支程序"><a href="#14-分支程序" class="headerlink" title="14. 分支程序"></a>14. 分支程序</h1><p>分支程序要统一入口，出口</p>
<h2 id="14-1-位操作的分支程序"><a href="#14-1-位操作的分支程序" class="headerlink" title="14.1. 位操作的分支程序"></a>14.1. 位操作的分支程序</h2><p>如 test指令</p>
<h2 id="14-2-菜单法"><a href="#14-2-菜单法" class="headerlink" title="14.2. 菜单法"></a>14.2. 菜单法</h2><h3 id="14-2-1-原理"><a href="#14-2-1-原理" class="headerlink" title="14.2.1. 原理"></a>14.2.1. 原理</h3><p>主要利用比较指令判断输入的菜单号，然后利用条件转移指令跳转到指定程序执行</p>
<h3 id="14-2-2-缺点"><a href="#14-2-2-缺点" class="headerlink" title="14.2.2. 缺点"></a>14.2.2. 缺点</h3><p>菜单项较多时，需要使用较多的比较指令和条件转移指令，程序冗长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">         mov al,x</span><br><span class="line">	       CMP	Al，0	  ;与0进行比较</span><br><span class="line">	       JGE	A1	       ;X≥0转A1</span><br><span class="line">	       MOV	Y，-1	  ;X ＜0时，-1→Y</span><br><span class="line">	       JMP	EXIT</span><br><span class="line">A1：     JG	A2 	       	   ;X＞0转</span><br><span class="line">	       MOV	Y，0	       ;X=0时，0→Y</span><br><span class="line">	       JMP	EXIT</span><br><span class="line">A2：     MOV	Y，1	       	  ;X＞0，1→Y </span><br><span class="line"></span><br><span class="line">EXIT：   MOV	AH，4CH</span><br><span class="line">	       INT	21H </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="14-3-跳转表法"><a href="#14-3-跳转表法" class="headerlink" title="14.3. 跳转表法"></a>14.3. 跳转表法</h2><p>跳转表法，表中顺序存放着进入各分支处理程序的程序段名(标号)或转移指令，称它们为跳转表的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">1．跳转表中存放多分支程序的偏移地址(标号)</span><br><span class="line">2．跳转表中存放多分支程序的转移指令</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">DATAS SEGMENT</span><br><span class="line">    BASE   DW SUB1,SUB2,SUB3,SUB4,SUB5,……</span><br><span class="line">    BN     DB 3   </span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">      MOV AL, BN      </span><br><span class="line">      MOV AH, 0</span><br><span class="line">      DEC AL          ;建索引号</span><br><span class="line">      SHL AL, 1       ; (3-1)*2</span><br><span class="line">      MOV BX, OFFSET  BASE  ;?不用XLAT?</span><br><span class="line">      ADD BX, AX      ;求功能3的有效地址 </span><br><span class="line">      MOV BX, [BX];      jmp near ptr  [bx]</span><br><span class="line">      JMP BX       ;BX中存放具体标号(SUB3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SUB1: ....</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">SUB2: ....</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">SUB3: .......</span><br><span class="line">      JMP EXIT</span><br><span class="line">      .....</span><br><span class="line">      .....</span><br><span class="line">SUB8: .....</span><br><span class="line">      JMP EXIT</span><br><span class="line">EXIT:</span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="15-循环程序"><a href="#15-循环程序" class="headerlink" title="15. 循环程序"></a>15. 循环程序</h1><p>找出循环体最后结果的输出点</p>
<h2 id="15-1-先判断，后执行"><a href="#15-1-先判断，后执行" class="headerlink" title="15.1. 先判断，后执行"></a>15.1. 先判断，后执行</h2><p>CMP</p>
<h2 id="15-2-先执行，后判断"><a href="#15-2-先执行，后判断" class="headerlink" title="15.2. 先执行，后判断"></a>15.2. 先执行，后判断</h2><p>LOOP</p>
<h1 id="16-串操作"><a href="#16-串操作" class="headerlink" title="16. 串操作"></a>16. 串操作</h1><h2 id="16-1-概念"><a href="#16-1-概念" class="headerlink" title="16.1. 概念"></a>16.1. 概念</h2><p>连续n 个存储单元称为串、表、数组等</p>
<h2 id="16-2-处理"><a href="#16-2-处理" class="headerlink" title="16.2. 处理"></a>16.2. 处理</h2><ul>
<li>串操作指令把附加段作为目的操作数的存放区域</li>
</ul>
<p>可以定义一个附加段，也可以把数据段、附加段定义为同一个段</p>
<h1 id="17-多重循环"><a href="#17-多重循环" class="headerlink" title="17. 多重循环"></a>17. 多重循环</h1><p>用两条loop指令实现双重循环时，对CX有冲突，可以用push CX，将外循环的CX进栈保存，内循环的LOOP结束后，再将外循环的CX恢复</p>
<h2 id="17-1-常用循环控制方法"><a href="#17-1-常用循环控制方法" class="headerlink" title="17.1. 常用循环控制方法"></a>17.1. 常用循环控制方法</h2><ul>
<li>计数器控制法：循环次数已知</li>
<li>条件控制法：循环次数未知</li>
<li>逻辑尺控制法：将标志位放入存储单元，存储单元就称为逻辑尺</li>
</ul>
<h2 id="17-2-内外循环的控制"><a href="#17-2-内外循环的控制" class="headerlink" title="17.2. 内外循环的控制"></a>17.2. 内外循环的控制</h2><p>不允许内外循环交叉</p>
<h2 id="17-3-内外循环的跳转"><a href="#17-3-内外循环的跳转" class="headerlink" title="17.3. 内外循环的跳转"></a>17.3. 内外循环的跳转</h2><p>只允许从内向外跳，不允许从外向内跳</p>
<p>例</p>
<p>用冒泡排序，实现升序排列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS,SS:STACKS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">   buf DW 12,32,45,1,33       ;要排序的数</span><br><span class="line">   COUNT DW ?      ;数组元素个数</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">STACKS SEGMENT</span><br><span class="line">    ;此处输入堆栈段代码</span><br><span class="line">STACKS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">	MOV AX,DATAS</span><br><span class="line">	MOV DS,AX</span><br><span class="line">    </span><br><span class="line">	;此段代码，按冒泡排序，小到大</span><br><span class="line">	MOV CX,COUNT	#count 记录数组长度</span><br><span class="line">	DEC CX		;记录循环次数</span><br><span class="line">	</span><br><span class="line">lp1:			;外循环</span><br><span class="line">	PUSH CX		;记录外循环次数</span><br><span class="line">	MOV BX,0</span><br><span class="line">					</span><br><span class="line">lp2:    		;内循环</span><br><span class="line">	MOV AX,buf[BX]</span><br><span class="line">	CMP AX,buf[BX+2]	;比较大小</span><br><span class="line">	JLE next</span><br><span class="line">	XCHG AX,buf[BX+2]</span><br><span class="line">	MOV buf[BX],AX</span><br><span class="line">	</span><br><span class="line">next:	</span><br><span class="line">	ADD BX,2</span><br><span class="line">	LOOP lp2</span><br><span class="line">	POP CX		;恢复外循环次数</span><br><span class="line">	LOOP lp1</span><br><span class="line"></span><br><span class="line">finish:	</span><br><span class="line">	MOV AH,4CH</span><br><span class="line">	INT 21H</span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure>
<h1 id="18-子程序"><a href="#18-子程序" class="headerlink" title="18. 子程序"></a>18. 子程序</h1><h2 id="18-1-概念"><a href="#18-1-概念" class="headerlink" title="18.1. 概念"></a>18.1. 概念</h2><p>一个具有一定功能的程序段，子程序又叫过程</p>
<h2 id="18-2-定义子程序"><a href="#18-2-定义子程序" class="headerlink" title="18.2. 定义子程序"></a>18.2. 定义子程序</h2><h3 id="18-2-1-方法一"><a href="#18-2-1-方法一" class="headerlink" title="18.2.1. 方法一"></a>18.2.1. 方法一</h3><p>将子程序第一条指令的标号作为子程序名调用(使用call调用)</p>
<h3 id="18-2-2-方法二"><a href="#18-2-2-方法二" class="headerlink" title="18.2.2. 方法二"></a>18.2.2. 方法二</h3><p>伪指令proc</p>
<p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc 属性       </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">子程序名 endp</span><br><span class="line"></span><br><span class="line">注：属性为 near或far</span><br><span class="line"></span><br><span class="line">属性的确定原则：</span><br><span class="line">1.主程序和子程序在同一个代码段内，用near</span><br><span class="line">2.主程序和子程序不在同一个代码段内，用far</span><br><span class="line">3.主程序是第一个被执行的程序，则主程序应定义为far(相对DOS系统来讲)</span><br></pre></td></tr></table></figure>
<h2 id="18-3-call执行子程序"><a href="#18-3-call执行子程序" class="headerlink" title="18.3. call执行子程序"></a>18.3. call执行子程序</h2><p>用call指令转去执行子程序，跳转之前call指令后面的指令的地址将存储在栈中</p>
<h2 id="18-4-现场保护"><a href="#18-4-现场保护" class="headerlink" title="18.4. 现场保护"></a>18.4. 现场保护</h2><p>为防止主程序中用寄存器存的数据被子程序覆盖，将主程序中用到的所有寄存器中的内容存入栈中，在子程序返回前再恢复</p>
<h2 id="18-5-参数和结果的传递"><a href="#18-5-参数和结果的传递" class="headerlink" title="18.5. 参数和结果的传递"></a>18.5. 参数和结果的传递</h2><p>如何将值传递给子程序去执行，然后将结果返回到主程序</p>
<h3 id="18-5-1-方法一"><a href="#18-5-1-方法一" class="headerlink" title="18.5.1. 方法一"></a>18.5.1. 方法一</h3><p>将数据存入内存中，然后传递其所在内存空间的首地址</p>
<h3 id="18-5-2-方法二"><a href="#18-5-2-方法二" class="headerlink" title="18.5.2. 方法二"></a>18.5.2. 方法二</h3><p>使用栈</p>
<h1 id="19-嵌套与递归"><a href="#19-嵌套与递归" class="headerlink" title="19. 嵌套与递归"></a>19. 嵌套与递归</h1><h2 id="19-1-子程序嵌套"><a href="#19-1-子程序嵌套" class="headerlink" title="19.1. 子程序嵌套"></a>19.1. 子程序嵌套</h2><h2 id="19-2-子程序递归"><a href="#19-2-子程序递归" class="headerlink" title="19.2. 子程序递归"></a>19.2. 子程序递归</h2><h1 id="20-宏汇编"><a href="#20-宏汇编" class="headerlink" title="20. 宏汇编"></a>20. 宏汇编</h1><h2 id="20-1-概念"><a href="#20-1-概念" class="headerlink" title="20.1. 概念"></a>20.1. 概念</h2><p>宏是源程序中具有一段独立功能的程序代码</p>
<h2 id="20-2-宏使用"><a href="#20-2-宏使用" class="headerlink" title="20.2. 宏使用"></a>20.2. 宏使用</h2><h3 id="20-2-1-宏定义"><a href="#20-2-1-宏定义" class="headerlink" title="20.2.1. 宏定义"></a>20.2.1. 宏定义</h3><p>一对伪指令MACRO、ENDM</p>
<p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">宏名字 MACRO 哑元1,哑元2,哑元3...</span><br><span class="line">	语句串</span><br><span class="line">	ENDM</span><br><span class="line">说明：</span><br><span class="line">语句串代表宏定义体，即具体的程序代码</span><br><span class="line">哑元代表形参，用逗号分割，可以没有形参，和哑元对应的是实元，相当于实参(实元和哑元统称为变元)</span><br><span class="line"></span><br><span class="line">例</span><br><span class="line">两数相加宏指令</span><br><span class="line">SUMM MACRO x1,x2,x3</span><br><span class="line">	MOV AX,x1</span><br><span class="line">	ADD AX,x2</span><br><span class="line">	MOV X3,AX</span><br><span class="line">	ENDM</span><br></pre></td></tr></table></figure>
<h3 id="20-2-2-宏调用"><a href="#20-2-2-宏调用" class="headerlink" title="20.2.2. 宏调用"></a>20.2.2. 宏调用</h3><p>使用宏时，直接写出宏的名称即可，若有参数，后面跟上参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例</span><br><span class="line">调用宏SUMM实现(BX) = 34 + 25</span><br><span class="line">SUMM 34,25,BX</span><br></pre></td></tr></table></figure>
<h3 id="20-2-3-宏展开"><a href="#20-2-3-宏展开" class="headerlink" title="20.2.3. 宏展开"></a>20.2.3. 宏展开</h3><p>源程序在汇编时，宏指令会被汇编程序用相应的代码替换(用宏定义体替换)</p>
<h2 id="20-3-宏参数"><a href="#20-3-宏参数" class="headerlink" title="20.3. 宏参数"></a>20.3. 宏参数</h2><h3 id="20-3-1-变元是操作数"><a href="#20-3-1-变元是操作数" class="headerlink" title="20.3.1. 变元是操作数"></a>20.3.1. 变元是操作数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">	MOV AX,x1</span><br><span class="line">	ADD AX,x2</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<h3 id="20-3-2-变元是操作码"><a href="#20-3-2-变元是操作码" class="headerlink" title="20.3.2. 变元是操作码"></a>20.3.2. 变元是操作码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">	x1 AX,2</span><br><span class="line">	x2 AX,3</span><br><span class="line">ENDM</span><br></pre></td></tr></table></figure>
<h3 id="20-3-3-变元是操作码的一部分"><a href="#20-3-3-变元是操作码的一部分" class="headerlink" title="20.3.3. 变元是操作码的一部分"></a>20.3.3. 变元是操作码的一部分</h3><p>用<code>&amp;</code>作为分隔符，变元替换掉<code>&amp;</code>后面的字符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2</span><br><span class="line">	MO&amp;x1 AX,2</span><br><span class="line">	AD&amp;x2 AX,3</span><br><span class="line">ENDM</span><br><span class="line">宏调用</span><br><span class="line">TEST V,D </span><br><span class="line">等价于</span><br><span class="line">	MOV AX,2</span><br><span class="line">	ADD AX,3</span><br></pre></td></tr></table></figure>
<h3 id="20-3-4-变元是存储单元"><a href="#20-3-4-变元是存储单元" class="headerlink" title="20.3.4. 变元是存储单元"></a>20.3.4. 变元是存储单元</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1,x2,x3</span><br><span class="line">	x1 DB x2 DUP(x3)</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">宏调用</span><br><span class="line">TEST SS,6,5</span><br><span class="line">等价于</span><br><span class="line">SS DB 6 DUP(5)</span><br></pre></td></tr></table></figure>
<h3 id="20-3-5-变元是字符串"><a href="#20-3-5-变元是字符串" class="headerlink" title="20.3.5. 变元是字符串"></a>20.3.5. 变元是字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TEST MACRO x1</span><br><span class="line">	SS DB &#x27;Number &amp;x1&#x27;,&#x27;$&#x27;</span><br><span class="line">ENDM</span><br><span class="line"></span><br><span class="line">宏调用</span><br><span class="line">TEST abc</span><br><span class="line">等价于</span><br><span class="line">SS DB &#x27;Number abc&#x27;,&#x27;$&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="20-4-宏运算"><a href="#20-4-宏运算" class="headerlink" title="20.4. 宏运算"></a>20.4. 宏运算</h2><p>5种</p>
<ul>
<li><code>&amp;</code></li>
</ul>
<p>替换运算</p>
<ul>
<li><code>&lt;&gt;</code></li>
</ul>
<p>传递运算</p>
<p>如果实元是含有空格的字符串，则实元要用<code>&lt;&gt;</code>括起来</p>
<ul>
<li><code>!</code></li>
</ul>
<p>转义运算</p>
<p>当字符串中含有<code>&lt;</code>或<code>&gt;</code>时，为防止与传递运算符冲突，用<code>!&gt;</code>或<code>!&lt;</code>来转义</p>
<ul>
<li><code>%</code></li>
</ul>
<p>表达式运算</p>
<p>如果实元中有表达式，<code>%</code>将表达式的值作为实元</p>
<p>如<code>TEST % 35+12</code></p>
<ul>
<li><code>;;</code></li>
</ul>
<p>宏注释</p>
<h2 id="20-5-宏和子程序"><a href="#20-5-宏和子程序" class="headerlink" title="20.5. 宏和子程序"></a>20.5. 宏和子程序</h2><h3 id="20-5-1-区别"><a href="#20-5-1-区别" class="headerlink" title="20.5.1. 区别"></a>20.5.1. 区别</h3><ul>
<li>子程序是能够实现一定功能的代码，使用方法只能是跳转到子程序所在位置去执行，不能传参数</li>
<li>宏类似高级语言的自定义函数，可以传参数</li>
</ul>
<h3 id="20-5-2-优缺点"><a href="#20-5-2-优缺点" class="headerlink" title="20.5.2. 优缺点"></a>20.5.2. 优缺点</h3><ul>
<li>当传递参数较多时，可优先考虑宏</li>
<li>宏使用过多，会导致主程序代码太长，占用内存空间过大</li>
<li>当程序较长或对内存空间有要求时，可优先考虑子程序</li>
</ul>
<h1 id="21-中断"><a href="#21-中断" class="headerlink" title="21. 中断"></a>21. 中断</h1><h2 id="21-1-外中断"><a href="#21-1-外中断" class="headerlink" title="21.1. 外中断"></a>21.1. 外中断</h2><p>硬中断</p>
<h2 id="21-2-内中断"><a href="#21-2-内中断" class="headerlink" title="21.2. 内中断"></a>21.2. 内中断</h2><p>软中断</p>
<h1 id="22-查询手册"><a href="#22-查询手册" class="headerlink" title="22. 查询手册"></a>22. 查询手册</h1><h2 id="22-1-如何学习指令"><a href="#22-1-如何学习指令" class="headerlink" title="22.1. 如何学习指令"></a>22.1. 如何学习指令</h2><ul>
<li>操作数是单还是双</li>
<li>操作数的类型要求(有符号、无符号、一个地址、立即数…)</li>
<li>指令执行了哪些操作</li>
<li>是否影响标志位</li>
<li>结果是否回送</li>
</ul>
<h2 id="22-2-指令分类"><a href="#22-2-指令分类" class="headerlink" title="22.2. 指令分类"></a>22.2. 指令分类</h2><ul>
<li>汇编指令(计算机执行)</li>
<li>伪指令(编译器执行)</li>
<li>宏指令</li>
</ul>
<h2 id="22-3-伪指令"><a href="#22-3-伪指令" class="headerlink" title="22.3. 伪指令"></a>22.3. 伪指令</h2><h3 id="22-3-1-定义段"><a href="#22-3-1-定义段" class="headerlink" title="22.3.1. 定义段"></a>22.3.1. 定义段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">段名 segment </span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>
<h3 id="22-3-2-ASSUME"><a href="#22-3-2-ASSUME" class="headerlink" title="22.3.2. ASSUME"></a>22.3.2. ASSUME</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume 段寄存器:段名</span><br></pre></td></tr></table></figure>
<h3 id="22-3-3-数据定义"><a href="#22-3-3-数据定义" class="headerlink" title="22.3.3. 数据定义"></a>22.3.3. 数据定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(变量名)存储单元名 DB 操作数</span><br><span class="line"></span><br><span class="line">DB 个数 dup(?)  ;重复定义相同操作数</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">一条数据定义指令，可为多个存储单元赋值</span><br><span class="line">操作数默认是10进制的，定义16进制后面加H</span><br><span class="line">数字不能以字母开头，前面要加0</span><br><span class="line">操作数可为 ? 表示为变量预留空间而不赋初值</span><br><span class="line">操作数可为表达式，表达式会先计算，再将结果存到存储单元</span><br><span class="line">操作数若为字符串，要用单引号包围</span><br><span class="line">字符串应使用DB定义，存入的是字符串的ASCII码</span><br></pre></td></tr></table></figure>
<h3 id="22-3-4-赋值伪指令"><a href="#22-3-4-赋值伪指令" class="headerlink" title="22.3.4. 赋值伪指令"></a>22.3.4. 赋值伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">变量名 EQU 表达式或数据 </span><br><span class="line"></span><br><span class="line">变量名 = 表达书或数据</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">EQU不允许重复定义，即一个变量名只能使用一次</span><br><span class="line">= 允许重复定义</span><br><span class="line"></span><br><span class="line">如</span><br><span class="line">CR EQU 0DH  </span><br><span class="line">MOV	AL,CR  ;等价于 MOV  AL, 0DH</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-3-5-模块定义伪指令"><a href="#22-3-5-模块定义伪指令" class="headerlink" title="22.3.5. 模块定义伪指令"></a>22.3.5. 模块定义伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name 模块名</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">end 起始标号</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">name伪指令可缺省</span><br></pre></td></tr></table></figure>
<h3 id="22-3-6-地址计数器"><a href="#22-3-6-地址计数器" class="headerlink" title="22.3.6. $地址计数器"></a>22.3.6. <code>$</code>地址计数器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ 表示当前的偏移地址</span><br><span class="line"></span><br><span class="line">如：jmp $+5 则跳转到当前指令的偏移地址加5的单元</span><br></pre></td></tr></table></figure>
<h3 id="22-3-7-ORG设置当前偏移地址"><a href="#22-3-7-ORG设置当前偏移地址" class="headerlink" title="22.3.7. ORG设置当前偏移地址"></a>22.3.7. ORG设置当前偏移地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在数据段中，可以在指定偏移地址的存储单元存放数据</span><br><span class="line">在代码段中，可以从指定单元开始存放并执行指令</span><br><span class="line"></span><br><span class="line">如 org 0020H 表示设置当前偏移地址为 0020H</span><br></pre></td></tr></table></figure>
<h3 id="22-3-8-操作符"><a href="#22-3-8-操作符" class="headerlink" title="22.3.8. 操作符"></a>22.3.8. 操作符</h3><p>程序在汇编时，将这些操作符变为相应的数值回送或者定义属性</p>
<p><strong>offset（回送偏移地址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov bx,offset x	;将x单元的偏移地址送给bx</span><br><span class="line">mov ax,offset start	;将标号start的偏移地址送给 ax</span><br></pre></td></tr></table></figure>
<p><strong>seg（回送段地址）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov bx,seg x	;将x单元的段地址送给bx</span><br></pre></td></tr></table></figure>
<p><strong>type（类型回送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov bx,type x ;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果 x 是字节单元，回送值为 1 </span><br><span class="line">如果 x 是字单元，回送值为 2 </span><br></pre></td></tr></table></figure>
<p><strong>length（变量数回送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov cx,length y</span><br><span class="line"></span><br><span class="line">注意</span><br><span class="line">y如果是dup()定义的，cx = 变量的个数</span><br></pre></td></tr></table></figure>
<p><strong>size（字节数回送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,size y</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">如果y是用dup()定义的，ax = 所有变量所占的总字节数</span><br></pre></td></tr></table></figure>
<p><strong>ptr（属性定义）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov byte ptr [bx],10	;定义目的操作数为字节单元</span><br><span class="line">mov word ptr [ax],20	;定义目的操作数为字单元</span><br></pre></td></tr></table></figure>
<p><strong>this（多重属性操作）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">要与EQU配合</span><br></pre></td></tr></table></figure>
<p><strong>label（类型操作符）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x label byte ;将x单元的类型定义为byte字节型</span><br></pre></td></tr></table></figure>
<h3 id="22-3-9-注释伪指令"><a href="#22-3-9-注释伪指令" class="headerlink" title="22.3.9. 注释伪指令"></a>22.3.9. 注释伪指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure>
<h2 id="22-4-基本汇编指令"><a href="#22-4-基本汇编指令" class="headerlink" title="22.4. 基本汇编指令"></a>22.4. 基本汇编指令</h2><p>操作数的属性必须一致</p>
<h3 id="22-4-1-数据、栈及查表"><a href="#22-4-1-数据、栈及查表" class="headerlink" title="22.4.1. 数据、栈及查表"></a>22.4.1. 数据、栈及查表</h3><p>数据操作指令不影响标志位</p>
<p><strong>mov（传送指令）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">立即数是字节型还是字型</span><br><span class="line">明确指令是字节操作还是字操作</span><br><span class="line">目标寄存器不能是CS</span><br><span class="line">立即数和存储器数不能直接送段寄存器</span><br><span class="line">两个段寄存器间不能直接传送</span><br><span class="line">两个存储单元之间不能直接传送</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>xchg（数据交换）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xchg ax,bx ;交换bx和ax的内容</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">必须有一个操作数是寄存器</span><br><span class="line">操作数不能是立即数</span><br></pre></td></tr></table></figure>
<p><strong>push（进栈）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">操作单位是 字</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>pop（出栈）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">操作单位是 字</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSH  SP指令入栈的是该指令已修改的SP新值，</span><br><span class="line">PUSH  ESP指令入栈的是执行该指令之前的ESP旧值，</span><br><span class="line">POP ESP使用指令执行后的ESP内容.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>xlat（查表转换指令）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">通过AL寄存器中的索引值在表中查得表项内容并返回到AL中</span><br><span class="line"></span><br><span class="line">使用这条指令之前，数据段中应有一个字节型表，该表起始地址的偏移量应放入BX，表索引值(要查找单元的位移量)放入AL</span><br><span class="line"></span><br><span class="line">(AL) = ((BX)+(AL))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-4-2-逻辑地址的获取"><a href="#22-4-2-逻辑地址的获取" class="headerlink" title="22.4.2. 逻辑地址的获取"></a>22.4.2. 逻辑地址的获取</h3><p>这类指令传送的是操作数的地址，而不是操作数本身</p>
<p>不能使用段寄存器</p>
<p>源操作数不能使用立即数和寄存器寻址方式</p>
<p><strong>lea（有效地址传送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">lea 寄存器,存储单元</span><br><span class="line">把源操作数的有效地址送给指定的寄存器(除段寄存器)</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">源操作数必须是存储单元</span><br><span class="line">等价的OFFSET后面只能跟变量，不能是变址(DI、SI)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>lds（数据段地址传送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lds 寄存器,双字存储单元</span><br><span class="line">将双字存储单元的低字节送入寄存器，高字节送入DS段寄存器</span><br></pre></td></tr></table></figure>
<p><strong>les（附加段地址传送）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">les 寄存器,双字存储单元</span><br><span class="line">将双字存储单元的低字节送入寄存器，高字节送入ES附加段寄存器</span><br></pre></td></tr></table></figure>
<h3 id="22-4-3-符号位扩展"><a href="#22-4-3-符号位扩展" class="headerlink" title="22.4.3. 符号位扩展"></a>22.4.3. 符号位扩展</h3><p>不影响条件标志位</p>
<p><strong>cbw（字节拓到字）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将al扩展到ax</span><br><span class="line">逻辑意义就是AL的符号扩展到AH</span><br></pre></td></tr></table></figure>
<p><strong>cwd（字拓到双字）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将ax扩展到dx</span><br></pre></td></tr></table></figure>
<h2 id="22-5-算术运算指令"><a href="#22-5-算术运算指令" class="headerlink" title="22.5. 算术运算指令"></a>22.5. 算术运算指令</h2><p>任何一条二进制加、减法指令均适用于带符号数和无符号数运算</p>
<h3 id="22-5-1-add-加法"><a href="#22-5-1-add-加法" class="headerlink" title="22.5.1. add(加法)"></a>22.5.1. add(加法)</h3><p>影响OF、SF、ZF、AF、PF、CF标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目的操作数是一个存储单元中的数据</span><br><span class="line">对操作数的限定同MOV指令</span><br></pre></td></tr></table></figure>
<h3 id="22-5-2-ADC-进位加法"><a href="#22-5-2-ADC-进位加法" class="headerlink" title="22.5.2. ADC(进位加法)"></a>22.5.2. ADC(进位加法)</h3><p>影响OF、SF、ZF、AF、PF、CF标志</p>
<p>适用于多字节或多字的加法运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADC执行加法运算时，会将CF位的值一起加到目标操作数中</span><br><span class="line">如果必须处理非常大的、不能存放到双字数据长度（ADD可以使用的最大长度）中的整数，可以把值分割为多个双字数据元素，并且对每个元素执行独立的加法操作。</span><br><span class="line">为了正确完成这个操作，必须检测每个加法操作的进位标志，如果进位标志被设置为1，就必须进位到下一对相加的数据元素</span><br></pre></td></tr></table></figure>
<h3 id="22-5-3-inc-加1指令"><a href="#22-5-3-inc-加1指令" class="headerlink" title="22.5.3. inc(加1指令)"></a>22.5.3. inc(加1指令)</h3><p>除不影响CF标志外，影响其它五个算术运算特征标志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现地址指针或循环次数的加1修改</span><br></pre></td></tr></table></figure>
<h3 id="22-5-4-加法指令对条件标志位的影响"><a href="#22-5-4-加法指令对条件标志位的影响" class="headerlink" title="22.5.4. 加法指令对条件标志位的影响"></a>22.5.4. 加法指令对条件标志位的影响</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sf = 1 结果为负</span><br><span class="line">zf = 1 结果为 0</span><br><span class="line">cf = 1 和的最高有效位，向前进位</span><br><span class="line">cf = 0 </span><br><span class="line">of = 1 两个操作数符号相同，结果符号与之相反</span><br><span class="line">of = 0 </span><br></pre></td></tr></table></figure>
<h3 id="22-5-5-sub-减法"><a href="#22-5-5-sub-减法" class="headerlink" title="22.5.5. sub(减法)"></a>22.5.5. sub(减法)</h3><p>要求同ADD</p>
<h3 id="22-5-6-sbb-带错位的"><a href="#22-5-6-sbb-带错位的" class="headerlink" title="22.5.6. sbb(带错位的)"></a>22.5.6. sbb(带错位的)</h3><p>同ADC</p>
<h3 id="22-5-7-dec-减1指令"><a href="#22-5-7-dec-减1指令" class="headerlink" title="22.5.7. dec(减1指令)"></a>22.5.7. dec(减1指令)</h3><p>和INC功能类似</p>
<h3 id="22-5-8-cmp-比较指令"><a href="#22-5-8-cmp-比较指令" class="headerlink" title="22.5.8. cmp(比较指令)"></a>22.5.8. cmp(比较指令)</h3><p>可进行两种比较，有符号数比较和无符号数比较</p>
<p>执行相减操作后，根据结果设置标志位，并不改变两个操作数的原值，其它要求同SUB</p>
<p>执行比较指令之后，可以根据标志判断两个数是否相等、大小关系等</p>
<h3 id="22-5-9-neg-求补指令"><a href="#22-5-9-neg-求补指令" class="headerlink" title="22.5.9. neg(求补指令)"></a>22.5.9. neg(求补指令)</h3><p>对目标操作数(含符号位)求反加1，并且把结果送回目标</p>
<p>利用NEG指令可实现求一个数的相反数</p>
<p>影响OF、SF、ZF、AF、PF、CF标志</p>
<h3 id="22-5-10-减法指令对条件标志位的影响"><a href="#22-5-10-减法指令对条件标志位的影响" class="headerlink" title="22.5.10. 减法指令对条件标志位的影响"></a>22.5.10. 减法指令对条件标志位的影响</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cf = 1 的最高有效位，向前进位</span><br><span class="line">cf = 0 </span><br><span class="line">of = 1 </span><br><span class="line">of = 0 </span><br></pre></td></tr></table></figure>
<h2 id="22-6-混合算术指令"><a href="#22-6-混合算术指令" class="headerlink" title="22.6. 混合算术指令"></a>22.6. 混合算术指令</h2><h3 id="22-6-1-mul-无符号乘法"><a href="#22-6-1-mul-无符号乘法" class="headerlink" title="22.6.1. mul(无符号乘法)"></a>22.6.1. mul(无符号乘法)</h3><p>实现两个无符号二进制数乘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字节乘法：被乘数放在al中，结果放在ax中</span><br><span class="line">字乘法：被乘数放在ax中，结果放在dx、ax中</span><br><span class="line">乘数写在指令中</span><br><span class="line">注意：</span><br><span class="line">源操作数只能是寄存器(reg)或存储器操作数(m)，不能是立即数</span><br><span class="line"></span><br><span class="line">对CF和OF的影响是:</span><br><span class="line">若乘积的高半部分(例字节型乘法结果的AH)为0则对CF和OF清0，否则置CF和OF为1</span><br></pre></td></tr></table></figure>
<h3 id="22-6-2-imul-带符号数相乘"><a href="#22-6-2-imul-带符号数相乘" class="headerlink" title="22.6.2. imul(带符号数相乘)"></a>22.6.2. imul(带符号数相乘)</h3><p>实现两个带符号二进制数乘</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">规则和mul一样</span><br><span class="line"></span><br><span class="line">对CF和OF的影响是:若乘积的高半部分为低半部分的符号扩展，则对CF和OF清0,否则置CF和OF为1</span><br></pre></td></tr></table></figure>
<h3 id="22-6-3-div-无符号除法"><a href="#22-6-3-div-无符号除法" class="headerlink" title="22.6.3. div(无符号除法)"></a>22.6.3. div(无符号除法)</h3><p>实现两个无符号数除法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line"></span><br><span class="line">div registre</span><br><span class="line">div 内存单元</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">除数</span><br><span class="line"></span><br><span class="line">有8位和16位两种，在一个寄存器中或内存单元中</span><br><span class="line"></span><br><span class="line">被除数</span><br><span class="line"></span><br><span class="line">默认放在AX或AX和DX中</span><br><span class="line"></span><br><span class="line">如果除数为8位，被除数为16位，则默认放在AX中</span><br><span class="line"></span><br><span class="line">如果除数为16位，被除数为32位，则放在DX和AX中，DX存放高16位，AX存放低16位</span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line"></span><br><span class="line">如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数</span><br><span class="line"></span><br><span class="line">如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数</span><br><span class="line"></span><br><span class="line">为了保证被除数位数，需进行位扩展，使用CBW和CWD</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-6-4-idiv-带符号除法"><a href="#22-6-4-idiv-带符号除法" class="headerlink" title="22.6.4. idiv(带符号除法)"></a>22.6.4. idiv(带符号除法)</h3><p>同div</p>
<h2 id="22-7-十进制数运算"><a href="#22-7-十进制数运算" class="headerlink" title="22.7. 十进制数运算"></a>22.7. 十进制数运算</h2><h3 id="22-7-1-压缩的BCD码"><a href="#22-7-1-压缩的BCD码" class="headerlink" title="22.7.1. 压缩的BCD码"></a>22.7.1. 压缩的BCD码</h3><p>只是看起来是用二进制编码表示0~9，在计算时，仍为二进制的计算，所以计算结果需要修正</p>
<h4 id="22-7-1-1-daa-加法调整"><a href="#22-7-1-1-daa-加法调整" class="headerlink" title="22.7.1.1. daa(加法调整)"></a>22.7.1.1. daa(加法调整)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制加法指令之后,把AL中的结果调整成压缩BCD码并送回AL</span><br><span class="line"></span><br><span class="line">标志:</span><br><span class="line">AF、CF按以上情况设置,SF、ZF、PF按结果设置，OF位不确定</span><br><span class="line"></span><br><span class="line">若是多字节加法，可以通过ADC指令把CF的进位加到高位中</span><br></pre></td></tr></table></figure>
<h4 id="22-7-1-2-das-减法调整"><a href="#22-7-1-2-das-减法调整" class="headerlink" title="22.7.1.2. das(减法调整)"></a>22.7.1.2. das(减法调整)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制减法指令之后,把AL中的结果调整成两位压缩BCD码并送回AL</span><br></pre></td></tr></table></figure>
<h3 id="22-7-2-非压缩的BCD码"><a href="#22-7-2-非压缩的BCD码" class="headerlink" title="22.7.2. 非压缩的BCD码"></a>22.7.2. 非压缩的BCD码</h3><p><strong>aaa（加法调整）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">跟在二进制减法指令之后</span><br><span class="line">调整AL中的结果成为非压缩BCD码并送回AL</span><br><span class="line">如果AL的低4位大于9，则AL+6，AH+1，AL的高4位清0，CF=1，AF=1</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">参与运算的操作数必须是ASCII码或非压缩BCD码</span><br></pre></td></tr></table></figure>
<p><strong>aas（减法调整）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同加法</span><br></pre></td></tr></table></figure>
<p><strong>aam（乘法调整）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">跟在乘法指令MUL之后,对AL中的结果进行调整，调整后的非压缩BCD码在AX中。（调整的过程相当于AL除10,商送AH，余数送AL）</span><br></pre></td></tr></table></figure>
<p><strong>aad（除法调整）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">除法指令之前，对AX中的非压缩BCD码进行调整,以便执行DIV指令之后，得到非压缩BCD码形式的商在AL中，余数在AH中</span><br></pre></td></tr></table></figure>
<h2 id="22-8-屏幕显示"><a href="#22-8-屏幕显示" class="headerlink" title="22.8. 屏幕显示"></a>22.8. 屏幕显示</h2><p>直接写显存显示字符</p>
<p>规定偶地址单元放字符的ASCII码，奇地址单元放字符的属性</p>
<p>字符的位置=行号x160D + 列号x2D</p>
<h2 id="22-9-输入输出"><a href="#22-9-输入输出" class="headerlink" title="22.9. 输入输出"></a>22.9. 输入输出</h2><h3 id="22-9-1-调用-中断INT-21H"><a href="#22-9-1-调用-中断INT-21H" class="headerlink" title="22.9.1. 调用 中断INT 21H"></a>22.9.1. 调用 中断INT 21H</h3><p>可以通过DOS系统功能调用中断INT 21H，来使用输入、输出</p>
<p>INT 21H 系统功能调用方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能号送AH寄存器，</span><br><span class="line">调用参数送所要求的位置，</span><br><span class="line">再执行 INT  21H 系统功能调用中断</span><br></pre></td></tr></table></figure>
<h3 id="22-9-2-单字符输入"><a href="#22-9-2-单字符输入" class="headerlink" title="22.9.2. 单字符输入"></a>22.9.2. 单字符输入</h3><p>输入的是字符串，但存的是字符串对应的ASCII码</p>
<p>如果输入的是数，运算前，记得减30H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">功能号：1</span><br><span class="line">	返回参数：AL＝输入字符的ASCII值</span><br><span class="line">	说明：等待从标准输入设备(通常为键盘)输入一个字符，把接收到的字符的ASCII值送给AL，并显示到显示器的当前光标位置。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-9-3-单字符输出"><a href="#22-9-3-单字符输出" class="headerlink" title="22.9.3. 单字符输出"></a>22.9.3. 单字符输出</h3><p>存的是ASCII，输出的是字符串</p>
<p>因为存的是字符串对应的ASCII码，所以输出的是数时，记得加30H(之前若减过30H)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能号：2</span><br><span class="line">	调用参数：DL＝字符的ASCII值</span><br><span class="line">	说明：该输出功能使光标跟随移动，同时输出字符的ASCII值送给AL</span><br><span class="line">	例：输出一个字符Y。</span><br><span class="line">		MOV    AH , 2</span><br><span class="line">		MOV    DL , &quot;Y&quot;</span><br><span class="line">		INT      21H</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-9-4-输出字符串"><a href="#22-9-4-输出字符串" class="headerlink" title="22.9.4. 输出字符串"></a>22.9.4. 输出字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">显示字符串</span><br><span class="line">	功能号：9</span><br><span class="line">	调用参数：DS:DX指向要输出的以＄结尾的字符串首地址</span><br><span class="line">	功能：输出字符串到标准输出设备</span><br><span class="line">	说明：要输出的字符串必须以＄结束</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PRINT	DB &#x27;What is your name$&#x27;</span><br><span class="line">MOV	AH,9</span><br><span class="line">MOV DX,OFFSET PRINT</span><br><span class="line">INT	21H</span><br></pre></td></tr></table></figure>
<h3 id="22-9-5-输入字符串"><a href="#22-9-5-输入字符串" class="headerlink" title="22.9.5. 输入字符串"></a>22.9.5. 输入字符串</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">功能号：0AH</span><br><span class="line">	调用参数：DS:DX指向自定义的输入缓冲区首地址</span><br><span class="line">	功能：从标准输入设备(例如键盘)输入一串字符到用户定义的缓冲区，直到按下Enter键为止，回车符0DH占用一个字节单元，在接收的同时显示到屏幕上，如果超过缓冲区的最大容纳量，则忽略此字符并响铃警告</span><br><span class="line">	说明：定义缓冲区的第一个字节单元为允许输入的最大字符数，第二个字节单元为实际键入的字符个数(系统自动填入)，第三个字节单元开始存放键入的字符</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BUFFER 	DB 60	;定义缓冲区长度</span><br><span class="line">			DB ?	;存放实际键入的字符数</span><br><span class="line">			DB 61 DUP(?)	;存放实际输入的字符</span><br><span class="line">			;设DS已是BUFFER的段基址</span><br><span class="line">			MOV  AH,0AH	;接收一串字符</span><br><span class="line">			LEA  DX,BUFFER</span><br><span class="line">			INT  21H</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-9-6-常用输出合集"><a href="#22-9-6-常用输出合集" class="headerlink" title="22.9.6. 常用输出合集"></a>22.9.6. 常用输出合集</h3><p><strong>输出换行</strong></p>
<p>先输出回车符，再输出换行符</p>
<p>方法一</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">;实现换行</span><br><span class="line">MOV AH,2	;先输出 回车符</span><br><span class="line">MOV DL,0DH</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2	;再输出 换行符</span><br><span class="line">MOV DL,0AH</span><br><span class="line">INT 21H</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">	CRLF DB 0AH,0DH,&#x27;$&#x27;		;存放换行的存储单元</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    MOV AX,DATAS</span><br><span class="line">    MOV DS,AX</span><br><span class="line">    LEA DX, CRLF     ;换行                   </span><br><span class="line">    MOV AH, 09H							 </span><br><span class="line">    INT 21H		</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出输入的字符</strong></p>
<p>输出输入的字符时，记得在输入的字符后面加<code>$</code>再输出</p>
<p>因为输入的字符串最后一个字符是回车符，所以要找到回车符的位置，并将其替换为<code>$</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">	n DB 60,?,61 DUP(?)		;存放输入字符串的缓冲区</span><br><span class="line">	</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:    </span><br><span class="line">		   	</span><br><span class="line">    MOV DX,OFFSET n ;接收字符串，放入缓冲区</span><br><span class="line">    MOV AH,10</span><br><span class="line">    INT 21H</span><br><span class="line">    	</span><br><span class="line">    				;对输入的字符串进行处理，准备输出</span><br><span class="line">    MOV AL,n+1       ;此时AL中存的是实际输入的字符的个数</span><br><span class="line">    ADD AL, 2		;此时AL存的是整个输入缓存区的使用长度，也是回车符所在存储单元的偏移量</span><br><span class="line">    MOV AH, 0		</span><br><span class="line">    MOV SI, AX		;此时 SI 中存的是回车符所在存储单元的偏移量</span><br><span class="line">    MOV n[SI], &#x27;$&#x27;	;用 $ 替换回车符</span><br><span class="line">    			 </span><br><span class="line">    </span><br><span class="line">	MOV DX,OFFSET n	;已经在输入字符串后面加了 $ ，所以直接 输出输入的字符</span><br><span class="line">    ADD DX,2		</span><br><span class="line">    MOV AH,9							 </span><br><span class="line">    INT 21H</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出数字</strong></p>
<p>在汇编语言中，只能直接输入输出字符串，数字是不能直接输出的，要想把数字输出，就要将其转换成字符串(即字符)的形式，然后再输出数字的字符形式</p>
<p>当数字大于9时，便无法用数字加30H的方式来表示数字的字符形式了。</p>
<p>解决方法：将数字除以10，分别取商和余数组成数的字符形式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">如：</span><br><span class="line">12除以10，商为1，余数为2，使用 1、2的字符形式组成12的字符形式</span><br></pre></td></tr></table></figure>
<p>具体实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">;输出数字36</span><br><span class="line"></span><br><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line"></span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line">   </span><br><span class="line">START:</span><br><span class="line">      MOV AX,DATAS</span><br><span class="line">      MOV DS,AX</span><br><span class="line">      </span><br><span class="line">      MOV AX,36</span><br><span class="line">   	  MOV BL,10</span><br><span class="line">      DIV BL</span><br><span class="line">      </span><br><span class="line">      MOV BL,AH		;BL存放余数</span><br><span class="line">      ADD BL,30H	;余数的ASCII码</span><br><span class="line">	  ADD AL,30H	;商的ASCII码</span><br><span class="line">	  </span><br><span class="line">	  MOV AH,2		;先输出商</span><br><span class="line">	  MOV DL,AL</span><br><span class="line">	  INT 21H</span><br><span class="line">	  </span><br><span class="line">	  MOV AH,2		;再输出余数</span><br><span class="line">	  MOV DL,BL</span><br><span class="line">	  INT 21H</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      MOV AX,4C00H</span><br><span class="line">      INT 21H </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">CODES ENDS</span><br><span class="line">    END START</span><br><span class="line">	</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>输出多位数</strong></p>
<p>因为2号功能只能输出单个字符，因此如果要输出多位数，需要一位一位的输出，利用将多位数除以10，再用得到的商除10，每次得到的余数，依次为多位数的个位、十位、百位…</p>
<p>在输出未知位数的数字时，需要判断商是否为0，除到商为0，就退出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">			;输出3位数，每次除10，取余</span><br><span class="line">MOV AX,res	 ; res中存的是3位数</span><br><span class="line">MOV Y,10</span><br><span class="line"></span><br><span class="line">DIV Y		;共3位数，求个位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV g,AH	</span><br><span class="line"></span><br><span class="line">CBW			;拓展AL		</span><br><span class="line">DIV Y		;共2位数，求十位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV shi,AH</span><br><span class="line"></span><br><span class="line">CBW</span><br><span class="line">DIV Y		;共1位数，求百位</span><br><span class="line">ADD AH,30H</span><br><span class="line">MOV bai,AH</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,bai</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,shi</span><br><span class="line">INT 21H</span><br><span class="line"></span><br><span class="line">MOV AH,2</span><br><span class="line">MOV DL,g</span><br><span class="line">INT 21H</span><br><span class="line"> </span><br><span class="line">   MOV AH,4CH</span><br><span class="line">   INT 21H</span><br></pre></td></tr></table></figure>
<p><strong>输入多位数</strong></p>
<p>利用1号功能的循环输入多位数，用空格分割数字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT</span><br><span class="line">   buf DW 100 dup(?)       ;预留100个数组元素</span><br><span class="line">   COUNT DW ?      ;数组元素个数</span><br><span class="line">   error DB 13,10,&#x27;input error&#x27;,13,10,&#x27;$&#x27;</span><br><span class="line">DATAS ENDS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CODES SEGMENT</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line"></span><br><span class="line">	MOV AX,DATAS</span><br><span class="line">	MOV DS,AX</span><br><span class="line">	</span><br><span class="line">	MOV SI,0</span><br><span class="line">	MOV DI,0</span><br><span class="line">	</span><br><span class="line">	MOV BX,0</span><br><span class="line">	</span><br><span class="line">input:	</span><br><span class="line"></span><br><span class="line">	MOV AH,1</span><br><span class="line">	INT 21H</span><br><span class="line">	</span><br><span class="line">	.IF AL == 13	;回车退出</span><br><span class="line">		JMP exit1</span><br><span class="line">	.ELSEIF AL== 32	;空格输入下一组数据</span><br><span class="line">		JMP lp1</span><br><span class="line">	.ENDIF</span><br><span class="line">	</span><br><span class="line">	.IF AL &lt; &#x27;0&#x27;</span><br><span class="line">		JMP e</span><br><span class="line">	.ELSEIF AL &gt; &#x27;9&#x27;</span><br><span class="line">		JMP e</span><br><span class="line">	.ELSE			; 40 - 49 得到输入的真实数值，并把两位数存入BX中</span><br><span class="line">		SUB AL,30H	;从ASCII码得到真实数字</span><br><span class="line"></span><br><span class="line">      	CBW			;将AL拓展为AX</span><br><span class="line">      	XCHG  AX, BX   </span><br><span class="line"></span><br><span class="line">     	MOV   CX, 10</span><br><span class="line">      	MUL   CX</span><br><span class="line">      	XCHG  AX, BX</span><br><span class="line">      	ADD   BX, AX</span><br><span class="line">      	JMP input      </span><br><span class="line">		</span><br><span class="line">	.ENDIF</span><br><span class="line">	</span><br><span class="line">lp1:</span><br><span class="line">	;存数据</span><br><span class="line">	MOV buf[SI],BX</span><br><span class="line">	MOV BX,0</span><br><span class="line">	INC SI</span><br><span class="line">	INC SI</span><br><span class="line">	INC DI</span><br><span class="line">	</span><br><span class="line">	MOV COUNT,DI		;记录输入的个数</span><br><span class="line">	</span><br><span class="line">	JMP input</span><br><span class="line">			</span><br><span class="line">		</span><br><span class="line">e:		;错误提示</span><br><span class="line">	MOV AH,9</span><br><span class="line">	LEA DX,error</span><br><span class="line">	INT 21H	</span><br><span class="line">	</span><br><span class="line">	JMP finish</span><br><span class="line">		</span><br><span class="line">exit1:</span><br><span class="line">	MOV buf[SI],BX  ;存入最后一个数</span><br><span class="line">finish:	</span><br><span class="line">	MOV AH,ACH</span><br><span class="line">	INT 21H</span><br></pre></td></tr></table></figure>
<h3 id="22-9-7-汇编中数的存储"><a href="#22-9-7-汇编中数的存储" class="headerlink" title="22.9.7. 汇编中数的存储"></a>22.9.7. 汇编中数的存储</h3><ul>
<li>调用输入功能，输入的数字，是以ASCII码的形式存的，在运算时要先减30H</li>
<li>直接在程序中定义的数字，是已数字的形式存的，输出时要输出它的字符串形式，要加30H</li>
</ul>
<h2 id="22-10-位操作指令"><a href="#22-10-位操作指令" class="headerlink" title="22.10. 位操作指令"></a>22.10. 位操作指令</h2><p><strong>逻辑运算和移位运算都用二进制来进行</strong></p>
<h3 id="22-10-1-逻辑运算"><a href="#22-10-1-逻辑运算" class="headerlink" title="22.10.1. 逻辑运算"></a>22.10.1. 逻辑运算</h3><p>适用于有符号数和无符号数</p>
<p><strong>AND</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">AND mem,imm/reg ;</span><br><span class="line">AND reg,imm/reg/mem ;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">均为1才为1，否则为0</span><br><span class="line">AND 指令可用于屏蔽某些位(用0相与)</span><br><span class="line">AND指令设置CF = OF = 0，根据结果设置SF、ZF和PF状态，而对AF未定义</span><br></pre></td></tr></table></figure>
<p><strong>OR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">同上</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">有1为1，否则为0</span><br><span class="line">OR 指令可用于置位某些位(用1相或)</span><br><span class="line">标志的影响同AND指令</span><br></pre></td></tr></table></figure>
<p><strong>XOR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">同上</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">相同为0，不同为1</span><br><span class="line">XOR 指令可用于求反某些位(用1相异或)</span><br><span class="line">标志的影响同AND指令</span><br></pre></td></tr></table></figure>
<p><strong>NOT</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">NOT reg/mem</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">取反</span><br><span class="line">NOT指令是一个单操作数指令</span><br><span class="line">NOT指令不影响标志位</span><br></pre></td></tr></table></figure>
<p><strong>TEST</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对两个操作数执行逻辑与运算，结果不回送到目的操作数</span><br><span class="line">标志的影响同 AND 指令</span><br></pre></td></tr></table></figure>
<p><strong>常用操作</strong></p>
<ul>
<li>使用TEST 数字和大小写字母的判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">大写字母A-Z: 01000001B - 01011010B		</span><br><span class="line">小写字母a-z: 01100001B - 01111010B</span><br><span class="line">数字0-9:     00110000B - 00111001B</span><br><span class="line"></span><br><span class="line">数字和字母的第6位不同，TEST AL，40H，第6位为0是数字，第6位为1是字母</span><br><span class="line"></span><br><span class="line">大小写字母的第5位不同，TEST AL,20H，第5位为0是大写字母，第5位为1是小写字母</span><br></pre></td></tr></table></figure>
<ul>
<li>使用TEST 正数、负数、奇数、偶数的判断</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">偶数的特点是换算成二进制的话最后一位必定是0(2的倍数),所以检测最后一位是否是0就能判断出是否是偶</span><br><span class="line"></span><br><span class="line">有符号数的第一位用0代表正，1代表负</span><br></pre></td></tr></table></figure>
<ul>
<li>使用AND将键盘输入的小写字母转为大写</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AND AL,0DFH</span><br></pre></td></tr></table></figure>
<h3 id="22-10-2-算术移位指令"><a href="#22-10-2-算术移位指令" class="headerlink" title="22.10.2. 算术移位指令"></a>22.10.2. 算术移位指令</h3><p>如果移位超过1，必须使用CL寄存器存放移位的位数</p>
<p>适用于有符号数</p>
<p><strong>SAL左移</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术左移，最高位进入CF，最低位补0</span><br></pre></td></tr></table></figure>
<p><strong>SAR右移</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">算术右移，最低位进入CF，最高位不变</span><br></pre></td></tr></table></figure>
<h3 id="22-10-3-逻辑移位指令"><a href="#22-10-3-逻辑移位指令" class="headerlink" title="22.10.3. 逻辑移位指令"></a>22.10.3. 逻辑移位指令</h3><p>使用于无符号数</p>
<p><strong>SHL左移</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑左移，最高位进入CF，最低位补0</span><br></pre></td></tr></table></figure>
<p><strong>SHR右移</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">逻辑右移，最低位进入CF，最高位补0</span><br></pre></td></tr></table></figure>
<p><strong>移位指令对标志的影响</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">按照移入的位设置进位标志CF</span><br><span class="line"></span><br><span class="line">对AF没有定义</span><br><span class="line"></span><br><span class="line">如果移位次数为1，则按照操作数的最高符号位是否改变，相应设置溢出标志OF：如果移位前操作数最高位与移位后不同则OF = 1；否则OF = 0。</span><br><span class="line"></span><br><span class="line">当移位次数大于1时，OF不确定</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-10-4-循环移位指令"><a href="#22-10-4-循环移位指令" class="headerlink" title="22.10.4. 循环移位指令"></a>22.10.4. 循环移位指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能：</span><br><span class="line">将操作数从一端移出的位返回到另一端形成循环，分成不带进位和带进位，分别具有左移或右移操作。</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">ROL reg/mem,1/CL	不带进位循环左移</span><br><span class="line">ROR reg/mem,1/CL	不带进位循环右移</span><br><span class="line">RCL reg/mem,1/CL	带进位循环左移</span><br><span class="line">RCR reg/mem,1/CL	带进位循环右移</span><br></pre></td></tr></table></figure>
<p><strong>ROL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最高位移入CF，同时将操作数从首端移出的位返回到末端形成循环</span><br><span class="line">如：</span><br><span class="line">MOV AL,8AH	;10001010</span><br><span class="line">ROL AL,1	;00010101</span><br></pre></td></tr></table></figure>
<p><strong>ROR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">最低位移入CF，同时将操作数从末端移出的位返回到首端形成循环</span><br><span class="line">如：</span><br><span class="line">MOV AL,8AH	;10001010</span><br><span class="line">ROR AL,1	;01000101</span><br></pre></td></tr></table></figure>
<p><strong>RCL</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数和进位一起循环左移，CF移入最低位，同时最高位移入CF</span><br></pre></td></tr></table></figure>
<p><strong>RCR</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作数和进位一起循环右移，CF移入最高位，同时最低位移入CF</span><br></pre></td></tr></table></figure>
<h3 id="22-10-5-总结"><a href="#22-10-5-总结" class="headerlink" title="22.10.5. 总结"></a>22.10.5. 总结</h3><p>用右移实现除法时，会出现余数丢失</p>
<h2 id="22-11-转移指令"><a href="#22-11-转移指令" class="headerlink" title="22.11. 转移指令"></a>22.11. 转移指令</h2><h3 id="22-11-1-CMP相关"><a href="#22-11-1-CMP相关" class="headerlink" title="22.11.1. CMP相关"></a>22.11.1. CMP相关</h3><p>可进行两种比较，有符号数比较和无符号数比较，所以转移也分两种，无符号比较结果根据(zf、cf的值)，有符号数比较根据(sf、of、zf的值)</p>
<p>无符号数比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CMP i,j</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JE 标号		;i == j 则跳转   检测 zf=1</span><br><span class="line">JNE 标号		;i != j 则转移  检测 zf=0</span><br><span class="line"></span><br><span class="line">JB 标号		;i &lt; j 跳转	检测 cf=1</span><br><span class="line">JNB 标号		;i &gt;= j 跳转	检测 cf=0</span><br><span class="line"></span><br><span class="line">JA 标号		;i &gt; j 跳转   检测 cf=0且zf=0</span><br><span class="line">JNA 标号		 ;i &lt;=j 跳转	检测 cf=1或zf=1</span><br><span class="line"></span><br><span class="line">JZ 标号		; i == j 跳转</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">e 表示 equal 等于</span><br><span class="line">b 表示 below 小于</span><br><span class="line">a 表示 above 大于</span><br><span class="line">n 表示 no 否</span><br></pre></td></tr></table></figure>
<p>有符号数比较</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">JL	小于			SF!=OF且ZF=0</span><br><span class="line">JLE 小于等于	   SF!=OF或ZF=1</span><br><span class="line"></span><br><span class="line">JG				SF=OF且ZF=0</span><br><span class="line">JGE				SF=OF或ZF=1</span><br><span class="line"></span><br><span class="line">G greater 大</span><br><span class="line">L less    小</span><br></pre></td></tr></table></figure>
<h3 id="22-11-2-条件标志转移"><a href="#22-11-2-条件标志转移" class="headerlink" title="22.11.2. 条件标志转移"></a>22.11.2. 条件标志转移</h3><p>指令结果影响标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">JZ (JE) 	结果为0或相等   	ZF=1</span><br><span class="line">JNZ (JNE) 	结果不为0或不相等  ZF=0</span><br><span class="line"></span><br><span class="line">JC 		    结果有进位		 CF=1</span><br><span class="line">JNC			结果无进位		CF=0</span><br><span class="line"></span><br><span class="line">JS			结果为负		 SF=1</span><br><span class="line">JNS			结果为正		 SF=0</span><br><span class="line"></span><br><span class="line">JO			结果溢出		 OF=1</span><br><span class="line">JNO			结果无溢出		OF=0</span><br><span class="line"></span><br><span class="line">JP			结果为偶数个1	    PF=1</span><br><span class="line">JNP			结果为奇数个1		PF=0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-11-3-CX相关"><a href="#22-11-3-CX相关" class="headerlink" title="22.11.3. CX相关"></a>22.11.3. CX相关</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：JCXZ OPR</span><br><span class="line">若CX=0则转移</span><br></pre></td></tr></table></figure>
<h2 id="22-12-循环指令"><a href="#22-12-循环指令" class="headerlink" title="22.12. 循环指令"></a>22.12. 循环指令</h2><p>对状态标志位都没影响</p>
<h3 id="22-12-1-LOOP"><a href="#22-12-1-LOOP" class="headerlink" title="22.12.1. LOOP"></a>22.12.1. LOOP</h3><ul>
<li>CX = CX - 1</li>
<li>CX != 0 时循环</li>
</ul>
<h3 id="22-12-2-LOOPZ-LOOPE"><a href="#22-12-2-LOOPZ-LOOPE" class="headerlink" title="22.12.2. LOOPZ/LOOPE"></a>22.12.2. LOOPZ/LOOPE</h3><ul>
<li>CX = CX - 1</li>
<li>CX != 0 且 ZF = 1 时循环，ZF = 0 提前退出循环</li>
</ul>
<h3 id="22-12-3-LOOPNZ-LOOPNE"><a href="#22-12-3-LOOPNZ-LOOPNE" class="headerlink" title="22.12.3. LOOPNZ/LOOPNE"></a>22.12.3. LOOPNZ/LOOPNE</h3><ul>
<li>CX = CX - 1</li>
<li>CX != 0 且 ZF = 0 时循环，ZF = 1 提前退出循环</li>
</ul>
<h2 id="22-13-串操作指令"><a href="#22-13-串操作指令" class="headerlink" title="22.13. 串操作指令"></a>22.13. 串操作指令</h2><h3 id="22-13-1-指令格式"><a href="#22-13-1-指令格式" class="headerlink" title="22.13.1. 指令格式"></a>22.13.1. 指令格式</h3><p>唯一源和目标可同时为寄存器的操作指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">显式：MOVS  DST, SRC	</span><br><span class="line">隐式：MOVSB	  ;字节传送</span><br><span class="line">     MOVSW		;字传送</span><br><span class="line">     MOVSD		;双字传送</span><br></pre></td></tr></table></figure>
<h3 id="22-13-2-操作数"><a href="#22-13-2-操作数" class="headerlink" title="22.13.2. 操作数"></a>22.13.2. 操作数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">串指令可以处理累加寄存器和存储器操作数。对于存储器操作数应先建立地址指针:</span><br><span class="line"></span><br><span class="line">	若为源操作数，则必须把DS：源串首地址放入SI寄存器，缺省情况寻址DS段</span><br><span class="line"></span><br><span class="line">    若为目标操作数，则必须把ES：目标串首地址放入DI寄存器，不允许使用段超越前缀</span><br></pre></td></tr></table></figure>
<h3 id="22-13-3-地址指针"><a href="#22-13-3-地址指针" class="headerlink" title="22.13.3. 地址指针"></a>22.13.3. 地址指针</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">串指令执行后自动修改地址指针SI、DI</span><br></pre></td></tr></table></figure>
<h3 id="22-13-4-方向标志"><a href="#22-13-4-方向标志" class="headerlink" title="22.13.4. 方向标志"></a>22.13.4. 方向标志</h3><p>方向标志DF决定地址指针的增减</p>
<p>CLD 指令 使 DF  = 0</p>
<p>STD 指令 使 DF = 1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">若DF＝0，则地址指针增量</span><br><span class="line">若DF＝1，则地址指针减量</span><br></pre></td></tr></table></figure>
<h3 id="22-13-5-重复前缀"><a href="#22-13-5-重复前缀" class="headerlink" title="22.13.5. 重复前缀"></a>22.13.5. 重复前缀</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">串指令前可以加重复前缀REPE／REPZ、 REP或REPNE／REPNZ,使后跟的串指令重复执行</span><br><span class="line"></span><br><span class="line">重复次数应事先初始化在计数器CX中</span><br><span class="line"></span><br><span class="line">串操作指令的重复前缀和LOOP对应</span><br><span class="line"></span><br><span class="line">REP :重复串操作，直到（CX） = 0</span><br><span class="line"></span><br><span class="line">REPZ/REPE :结果为0或相等则重复。若CX != 0 且 ZF = 1，则重复，（CX） = （CX） - 1，直到（CX） = 0。如果结果不为0或不相等则提前退出，此时CX还没减为 0，SI和DI已经增量</span><br><span class="line"></span><br><span class="line">REPNZ/REPNE :结果不为0或不相等则重复。若CX != 0 且 ZF = 0，则重复，（CX） = （CX） - 1，直到（CX） = 0。如果结果为0或相等则提前退出，此时CX还没减为 0，SI和DI已经增量</span><br></pre></td></tr></table></figure>
<h3 id="22-13-6-操作指令"><a href="#22-13-6-操作指令" class="headerlink" title="22.13.6. 操作指令"></a>22.13.6. 操作指令</h3><p>串操作指令应该和重复前缀一起使用，但不是所有串操作指令前都可以加重复前缀</p>
<p>串操作指令和重复前缀，其中先执行串操作指令，后执行重复前缀</p>
<p><strong>串传送</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不影响标志位</span><br><span class="line">MOVS  DST, SRC</span><br><span class="line">REP MOVSB 以字节形式重复传送</span><br></pre></td></tr></table></figure>
<p><strong>串比较</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">结果不回送，改变标志位</span><br><span class="line">CMPS</span><br><span class="line">REPE CMPSB 以字节形式重复比较</span><br></pre></td></tr></table></figure>
<p><strong>串扫描</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结果不保存，影响标志位</span><br><span class="line">在目的串中查找与AL、AX中相同或不同的字节或字</span><br><span class="line">SCAS DST</span><br><span class="line">SCASB</span><br></pre></td></tr></table></figure>
<p><strong>串获取</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">前面不加重复指令</span><br><span class="line">不影响标志位</span><br><span class="line">从源串中取出字或字节放入AL、AX中</span><br><span class="line">LODS SRC</span><br><span class="line">LODSB</span><br></pre></td></tr></table></figure>
<p><strong>串存入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将AL、AX内容存入目的串中</span><br><span class="line">STOS DST</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="22-14-高级汇编指令"><a href="#22-14-高级汇编指令" class="headerlink" title="22.14. 高级汇编指令"></a>22.14. 高级汇编指令</h2><h3 id="22-14-1-IF语句"><a href="#22-14-1-IF语句" class="headerlink" title="22.14.1. IF语句"></a>22.14.1. IF语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.IF 条件表达式 </span><br><span class="line">               分支体</span><br><span class="line"> [.ELSEIF 条件表达式 </span><br><span class="line">               分支体 ]</span><br><span class="line"> [.ELSE</span><br><span class="line">            分支体 ]</span><br><span class="line"> .ENDIF ;分支结束</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 例</span><br><span class="line">    .IF ax==5</span><br><span class="line">             mov bx, ax</span><br><span class="line">             mov ax, 0</span><br><span class="line">    .ELSE</span><br><span class="line">             dec  ax</span><br><span class="line">    .ENDIF</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="22-14-2-WHILE语句"><a href="#22-14-2-WHILE语句" class="headerlink" title="22.14.2. WHILE语句"></a>22.14.2. WHILE语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">           .WHILE 条件表达式 </span><br><span class="line">                  循环体</span><br><span class="line">           .ENDW</span><br><span class="line"> UNTIL结构格式为：     &gt;=类是按无符号数</span><br><span class="line">           .REPEAT</span><br><span class="line">                  循环体</span><br><span class="line">           .UNTIL 条件表达式 </span><br><span class="line"> UNTIL结构还有一种格式：</span><br><span class="line">           .REPEAT </span><br><span class="line">                  循环体</span><br><span class="line">           .UNTILCXZ [条件表达式] </span><br><span class="line">;cx←cx-1，直到cx=0或条件为真</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="22-15-汇编错误汇总"><a href="#22-15-汇编错误汇总" class="headerlink" title="22.15. 汇编错误汇总"></a>22.15. 汇编错误汇总</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">.MODEL must precede this directive                           .MODEL必须在指令之前</span><br><span class="line">[ELSE]IF2/.ERR2 not allowed : single-pass assembler          [ELSE]IF2/.ERR2不允许单独汇编</span><br><span class="line">assembler limit : macro parameter name table full      汇编限制：宏参数名表已满</span><br><span class="line">can ALIGN only to power of 2                    仅能对齐到2的幂</span><br><span class="line">cannot access label through segment registers        在段寄存器中不能存取标记</span><br><span class="line">cannot access symbol in given segment or group        在特定的段或类不能存取符号</span><br><span class="line">cannot add memory expression and code label                  不能增加内存表达式和代码标记</span><br><span class="line">cannot add two relocatable labels                         不能增加双重转移表标记</span><br><span class="line">cannot define as public or external                     不能定义为公有或外部的</span><br><span class="line">cannot find cvpack.exe                          找不到cvpack.exe</span><br><span class="line">cannot find link.exe                              找不到连接程序</span><br><span class="line">cannot have more than one ELSE clause per IF block            IF段只能有一个ELSE从句</span><br><span class="line">cannot mix 16- and 32-bit registers                 不能结合16位和32位寄存器</span><br><span class="line">cannot open file 不能打开文件</span><br><span class="line">COFF error writing file                      COFF错误，正在写文件</span><br><span class="line">constant expected                         连续预期</span><br><span class="line">constant or relocatable label expected                       预期的转移表或连续的</span><br><span class="line">constant value too large             连续标准太多</span><br><span class="line">count must be positive or zero                              计数必须是零或明确的</span><br><span class="line">count value too large                                        计数标准太多</span><br><span class="line">directive must be in control block                指令必须在控制段</span><br><span class="line">distance invalid for word size of current segment           当前区、段的大小命令无效</span><br><span class="line">DUP too complex                          DUP太复杂</span><br><span class="line">empty (null) string                没有字符串</span><br><span class="line">END directive required at end of file                        END指令必须在文件结尾</span><br><span class="line">error count exceeds 100; stopping assembly             错误数超过100，停止汇编</span><br><span class="line">expected               预定义  </span><br><span class="line">expression expected                   预期表达式</span><br><span class="line">expression must be a code address             表达式必须是一个代码地址</span><br><span class="line">expression too complex for .UNTILCXZ             .UNTILCXZ表达式太复杂</span><br><span class="line">extra characters after statement                           附加的字符在声明之后</span><br><span class="line">FATAL   严重错误</span><br><span class="line">forced error                           强制错误</span><br><span class="line">forced error : string blank                   字符串是空的</span><br><span class="line">forced error : string not blank             字符串不是空的</span><br><span class="line">forced error : strings equal              字符串是相同的</span><br><span class="line">forced error : strings not equal              字符串不是相同的</span><br><span class="line">forced error : symbol defined               符号已定义</span><br><span class="line">forced error : symbol not defined            符号没有定义</span><br><span class="line">forced error : value equal to 0                 标准等于零</span><br><span class="line">forced error : value not equal to 0             标准不等于零</span><br><span class="line">I/O error closing file I/O错误 正在关闭文件</span><br><span class="line">I/O error reading file            I/O错误 正在读取文件</span><br><span class="line">I/O error writing file I/O错误 正在写文件</span><br><span class="line">identifier not a record                      没有记录标示符</span><br><span class="line">identifier too long                       标识符太长</span><br><span class="line">immediate operand not allowed                      当前操作数无法载入</span><br><span class="line">incompatible CPU mode and segment size              不匹配的CPU模式和段尺寸</span><br><span class="line">index value past end of string                              索引标准在字符串结尾之后</span><br><span class="line">initializer magnitude too large for specified size        初始指定尺寸太大</span><br><span class="line">instruction does not allow FAR direct addressing       指令不允许远直接寻址</span><br><span class="line">instruction does not allow FAR indirect addressing      指令不允许远间接寻址</span><br><span class="line">instruction does not allow NEAR indirect addressing      指令不允许近间接寻址</span><br><span class="line">instruction form requires 80386/486                 指令需要80386/486指示   </span><br><span class="line">instruction operand must have size             命令操作数必须有长度</span><br><span class="line">instruction operands must be the same size        命令操作数必须是一样的长度</span><br><span class="line">instruction or register not accepted in current CPU mode   当前CPU模式不认可的指令或寄存器</span><br><span class="line">instruction prefix not allowed                    不允许的命令前缀</span><br><span class="line">Internal Assembler Error                         内部汇编错误</span><br><span class="line">invalid character in file                 文件里有无效字符</span><br><span class="line">invalid command-line option           无效命令行参数</span><br><span class="line">invalid debug and browser data; file exceeds line limit        不能排除故障和浏览数据；文件超过行限制</span><br><span class="line">invalid instruction operands                   无效的指令操作数</span><br><span class="line">invalid INVOKE argument                   无效的INVOKE符号</span><br><span class="line">invalid numerical command-line argument                无效命令行参数</span><br><span class="line">invalid operand for OFFSET                                    OFFSET操作数无效</span><br><span class="line">invalid operand size for instruction            操作数长度对于指令无效</span><br><span class="line">invalid scale value                                无效范围标准</span><br><span class="line">invalid type expression                      无效的类型表达式</span><br><span class="line">invalid use of external absolute                             由于完全外部的使用无效</span><br><span class="line">invalid use of external symbol               使用了无效的外部符号</span><br><span class="line">invalid use of register                     使用的寄存器无效</span><br><span class="line">jump destination must specify a label           跳转目标必须指定一个标记</span><br><span class="line">jump destination too far                            跳转目标太远</span><br><span class="line">jump distance not possible in current CPU mode       跳转距离不适合当前CPU模式</span><br><span class="line">line too long</span><br><span class="line">line too long                  行太长</span><br><span class="line">LOCK must be followed by a memory operation          LOCK指令必须跟在内存操作之后</span><br><span class="line">memory operand not allowed in context                  内存操作数无法载入上下文环境</span><br><span class="line">missing angle bracket or brace in literal         语句里找不到同样的括弧或框架</span><br><span class="line">missing operand after unary operator                 一元运算符之后找不到操作数</span><br><span class="line">missing operand for macro operator             找不到宏的操作数</span><br><span class="line">missing single or double quotation mark in string          找不到单引号或双引号</span><br><span class="line">missing source filename                                找不到源文件名</span><br><span class="line">multiple base registers not allowed             不允许多重基础寄存器</span><br><span class="line">multiple index registers not allowed           不允许多重标志寄存器</span><br><span class="line">must be in segment block                  必须在区、段、块中</span><br><span class="line">must be index or base register                  必须是基础或标志寄存器</span><br><span class="line">nesting level too deep             嵌套过深</span><br><span class="line">no operands allowed for this instruction          指令没有操作数</span><br><span class="line">non-benign record redefinition                      没有利于记录的定义</span><br><span class="line">nondigit in number                   没有总数</span><br><span class="line">operand must be a memory expression             操作数必须是一个内存表达式</span><br><span class="line">operand must be RECORD type or field            操作数必须是RECORD类型或域</span><br><span class="line">operand must be relocatable                                  操作数必须是转移表</span><br><span class="line">operands have different frames                  操作数存在不同的结构</span><br><span class="line">operands must be in same segment              操作数必须在相同的段</span><br><span class="line">operator expected                      预期操作数</span><br><span class="line">out of memory              缺少内存</span><br><span class="line">positive value expected                                      预期的明确的标准</span><br><span class="line">PROC, MACRO, or macro repeat directive must precede LOCAL    PROC, MACRO, 或 macro repeat指令必须在LOCAL之前</span><br><span class="line">real or BCD number not allowed                不允许real或BCD编码</span><br><span class="line">record constants may not span line breaks                 连续记录不能超过行间隔</span><br><span class="line">reserved word expected                      预期的保留字</span><br><span class="line">segment attributes cannot change                        区、段属性不能更换</span><br><span class="line">segment expected                                                预期的区段</span><br><span class="line">segment or group not allowed                               区段或类型不允许</span><br><span class="line">segment register not allowed in context            上下文不允许有寄存器</span><br><span class="line">segment, group, or segment register expected                   预期的段，类型或段寄存器</span><br><span class="line">SEVERE                              严重的错误</span><br><span class="line">statement not allowed inside structure definition         声明不允许在结构里面</span><br><span class="line">statement too complex                                   声明太复杂</span><br><span class="line">statement too complex                    声明太复杂</span><br><span class="line">string or text literal too long                 文本或字符串太长</span><br><span class="line">structure alignment must be 1, 2, 4, 8, or 16             结构对齐必须是1，2，4，8或16</span><br><span class="line">symbol redefinition                         符号已经定义</span><br><span class="line">symbol type conflict                             符号类型冲突</span><br><span class="line">syntax error                                语法错误</span><br><span class="line">syntax error in expression                   表达式存在语法错误</span><br><span class="line">syntax error in floating-point constant           不确定的指向中有语法错误</span><br><span class="line">text item required                       必须的文本项</span><br><span class="line">too many arguments                                     太多参数、定义、冲突</span><br><span class="line">too many bits in RECORD                                      太多位在记录里</span><br><span class="line">too many initial values for structure                太多结构的基础资料</span><br><span class="line">undefined symbol                        符号没有定义</span><br><span class="line">unmatched block nesting                   不正确的区、段嵌套</span><br><span class="line">unmatched macro nesting            不正确的宏嵌套</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://szx-zhao.github.io">robotszx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://szx-zhao.github.io/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/">https://szx-zhao.github.io/2024/10/28/2021-10-24-%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://szx-zhao.github.io" target="_blank">机器人之家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B1%87%E7%BC%96/">汇编</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/28/2021-09-30-%E5%AE%89%E5%85%A8%E8%B5%84%E8%AE%AF/" title=""><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"></div></div></a></div><div class="next-post pull-right"><a href="/2024/10/28/2021-06-26-JDBC/" title="JDBC"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JDBC</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Avatar/60910068.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">robotszx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/szx-zhao"><i class="fab fa-github"></i><span>前往未知的领域~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/szx-zhao" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1358861771@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B1%87%E7%BC%96"><span class="toc-number">1.</span> <span class="toc-text">1. 什么是汇编</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">2. 第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. 数的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%BF%9B%E5%88%B6%E6%95%B0%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1. 进制数三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2. 有符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3. 无符号数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E6%9C%BA%E5%99%A8%E6%95%B0"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4. 机器数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E7%9C%9F%E5%80%BC"><span class="toc-number">2.1.5.</span> <span class="toc-text">2.1.5. 真值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.1.6.</span> <span class="toc-text">2.1.6. 内存中的数据（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-7-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">2.1.7.</span> <span class="toc-text">2.1.7. 二进制数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-8-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0"><span class="toc-number">2.1.8.</span> <span class="toc-text">2.1.8. 十进制数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-9-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.9.</span> <span class="toc-text">2.1.9. 十进制数和二进制数的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. 进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E5%8D%81%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1. 十进制与其他进制转换（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2. 二进制与其他进制转换（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B8%8E%E5%85%B6%E4%BB%96%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3. 十六进制与其他进制转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 进制运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1. 二进制运算（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2. 十六进制运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E8%A1%A5%E7%A0%81%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. 补码（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%8E%9F%E7%A0%81"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. 原码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%8F%8D%E7%A0%81"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. 反码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E8%A1%A5%E7%A0%81"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3. 补码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E6%B1%82%E8%A1%A5%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4. 求补运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E4%BB%8E%E8%A1%A5%E7%A0%81%E6%B1%82%E7%9C%9F%E5%80%BC"><span class="toc-number">2.4.5.</span> <span class="toc-text">2.4.5. 从补码求真值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E8%A1%A5%E7%A0%81%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">2.4.6.</span> <span class="toc-text">2.4.6. 补码的运算规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-7-%E5%BC%95%E5%85%A5%E8%A1%A5%E7%A0%81%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.4.7.</span> <span class="toc-text">2.4.7. 引入补码的意义（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%95%B0%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">2.5.</span> <span class="toc-text">2.5. 数的范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-8%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%80%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%8C%83%E5%9B%B4"><span class="toc-number">2.5.1.</span> <span class="toc-text">2.5.1. 8位二进制所能表示的有符号数范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-8%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%80%E8%83%BD%E8%A1%A8%E7%A4%BA%E7%9A%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E8%8C%83%E5%9B%B4"><span class="toc-number">2.5.2.</span> <span class="toc-text">2.5.2. 8位二进制所能表示的无符号数范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E5%8F%8C%E7%B2%BE%E5%BA%A6%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">2.6. 双精度数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E5%AD%97%E8%8A%82-byte"><span class="toc-number">2.6.1.</span> <span class="toc-text">2.6.1. 字节(byte)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E5%AD%97"><span class="toc-number">2.6.2.</span> <span class="toc-text">2.6.2. 字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E5%AD%97%E9%95%BF"><span class="toc-number">2.6.3.</span> <span class="toc-text">2.6.3. 字长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%AD%98%E5%82%A8%E5%AE%B9%E9%87%8F"><span class="toc-number">2.7.</span> <span class="toc-text">2.7. 存储容量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text">2.7.1. 表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E6%8D%A2%E7%AE%97"><span class="toc-number">2.7.2.</span> <span class="toc-text">2.7.2. 换算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">2.8.</span> <span class="toc-text">2.8. 符号位扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E8%BF%9B%E4%BD%8D"><span class="toc-number">2.9.</span> <span class="toc-text">2.9. 进位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E6%BA%A2%E5%87%BA"><span class="toc-number">2.10.</span> <span class="toc-text">2.10. 溢出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-11-%E7%BC%96%E7%A0%81"><span class="toc-number">2.11.</span> <span class="toc-text">2.11. 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-11-1-BCD%E7%A0%81"><span class="toc-number">2.11.1.</span> <span class="toc-text">2.11.1. BCD码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-12-ASCII%E7%A0%81"><span class="toc-number">2.12.</span> <span class="toc-text">2.12. ASCII码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">3. 第二章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. 计算机基本结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E7%BB%84%E6%88%90%EF%BC%88%E4%BA%94%E5%A4%A7%E4%BB%B6%EF%BC%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1. 组成（五大件）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%80%BB%E7%BA%BF"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2. 总线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3. 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-8086CPU"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. 8086CPU</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E7%BB%84%E6%88%90"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1. 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E5%86%85%E9%83%A8"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2. 内部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-8086%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. 8086寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%95%B0%E6%8D%AE%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">3.3.1. 数据寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E6%8C%87%E9%92%88%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">3.3.2. 指针寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-%E5%8F%98%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">3.3.3. 变址寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-4-%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">3.3.4. 段寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-5-%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">3.3.5. 控制寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-6-%E6%B3%A8%E6%84%8F"><span class="toc-number">3.3.6.</span> <span class="toc-text">3.3.6. 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. 内存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. 内存地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. 存储单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. 物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.4.</span> <span class="toc-text">3.4.4. 逻辑地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E5%92%8C%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.5.</span> <span class="toc-text">3.4.5. 逻辑地址和物理地址的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-6-%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81"><span class="toc-number">3.4.6.</span> <span class="toc-text">3.4.6. 字的传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-7-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E5%AF%B9%E9%BD%90"><span class="toc-number">3.4.7.</span> <span class="toc-text">3.4.7. 数据的地址对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-8-%E8%AE%A1%E7%AE%97%E6%9F%90%E6%95%B0%E6%8D%AE%E5%8C%BA%E6%9C%80%E6%9C%AB%E5%8D%95%E5%85%83%E7%9A%84%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80"><span class="toc-number">3.4.8.</span> <span class="toc-text">3.4.8. 计算某数据区最末单元的物理地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-9-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83%E4%B8%AD%E5%9C%B0%E5%9D%80%E4%B8%8E%E5%86%85%E5%AE%B9"><span class="toc-number">3.4.9.</span> <span class="toc-text">3.4.9. 存储单元中地址与内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-10-%E5%AD%98%E5%82%A8%E5%99%A8%E5%88%86%E6%AE%B5"><span class="toc-number">3.4.10.</span> <span class="toc-text">3.4.10. 存储器分段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">4. 第三章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%A0%BC%E5%BC%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E5%B1%9E%E6%80%A7"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E6%B3%A8%E6%84%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3. 注意</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E6%8F%8F%E8%BF%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 内存单元的描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E6%8C%87%E4%BB%A4%E7%9A%84%E5%AF%BB%E5%9D%80"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 指令的寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E6%AE%B5%E5%89%8D%E7%BC%80%EF%BC%88%E6%AE%B5%E8%B6%85%E8%B6%8A%EF%BC%89"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 段前缀（段超越）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E6%95%B0%E6%8D%AE%E7%9B%B8%E5%85%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. 数据相关寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.4.1. 立即寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.4.2. 寄存器寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.4.3. 存储器寻址</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%A0%88"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. 栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1. 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%93%8D%E4%BD%9C"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2. 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E8%AE%A1%E7%AE%97sp"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3. 计算sp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E7%94%A8%E9%80%94"><span class="toc-number">4.5.4.</span> <span class="toc-text">4.5.4. 用途</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Debug%E4%BD%BF%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">5. Debug使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-debug%E7%89%B9%E6%80%A7"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. debug特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-R-%E6%9F%A5%E6%94%B9%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1. R - 查改寄存器内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-D-%E6%98%BE%E7%A4%BA%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2. D - 显示内存单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-E-%E4%BF%AE%E6%94%B9%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3. E - 修改内存单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-U-%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4. U - 反汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-5-T-%E8%B7%9F%E8%B8%AA"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.2.5. T - 跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-6-A-%E6%B1%87%E7%BC%96"><span class="toc-number">5.2.6.</span> <span class="toc-text">5.2.6. A - 汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-7-P-%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">5.2.7.</span> <span class="toc-text">5.2.7. P - 执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-8-Q-%E9%80%80%E5%87%BA"><span class="toc-number">5.2.8.</span> <span class="toc-text">5.2.8. Q - 退出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E7%86%9F%E6%82%89%E7%95%8C%E9%9D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 熟悉界面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-number">6.</span> <span class="toc-text">6. 第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 汇编程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1. 概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E5%BD%A2%E6%88%90"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2. 形成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.1.3. 伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-%E6%A0%87%E5%8F%B7"><span class="toc-number">6.1.4.</span> <span class="toc-text">6.1.4. 标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-%E7%A8%8B%E5%BA%8F%E8%BF%94%E5%9B%9E"><span class="toc-number">6.1.5.</span> <span class="toc-text">6.1.5. 程序返回</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-6-EXE%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.1.6.</span> <span class="toc-text">6.1.6. EXE的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%B3%A8%E6%84%8F"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 注意</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">7.</span> <span class="toc-text">7. 第五章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-LOOP"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. LOOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-1-%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1. 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-2-%E6%93%8D%E4%BD%9C"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2. 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-3-%E4%BD%BF%E7%94%A8"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3. 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-4-%E5%AF%BB%E5%9D%80%E8%8C%83%E5%9B%B4"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4. 寻址范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%AE%89%E5%85%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 安全空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%85%B6%E4%BB%96"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. 其他</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E7%AC%AC%E5%85%AD%E7%AB%A0"><span class="toc-number">8.</span> <span class="toc-text">8. 第六章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 代码段中使用数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-db"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1. db</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-dw"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2. dw</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 多个段的程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-%E5%AF%B9%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1. 对段地址的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2. 多个段的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E7%AC%AC%E4%B8%83%E7%AB%A0"><span class="toc-number">9.</span> <span class="toc-text">9. 第七章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-and"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. and</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-or"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. or</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%AD%97%E7%AC%A6%E5%9E%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. 字符型数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-number">9.4.</span> <span class="toc-text">9.4. 大小写转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">9.5.</span> <span class="toc-text">9.5. 定位内存地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-bx-idata"><span class="toc-number">9.5.1.</span> <span class="toc-text">9.5.1. [bx + idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-2-bx-si-%E5%92%8C-bx-di"><span class="toc-number">9.5.2.</span> <span class="toc-text">9.5.2. [bx + si]和[bx + di]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-3-bx-si-idata-%E5%92%8C-bx-di-idata"><span class="toc-number">9.5.3.</span> <span class="toc-text">9.5.3. [bx + si + idata]和[bx + di + idata]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-4-%E4%BA%8C%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">9.5.4.</span> <span class="toc-text">9.5.4. 二重循环</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E7%AC%AC%E5%85%AB%E7%AB%A0"><span class="toc-number">10.</span> <span class="toc-text">10. 第八章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E8%A1%A8%E7%A4%BA%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. [...]表示的内存地址</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-bx%E3%80%81si%E3%80%81di%E3%80%81bp"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1. bx、si、di、bp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E7%BB%84%E5%90%88"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2. 组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-3-bp"><span class="toc-number">10.1.3.</span> <span class="toc-text">10.1.3. bp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%8C%87%E4%BB%A4%E4%B8%AD%E6%95%B0%E6%8D%AE%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 指令中数据的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-1-ptr"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1. ptr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-div"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. div</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-dd"><span class="toc-number">10.4.</span> <span class="toc-text">10.4. dd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-dup"><span class="toc-number">10.5.</span> <span class="toc-text">10.5. dup</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E7%AC%AC%E4%B9%9D%E7%AB%A0"><span class="toc-number">11.</span> <span class="toc-text">11. 第九章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E8%BD%AC%E7%A7%BB%E8%A1%8C%E4%B8%BA"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 转移行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-1-%E6%AE%B5%E5%86%85%E8%BD%AC%E7%A7%BB"><span class="toc-number">11.1.1.</span> <span class="toc-text">11.1.1. 段内转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-2-%E6%AE%B5%E9%97%B4%E8%BD%AC%E7%A7%BB"><span class="toc-number">11.1.2.</span> <span class="toc-text">11.1.2. 段间转移</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">11.3.</span> <span class="toc-text">11.3. 转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-1-%E6%B3%A8"><span class="toc-number">11.3.1.</span> <span class="toc-text">11.3.1. 注</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-2-%E8%BD%AC%E7%A7%BB%E5%8E%9F%E7%90%86"><span class="toc-number">11.3.2.</span> <span class="toc-text">11.3.2. 转移原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-3-%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB"><span class="toc-number">11.3.3.</span> <span class="toc-text">11.3.3. 条件转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-4-loop%E6%8C%87%E4%BB%A4"><span class="toc-number">11.3.4.</span> <span class="toc-text">11.3.4. loop指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-5-%E6%80%BB%E7%BB%93"><span class="toc-number">11.3.5.</span> <span class="toc-text">11.3.5. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E7%AC%AC%E5%8D%81%E7%AB%A0"><span class="toc-number">12.</span> <span class="toc-text">12. 第十章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-ret"><span class="toc-number">12.1.</span> <span class="toc-text">12.1. ret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-retf"><span class="toc-number">12.2.</span> <span class="toc-text">12.2. retf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-call"><span class="toc-number">12.3.</span> <span class="toc-text">12.3. call</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-%E4%BD%8D%E7%A7%BB%E8%BD%AC%E7%A7%BB"><span class="toc-number">12.3.1.</span> <span class="toc-text">12.3.1. 位移转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-%E7%9B%AE%E7%9A%84%E5%9C%B0%E5%9D%80%E8%BD%AC%E7%A7%BB"><span class="toc-number">12.3.2.</span> <span class="toc-text">12.3.2. 目的地址转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD"><span class="toc-number">12.3.3.</span> <span class="toc-text">12.3.3. 转移地址在寄存器中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-%E8%BD%AC%E7%A7%BB%E5%9C%B0%E5%9D%80%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD"><span class="toc-number">12.3.4.</span> <span class="toc-text">12.3.4. 转移地址在内存中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0"><span class="toc-number">13.</span> <span class="toc-text">13. 第十一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">13.1.</span> <span class="toc-text">13.1. 标志寄存器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-1-%E8%A7%84%E5%BE%8B"><span class="toc-number">13.1.1.</span> <span class="toc-text">13.1.1. 规律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-2-flag%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">13.1.2.</span> <span class="toc-text">13.1.2. flag寄存器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-3-%E6%A0%87%E5%BF%97"><span class="toc-number">13.1.3.</span> <span class="toc-text">13.1.3. 标志</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E5%88%86%E6%94%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">14.</span> <span class="toc-text">14. 分支程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E4%BD%8D%E6%93%8D%E4%BD%9C%E7%9A%84%E5%88%86%E6%94%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">14.1.</span> <span class="toc-text">14.1. 位操作的分支程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E8%8F%9C%E5%8D%95%E6%B3%95"><span class="toc-number">14.2.</span> <span class="toc-text">14.2. 菜单法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-1-%E5%8E%9F%E7%90%86"><span class="toc-number">14.2.1.</span> <span class="toc-text">14.2.1. 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-2-%E7%BC%BA%E7%82%B9"><span class="toc-number">14.2.2.</span> <span class="toc-text">14.2.2. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E8%B7%B3%E8%BD%AC%E8%A1%A8%E6%B3%95"><span class="toc-number">14.3.</span> <span class="toc-text">14.3. 跳转表法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-%E5%BE%AA%E7%8E%AF%E7%A8%8B%E5%BA%8F"><span class="toc-number">15.</span> <span class="toc-text">15. 循环程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E5%85%88%E5%88%A4%E6%96%AD%EF%BC%8C%E5%90%8E%E6%89%A7%E8%A1%8C"><span class="toc-number">15.1.</span> <span class="toc-text">15.1. 先判断，后执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E5%85%88%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%90%8E%E5%88%A4%E6%96%AD"><span class="toc-number">15.2.</span> <span class="toc-text">15.2. 先执行，后判断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">16.</span> <span class="toc-text">16. 串操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">16.1.</span> <span class="toc-text">16.1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E5%A4%84%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">16.2. 处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-%E5%A4%9A%E9%87%8D%E5%BE%AA%E7%8E%AF"><span class="toc-number">17.</span> <span class="toc-text">17. 多重循环</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E5%B8%B8%E7%94%A8%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6%E6%96%B9%E6%B3%95"><span class="toc-number">17.1.</span> <span class="toc-text">17.1. 常用循环控制方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E5%86%85%E5%A4%96%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">17.2.</span> <span class="toc-text">17.2. 内外循环的控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E5%86%85%E5%A4%96%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%B7%B3%E8%BD%AC"><span class="toc-number">17.3.</span> <span class="toc-text">17.3. 内外循环的跳转</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">18.</span> <span class="toc-text">18. 子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#18-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">18.1.</span> <span class="toc-text">18.1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-2-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">18.2.</span> <span class="toc-text">18.2. 定义子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-1-%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">18.2.1.</span> <span class="toc-text">18.2.1. 方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-2-2-%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">18.2.2.</span> <span class="toc-text">18.2.2. 方法二</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-3-call%E6%89%A7%E8%A1%8C%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">18.3.</span> <span class="toc-text">18.3. call执行子程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-4-%E7%8E%B0%E5%9C%BA%E4%BF%9D%E6%8A%A4"><span class="toc-number">18.4.</span> <span class="toc-text">18.4. 现场保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-5-%E5%8F%82%E6%95%B0%E5%92%8C%E7%BB%93%E6%9E%9C%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-number">18.5.</span> <span class="toc-text">18.5. 参数和结果的传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-1-%E6%96%B9%E6%B3%95%E4%B8%80"><span class="toc-number">18.5.1.</span> <span class="toc-text">18.5.1. 方法一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-5-2-%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="toc-number">18.5.2.</span> <span class="toc-text">18.5.2. 方法二</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-%E5%B5%8C%E5%A5%97%E4%B8%8E%E9%80%92%E5%BD%92"><span class="toc-number">19.</span> <span class="toc-text">19. 嵌套与递归</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1-%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%B5%8C%E5%A5%97"><span class="toc-number">19.1.</span> <span class="toc-text">19.1. 子程序嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E5%AD%90%E7%A8%8B%E5%BA%8F%E9%80%92%E5%BD%92"><span class="toc-number">19.2.</span> <span class="toc-text">19.2. 子程序递归</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-%E5%AE%8F%E6%B1%87%E7%BC%96"><span class="toc-number">20.</span> <span class="toc-text">20. 宏汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">20.1.</span> <span class="toc-text">20.1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2-%E5%AE%8F%E4%BD%BF%E7%94%A8"><span class="toc-number">20.2.</span> <span class="toc-text">20.2. 宏使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-1-%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">20.2.1.</span> <span class="toc-text">20.2.1. 宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-2-%E5%AE%8F%E8%B0%83%E7%94%A8"><span class="toc-number">20.2.2.</span> <span class="toc-text">20.2.2. 宏调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-2-3-%E5%AE%8F%E5%B1%95%E5%BC%80"><span class="toc-number">20.2.3.</span> <span class="toc-text">20.2.3. 宏展开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3-%E5%AE%8F%E5%8F%82%E6%95%B0"><span class="toc-number">20.3.</span> <span class="toc-text">20.3. 宏参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-1-%E5%8F%98%E5%85%83%E6%98%AF%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">20.3.1.</span> <span class="toc-text">20.3.1. 变元是操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-2-%E5%8F%98%E5%85%83%E6%98%AF%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-number">20.3.2.</span> <span class="toc-text">20.3.2. 变元是操作码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-3-%E5%8F%98%E5%85%83%E6%98%AF%E6%93%8D%E4%BD%9C%E7%A0%81%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86"><span class="toc-number">20.3.3.</span> <span class="toc-text">20.3.3. 变元是操作码的一部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-4-%E5%8F%98%E5%85%83%E6%98%AF%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83"><span class="toc-number">20.3.4.</span> <span class="toc-text">20.3.4. 变元是存储单元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-3-5-%E5%8F%98%E5%85%83%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">20.3.5.</span> <span class="toc-text">20.3.5. 变元是字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-4-%E5%AE%8F%E8%BF%90%E7%AE%97"><span class="toc-number">20.4.</span> <span class="toc-text">20.4. 宏运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-5-%E5%AE%8F%E5%92%8C%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">20.5.</span> <span class="toc-text">20.5. 宏和子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-1-%E5%8C%BA%E5%88%AB"><span class="toc-number">20.5.1.</span> <span class="toc-text">20.5.1. 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-2-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">20.5.2.</span> <span class="toc-text">20.5.2. 优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-%E4%B8%AD%E6%96%AD"><span class="toc-number">21.</span> <span class="toc-text">21. 中断</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1-%E5%A4%96%E4%B8%AD%E6%96%AD"><span class="toc-number">21.1.</span> <span class="toc-text">21.1. 外中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2-%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-number">21.2.</span> <span class="toc-text">21.2. 内中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-%E6%9F%A5%E8%AF%A2%E6%89%8B%E5%86%8C"><span class="toc-number">22.</span> <span class="toc-text">22. 查询手册</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#22-1-%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%E6%8C%87%E4%BB%A4"><span class="toc-number">22.1.</span> <span class="toc-text">22.1. 如何学习指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-2-%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">22.2.</span> <span class="toc-text">22.2. 指令分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-3-%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">22.3.</span> <span class="toc-text">22.3. 伪指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-1-%E5%AE%9A%E4%B9%89%E6%AE%B5"><span class="toc-number">22.3.1.</span> <span class="toc-text">22.3.1. 定义段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-2-ASSUME"><span class="toc-number">22.3.2.</span> <span class="toc-text">22.3.2. ASSUME</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-3-%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89"><span class="toc-number">22.3.3.</span> <span class="toc-text">22.3.3. 数据定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-4-%E8%B5%8B%E5%80%BC%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">22.3.4.</span> <span class="toc-text">22.3.4. 赋值伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-5-%E6%A8%A1%E5%9D%97%E5%AE%9A%E4%B9%89%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">22.3.5.</span> <span class="toc-text">22.3.5. 模块定义伪指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-6-%E5%9C%B0%E5%9D%80%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">22.3.6.</span> <span class="toc-text">22.3.6. $地址计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-7-ORG%E8%AE%BE%E7%BD%AE%E5%BD%93%E5%89%8D%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80"><span class="toc-number">22.3.7.</span> <span class="toc-text">22.3.7. ORG设置当前偏移地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-8-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">22.3.8.</span> <span class="toc-text">22.3.8. 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-3-9-%E6%B3%A8%E9%87%8A%E4%BC%AA%E6%8C%87%E4%BB%A4"><span class="toc-number">22.3.9.</span> <span class="toc-text">22.3.9. 注释伪指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-4-%E5%9F%BA%E6%9C%AC%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">22.4.</span> <span class="toc-text">22.4. 基本汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4-1-%E6%95%B0%E6%8D%AE%E3%80%81%E6%A0%88%E5%8F%8A%E6%9F%A5%E8%A1%A8"><span class="toc-number">22.4.1.</span> <span class="toc-text">22.4.1. 数据、栈及查表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4-2-%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8E%B7%E5%8F%96"><span class="toc-number">22.4.2.</span> <span class="toc-text">22.4.2. 逻辑地址的获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-4-3-%E7%AC%A6%E5%8F%B7%E4%BD%8D%E6%89%A9%E5%B1%95"><span class="toc-number">22.4.3.</span> <span class="toc-text">22.4.3. 符号位扩展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-5-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4"><span class="toc-number">22.5.</span> <span class="toc-text">22.5. 算术运算指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-1-add-%E5%8A%A0%E6%B3%95"><span class="toc-number">22.5.1.</span> <span class="toc-text">22.5.1. add(加法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-2-ADC-%E8%BF%9B%E4%BD%8D%E5%8A%A0%E6%B3%95"><span class="toc-number">22.5.2.</span> <span class="toc-text">22.5.2. ADC(进位加法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-3-inc-%E5%8A%A01%E6%8C%87%E4%BB%A4"><span class="toc-number">22.5.3.</span> <span class="toc-text">22.5.3. inc(加1指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-4-%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">22.5.4.</span> <span class="toc-text">22.5.4. 加法指令对条件标志位的影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-5-sub-%E5%87%8F%E6%B3%95"><span class="toc-number">22.5.5.</span> <span class="toc-text">22.5.5. sub(减法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-6-sbb-%E5%B8%A6%E9%94%99%E4%BD%8D%E7%9A%84"><span class="toc-number">22.5.6.</span> <span class="toc-text">22.5.6. sbb(带错位的)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-7-dec-%E5%87%8F1%E6%8C%87%E4%BB%A4"><span class="toc-number">22.5.7.</span> <span class="toc-text">22.5.7. dec(减1指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-8-cmp-%E6%AF%94%E8%BE%83%E6%8C%87%E4%BB%A4"><span class="toc-number">22.5.8.</span> <span class="toc-text">22.5.8. cmp(比较指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-9-neg-%E6%B1%82%E8%A1%A5%E6%8C%87%E4%BB%A4"><span class="toc-number">22.5.9.</span> <span class="toc-text">22.5.9. neg(求补指令)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-5-10-%E5%87%8F%E6%B3%95%E6%8C%87%E4%BB%A4%E5%AF%B9%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">22.5.10.</span> <span class="toc-text">22.5.10. 减法指令对条件标志位的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-6-%E6%B7%B7%E5%90%88%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">22.6.</span> <span class="toc-text">22.6. 混合算术指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6-1-mul-%E6%97%A0%E7%AC%A6%E5%8F%B7%E4%B9%98%E6%B3%95"><span class="toc-number">22.6.1.</span> <span class="toc-text">22.6.1. mul(无符号乘法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6-2-imul-%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">22.6.2.</span> <span class="toc-text">22.6.2. imul(带符号数相乘)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6-3-div-%E6%97%A0%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">22.6.3.</span> <span class="toc-text">22.6.3. div(无符号除法)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-6-4-idiv-%E5%B8%A6%E7%AC%A6%E5%8F%B7%E9%99%A4%E6%B3%95"><span class="toc-number">22.6.4.</span> <span class="toc-text">22.6.4. idiv(带符号除法)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-7-%E5%8D%81%E8%BF%9B%E5%88%B6%E6%95%B0%E8%BF%90%E7%AE%97"><span class="toc-number">22.7.</span> <span class="toc-text">22.7. 十进制数运算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-7-1-%E5%8E%8B%E7%BC%A9%E7%9A%84BCD%E7%A0%81"><span class="toc-number">22.7.1.</span> <span class="toc-text">22.7.1. 压缩的BCD码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#22-7-1-1-daa-%E5%8A%A0%E6%B3%95%E8%B0%83%E6%95%B4"><span class="toc-number">22.7.1.1.</span> <span class="toc-text">22.7.1.1. daa(加法调整)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-7-1-2-das-%E5%87%8F%E6%B3%95%E8%B0%83%E6%95%B4"><span class="toc-number">22.7.1.2.</span> <span class="toc-text">22.7.1.2. das(减法调整)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-7-2-%E9%9D%9E%E5%8E%8B%E7%BC%A9%E7%9A%84BCD%E7%A0%81"><span class="toc-number">22.7.2.</span> <span class="toc-text">22.7.2. 非压缩的BCD码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-8-%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA"><span class="toc-number">22.8.</span> <span class="toc-text">22.8. 屏幕显示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-9-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">22.9.</span> <span class="toc-text">22.9. 输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-1-%E8%B0%83%E7%94%A8-%E4%B8%AD%E6%96%ADINT-21H"><span class="toc-number">22.9.1.</span> <span class="toc-text">22.9.1. 调用 中断INT 21H</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-2-%E5%8D%95%E5%AD%97%E7%AC%A6%E8%BE%93%E5%85%A5"><span class="toc-number">22.9.2.</span> <span class="toc-text">22.9.2. 单字符输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-3-%E5%8D%95%E5%AD%97%E7%AC%A6%E8%BE%93%E5%87%BA"><span class="toc-number">22.9.3.</span> <span class="toc-text">22.9.3. 单字符输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-4-%E8%BE%93%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">22.9.4.</span> <span class="toc-text">22.9.4. 输出字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-5-%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">22.9.5.</span> <span class="toc-text">22.9.5. 输入字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-6-%E5%B8%B8%E7%94%A8%E8%BE%93%E5%87%BA%E5%90%88%E9%9B%86"><span class="toc-number">22.9.6.</span> <span class="toc-text">22.9.6. 常用输出合集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-9-7-%E6%B1%87%E7%BC%96%E4%B8%AD%E6%95%B0%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">22.9.7.</span> <span class="toc-text">22.9.7. 汇编中数的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-10-%E4%BD%8D%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">22.10.</span> <span class="toc-text">22.10. 位操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10-1-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">22.10.1.</span> <span class="toc-text">22.10.1. 逻辑运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10-2-%E7%AE%97%E6%9C%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">22.10.2.</span> <span class="toc-text">22.10.2. 算术移位指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10-3-%E9%80%BB%E8%BE%91%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">22.10.3.</span> <span class="toc-text">22.10.3. 逻辑移位指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10-4-%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">22.10.4.</span> <span class="toc-text">22.10.4. 循环移位指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-10-5-%E6%80%BB%E7%BB%93"><span class="toc-number">22.10.5.</span> <span class="toc-text">22.10.5. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-11-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">22.11.</span> <span class="toc-text">22.11. 转移指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-11-1-CMP%E7%9B%B8%E5%85%B3"><span class="toc-number">22.11.1.</span> <span class="toc-text">22.11.1. CMP相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-11-2-%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97%E8%BD%AC%E7%A7%BB"><span class="toc-number">22.11.2.</span> <span class="toc-text">22.11.2. 条件标志转移</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-11-3-CX%E7%9B%B8%E5%85%B3"><span class="toc-number">22.11.3.</span> <span class="toc-text">22.11.3. CX相关</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-12-%E5%BE%AA%E7%8E%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">22.12.</span> <span class="toc-text">22.12. 循环指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-12-1-LOOP"><span class="toc-number">22.12.1.</span> <span class="toc-text">22.12.1. LOOP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-12-2-LOOPZ-LOOPE"><span class="toc-number">22.12.2.</span> <span class="toc-text">22.12.2. LOOPZ&#x2F;LOOPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-12-3-LOOPNZ-LOOPNE"><span class="toc-number">22.12.3.</span> <span class="toc-text">22.12.3. LOOPNZ&#x2F;LOOPNE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-13-%E4%B8%B2%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">22.13.</span> <span class="toc-text">22.13. 串操作指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-1-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-number">22.13.1.</span> <span class="toc-text">22.13.1. 指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-2-%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">22.13.2.</span> <span class="toc-text">22.13.2. 操作数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-3-%E5%9C%B0%E5%9D%80%E6%8C%87%E9%92%88"><span class="toc-number">22.13.3.</span> <span class="toc-text">22.13.3. 地址指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-4-%E6%96%B9%E5%90%91%E6%A0%87%E5%BF%97"><span class="toc-number">22.13.4.</span> <span class="toc-text">22.13.4. 方向标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-5-%E9%87%8D%E5%A4%8D%E5%89%8D%E7%BC%80"><span class="toc-number">22.13.5.</span> <span class="toc-text">22.13.5. 重复前缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-13-6-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4"><span class="toc-number">22.13.6.</span> <span class="toc-text">22.13.6. 操作指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-14-%E9%AB%98%E7%BA%A7%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">22.14.</span> <span class="toc-text">22.14. 高级汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#22-14-1-IF%E8%AF%AD%E5%8F%A5"><span class="toc-number">22.14.1.</span> <span class="toc-text">22.14.1. IF语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-14-2-WHILE%E8%AF%AD%E5%8F%A5"><span class="toc-number">22.14.2.</span> <span class="toc-text">22.14.2. WHILE语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-15-%E6%B1%87%E7%BC%96%E9%94%99%E8%AF%AF%E6%B1%87%E6%80%BB"><span class="toc-number">22.15.</span> <span class="toc-text">22.15. 汇编错误汇总</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/2024-09-06-Mobx%E5%85%A5%E9%97%A8/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/28/2024-09-06-Mobx%E5%85%A5%E9%97%A8/" title="无题">无题</a><time datetime="2024-10-28T12:46:25.305Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/2024-09-09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/28/2024-09-09-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/" title="无题">无题</a><time datetime="2024-10-28T12:46:25.305Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/2024-09-10-Taro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/28/2024-09-10-Taro%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/" title="无题">无题</a><time datetime="2024-10-28T12:46:25.305Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/2024-09-11-ping%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%86%E7%A8%8B/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/28/2024-09-11-ping%E6%8E%A2%E6%B5%8B%E7%9A%84%E5%8E%86%E7%A8%8B/" title="无题">无题</a><time datetime="2024-10-28T12:46:25.305Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/28/2024-09-13-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" title="无题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2024/10/28/2024-09-13-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/" title="无题">无题</a><time datetime="2024-10-28T12:46:25.305Z" title="发表于 2024-10-28 20:46:25">2024-10-28</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By robotszx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '113.34532,23.15624';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://assets.akilar.top/image/cover1.webp);"> <a class="categoryBar-list-link" href="categories/new/">new</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr">Ubuntu指南</span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://npm.elemecdn.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>