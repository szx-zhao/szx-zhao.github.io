<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker理论 | 机器人之家</title><meta name="author" content="robotszx"><meta name="copyright" content="robotszx"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="1. 概念123456flowchart LR 	docker --&gt; docker-ce社区免费版	docker --&gt; docker-ee企业收费版	docker-ce社区免费版 --&gt; docker-compose管理多个Docker容器的工具	docker-ce社区免费版 --&gt; Kubernetes管理大规模容器集群的容器编排平台 2. Docker 是什么Doc">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker理论">
<meta property="og:url" content="https://szx-zhao.github.io/2023/01/20/2023-01-20-Docker%E7%90%86%E8%AE%BA/index.html">
<meta property="og:site_name" content="机器人之家">
<meta property="og:description" content="1. 概念123456flowchart LR 	docker --&gt; docker-ce社区免费版	docker --&gt; docker-ee企业收费版	docker-ce社区免费版 --&gt; docker-compose管理多个Docker容器的工具	docker-ce社区免费版 --&gt; Kubernetes管理大规模容器集群的容器编排平台 2. Docker 是什么Doc">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/6.avif">
<meta property="article:published_time" content="2023-01-19T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-19T16:00:00.000Z">
<meta property="article:author" content="robotszx">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/6.avif"><link rel="shortcut icon" href="/img/favicon/%E6%9C%BA%E5%99%A8%E4%BA%BA.png"><link rel="canonical" href="https://szx-zhao.github.io/2023/01/20/2023-01-20-Docker%E7%90%86%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker理论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-01-20 00:00:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Avatar/60910068.avif" onerror="onerror=null;src='/img/favicon/404.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/6.avif')"><nav id="nav"><span id="blog-info"><a href="/" title="机器人之家"><span class="site-name">机器人之家</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Docker理论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-19T16:00:00.000Z" title="发表于 2023-01-20 00:00:00">2023-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-01-19T16:00:00.000Z" title="更新于 2023-01-20 00:00:00">2023-01-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Docker理论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR </span><br><span class="line">	docker --&gt; docker-ce社区免费版</span><br><span class="line">	docker --&gt; docker-ee企业收费版</span><br><span class="line">	docker-ce社区免费版 --&gt; docker-compose管理多个Docker容器的工具</span><br><span class="line">	docker-ce社区免费版 --&gt; Kubernetes管理大规模容器集群的容器编排平台</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="2-Docker-是什么"><a href="#2-Docker-是什么" class="headerlink" title="2. Docker 是什么"></a>2. Docker 是什么</h1><p>Docker容器对进程封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程</p>
<p>Docker允许开发中将应用、依赖、函数库、配置一起打包，形成可移植镜像</p>
<p>Docker镜像中包含完整运行环境， 包括系统函数库（仅依赖系统的Linux内核），因此可以在任意Linux操作系统上运行</p>
<p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程。而<strong>容器内的应用进程直接运行于宿主的内核</strong>，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便</p>
<h1 id="3-为什么要用-Docker"><a href="#3-为什么要用-Docker" class="headerlink" title="3. 为什么要用 Docker"></a>3. 为什么要用 Docker</h1><ul>
<li>高效利用系统资源</li>
<li>快速的启动时间</li>
<li>一致的运行环境。避免由于开发环境、测试环境、生产环境不一致，导致的 bug </li>
<li>持续交付和部署。一次创建或配置，可以在任意地方正常运行。使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。使用Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件。</li>
<li>更轻松的维护和扩展。<code>Docker</code> 使用的分层存储以及镜像的技术，使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。<a target="_blank" rel="noopener" href="https://hub.docker.com/search/?type=image&amp;image_filter=official&amp;q=">官网镜像库</a></li>
</ul>
<h1 id="4-Docker-基本组成"><a href="#4-Docker-基本组成" class="headerlink" title="4. Docker 基本组成"></a>4. Docker 基本组成</h1><p><strong>镜像、容器、仓库</strong> 这三个概念，涵盖了 Docker 的整个生命周期</p>
<h2 id="4-1-镜像"><a href="#4-1-镜像" class="headerlink" title="4.1. 镜像"></a>4.1. 镜像</h2><p>Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含任何动态数据</strong>，其内容在构建之后也不会被改变</p>
<h3 id="4-1-1-分层存储（重点）"><a href="#4-1-1-分层存储（重点）" class="headerlink" title="4.1.1. 分层存储（重点）"></a>4.1.1. 分层存储（重点）</h3><p>Docker 镜像构建时，会一层一层地构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p>
<p>eg：删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p>
<h2 id="4-2-容器"><a href="#4-2-容器" class="headerlink" title="4.2. 容器"></a>4.2. 容器</h2><p>镜像是静态的定义，<strong>容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等</p>
<p><strong>容器的实质是进程</strong>，但与直接在宿主执行的进程不同，<strong>容器进程运行于属于自己的独立的命名空间</strong>（ the same namespace for a set of resources and processes, but those namespaces refer to distinct resources. Resources may exist in multiple spaces）</p>
<p>Docker 不是虚拟机，<strong>容器中的应用都应该以前台执行</strong>，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，<strong>容器内没有后台服务的概念</strong>。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西</p>
<h3 id="4-2-1-容器存储层（不推荐）"><a href="#4-2-1-容器存储层（不推荐）" class="headerlink" title="4.2.1. 容器存储层（不推荐）"></a>4.2.1. 容器存储层（不推荐）</h3><p>每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层（为容器运行时读、写而准备的存储层）</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡</p>
<p><strong>Docker 最佳实践</strong>的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。<strong>所有的文件写入操作，都应该使用数据卷、或者绑定宿主目录</strong>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<h2 id="4-3-仓库"><a href="#4-3-仓库" class="headerlink" title="4.3. 仓库"></a>4.3. 仓库</h2><p>镜像构建完成后，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库。每个仓库可以包含多个标签（Tag）。每个标签对应一个镜像。</p>
<p>通常，一个仓库包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以latest 作为默认标签。</p>
<h3 id="4-3-1-公开-Docker-Registry"><a href="#4-3-1-公开-Docker-Registry" class="headerlink" title="4.3.1. 公开 Docker Registry"></a>4.3.1. 公开 Docker Registry</h3><p>一般这类公开服务允许用户免费上传、下载公开的镜像</p>
<p>最常使用的 Registry 公开服务是官方的 <a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的 <a target="_blank" rel="noopener" href="https://hub.docker.com/search?q=&amp;type=image&amp;image_filter=official">官方镜像</a>。除此以外，还有 Red Hat 的 <a target="_blank" rel="noopener" href="https://quay.io/repository/">Quay.io</a>；Google 的 <a target="_blank" rel="noopener" href="https://cloud.google.com/container-registry/">Google Container Registry</a>，<a target="_blank" rel="noopener" href="https://kubernetes.io/">Kubernetes</a> 的镜像使用的就是这个服务；代码托管平台 <a target="_blank" rel="noopener" href="https://github.com">GitHub</a> 推出的 <a target="_blank" rel="noopener" href="https://docs.github.com/cn/packages/working-with-a-github-packages-registry/working-with-the-container-registry">ghcr.io</a></p>
<h3 id="4-3-2-私有-Docker-Registry"><a href="#4-3-2-私有-Docker-Registry" class="headerlink" title="4.3.2. 私有 Docker Registry"></a>4.3.2. 私有 Docker Registry</h3><p>用户还可以在本地搭建私有 Docker Registry</p>
<h1 id="5-安装Docker"><a href="#5-安装Docker" class="headerlink" title="5. 安装Docker"></a>5. 安装Docker</h1><h2 id="5-1-官方脚本自动安装（推荐）"><a href="#5-1-官方脚本自动安装（推荐）" class="headerlink" title="5.1. 官方脚本自动安装（推荐）"></a>5.1. 官方脚本自动安装（推荐）</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure>
<p>官方被封了，用这个</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -fsSL https://github.com/tech-shrimp/docker_installer/releases/download/latest/linux.sh| bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>
<h2 id="5-2-启动"><a href="#5-2-启动" class="headerlink" title="5.2. 启动"></a>5.2. 启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>
<h2 id="5-3-建立-docker-用户组"><a href="#5-3-建立-docker-用户组" class="headerlink" title="5.3. 建立 docker 用户组"></a>5.3. 建立 docker 用户组</h2><p>默认情况下，<strong>docker命令会使用 Unix socket 与 Docker 引擎通讯</strong>。而只有root用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是<strong>将需要使用 docker 的用户加入 docker 用户组</strong></p>
<p>建立docker组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br></pre></td></tr></table></figure>
<p>将当前用户加入 docker 组</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure>
<h2 id="5-4-测试-Docker-是否安装正确"><a href="#5-4-测试-Docker-是否安装正确" class="headerlink" title="5.4. 测试 Docker 是否安装正确"></a>5.4. 测试 Docker 是否安装正确</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm hello-world</span><br></pre></td></tr></table></figure>
<h2 id="5-5-镜像加速"><a href="#5-5-镜像加速" class="headerlink" title="5.5. 镜像加速"></a>5.5. 镜像加速</h2><p>查看是否在 <code>docker.service</code> 文件中配置过镜像地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl cat docker | grep &#x27;\-\-registry\-mirror&#x27;</span><br></pre></td></tr></table></figure>
<p>如果该命令有输出，那么请执行 <code>$ systemctl cat docker</code> 查看 <code>ExecStart=</code> 出现的位置，修改对应的文件内容去掉 <code>--registry-mirror</code> 参数及其值，并按接下来的步骤进行配置。</p>
<p>如果以上命令没有任何输出，那么就可以在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;https://docker.1panel.live&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://docker.m.daocloud.io&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;https://huecker.io&quot;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>重新启动服务</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>检查加速器是否生效</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure>
<h1 id="6-Docker-架构（重点）"><a href="#6-Docker-架构（重点）" class="headerlink" title="6. Docker 架构（重点）"></a>6. Docker 架构（重点）</h1><h2 id="6-1-客户端"><a href="#6-1-客户端" class="headerlink" title="6.1. 客户端"></a>6.1. 客户端</h2><p>通过命令或Docker API 向Docker服务端发送指令。可以在本地或远程向服务端发送指令</p>
<h2 id="6-2-服务端"><a href="#6-2-服务端" class="headerlink" title="6.2. 服务端"></a>6.2. 服务端</h2><p><strong>服务端=Docker引擎=Docker守护进程</strong>， 负责处理Docker指令，管理镜像、容器等</p>
<h1 id="7-Docker-镜像操作"><a href="#7-Docker-镜像操作" class="headerlink" title="7. Docker 镜像操作"></a>7. Docker 镜像操作</h1><p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像</p>
<h2 id="7-1-获取镜像"><a href="#7-1-获取镜像" class="headerlink" title="7.1. 获取镜像"></a>7.1. 获取镜像</h2><p>访问DockerHub搜索镜像，<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是 <code>docker.io</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<h2 id="7-2-运行"><a href="#7-2-运行" class="headerlink" title="7.2. 运行"></a>7.2. 运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run</span><br></pre></td></tr></table></figure>
<p>通过 <code>exit</code> 退出容器</p>
<h2 id="7-3-列出镜像"><a href="#7-3-列出镜像" class="headerlink" title="7.3. 列出镜像"></a>7.3. 列出镜像</h2><p>查看本地镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p>查看镜像、容器、数据卷所占用的空间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>
<p>同时显示依赖的中间层镜像</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls -a</span><br></pre></td></tr></table></figure>
<h2 id="7-4-导出导入"><a href="#7-4-导出导入" class="headerlink" title="7.4. 导出导入"></a>7.4. 导出导入</h2><p>导出镜像到本地</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o &lt;保存的文件名&gt;.tar &lt;镜像名称&gt;</span><br></pre></td></tr></table></figure>
<p>导入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i /path/to/myimage.tar</span><br></pre></td></tr></table></figure>
<p>这将在另一台机器上导入名为<code>myimage</code>的镜像</p>
<h2 id="7-5-删除镜像"><a href="#7-5-删除镜像" class="headerlink" title="7.5. 删除镜像"></a>7.5. 删除镜像</h2><p><code>&lt;镜像&gt;</code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]</span><br></pre></td></tr></table></figure>
<p><strong>Untagged 和 Deleted</strong></p>
<p>删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像</p>
<h2 id="7-6-Dockerfile定制镜像（重点）"><a href="#7-6-Dockerfile定制镜像（重点）" class="headerlink" title="7.6. Dockerfile定制镜像（重点）"></a>7.6. Dockerfile定制镜像（重点）</h2><p>定制镜像，是以一个镜像为基础，在其上进行定制</p>
<p>镜像的定制实际上就是<strong>定制每一层所添加的配置、文件</strong>。我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile</p>
<p>注：禁止使用 docker commit定制镜像，使用 docker commit 意味着除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令（Instruction），<strong>每一条指令构建一层</strong>，因此每一条指令的内容，就是描述该层应当如何构建</p>
<p>建立一个文本文件，并命名为 Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch Dockerfile</span><br></pre></td></tr></table></figure>
<h3 id="7-6-1-Dockerfile指令"><a href="#7-6-1-Dockerfile指令" class="headerlink" title="7.6.1. Dockerfile指令"></a>7.6.1. Dockerfile指令</h3><p><a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">Dockerfile最佳实践</a></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM python:3.8.10</span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"># 将项目下的requirements.txt文件复制到 /app目录</span><br><span class="line">COPY ./requirements.txt .</span><br><span class="line"># 执行命令pip install --no-cache-dir -r requirements.txt 安装项目依赖</span><br><span class="line">RUN pip install --no-cache-dir -r requirements.txt</span><br><span class="line"># 将Flask 项目复制到容器中的 /app 目录</span><br><span class="line">COPY . .</span><br><span class="line"># 容器向外暴露5000端口</span><br><span class="line">EXPOSE 5000</span><br><span class="line"># 在容器启动时运行 app.py 脚本</span><br><span class="line">CMD [ &quot;python&quot;, &quot;app.py&quot; ]</span><br></pre></td></tr></table></figure>
<p><strong>FROM 命令</strong></p>
<p><strong>指定基础镜像，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令</strong></p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。如果以 <code>scratch</code> 为基础镜像的话，意味着不以任何镜像为基础</p>
<p><strong>RUN 命令</strong></p>
<p><code>RUN</code> 指令用来执行命令行的命令，其格式有两种：</p>
<ul>
<li>shell 格式：<code>RUN &lt;命令&gt;</code>，就像直接在命令行中输入的命令一样</li>
<li>exec 格式：<code>RUN [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;]</code>，这更像是函数调用中的格式</li>
</ul>
<p><strong>Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式</strong></p>
<p>此外，通常要在一组命令的最后添加清理工作的命令 <code>apt-get purge -y --auto-remove $buildDeps</code>，删除为了编译构建所需要的软件，清理所有下载、展开的文件，并且清理 <code>apt</code> 缓存文件。这是很重要的一步，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉</p>
<p><strong>COPY</strong></p>
<p>将从构建上下文目录中 <code>&lt;源路径&gt;</code> 的文件或目录复制到新的一层的镜像内的 <code>&lt;目标路径&gt;</code> 位置。<code>COPY &lt;源路径&gt; &lt;目标路径&gt;</code></p>
<p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>需要注意，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用</p>
<p>如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径</p>
<p><strong>COPY 命令的源路径是相对于构建上下文（即通过 <code>docker build</code> 命令传递给 Docker 的目录或文件）</strong></p>
<p><strong>ADD</strong></p>
<p>与COPY类似，但还支持从URL中下载文件，并且可以自动解压压缩文件。</p>
<p>Dockerfile <strong>最佳实践</strong>中要求，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p>
<p><strong>WORKDIR</strong></p>
<p>设置工作目录，改变以后各层的工作目录的位置。<code>WORKDIR &lt;工作目录路径&gt;</code></p>
<p>如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p><strong>工作目录就是容器运行时所用的根目录</strong></p>
<p><strong>EXPOSE</strong></p>
<p>声明容器运行时需要开放的端口。<code>EXPOSE &lt;端口&gt;</code></p>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<p>在 Dockerfile 中使用 EXPOSE 声明的好处是在容器运行时，使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p>
<p><strong>ENV</strong></p>
<p>设置环境变量。</p>
<p>定义了环境变量，无论是后面的其它指令，还是运行时的应用，都可以直接使用定义的环境变量。</p>
<p>通过环境变量，可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p>
<p><strong>CMD</strong></p>
<p>设置容器启动后默认执行的命令。</p>
<p><strong>ENTRYPOINT</strong></p>
<p>设置容器启动后默认执行的命令，与CMD不同的是，ENTRYPOINT指定的命令不会被覆盖。</p>
<p><strong>USER</strong></p>
<p>设置容器中执行命令的用户。</p>
<p><strong>VOLUME</strong></p>
<p>声明持久化数据的目录，可以在容器中挂载主机的目录。<code>VOLUME &lt;路径&gt;</code></p>
<p>容器运行时应该尽量保持容器存储层不发生写操作，在 <code>Dockerfile</code> 中，可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p>
<p><strong>ARG</strong></p>
<p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。</p>
<h3 id="7-6-2-构建镜像"><a href="#7-6-2-构建镜像" class="headerlink" title="7.6.2. 构建镜像"></a>7.6.2. 构建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt;</span><br></pre></td></tr></table></figure>
<h3 id="7-6-3-镜像构建上下文（重点）"><a href="#7-6-3-镜像构建上下文（重点）" class="headerlink" title="7.6.3. 镜像构建上下文（重点）"></a>7.6.3. 镜像构建上下文（重点）</h3><p><code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，<code>docker build</code> 命令构建镜像，并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。<strong>当构建的时候，用户会指定构建镜像上下文的路径</strong>，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p><strong>一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</strong></p>
<h3 id="7-6-4-多阶段构建"><a href="#7-6-4-多阶段构建" class="headerlink" title="7.6.4. 多阶段构建"></a>7.6.4. 多阶段构建</h3><p>…<br>…</p>
<h1 id="8-Docker-容器操作"><a href="#8-Docker-容器操作" class="headerlink" title="8. Docker 容器操作"></a>8. Docker 容器操作</h1><p>容器是独立运行的一个或一组应用，以及它们的运行态环境</p>
<h2 id="8-1-启动"><a href="#8-1-启动" class="headerlink" title="8.1. 启动"></a>8.1. 启动</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p>
<h3 id="8-1-1-新建并启动"><a href="#8-1-1-新建并启动" class="headerlink" title="8.1.1. 新建并启动"></a>8.1.1. 新建并启动</h3><p>命令主要为 <code>docker run</code></p>
<p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-   检查本地是否存在指定的镜像，不存在就从仓库下载</span><br><span class="line"></span><br><span class="line">-   利用镜像创建并启动一个容器</span><br><span class="line"></span><br><span class="line">-   分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</span><br><span class="line"></span><br><span class="line">-   从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</span><br><span class="line"></span><br><span class="line">-   从地址池配置一个 ip 地址给容器</span><br><span class="line"></span><br><span class="line">-   执行用户指定的应用程序</span><br><span class="line"></span><br><span class="line">-   执行完毕后容器被终止</span><br></pre></td></tr></table></figure>
<h3 id="8-1-2-启动已终止容器"><a href="#8-1-2-启动已终止容器" class="headerlink" title="8.1.2. 启动已终止容器"></a>8.1.2. 启动已终止容器</h3><p>利用 <code>docker container start</code> 命令，直接将一个已经终止（<code>exited</code>）的容器启动运行。</p>
<h2 id="8-2-守护态运行"><a href="#8-2-守护态运行" class="headerlink" title="8.2. 守护态运行"></a>8.2. 守护态运行</h2><p>更多的时候，需要<strong>让 Docker 在后台运行</strong>，而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现 <code>docker run -d</code></p>
<p><strong>注：</strong> 容器是否会长久运行和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关</p>
<p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令</p>
<p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息</p>
<h2 id="8-3-终止"><a href="#8-3-终止" class="headerlink" title="8.3. 终止"></a>8.3. 终止</h2><p>使用 <code>docker container stop</code> 来终止一个运行中的容器</p>
<p>注：当 Docker 容器中指定的应用终结时，容器也自动终止</p>
<h2 id="8-4-进入容器"><a href="#8-4-进入容器" class="headerlink" title="8.4. 进入容器"></a>8.4. 进入容器</h2><p>推荐 <code>docker exec</code> 命令，<code>docker exec</code> command allows you to run commands inside a Docker container</p>
<p>使用<code>-it</code> 参数，可以看到我们熟悉的 Linux 命令提示符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg：docker exec -it container-name bash</span><br></pre></td></tr></table></figure>
<h2 id="8-5-导出导入"><a href="#8-5-导出导入" class="headerlink" title="8.5. 导出导入"></a>8.5. 导出导入</h2><p>导出容器快照到本地 <code>tar</code>文件，可以使用 <code>docker export</code> 命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export [CONTAINER ID] &gt; ubuntu.tar</span><br></pre></td></tr></table></figure></p>
<p>导入容器可以使用<code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用<code>docker import</code> 来导入一个容器快照到本地镜像库</p>
<p><strong>镜像与容器快照的区别</strong></p>
<p>容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息</p>
<h2 id="8-6-删除"><a href="#8-6-删除" class="headerlink" title="8.6. 删除"></a>8.6. 删除</h2><p>使用 <code>docker container rm</code> 来删除一个处于终止状态的容器</p>
<p>要删除一个运行中的容器，可以添加 <code>-f</code> 参数</p>
<p>清理掉所有处于终止状态的容器<code>docker container prune</code></p>
<h1 id="9-Docker-仓库"><a href="#9-Docker-仓库" class="headerlink" title="9. Docker 仓库"></a>9. Docker 仓库</h1><p>仓库（<code>Repository</code>）是集中存放镜像的地方</p>
<h2 id="9-1-Docker-Hub"><a href="#9-1-Docker-Hub" class="headerlink" title="9.1. Docker Hub"></a>9.1. Docker Hub</h2><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h2 id="9-2-私有仓库"><a href="#9-2-私有仓库" class="headerlink" title="9.2. 私有仓库"></a>9.2. 私有仓库</h2><p>一个本地仓库供私人使用</p>
<p>docker-registry 是官方提供的工具，可以用于构建私有的镜像仓库</p>
<h1 id="10-Docker-数据管理"><a href="#10-Docker-数据管理" class="headerlink" title="10. Docker 数据管理"></a>10. Docker 数据管理</h1><p>在Docker 内部以及容器之间管理数据。在容器中管理数据主要有两种方式：</p>
<ul>
<li>数据卷（Volumes）</li>
<li>挂载主机目录 (Bind mounts)</li>
</ul>
<h2 id="10-1-数据卷（重点）"><a href="#10-1-数据卷（重点）" class="headerlink" title="10.1. 数据卷（重点）"></a>10.1. 数据卷（重点）</h2><p>在 Docker 中，数据卷（volume）是一种用于在容器和宿主机之间共享数据的机制</p>
<p>数据卷在 Docker 中是一种特殊的文件系统，它可以映射到宿主机上的一个目录或者一个 Docker 管理的卷（volume）上。<strong>数据卷本身并不属于宿主机</strong>。数据卷是由 Docker 管理的，它存储在 Docker 数据目录下的某个位置，而不是存储在宿主机上的普通文件或目录中。因此，删除容器或删除数据卷映射并不会删除数据卷本身，数据卷可以被多个容器共享，并且可以在宿主机和容器之间方便地移动和复制</p>
<p>当一个数据卷被映射到一个目录上时，这个目录会成为该数据卷的挂载点，并且可以在容器中访问该目录下的所有内容</p>
<p>当一个数据卷被映射到一个 Docker 管理的卷上时，这个卷会成为该数据卷的挂载点，并且可以在多个容器之间共享</p>
<h3 id="10-1-1-数据卷特点"><a href="#10-1-1-数据卷特点" class="headerlink" title="10.1.1. 数据卷特点"></a>10.1.1. 数据卷特点</h3><p>数据卷可以在容器之间共享和重用，方便容器间传递数据</p>
<p>对数据卷内数据的修改会立马生效（无论是容器内操作还是本地操作）</p>
<p>对数据卷的更新不会影响镜像，解耦开应用和数据</p>
<p>数据卷可以独立于容器存在（数据卷默认会一直存在，即使容器被删除）</p>
<h3 id="10-1-2-数据卷操作命令"><a href="#10-1-2-数据卷操作命令" class="headerlink" title="10.1.2. 数据卷操作命令"></a>10.1.2. 数据卷操作命令</h3><p>数据卷操作的基本语法为：<code>docker volume [COMMAND]</code>，其中COMMAND是某个具体的命令</p>
<p><strong>创建一个数据卷</strong></p>
<p><code>docker volume create my-vol</code></p>
<p><strong>列出所有的数据卷</strong></p>
<p><code>docker volume ls</code></p>
<p><strong>查看指定数据卷的信息</strong> </p>
<p><code>docker volume inspect my-vol</code></p>
<p><strong>挂载数据卷到某容器（重点）</strong></p>
<p>使用 <code>docker run</code> 命令的 <code>-v</code> 将数据卷挂载到容器中的某个目录下，从而<strong>实现容器中的应用程序对宿主机上的数据进行读写</strong>。在一次 <code>docker run</code> 中可以挂载多个数据卷（在linux的docker主机中创建一个卷时， 其在宿主机对应的目录或挂载点路径为<code>/var/lib/docker/volumes/卷名/_ data</code>）</p>
<p><strong>删除指定的数据卷</strong> </p>
<p><code>docker volume rm my-vol</code></p>
<p><strong>在删除容器的同时移除数据卷</strong></p>
<p>数据卷是用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p>
<p><strong>删除未使用的数据卷</strong></p>
<p><code>docker volume prune</code></p>
<h2 id="10-2-挂载主机目录"><a href="#10-2-挂载主机目录" class="headerlink" title="10.2. 挂载主机目录"></a>10.2. 挂载主机目录</h2><p><strong>将宿主机上的目录直接挂载到容器中</strong>，容器中的数据改变会直接影响宿主机上的数据，而且需要手动管理数据的备份和恢复等工作</p>
<p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录或文件到容器中去</p>
<p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code></p>
<p>需要在容器中访问宿主机上的文件系统，建议使用挂载主机目录</p>
<h1 id="11-Docker-网络通信"><a href="#11-Docker-网络通信" class="headerlink" title="11. Docker 网络通信"></a>11. Docker 网络通信</h1><p>Docker 允许通过外部访问容器、容器互联的方式来提供网络服务</p>
<h2 id="11-1-外部访问容器"><a href="#11-1-外部访问容器" class="headerlink" title="11.1. 外部访问容器"></a>11.1. 外部访问容器</h2><p>使用 <code>-P</code> 标记时，Docker 会随机映射一个本地端口到内部容器的端口。让外部也可以访问容器应用</p>
<p><code>-P</code> 标记支持的格式 <code>ip:hostPort:containerPort</code> 、<code>ip::containerPort</code> 、 `hostPort:containerPort</p>
<p>注：在一个指定端口上只可以绑定一个容器</p>
<p>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</p>
<p> <code>-p</code> 标记可以多次使用来绑定多个端口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d \</span><br><span class="line">-p 80:80 \</span><br><span class="line">-p 443:443 \</span><br><span class="line">nginx:alpine</span><br></pre></td></tr></table></figure>
<h2 id="11-2-容器互联"><a href="#11-2-容器互联" class="headerlink" title="11.2. 容器互联"></a>11.2. 容器互联</h2><p>强烈建议将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。如：要想从 Web 容器访问 Redis 容器，我们只需要把他们放到同个网络中就可以了</p>
<p><strong>新建网络</strong></p>
<p><code>docker network create -d bridge my-net</code>，<code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 、<code>overlay</code></p>
<p><strong>连接容器</strong></p>
<p>运行一个容器并连接到新建的 <code>my-net</code> 网络，打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络。通过 <code>ping</code> 来证明容器与容器间建立了互联关系</p>
<p><strong>查看网络列表</strong></p>
<p><code>docker network ls</code> </p>
<h2 id="11-3-配置-DNS"><a href="#11-3-配置-DNS" class="headerlink" title="11.3. 配置 DNS"></a>11.3. 配置 DNS</h2><p>配置全部容器的 DNS ，也可以在 <code>/etc/docker/daemon.json</code> 文件中增加以下内容来设置。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;dns&quot;</span> <span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;114.114.114.114&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;8.8.8.8&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这样每次启动的容器 DNS 自动配置为 <code>114.114.114.114</code> 和 <code>8.8.8.8</code></p>
<h1 id="12-Docker-Compose（重点）"><a href="#12-Docker-Compose（重点）" class="headerlink" title="12. Docker Compose（重点）"></a>12. Docker Compose（重点）</h1><h2 id="12-1-简介"><a href="#12-1-简介" class="headerlink" title="12.1. 简介"></a>12.1. 简介</h2><p>Docker Compose 负责实现对 Docker 容器集群的快速编排，可以把项目的多个服务集合到一起，一键运行。</p>
<p>如：要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p>Docker Compose 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
<p>Docker Compose 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p>Docker Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理</p>
<h2 id="12-2-安装与卸载"><a href="#12-2-安装与卸载" class="headerlink" title="12.2. 安装与卸载"></a>12.2. 安装与卸载</h2><p><strong>docker-compose和docker compose的区别</strong></p>
<p>Compose分为V1和V2版本，安装方式分为两种，一种是独立安装（standalone），一种是插件安装（plugin），所以有四种组合方式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>V1</th>
<th>V2</th>
</tr>
</thead>
<tbody>
<tr>
<td>standalone（独立式安装）</td>
<td>docker-compose</td>
<td>docker-compose</td>
</tr>
<tr>
<td>plugin（插件式安装）</td>
<td>不支持插件式安装</td>
<td>docker compose</td>
</tr>
</tbody>
</table>
</div>
<p>插件安装的Compose，在V2版本，指令是docker compose（中间是空格），最新版的docker安装时会自动以插件的形式安装docker compose</p>
<p>支持同时采用两种方式安装Compose，安装后可以同时使用docker-compose和docker compose</p>
<p><strong>独立式安装</strong></p>
<p>在 Linux 64 位系统上直接下载对应的二进制包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/2.17.2/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"># 国内用户可以使用以下方式加快下载</span><br><span class="line">$ sudo curl -L https://get.daocloud.io/docker/compose/releases/download/2.17.2/docker-compose-`uname -s-uname -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line"># 给脚本执行权限</span><br><span class="line">$ sudo chmod +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>运行<code>docker-compose --version</code>检查是否安装成功</p>
<p>卸载：如果是二进制包方式安装的，删除二进制文件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo rm /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<h2 id="12-3-Compose-模板文件"><a href="#12-3-Compose-模板文件" class="headerlink" title="12.3. Compose 模板文件"></a>12.3. Compose 模板文件</h2><p>默认的模板文件名称为 <code>docker-compose.yml</code></p>
<p>参考文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    build: ./</span><br><span class="line">    ports:</span><br><span class="line">      - 80:8080</span><br><span class="line">    volumes:</span><br><span class="line">      - ./:/app</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:5.0.13</span><br><span class="line">    volumes:</span><br><span class="line">      - redis:/data</span><br><span class="line">    environment:</span><br><span class="line">      - TZ=Asia/Shanghai</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  redis:</span><br></pre></td></tr></table></figure>
<blockquote>
<p>容器默认时间不是北京时间，增加 TZ=Asia/Shanghai 可以改为北京时间</p>
</blockquote>
<h2 id="12-4-常用命令"><a href="#12-4-常用命令" class="headerlink" title="12.4. 常用命令"></a>12.4. 常用命令</h2><p>docker compose命令的运行需要docker-compose.yml文件的支持，可以指定文件位置，也可以在文件同目录运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">## 构建镜像并启动文件内配置的所有容器</span><br><span class="line">docker compose up</span><br><span class="line"></span><br><span class="line">## 构建镜像并启动所有容器，后台运行</span><br><span class="line">docker compose up -d</span><br><span class="line"></span><br><span class="line">## 停止并删除所有容器</span><br><span class="line">docker compose down</span><br><span class="line"></span><br><span class="line">## 重启单个服务</span><br><span class="line">docker-compose restart service-name</span><br><span class="line"></span><br><span class="line">## 重启所有服务</span><br><span class="line">docker compose restart</span><br><span class="line"></span><br><span class="line">## 启动服务</span><br><span class="line">docker compose start</span><br><span class="line"></span><br><span class="line">## 停止服务</span><br><span class="line">docker compose stop</span><br><span class="line"></span><br><span class="line">## 展示当前docker compose编排过并运行的所有容器（在docker-compose.yml文件同目录下运行）</span><br><span class="line">docker compose ps</span><br><span class="line"></span><br><span class="line">## 检查docker-compose.yml文件</span><br><span class="line">docker compose config</span><br><span class="line"></span><br><span class="line">## 检查docker-compose.yml文件，有问题就输出</span><br><span class="line">docker compose config -q</span><br><span class="line"></span><br><span class="line">## 进入容器命令行</span><br><span class="line">docker-compose exec service-name sh</span><br><span class="line"></span><br><span class="line">## 查看容器运行log</span><br><span class="line">docker-compose logs [service-name]</span><br></pre></td></tr></table></figure>
<h1 id="13-Docker-GUI-管理"><a href="#13-Docker-GUI-管理" class="headerlink" title="13. Docker GUI 管理"></a>13. Docker GUI 管理</h1><p>推荐使用<a target="_blank" rel="noopener" href="https://docs.portainer.io/start/install-ce/server/docker/linux">Portainer</a>（Portainer-CE社区版） 作为容器的 GUI 管理方案</p>
<h2 id="13-1-单机版运行"><a href="#13-1-单机版运行" class="headerlink" title="13.1. 单机版运行"></a>13.1. 单机版运行</h2><p>如果仅有一个docker宿主机，则可使用单机版运行</p>
<p>在Docker中创建一个数据卷</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create portainer_data</span><br></pre></td></tr></table></figure>
<p>该命令的作用是在Docker中创建一个名为portainer_data的数据卷，用于挂载到Portainer容器中的/data目录以保存Portainer的数据</p>
<p>访问<code>https://ip:9443</code>，首次登陆需要注册用户，给admin用户设置密码：<code>adminadminadmin</code><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer-ce:latest</span><br></pre></td></tr></table></figure></p>
<p>具体参数的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-d: 让容器在后台以守护进程方式运行</span><br><span class="line">-p 8000:8000: 将主机的8000端口映射到容器的8000端口，这样可以通过访问主机的8000端口来访问Portainer的Web界面</span><br><span class="line">-p 9443:9443: 将主机的9443端口映射到容器的9443端口，这样可以通过访问主机的9443端口来访问Portainer的Web界面（使用HTTPS）</span><br><span class="line">--name portainer: 为容器指定一个名称，这里指定为portainer</span><br><span class="line">--restart=always: 让Docker在启动时自动重新启动容器，即使容器因为某种原因而停止了</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock: 将主机上的/var/run/docker.sock文件映射到容器内的同一文件，这样Portainer就可以通过Docker API与主机上的Docker守护程序进行交互</span><br><span class="line">-v portainer_data:/data: 将名为portainer_data的Docker卷挂载到容器的/data目录，这样Portainer就可以将其数据保存在该卷中</span><br><span class="line">portainer/portainer-ce:latest: 运行的镜像名称和标签，这里使用的是Portainer社区版的最新版本。</span><br></pre></td></tr></table></figure>
<h2 id="13-2-集群版运行"><a href="#13-2-集群版运行" class="headerlink" title="13.2. 集群版运行"></a>13.2. 集群版运行</h2><p>…<br>…</p>
<h1 id="14-Docker-的目录结构"><a href="#14-Docker-的目录结构" class="headerlink" title="14. Docker 的目录结构"></a>14. Docker 的目录结构</h1><p>Docker 安装目录：这是 Docker 引擎的安装目录，通常包括二进制文件、配置文件和其他相关文件等。在 Linux 系统中，默认安装目录为 <code>/usr/bin/docker</code></p>
<p>Docker 数据目录：这是 Docker 引擎用于存储容器、映像和其他数据的目录。在 Linux 系统中，默认数据目录为 <code>/var/lib/docker</code>。Docker 数据目录下通常包括以下几个子目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">containers：存储容器的相关数据，包括容器文件系统、元数据和日志等。</span><br><span class="line">image：存储 Docker 镜像的相关数据，包括镜像文件、元数据和缓存等。</span><br><span class="line">volumes：存储 Docker 数据卷的相关数据，包括数据卷文件和元数据等。</span><br><span class="line">networks：存储 Docker 网络的相关数据，包括网络配置和元数据等。</span><br></pre></td></tr></table></figure>
<p>Docker 配置目录：这是 Docker 引擎的配置目录，通常包括一些配置文件和证书等。在 Linux 系统中，默认配置目录为 <code>/etc/docker</code></p>
<p>Docker 日志目录：这是 Docker 引擎的日志目录，通常包括 Docker 引擎和容器的日志文件。在 Linux 系统中，默认日志目录为 <code>/var/log/docker</code></p>
<p>Docker 工作目录：这是 Docker 引擎的工作目录，通常用于存储一些临时文件和脚本等。在 Linux 系统中，默认工作目录为 <code>/var/lib/docker/tmp</code></p>
<h1 id="15-Docker命令"><a href="#15-Docker命令" class="headerlink" title="15. Docker命令"></a>15. Docker命令</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Common Commands:</span><br><span class="line">  run         Create and run a new container from an image</span><br><span class="line">  exec        Execute a command in a running container</span><br><span class="line">  ps          List containers</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  pull        Download an image from a registry</span><br><span class="line">  push        Upload an image to a registry</span><br><span class="line">  images      List images</span><br><span class="line">  login       Log in to a registry</span><br><span class="line">  logout      Log out from a registry</span><br><span class="line">  search      Search Docker Hub for images</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  info        Display system-wide information</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  buildx*     Docker Buildx (Docker Inc., v0.11.1)</span><br><span class="line">  compose*    Docker Compose (Docker Inc., v2.19.1)</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  image       Manage images</span><br><span class="line">  manifest    Manage Docker image manifests and manifest lists</span><br><span class="line">  network     Manage networks</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Swarm Commands:</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">      --config string      Location of client config files (default &quot;/root/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to connect to the daemon (overrides</span><br><span class="line">                           DOCKER_HOST env var and default context set with &quot;docker context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level (&quot;debug&quot;, &quot;info&quot;, &quot;warn&quot;, &quot;error&quot;, &quot;fatal&quot;)</span><br><span class="line">                           (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default &quot;/root/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default &quot;/root/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default &quot;/root/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://szx-zhao.github.io">robotszx</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://szx-zhao.github.io/2023/01/20/2023-01-20-Docker%E7%90%86%E8%AE%BA/">https://szx-zhao.github.io/2023/01/20/2023-01-20-Docker%E7%90%86%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://szx-zhao.github.io" target="_blank">机器人之家</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post_share"><div class="social-share" data-image="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/6.avif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/01/26/2023-01-26-python%E5%9F%BA%E7%A1%80/" title="python基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/16.avif" onerror="onerror=null;src='/img/favicon/404.png'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python基础</div></div></a></div><div class="next-post pull-right"><a href="/2023/01/12/2023-01-12-IDEA%E4%BD%BF%E7%94%A8/" title="IDEA使用"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/15.avif" onerror="onerror=null;src='/img/favicon/404.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">IDEA使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/07/26/2023-07-26-Docker%E5%AE%9E%E8%B7%B5/" title="Docker实践"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/15.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-07-26</div><div class="title">Docker实践</div></div></a></div><div><a href="/2024/06/27/2024-06-27-Docker%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Docker最佳实践"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.x914.com/daemao/i/%E5%AE%98%E7%BD%91%E7%B4%A0%E6%9D%90/%E9%A6%96%E9%A1%B5/%E8%A6%86%E7%9B%96%E5%9B%BE/4.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-27</div><div class="title">Docker最佳实践</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/Avatar/60910068.avif" onerror="this.onerror=null;this.src='/img/favicon/404.png'" alt="avatar"/></div><div class="author-info__name">robotszx</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">167</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/szx-zhao"><i class="fab fa-github"></i><span>前往未知的领域~</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/szx-zhao" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1358861771@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1. 概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.</span> <span class="toc-text">2. Docker 是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-Docker"><span class="toc-number">3.</span> <span class="toc-text">3. 为什么要用 Docker</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Docker-%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">4. Docker 基本组成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E9%95%9C%E5%83%8F"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. 分层存储（重点）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%B9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. 容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%AE%B9%E5%99%A8%E5%AD%98%E5%82%A8%E5%B1%82%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. 容器存储层（不推荐）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BB%93%E5%BA%93"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. 仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E5%85%AC%E5%BC%80-Docker-Registry"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. 公开 Docker Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%A7%81%E6%9C%89-Docker-Registry"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. 私有 Docker Registry</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%AE%89%E8%A3%85Docker"><span class="toc-number">5.</span> <span class="toc-text">5. 安装Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%AE%98%E6%96%B9%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. 官方脚本自动安装（推荐）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%90%AF%E5%8A%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. 启动</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%BB%BA%E7%AB%8B-docker-%E7%94%A8%E6%88%B7%E7%BB%84"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 建立 docker 用户组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%B5%8B%E8%AF%95-Docker-%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%AD%A3%E7%A1%AE"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. 测试 Docker 是否安装正确</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">5.5.</span> <span class="toc-text">5.5. 镜像加速</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Docker-%E6%9E%B6%E6%9E%84%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">6.</span> <span class="toc-text">6. Docker 架构（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 服务端</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Docker-%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C"><span class="toc-number">7.</span> <span class="toc-text">7. Docker 镜像操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. 获取镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E8%BF%90%E8%A1%8C"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. 运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E5%88%97%E5%87%BA%E9%95%9C%E5%83%8F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. 列出镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5"><span class="toc-number">7.4.</span> <span class="toc-text">7.4. 导出导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">7.5.</span> <span class="toc-text">7.5. 删除镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-Dockerfile%E5%AE%9A%E5%88%B6%E9%95%9C%E5%83%8F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">7.6.</span> <span class="toc-text">7.6. Dockerfile定制镜像（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-1-Dockerfile%E6%8C%87%E4%BB%A4"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.6.1. Dockerfile指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-2-%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.6.2. 构建镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-3-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E4%B8%8A%E4%B8%8B%E6%96%87%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">7.6.3.</span> <span class="toc-text">7.6.3. 镜像构建上下文（重点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-4-%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA"><span class="toc-number">7.6.4.</span> <span class="toc-text">7.6.4. 多阶段构建</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Docker-%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">8.</span> <span class="toc-text">8. Docker 容器操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%90%AF%E5%8A%A8"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-1-%E6%96%B0%E5%BB%BA%E5%B9%B6%E5%90%AF%E5%8A%A8"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1. 新建并启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-2-%E5%90%AF%E5%8A%A8%E5%B7%B2%E7%BB%88%E6%AD%A2%E5%AE%B9%E5%99%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2. 启动已终止容器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%AE%88%E6%8A%A4%E6%80%81%E8%BF%90%E8%A1%8C"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 守护态运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-%E7%BB%88%E6%AD%A2"><span class="toc-number">8.3.</span> <span class="toc-text">8.3. 终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">8.4. 进入容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5-%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5"><span class="toc-number">8.5.</span> <span class="toc-text">8.5. 导出导入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-6-%E5%88%A0%E9%99%A4"><span class="toc-number">8.6.</span> <span class="toc-text">8.6. 删除</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Docker-%E4%BB%93%E5%BA%93"><span class="toc-number">9.</span> <span class="toc-text">9. Docker 仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-Docker-Hub"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. Docker Hub</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. 私有仓库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">10. Docker 数据管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%95%B0%E6%8D%AE%E5%8D%B7%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 数据卷（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-1-%E6%95%B0%E6%8D%AE%E5%8D%B7%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1. 数据卷特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-2-%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2. 数据卷操作命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E6%8C%82%E8%BD%BD%E4%B8%BB%E6%9C%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 挂载主机目录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Docker-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">11.</span> <span class="toc-text">11. Docker 网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE%E5%AE%B9%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 外部访问容器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 容器互联</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-%E9%85%8D%E7%BD%AE-DNS"><span class="toc-number">11.3.</span> <span class="toc-text">11.3. 配置 DNS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Docker-Compose%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">12.</span> <span class="toc-text">12. Docker Compose（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E7%AE%80%E4%BB%8B"><span class="toc-number">12.1.</span> <span class="toc-text">12.1. 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8D%B8%E8%BD%BD"><span class="toc-number">12.2.</span> <span class="toc-text">12.2. 安装与卸载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Compose-%E6%A8%A1%E6%9D%BF%E6%96%87%E4%BB%B6"><span class="toc-number">12.3.</span> <span class="toc-text">12.3. Compose 模板文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">12.4.</span> <span class="toc-text">12.4. 常用命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Docker-GUI-%E7%AE%A1%E7%90%86"><span class="toc-number">13.</span> <span class="toc-text">13. Docker GUI 管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-%E5%8D%95%E6%9C%BA%E7%89%88%E8%BF%90%E8%A1%8C"><span class="toc-number">13.1.</span> <span class="toc-text">13.1. 单机版运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E9%9B%86%E7%BE%A4%E7%89%88%E8%BF%90%E8%A1%8C"><span class="toc-number">13.2.</span> <span class="toc-text">13.2. 集群版运行</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-Docker-%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">14.</span> <span class="toc-text">14. Docker 的目录结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-Docker%E5%91%BD%E4%BB%A4"><span class="toc-number">15.</span> <span class="toc-text">15. Docker命令</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By robotszx</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>